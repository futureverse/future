% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/backend_api-ClusterFutureBackend-class.R,
%   R/backend_api-FutureBackend-class.R,
%   R/backend_api-MulticoreFutureBackend-class.R,
%   R/backend_api-MultisessionFutureBackend-class.R,
%   R/backend_api-SequentialFutureBackend-class.R
\name{ClusterFutureBackend}
\alias{ClusterFutureBackend}
\alias{FutureBackend}
\alias{launchFuture}
\alias{MulticoreFutureBackend}
\alias{MultisessionFutureBackend}
\alias{SequentialFutureBackend}
\title{A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster}
\usage{
ClusterFutureBackend(
  workers = availableWorkers(),
  persistent = FALSE,
  gc = TRUE,
  earlySignal = TRUE,
  ...
)

FutureBackend(
  ...,
  earlySignal = FALSE,
  gc = FALSE,
  maxSizeOfObjects = getOption("future.globals.maxSize", 500 * 1024^2)
)

launchFuture(backend, future, ...)

MulticoreFutureBackend(
  workers = availableCores(constraints = "multicore"),
  maxSizeOfObjects = +Inf,
  ...
)

MultisessionFutureBackend(workers = availableCores(), ...)

SequentialFutureBackend(..., maxSizeOfObjects = +Inf)
}
\arguments{
\item{workers}{...}

\item{persistent}{(deprecated) ...}

\item{gc}{Overrides the default behavior of whether futures should trigger
garbage collection via \code{\link[=gc]{gc()}} on the parallel worker after the value has
been collected from the worker.
This can help to release memory sooner than letting R itself on the parallel
worker decided when it is needed. Releasing memory sooner can help to fit
more parallel workers on a machine with limited amount of total memory.
(Default: \code{FALSE})}

\item{earlySignal}{Overrides the default behavior on whether futures
should resignal ("relay") conditions captured as soon as possible, or
delayed, for instance, until \code{\link[=value]{value()}} is called on the future.
(Default: \code{FALSE})}

\item{maxSizeOfObjects}{The maximum allowed total size, in bytes, of all
objects to and from the parallel worker allows.
This can help to protect against unexpectedly large data transfers between
the parent process and the parallel workers - data that is often transferred
over the network, which sometimes also includes the internet. For instance,
if you sit at home and have set up a future backend with workers running
remotely at your university or company, then you might want to use this
protection to avoid transferring giga- or terabytes of data without noticing.
(Default: \eqn{500 \cdot 1024^2} bytes = 500 MiB, unless overridden by a
FutureBackend subclass, or by R option \link{future.globals.maxSize} (sic!))}

\item{backend}{a \link{FutureBackend}.}

\item{future}{a \link{Future} to be started.}

\item{\ldots}{(optional) not used.}
}
\value{
\code{FutureBackend()} returns a FutureBackend object, which inherits an
environment. Specific future backends are defined by subclasses
implementing the FutureBackend API.

\code{launchFuture()} returns the launched \code{Future} object.
}
\description{
A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster

Configure a backend that controls how and where futures are evaluated

\code{launchFuture()} runs a future on the backend.

A MulticoreFutureBackend resolves futures in parallel using forked processing on the current machine

A MultisessionFutureBackend resolves futures in parallel using a PSOCK cluster on the current machine

A SequentialFutureBackend resolves futures sequentially in the current R session
}
\details{
The \code{ClusterFutureBackend} is selected by
\code{plan(cluster, workers = workers)}.

The \code{MulticoreFutureBackend} backend is selected by
\code{plan(multicore, workers = workers)}.

The \code{MultisessionFutureBackend} backend is selected by
\code{plan(multisession, workers = workers)}.

The \code{SequentialFutureBackend} is selected by \code{plan(sequential)}.
}
\section{The FutureBackend API}{

The \code{FutureBackend} class specifies FutureBackend API,
that all backends must implement and comply to. Specifically,
}

\keyword{internal}
