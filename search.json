[{"path":[]},{"path":"https://future.futureverse.org/CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported project lead. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://future.futureverse.org/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to the ‘future’ package","title":"Contributing to the ‘future’ package","text":"Git repository uses Git Flow branching model (git flow extension useful ). develop branch contains latest contributions code appear next release, master branch contains code latest release, exactly currently CRAN. Contributing package easy. Just send pull request. send PR, make sure develop destination branch future repository. PR pass R CMD check ---cran, also checked GitHub Actions PR submitted. abide Code Conduct Contributor Covenant.","code":""},{"path":[]},{"path":"https://future.futureverse.org/README_ja.html","id":"イントロダクション","dir":"","previous_headings":"","what":"イントロダクション","title":"future: Rにおける統一的な並列分散処理 ","text":"future パッケージは、R の式 (expression) を非同期的に実行するためのシンプルな方法を提供する。 また、非同期処理に使われる様々なリソースを一貫した方法で取り扱うことができる。 フューチャ (future) はプログラミング用語であり、「未来のある時点で利用可能になる予定の値 (value)」を表す抽象的な概念である。 フューチャは状態をもち、解決済みか未解決かのどちらかの状態をとる。 フューチャが解決済み状態の場合、そのフューチャの値はすぐに利用できる。 一方、フューチャが未解決状態の場合、そのフューチャの値を利用しようとすると、フューチャの状態が解決済みになるまでプロセスはブロックされる。 ただし、ブロックされずにフューチャの状態を確認する方法も用意されている。 いつどのようにフューチャが解決されるかは、式の評価に使われる戦略 (strategy) によって異なる。 例えば、フューチャを解決する戦略の1つに逐次戦略がある。 この戦略は、フューチャを現行の R セッションで解決しようとする。 また、フューチャを非同期的に解決する戦略として、1台のコンピュータ上で式の並列評価を行う戦略や、計算クラスタ上で一斉に式を評価する戦略などがある。 フューチャがどのように動作するか例を示そう。 まず、フューチャを使わずに式を評価する次のコードを見てみよう。 上のコードは式の値を変数 v に代入し、次に v の値を表示している。 このとき、v の式が評価される際にメッセージも表示されることに注意しよう。 上のコードをフューチャを使った式に書き換えよう。 2つのコード違いは v に対する代入記号にある。 最初のコードで <- が使われていたところが、フューチャの場合は %<-% に変わっている。 もう1つの違いは、Hello World! がフューチャが解決されたあと、すなわち値が要求されたときに表示される（ビネット ‘Outputting Text’ を参照）。 フューチャは何が便利なのだろうか？ 式をフューチャにしておくと、式の評価を非同期実行したいときに、次のように簡単に切り替えることができる。 非同期化されたフューチャは、実行時に現行のメインプロセスをブロックしない。 つまり、バックグラウンドの別のプロセスでフューチャが解決されている間に、現行のプロセスで引き続き処理を実行できる。 このように、フューチャは、R における並列分散処理のためのシンプルで強力な実行方法を提供するのである。 以降では future パッケージが提供する機能の詳細について説明していく。 その前に、とりあえず試してみたいという人は、先に終わりの方のセクション「デモ」を読んで、マンデルブロ集合を様々な戦略で描画してみると良いだろう。","code":"> v <- { +   cat(\"Hello world!\\n\") +   3.14 + } Hello world! > v [1] 3.14 > library(future) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14 > library(future) > plan(multisession) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14"},{"path":"https://future.futureverse.org/README_ja.html","id":"フューチャの作成","dir":"","previous_headings":"","what":"フューチャの作成","title":"future: Rにおける統一的な並列分散処理 ","text":"future パッケージには、フューチャを作成する方法として、明示的なスタイルと非明示的なスタイルの2種類がある。 上記の例では、v %<-% { 式 } という非明示的なスタイルでフューチャを作成した。 一方、明示的にフューチャを作成する方法として f <- future({ 式 }) と v <- value(f) という2つの関数を使うスタイルがある。 上記の例を明示的なスタイルに書き換えると次のようになる。 どちらのスタイルで作成してもフューチャの動作は同じである(*)。 非明示的なスタイルを使うと通常の R コードに近い書き方になる。 この場合、原則的に、フューチャの作成は <- で代入していたところを %<-% に置き換えるだけである。 しかし、このシンプルさの欠点として、コードを読む際に、コード内で非同期フューチャが使用されていることに気づかない可能性がある。 明示的なスタイルならば、フューチャが使用されていることが明確になり、こうした見逃しのリスクは軽減されるため、コードを読む人に優しい。 (*) 少し変更しないと %<-% が使えない場合がある。 この話題には、下の方のセクション「非明示的フューチャの制約」で触れる。 フューチャを作成する明示的なスタイルを正式に述べると次のようになる。 f <- future({ 式 }) – フューチャの作成 v <- value(f) – フューチャから値を取得する (未解決の場合は解決されるまでプロセスはブロックされる) また、非明示的なスタイルは次のようになる。 v %<-% { 式 } – フューチャを作成し、その値のプロミスを作成する 以降では、コードを簡潔にするためにフューチャの作成には非明示的なスタイルを使う。 ただし、議論されているすべてのことが明示的なスタイルで作成されたフューチャに対しても同様に成り立つ。","code":"> library(future) > f <- future({ +   cat(\"Hello world!\\n\") +   3.14 + }) > v <- value(f) Hello world! > v [1] 3.14"},{"path":"https://future.futureverse.org/README_ja.html","id":"戦略フューチャの解決方法を決める","dir":"","previous_headings":"","what":"戦略：フューチャの解決方法を決める","title":"future: Rにおける統一的な並列分散処理 ","text":"future パッケージで利用できる戦略を次の表に示す。 future パッケージは、自分で実装した戦略を追加できるように設計されている。 例えば、future.callr パッケージは、callr パッケージを利用してバックグラウンドの R プロセスでフューチャを評価するバックエンドを提供する。 これは multisession 戦略と似ているが、いくつかの利点がある。 また、future.batchtools パッケージは、batchtools パッケージがサポートするすべてのクラスタ関数に対するフューチャバックエンドを提供する。 具体的には、Slurm、TORQUE/PBS、Oracle/Sun Grid Engine (SGE)、Load Sharing Facility (LSF) などのジョブスケジューラを使用して R の式を評価するフューチャがある。 デフォルトでは、フューチャの式はその場で同期的に（現行のRセッションで）評価される。 このデフォルトの戦略は逐次 (sequential) 戦略と呼ばれる。 このセクションでは、future パッケージで利用できるそれぞれの戦略について説明し、共通点と相違点について述べる。","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"フューチャに共通のふるまい","dir":"","previous_headings":"戦略：フューチャの解決方法を決める","what":"フューチャに共通のふるまい","title":"future: Rにおける統一的な並列分散処理 ","text":"それぞれの戦略の説明に進む前に、future パッケージが提供する API (Future API) の設計について理解しよう。 Future API はユーザがどの戦略を使っても同じふるまいをするように設計されている。 なぜなら、ユーザが実際にどんな計算リソースを使うかについてあらかじめ知ることができないからである。 これにより、Future API は、ユーザが使用する戦略について、同期か非同期かなどのいかなる仮定もおかずに利用できる。 Future API は、その動作が戦略に依存しないように、あらゆる違いをカプセル化するように設計されている。 フューチャの式が現行の R セッションで評価されようが、リモートの R セッションで評価されようが関係なく、どのフューチャ戦略に対しても一貫した API とふるまいを持つ。 これにより、フューチャを使ってプログラミングするとき、ユーザはどの戦略を使うかを気にしなくてすむ。 また、この設計のもう1つの利点は、プロトタイピングしやすいことにある。 非同期処理のスクリプトを書く際に、最初はデバッグしやすい逐次戦略を使用して書き、実際の処理のときに簡単に非同期処理へ切り替えることができる。 そのために、すべての戦略は、フューチャの式の評価結果と副作用が可能な限り同じになるように作られている。 具体的には、すべてのフューチャ戦略は以下を満たす。 式の評価はローカル環境（すなわち local({ 式 })）で行われる。したがって、代入文は呼び出し環境に影響を与えない。 これは評価が外部の R プロセスで行われるときはもちろん、現行の R セッションで行われるときにも適用される。 フューチャの作成時に、グローバル変数が固定される。 非同期評価の場合、グローバル変数は、フューチャの式を評価する R プロセスにエクスポートされる。 遅延評価 (lazy = TRUE) を伴う逐次戦略においては、グローバル変数はフリーズ（フューチャのローカル環境にクローン）される。 また、誤って大きすぎるオブジェクトをエクスポートすることを防ぐために、グローバル変数の合計サイズにしきい値を設定できる。このしきい値を超えるとエラーが発生する（help(\"future.options\") を参照）。 フューチャの式の評価は一度だけ実行される。 値が定まった（解決済み状態になった）あとで、同じフューチャをもう一度評価することはできない。 代入がローカル環境で実行される（グローバル環境に影響しない）ことは、次のコードの実行結果からわかる。 以上で、フューチャに共通するふるまいがわかった。 以降ではそれぞれのフューチャ戦略について見ていく。","code":"> plan(sequential) > a <- 1 > x %<-% { +     a <- 2 +     2 * a + } > x [1] 4 > a [1] 1"},{"path":"https://future.futureverse.org/README_ja.html","id":"同期的フューチャ","dir":"","previous_headings":"戦略：フューチャの解決方法を決める","what":"同期的フューチャ","title":"future: Rにおける統一的な並列分散処理 ","text":"同期的フューチャはフューチャを作成した R プロセスで一つひとつ解決される。 同期的フューチャが解決されている間、メインプロセスはブロックされる。","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"逐次的フューチャ-sequential-future","dir":"","previous_headings":"戦略：フューチャの解決方法を決める > 同期的フューチャ","what":"逐次的フューチャ (Sequential Future)","title":"future: Rにおける統一的な並列分散処理 ","text":"逐次的フューチャはデフォルトのフューチャである。 Future API の共通のふるまいを満たしながら、通常の R 評価と同じように動作するように設計されている。 逐次的フューチャのふるまいを次のコードに示す。 逐次的な評価がその場で行われるため、3つのフューチャは作成と同時に即座に解決される。 呼び出し環境の pid（これは現行プロセスのプロセス ID が代入されている）は上書きも削除もされないことに注意しよう。 これはフューチャがローカル環境で評価されるためである。 同期的な（単一の）プロセスが評価に使われるので、フューチャ b はメインの R プロセスによって（ローカル環境で）解決される 。 これが b の値と pid が一致する理由である。","code":"> plan(sequential) > pid <- Sys.getpid() > pid [1] 1427324 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1427324 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1427324"},{"path":"https://future.futureverse.org/README_ja.html","id":"非同期的フューチャ","dir":"","previous_headings":"戦略：フューチャの解決方法を決める","what":"非同期的フューチャ","title":"future: Rにおける統一的な並列分散処理 ","text":"非同期的フューチャの説明に移ろう。 非同期的フューチャは、バックグラウンドで処理されるフューチャである。 設計上、これらのフューチャはノンブロッキングである。 すなわち、フューチャを作成したとき、呼び出し側のプロセスは他のタスク（さらにフューチャを作るなど）に利用できる。 呼び出し側のプロセスがブロックされるのは、未解決のフューチャの値にアクセスを試みた場合か、すべての利用可能な R プロセスが他のフューチャでビジーになっているときにさらに非同期のフューチャを作成しようとした場合に限られる。","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"マルチセッションフューチャ-multisession-future","dir":"","previous_headings":"戦略：フューチャの解決方法を決める > 非同期的フューチャ","what":"マルチセッションフューチャ (Multisession Future)","title":"future: Rにおける統一的な並列分散処理 ","text":"すべての OS で提供されているマルチセッションフューチャから始めよう。 マルチセッションフューチャは呼び出し側の R プロセスと同じマシンで、バックグラウンドの R セッションにおいてフューチャを評価する。 マルチセッション評価の例を示そう。 この結果を見ると、, c, pid の値は逐次的フューチャのときと同じであり、b だけが異なることがわかる。 その理由は、フューチャ b は現行とは別の R プロセスで評価され、そのプロセス ID を返すからである。 マルチセッション戦略を使うと、現行とは別の R セッションがバックグラウンドで起動され、フューチャは作成と同時にそれらの R セッションで評価される。 もしすべてのバックグラウンドセッションが他のフューチャでビジーならば、新しく作成されたマルチセッションフューチャはバックグラウンドセッションが利用可能になるまでブロックされる。 いくつのバックグラウンドプロセスが起動されるかは availableCores() の値によって決まる。 この結果から、メインプロセス以外に 2つのプロセスが利用可能なことがわかる。 したがって、この設定では、マルチセッションフューチャは 2つのバックグラウンドプロセスを使うことができる。 この値は mc.cores オプションで変更できる。 availableCores() はさまざまなオプションやシステム環境にも対応している。 例えば、計算クラスタスケジューラ（例えば TORQUE/PBS や Slurm）を使用する場合、与えられたジョブに割り当てられたコア数を指定するための環境変数を設定する。 その場合も availableCores() はそのコア数を認識する。 何も指定しない場合、マシン上の利用可能なすべてのコアが使われる。 このデフォルトの値は parallel::detectCores() で確認できる。 詳細については help(\"availableCores\", package = \"parallelly\") を参照してほしい。","code":"> plan(multisession) > pid <- Sys.getpid() > pid [1] 1427324 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1427382 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1427324 > availableCores() mc.cores         2"},{"path":"https://future.futureverse.org/README_ja.html","id":"マルチコアフューチャ-multicore-future","dir":"","previous_headings":"戦略：フューチャの解決方法を決める > 非同期的フューチャ","what":"マルチコアフューチャ (Multicore Future)","title":"future: Rにおける統一的な並列分散処理 ","text":"R がプロセスのフォーク (forking) をサポートしている OS（基本的には Windows 以外）では、バックグラウンドで R セッションを作成する代わりに、既存の R プロセスをフォークすることができる。 フォークがサポートされている場合、次のようにしてマルチコアフューチャを使用することができる。 マルチセッションフューチャと同じように、並列に実行できるプロセスの最大値は availableCores() によって決まる。 どちらの場合も評価はローカルマシン上で行われる。 フォークされた R プロセスでの実行は、バックグラウンド R セッションでの実行より速くなる。 その理由の1つは、フォークではメモリを共有するため、バックグラウンドセッションに大きなグローバル変数をエクスポートすることによるオーバーヘッドが無くなることにある。 一方、共有メモリは読み取り専用である。 つまり、フォークされたプロセス（ワーカ）が共有オブジェクトを変更しようとするとコピーを引き起こす。 これは、R のガベージコレクタが、フォークされたプロセスの1つで実行された場合にも生じる。 また、プロセスのフォークは R 環境によっては不安定である。 例えば、RStudio のプロセス内から R を実行しているときにフォークを行うと、 R セッションがクラッシュする可能性がある。 このため、future パッケージでは、RStudio 上でマルチコアフューチャの使用をデフォルトで無効にしている。 詳細は help(\"supportsMulticore\") を参照してほしい。","code":"plan(multicore)"},{"path":"https://future.futureverse.org/README_ja.html","id":"クラスタフューチャ-cluster-future","dir":"","previous_headings":"戦略：フューチャの解決方法を決める > 非同期的フューチャ","what":"クラスタフューチャ (Cluster Future)","title":"future: Rにおける統一的な並列分散処理 ","text":"クラスタフューチャは、（parallel パッケージで実装されているような）アドホッククラスタ上で式を評価する。 例えば、3つのクラスタノード n1, n2, n3 があるとき、それらを使って非同期処理を行うには次のようにする。 parallel::makeCluster() で作られたクラスタなら何でもクラスタフューチャで利用できる。 例えば、上記のクラスタを明示的にセットアップするには次のように書く。 クラスタ cl がもう使われなくなったとき、parallel::stopCluster(cl) を実行してクラスタをシャットダウンするのが良い作法である。 便利なことに、future パッケージは、メインプロセスが終了したときに、クラスタを自動でシャットダウンしてくれる。 クラスタのセットアップや管理については help(\"makeCluster\", package = \"parallel\") を参照してほしい。 plan(cluster, workers = hosts)（hosts には文字列が入る）で非明示的に作られたクラスタも、メインの R セッションが終了するとシャットダウンされる。 また、フューチャ戦略が変更されたとき（例えば plan(sequential) が呼ばれたとき）もクラスタはシャットダウンされる。 SSH キーペアなどの自動認証設定があるなら、リモートマシンのクラスタが同じ方法で使用できる。 各ノードで複数のワーカを実行したい場合は、次のようにノード名を複数回書けばよい。 この例では、n1 では3つ、n2 では1つ、n3 では5つと、合計9つのワーカにより並列実行される。","code":"> plan(cluster, workers = c(\"n1\", \"n2\", \"n3\")) > pid <- Sys.getpid() > pid [1] 1427324 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1427499 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1427324 cl <- parallel::makeCluster(c(\"n1\", \"n2\", \"n3\")) plan(cluster, workers = cl) > plan(cluster, workers = c(rep(\"n1\", times = 3), \"n2\", rep(\"n3\", times = 5)))"},{"path":"https://future.futureverse.org/README_ja.html","id":"フューチャのネストと評価トポロジー","dir":"","previous_headings":"戦略：フューチャの解決方法を決める","what":"フューチャのネストと評価トポロジー","title":"future: Rにおける統一的な並列分散処理 ","text":"ここまでの説明では、フューチャは同じ環境で作成されていた。 これは「フラットトポロジー」と言うことができる。 しかし、フューチャの内部でフューチャを作成することもできる。 これを「ネストトポロジー」と呼ぶ。 例えば、次の例では、2つの「トップ」フューチャ（と b）があり、マルチセッション戦略を使って評価される。 ただし、フューチャ b は内部に別のフューチャが使われている。 プロセスIDを見ると、3つの異なるプロセスがフューチャの解決に使われていることがわかる。 メインプロセス (pid 1427324)、に使われるプロセス (pid 1427606)、b に使われるプロセス (pid 1427607) である。 しかし、b にネストされている2つのフューチャ b1 と b2 は b と同じプロセスで評価されている。 これは、特に指定しない限り、ネストされたフューチャは逐次戦略を使って評価されるためである。 これにはいくつかの理由があるが、主な理由は、再帰呼び出しなどによって、誤って多くのバックグラウンドプロセスが発生するのを防ぐためである。 plan() に戦略のリストを渡すことで、評価トポロジーを指定することができる。 例えば、上記と同じ評価トポロジーを明示的に指定するには次のようにする。 しかし、次に示すように、複数レベルのマルチセッション評価を試しても、上記と同じ動作になる。 この理由は、ここでも、誤って多くのプロセスが起動するのを防ぐためである。 内部的には、parallel::mclapply() のような関数が逐次実行されるように mc.core = 1 が設定される。 これはマルチセッション評価とマルチコア評価の両方で起こる。 次に、トップレベルを逐次評価にして、ネストされたフューチャをマルチセッション評価してみよう。 と b は呼び出しプロセス (pid 1427324) で解決され、ネストされた2つのフューチャ（b1 と b2）はそれぞれ別のプロセス (pid 1427855 と 1427854) で解決されることがわかる。 各レベルで利用可能なコアの数を明示的に指定する（強制する）と、ネストされたマルチセッション評価戦略を使用することができる。 そのためには、次のようにしてデフォルト設定を “tweak” する必要がある。 まず、と b は呼び出しプロセス (pid 1427324) とは異なるプロセス（pid 1427973 と 1427972）で解決される。 次に、2つのネストされたフューチャ（b1 と b2）もまた異なるプロセス（pid 1428098 と 1428099）で解決される。 ネストされたフューチャの各レベルで異なる評価戦略を使う方法についての詳細は、ビネット ‘Futures R: Future Topologies’ を参照してほしい。","code":"> plan(multisession) > pid <- Sys.getpid() > a %<-% { +     cat(\"Future 'a' ...\\n\") +     Sys.getpid() + } > b %<-% { +     cat(\"Future 'b' ...\\n\") +     b1 %<-% { +         cat(\"Future 'b1' ...\\n\") +         Sys.getpid() +     } +     b2 %<-% { +         cat(\"Future 'b2' ...\\n\") +         Sys.getpid() +     } +     c(b.pid = Sys.getpid(), b1.pid = b1, b2.pid = b2) + } > pid [1] 1427324 > a Future 'a' ... [1] 1427606 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427607 1427607 1427607 plan(list(multisession, sequential)) > plan(list(multisession, multisession)) [...] > pid [1] 1427324 > a Future 'a' ... [1] 1427721 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427722 1427722 1427722 > plan(list(sequential, multisession)) [...] > pid [1] 1427324 > a Future 'a' ... [1] 1427324 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427324 1427855 1427854 > plan(list(tweak(multisession, workers = 2), tweak(multisession,  +     workers = 2))) [...] > pid [1] 1427324 > a Future 'a' ... [1] 1427973 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427972 1428098 1428099"},{"path":"https://future.futureverse.org/README_ja.html","id":"ブロックされずにフューチャの状態を確認する","dir":"","previous_headings":"戦略：フューチャの解決方法を決める","what":"ブロックされずにフューチャの状態を確認する","title":"future: Rにおける統一的な並列分散処理 ","text":"フューチャが解決済みか未解決かをブロックされずに確認する方法がある。 これには resolved(f) 関数を使う。 この関数には入力として明示的なフューチャ f を与える。 もし非明示的なフューチャを使っている場合、f <- futureOf() のようにして非明示的なフューチャを明示的なフューチャに変換する必要がある。 例を次に示す。","code":"> plan(multisession) > a %<-% { +     cat(\"Future 'a' ...\") +     Sys.sleep(2) +     cat(\"done\\n\") +     Sys.getpid() + } > cat(\"Waiting for 'a' to be resolved ...\\n\") Waiting for 'a' to be resolved ... > f <- futureOf(a) > count <- 1 > while (!resolved(f)) { +     cat(count, \"\\n\") +     Sys.sleep(0.2) +     count <- count + 1 + } 1  2  3  4  5  > cat(\"Waiting for 'a' to be resolved ... DONE\\n\") Waiting for 'a' to be resolved ... DONE > a Future 'a' ...done [1] 1428185"},{"path":"https://future.futureverse.org/README_ja.html","id":"フューチャにおけるエラー処理","dir":"","previous_headings":"","what":"フューチャにおけるエラー処理","title":"future: Rにおける統一的な並列分散処理 ","text":"フューチャが期待通りに動かない場合がある。 フューチャを評価しているときにエラーが起こった場合、そのエラーはフューチャの値が要求されたときに呼び出し環境へ伝播される。 例えば、遅延評価を使ったフューチャでエラーが起こった場合、次のようになる。 このエラーは値を要求するたびに起こる。 すなわち、もう一度値を取得しようとすると同じエラー（と出力）になる。 エラーを起こしたコールスタックの最後の呼び出しを見るには、backtrace() 関数(*)を使う。 (*) 一般的に使用される traceback() はフューチャの場合には関連情報を提供しない。 さらに、残念ながら、エラーの原因となった呼び出しのリストを見ることはできない。 エラーを起こした呼び出しだけを見ることができる（これは内部で使われる tryCatch() の制約である）。","code":"> plan(sequential) > b <- \"hello\" > a %<-% { +     cat(\"Future 'a' ...\\n\") +     log(b) + } %lazy% TRUE > cat(\"Everything is still ok although we have created a future that will fail.\\n\") Everything is still ok although we have created a future that will fail. > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function In addition: Warning message: restarting interrupted promise evaluation > backtrace(a) [[1]] log(a)"},{"path":"https://future.futureverse.org/README_ja.html","id":"グローバルオブジェクト","dir":"","previous_headings":"","what":"グローバルオブジェクト","title":"future: Rにおける統一的な並列分散処理 ","text":"R の式を非同期的に（並列に）評価するとき、または遅延評価で逐次評価するときは、グローバルオブジェクト（「フリー」オブジェクトとも言う）を特定して渡す必要がある。 遅延評価では、グローバルオブジェクトはフューチャの作成時と評価時で変更されている可能性があるため、フューチャの作成時とまったく同じ状態で渡す必要がある。 非同期評価では、フューチャを評価するプロセスにグローバルオブジェクトをエクスポートするために、それらを特定する必要がある。 future パッケージではこれをできる限り自動化している。 そのために静的コード解析によってグローバル変数を特定する globals パッケージが使われる。 グローバル変数が特定されると、キャプチャされ、評価プロセスで利用可能になる。 また、パッケージ内でグローバル変数が定義されている場合、それらはエクスポートされない。 かわりに、フューチャが評価されるときに対応するパッケージが確実に読み込まれているようにする。 これはメイン R セッションの設定をよりよく反映するだけでなく、グローバルオブジェクトのエクスポートの必要性も最小限に抑える。 これにより、特にリモートの計算ノードを使用する場合、メモリだけでなく時間と帯域幅も節約できる。 最後に、静的コード解析だけではグローバル変数を特定するのは難しいということを述べておこう。 グローバル変数の自動識別に失敗するケースが常に存在する。 そのため、間違ってグローバル判定してしまう場合（これは特に問題にならない）と、グローバル変数を見逃してしまう場合（この場合はエラーか間違った結果になる）がある。 ビネット ‘Futures R: Common Issues Solutions’ では、そのようなケースの一般的な例や、避けるにはどうすればいいか、また、どのようにグローバル変数が特定されるかや間違って特定したグローバル変数を無視する方法を説明している。 それでも十分でない場合、グローバル変数の名前を指定する（例：globals = c(\"\", \"slow_sum\")）か、名前と値のペアで指定する（例：globals = list(= 42, slow_sum = my_sum)）ことができる。","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"非明示的フューチャの制約","dir":"","previous_headings":"","what":"非明示的フューチャの制約","title":"future: Rにおける統一的な並列分散処理 ","text":"非明示的なフューチャには1つの制約がある。 明示的なフューチャは単なる R オブジェクトなので、どこでも何にでも代入可能である。 例えば、次のように、ループの中でフューチャをリストの要素として代入できる。 これは非明示的なフューチャではできない。 なぜなら、%<-% 演算子は通常の <- 代入演算子とは違う動作をするからである。 %<-% 演算子はフューチャの値を環境（呼び出し環境など）に代入する。 これは assign(name, value, envir) と同じ動作である。 したがって、上記と同様のことを非明示的フューチャで行いたい場合は、次のように名前インデックスを使って環境に代入する。 ここで、.list(v) は環境 v のすべてのフューチャが解決するまでブロックされる。 その後、フューチャの値は通常のリストとして返される。 もし数値インデックスを使いたい場合は、listenv パッケージで提供されているリスト環境を使えばよい。 リスト環境は、インデックス付きリストと同じように、インデックス付けすることができる環境である。 上記のコードでリストをリスト環境に置き換えると、数値インデックスを使って非明示的フューチャを代入できるようになる。 ここでも、.list(v) はすべてのフューチャが解決するまでブロックされる。","code":"> plan(multisession) > f <- list() > for (ii in 1:3) { +     f[[ii]] <- future({ +         Sys.getpid() +     }) + } > v <- lapply(f, FUN = value) > str(v) List of 3  $ : int 1428291  $ : int 1428290  $ : int 1428291 > plan(multisession) > v <- new.env() > for (name in c(\"a\", \"b\", \"c\")) { +     v[[name]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ a: int 1428405  $ b: int 1428406  $ c: int 1428405 > library(listenv) > plan(multisession) > v <- listenv() > for (ii in 1:3) { +     v[[ii]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ : int 1428523  $ : int 1428522  $ : int 1428523"},{"path":"https://future.futureverse.org/README_ja.html","id":"デモ","dir":"","previous_headings":"","what":"デモ","title":"future: Rにおける統一的な並列分散処理 ","text":"様々な戦略においてフューチャがどのように評価されるかの実例を見るには、このパッケージに含まれるマンデルブロ (Mandelbrot) デモを実行するとよい。 まず、逐次評価で実行してみよう。 これはフューチャを使用しない場合の動作とほとんど同じである。 次に、マルチセッション評価を試してみよう。 これは異なるマンデルブロ平面をバックグラウンドで実行される R プロセスで並列に計算する。 最後に、複数の計算機にアクセスできる場合、クラスタのワーカを指定して実行できる。","code":"library(future) plan(sequential) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(multisession) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(cluster, workers = c(\"n2\", \"n5\", \"n6\", \"n6\", \"n9\")) demo(\"mandelbrot\", package = \"future\", ask = FALSE)"},{"path":"https://future.futureverse.org/README_ja.html","id":"貢献するには","dir":"","previous_headings":"","what":"貢献するには","title":"future: Rにおける統一的な並列分散処理 ","text":"このパッケージの目的は、R でフューチャを使うための標準的で統一された API を提供することである。 現状はこの目的を達成するための初期段階にすぎない。 future パッケージを改善するアイデアや意見を持っている人がいたらぜひ教えてほしい。 開発者に連絡をとるには GitHub リポジトリ経由が好ましいが、どのような手段であっても歓迎する。","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"インストール","dir":"","previous_headings":"","what":"インストール","title":"future: Rにおける統一的な並列分散処理 ","text":"future パッケージは CRAN で利用可能であり、次のコードを実行してインストールできる。","code":"install.packages(\"future\")"},{"path":"https://future.futureverse.org/README_ja.html","id":"プレリリースバージョンのインストール","dir":"","previous_headings":"インストール","what":"プレリリースバージョンのインストール","title":"future: Rにおける統一的な並列分散処理 ","text":"プレリリースバージョンは GitHub の develop ブランチにあり、インストールするには次のようにする。 これはソースからのインストールとなる。","code":"remotes::install_github(\"futureverse/future\", ref=\"develop\")"},{"path":"https://future.futureverse.org/README_ja.html","id":"貢献","dir":"","previous_headings":"","what":"貢献","title":"future: Rにおける統一的な並列分散処理 ","text":"このパッケージに貢献するには、CONTRIBUTING.md を参照してほしい。","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A Future for R: A Comprehensive Overview","text":"purpose future package provide simple uniform way evaluating R expressions asynchronously using various resources available user. programming, future abstraction value may available point future. state future can either unresolved resolved. soon resolved, value available instantaneously. value queried future still unresolved, current process blocked future resolved. possible check whether future resolved without blocking. Exactly futures resolved depends strategy used evaluate . instance, future can resolved using sequential strategy, means resolved current R session. strategies may resolve futures asynchronously, instance, evaluating expressions parallel current machine concurrently compute cluster. example illustrating basics futures work. First, consider following code snippet uses plain R code: works assigning value expression variable v print value v. Moreover, expression v evaluated also print message. code snippet modified use futures instead: difference v constructed; plain R use <- whereas futures use %<-%. difference output relayed future resolved () value queried (see Vignette ‘Outputting Text’). futures useful? can choose evaluate future expression separate R process asynchronously simply switching settings : asynchronous futures, current/main R process block, means available processing futures resolved separate processes running background. words, futures provide simple yet powerful construct parallel / distributed processing R. Now, bothered read nitty-gritty details futures, just want try , skip end play Mandelbrot demo using parallel non-parallel evaluation.","code":"> v <- { +   cat(\"Hello world!\\n\") +   3.14 + } Hello world! > v [1] 3.14 > library(future) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14 > library(future) > plan(multisession) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"implicit-or-explicit-futures","dir":"Articles","previous_headings":"","what":"Implicit or Explicit Futures","title":"A Future for R: A Comprehensive Overview","text":"Futures can created either implicitly explicitly. introductory example used implicit futures created via v %<-% { expr } construct. alternative explicit futures using f <- future({ expr }) v <- value(f) constructs. , example alternatively written : Either style future construct works equally(*) well. implicit style similar regular R code written. principle, replace <- %<-% turn assignment future assignment. hand, simplicity can also deceiving, particularly asynchronous futures used. contrast, explicit style makes much clearer futures used, lowers risk mistakes better communicates design others reading code. (*) cases %<-% used without (small) modifications. return Section ‘Constraints using Implicit Futures’ near end document. summarize, explicit futures, use: f <- future({ expr }) - creates future v <- value(f) - gets value future (blocks yet resolved) implicit futures, use: v %<-% { expr } - creates future promise value keep simple, use implicit style rest document, everything discussed also apply explicit futures.","code":"> library(future) > f <- future({ +   cat(\"Hello world!\\n\") +   3.14 + }) > v <- value(f) Hello world! > v [1] 3.14"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"controlling-how-futures-are-resolved","dir":"Articles","previous_headings":"","what":"Controlling How Futures are Resolved","title":"A Future for R: A Comprehensive Overview","text":"future package implements following types futures: future package designed support additional strategies can implemented well. instance, future.callr package provides future backends evaluates futures background R process utilizing callr package - work similarly multisession futures advantages. Continuing, future.batchtools package provides futures types cluster functions (“backends”) batchtools package supports. Specifically, futures evaluating R expressions via job schedulers Slurm, TORQUE/PBS, Oracle/Sun Grid Engine (SGE) Load Sharing Facility (LSF) also available. default, future expressions evaluated eagerly (= instantaneously) synchronously (current R session). evaluation strategy referred “sequential”. section, go strategies discuss common differ.","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"consistent-behavior-across-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Consistent Behavior Across Futures","title":"A Future for R: A Comprehensive Overview","text":"going different future strategies, probably helpful clarify objectives Future API (defined future package). programming futures, really matter future strategy used executing code. really know computational resources user access choice evaluation strategy hands user developer. words, code make assumptions type futures used, e.g. synchronous asynchronous. One designs Future API encapsulate differences types futures appear work . despite expressions may evaluated locally current R session across world remote R sessions. Another obvious advantage consistent API behavior among different types futures helps prototyping. Typically one use sequential evaluation building script , later, script fully developed, one may turn asynchronous processing. , defaults different strategies results side effects evaluating future expression similar possible. specifically, following true futures: evaluation done local environment (.e. local({ expr })) assignments affect calling environment. natural evaluating external R process, also enforced evaluating current R session. future constructed, global variables identified. asynchronous evaluation, globals exported R process/session evaluating future expression. sequential futures lazy evaluation (lazy = TRUE), globals “frozen” (cloned local environment future). Also, order protect exporting large objects mistake, built-assertion total size globals less given threshold (controllable via option, cf. help(\"future.options\")). threshold exceeded, informative error thrown. Future expressions evaluated . soon value (error) collected available succeeding requests. example illustrating assignments done local environment: Now ready explore different future strategies.","code":"> plan(sequential) > a <- 1 > x %<-% { +     a <- 2 +     2 * a + } > x [1] 4 > a [1] 1"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"synchronous-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Synchronous Futures","title":"A Future for R: A Comprehensive Overview","text":"Synchronous futures resolved one another commonly R process creates . synchronous future resolved blocks main process resolved.","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"sequential-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Synchronous Futures","what":"Sequential Futures","title":"A Future for R: A Comprehensive Overview","text":"Sequential futures default unless otherwise specified. designed behave similar possible regular R evaluation still fulfilling Future API behaviors. example illustrating properties: Since eager sequential evaluation taking place, three futures resolved instantaneously moment created. Note also pid calling environment, assigned process ID current process, neither overwritten removed. futures evaluated local environment. Since synchronous (uni-)processing used, future b resolved main R process (still local environment), value b pid .","code":"> plan(sequential) > pid <- Sys.getpid() > pid [1] 1437557 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1437557 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1437557"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"asynchronous-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Asynchronous Futures","title":"A Future for R: A Comprehensive Overview","text":"Next, turn asynchronous futures, futures resolved background. design, futures non-blocking, , created calling process available tasks including creating additional futures. calling process tries access value future yet resolved, trying create another asynchronous future available R processes busy serving futures, blocks.","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"multisession-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multisession Futures","title":"A Future for R: A Comprehensive Overview","text":"start multisession futures supported operating systems. multisession future evaluated background R session running machine calling R process. example multisession evaluation: first thing observe values , c pid previously. However, notice b different . future b evaluated different R process therefore returns different process ID. multisession evaluation used, package launches set R sessions background serve multisession futures evaluating expressions created. background sessions busy serving futures, creation next multisession future blocked background session becomes available . total number background processes launched decided value availableCores(), e.g. particular result tells us mc.cores option set allowed use total two (2) processes including main process. words, settings, two (2) background processes serving multisession futures. availableCores() also agile different options system environment variables. instance, compute cluster schedulers used (e.g. TORQUE/PBS Slurm), set specific environment variable specifying number cores allotted given job; availableCores() acknowledges well. nothing else specified, available cores machine utilized, cf. parallel::detectCores(). details, please see help(\"availableCores\", package = \"parallelly\").","code":"> plan(multisession) > pid <- Sys.getpid() > pid [1] 1437557 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1437616 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1437557 > availableCores() mc.cores         2"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"multicore-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multicore Futures","title":"A Future for R: A Comprehensive Overview","text":"operating systems R supports forking processes, basically operating system except Windows, alternative spawning R sessions background fork existing R process. use multicore futures, supported, specify: Just like multisession futures, maximum number parallel processes running decided availableCores(), since cases evaluation done local machine. Forking R process can faster working separate R session running background. One reason overhead exporting large globals background session can greater forking, therefore shared memory, used. hand, shared memory read , meaning modifications shared objects one forked processes (“workers”) cause copy operating system. can also happen R garbage collector runs one forked processes. hand, process forking also considered unstable R environments. instance, running R within RStudio process forking may resulting crashed R sessions. , future package disables multicore futures default running RStudio. See help(\"supportsMulticore\") details.","code":"plan(multicore)"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"cluster-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Cluster Futures","title":"A Future for R: A Comprehensive Overview","text":"Cluster futures evaluate expressions ad-hoc cluster (implemented parallel package). instance, assume access three nodes n1, n2 n3, can use asynchronous evaluation : types clusters parallel::makeCluster() creates can used cluster futures. instance, cluster can explicitly set : Also, considered good style shut cluster cl longer needed, , calling parallel::stopCluster(cl). However, shut main process terminated. information set manage clusters, see help(\"makeCluster\", package = \"parallel\"). Clusters created implicitly using plan(cluster, workers = hosts) hosts character vector also shut main R session terminates, future strategy changed, e.g. calling plan(sequential). Note automatic authentication setup (e.g. SSH key pairs), nothing preventing us using approach using cluster remote machines. want run multiple workers node, replicate node name many times number workers run node. example, run three workers n1, one n2, five n3, total nine parallel workers.","code":"> plan(cluster, workers = c(\"n1\", \"n2\", \"n3\")) > pid <- Sys.getpid() > pid [1] 1437557 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1437715 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1437557 cl <- parallel::makeCluster(c(\"n1\", \"n2\", \"n3\")) plan(cluster, workers = cl) > plan(cluster, workers = c(rep(\"n1\", times = 3), \"n2\", rep(\"n3\", times = 5)))"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"nested-futures-and-evaluation-topologies","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Nested Futures and Evaluation Topologies","title":"A Future for R: A Comprehensive Overview","text":"far discussed can referred “flat topology” futures, , futures created assigned environment. However, nothing stopping us using “nested topology” futures, one set futures may, turn, create another set futures internally . instance, example two “top” futures (b) uses multisession evaluation second future (b) turn uses two internal futures: inspection process IDs, see total three different processes involved resolving futures. main R process (pid 1437557), two processes used (pid 1437804) b (pid 1437805). However, two futures (b1 b2) nested b evaluated R process b. nested futures use sequential evaluation unless otherwise specified. reasons , main reason protects us spawning large number background processes mistake, e.g. via recursive calls. specify different type evaluation topology, first level futures resolved multisession evaluation second level sequential evaluation, can provide list evaluation strategies plan(). First, evaluation strategies can explicitly specified : actually get behavior try multiple levels multisession evaluations; reason , also , protect us launching processes machine can support. Internally, done setting mc.cores = 1 functions like parallel::mclapply() fall back run sequentially. case multisession multicore evaluation. Continuing, start sequential evaluation use multisession evaluation nested futures, get: clearly show b resolved calling process (pid 1437557) whereas two nested futures (b1 b2) resolved two separate R processes (pids 1438017 1438016). said , indeed possible use nested multisession evaluation strategies, explicitly specify (read force) number cores available level. order need “tweak” default settings, can done follows: First, see b resolved different processes (pids 1438105 1438106) calling process (pid 1437557). Second, two nested futures (b1 b2) resolved yet two R processes (pids 1438211 1438212). details working nested futures different evaluation strategies level, see Vignette ‘Futures R: Future Topologies’.","code":"> plan(multisession) > pid <- Sys.getpid() > a %<-% { +     cat(\"Future 'a' ...\\n\") +     Sys.getpid() + } > b %<-% { +     cat(\"Future 'b' ...\\n\") +     b1 %<-% { +         cat(\"Future 'b1' ...\\n\") +         Sys.getpid() +     } +     b2 %<-% { +         cat(\"Future 'b2' ...\\n\") +         Sys.getpid() +     } +     c(b.pid = Sys.getpid(), b1.pid = b1, b2.pid = b2) + } > pid [1] 1437557 > a Future 'a' ... [1] 1437804 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1437805 1437805 1437805 plan(list(multisession, sequential)) > plan(list(multisession, multisession)) [...] > pid [1] 1437557 > a Future 'a' ... [1] 1437901 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1437902 1437902 1437902 > plan(list(sequential, multisession)) [...] > pid [1] 1437557 > a Future 'a' ... [1] 1437557 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1437557 1438017 1438016 > plan(list(tweak(multisession, workers = 2), tweak(multisession,  +     workers = 2))) [...] > pid [1] 1437557 > a Future 'a' ... [1] 1438105 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1438106 1438211 1438212"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"checking-a-future-without-blocking","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Checking A Future without Blocking","title":"A Future for R: A Comprehensive Overview","text":"possible check whether future resolved without blocking. can done using resolved(f) function, takes explicit future f input. work implicit futures (examples ), can use f <- futureOf() function retrieve explicit future implicit one. example,","code":"> plan(multisession) > a %<-% { +     cat(\"Future 'a' ...\") +     Sys.sleep(2) +     cat(\"done\\n\") +     Sys.getpid() + } > cat(\"Waiting for 'a' to be resolved ...\\n\") Waiting for 'a' to be resolved ... > f <- futureOf(a) > count <- 1 > while (!resolved(f)) { +     cat(count, \"\\n\") +     Sys.sleep(0.2) +     count <- count + 1 + } 1  2  3  4  5  6  7  8  9  10  > cat(\"Waiting for 'a' to be resolved ... DONE\\n\") Waiting for 'a' to be resolved ... DONE > a Future 'a' ...done [1] 1438287"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"failed-futures","dir":"Articles","previous_headings":"","what":"Failed Futures","title":"A Future for R: A Comprehensive Overview","text":"Sometimes future expected. error occurs evaluating future, error propagated thrown error calling environment future value requested. example, use lazy evaluation future generates error, might see something like error thrown time value requested, , try get value generate error (output): see last call call stack gave error, can use backtrace() function(*) future, .e. (*) commonly used traceback() provide relevant information context futures. Furthermore, unfortunately possible see list calls (evaluated expressions) led error; call gave error (due limitation tryCatch() used internally).","code":"> plan(sequential) > b <- \"hello\" > a %<-% { +     cat(\"Future 'a' ...\\n\") +     log(b) + } %lazy% TRUE > cat(\"Everything is still ok although we have created a future that will fail.\\n\") Everything is still ok although we have created a future that will fail. > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function In addition: Warning message: restarting interrupted promise evaluation > backtrace(a) [[1]] log(a)"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"globals","dir":"Articles","previous_headings":"","what":"Globals","title":"A Future for R: A Comprehensive Overview","text":"Whenever R expression evaluated asynchronously (parallel) sequentially via lazy evaluation, global (aka “free”) objects identified passed evaluator. need passed exactly time future created, , lazy evaluation, globals may otherwise change created resolved. asynchronous processing, reason globals need identified can exported process evaluates future. future package tries automate tasks far possible. help globals package, uses static-code inspection identify global variables. global variable identified, captured made available evaluating process. Moreover, global defined package, global exported. Instead, made sure corresponding package attached future evaluated. better reflects setup main R session, also minimizes need exporting globals, saves memory also time bandwidth, especially using remote compute nodes. Finally, clarified identifying globals static code inspection alone challenging problem. always corner cases automatic identification globals fails either false globals identified (less concern) true globals missing (result run-time error possibly wrong results). Vignette ‘Futures R: Common Issues Solutions’ provides examples common cases explains avoid well help package identify globals ignore falsely identified globals. suffice, always possible manually specify global variables names (e.g. globals = c(\"\", \"slow_sum\")) name-value pairs (e.g. globals = list(= 42, slow_sum = my_sum)).","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"constraints-when-using-implicit-futures","dir":"Articles","previous_headings":"","what":"Constraints when using Implicit Futures","title":"A Future for R: A Comprehensive Overview","text":"one limitation implicit futures exist explicit ones. explicit future just like object R can assigned anywhere/anything. instance, can create several loop assign list, e.g. possible using implicit futures. %<-% assignment operator used cases regular <- assignment operator can used. can used assign future values environments (including calling environment) much like assign(name, value, envir) works. However, can assign implicit futures environments using named indices, e.g. .list(v) blocks futures environment v resolved. values collected returned regular list. numeric indices required, list environments can used. List environments, implemented listenv package, regular environments customized subsetting operators making possible index much like lists can indexed. using list environments otherwise use lists, can also assign implicit futures list-like objects using numeric indices. example, previously, .list(v) blocks futures resolved.","code":"> plan(multisession) > f <- list() > for (ii in 1:3) { +     f[[ii]] <- future({ +         Sys.getpid() +     }) + } > v <- lapply(f, FUN = value) > str(v) List of 3  $ : int 1438377  $ : int 1438378  $ : int 1438377 > plan(multisession) > v <- new.env() > for (name in c(\"a\", \"b\", \"c\")) { +     v[[name]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ a: int 1438485  $ b: int 1438486  $ c: int 1438485 > library(listenv) > plan(multisession) > v <- listenv() > for (ii in 1:3) { +     v[[ii]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ : int 1438582  $ : int 1438583  $ : int 1438582"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"demos","dir":"Articles","previous_headings":"","what":"Demos","title":"A Future for R: A Comprehensive Overview","text":"see live illustration different types futures evaluated, run Mandelbrot demo package. First, try sequential evaluation, resembles script run futures used. , try multisession evaluation, calculates different Mandelbrot planes using parallel R processes running background. Try, Finally, access multiple machines can try set cluster workers use , e.g.","code":"library(future) plan(sequential) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(multisession) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(cluster, workers = c(\"n2\", \"n5\", \"n6\", \"n6\", \"n9\")) demo(\"mandelbrot\", package = \"future\", ask = FALSE)"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"future-frontends","dir":"Articles","previous_headings":"","what":"Future frontends","title":"A Future for R: Text and Message Output","text":"output relayed automatically also using frontends future.apply foreach doFuture. , works future backend. example, Equivalently,","code":"> library(future.apply) > plan(future.callr::callr)  > y <- future_lapply(1:3, FUN = function(x) { cat(\"x =\", x, \"\\n\"); message(\"x : \", x); sqrt(x) }) x = 1  x = 2  x = 3  x : 1  ## <= 1st message x : 2  ## <= 2nd message x : 3  ## <= 3rd message  > str(y) List of 3  $ : num 1  $ : num 1.41  $ : num 1.73 > library(doFuture) > registerDoFuture() > plan(future.callr::callr)  > y <- foreach(x = 1:3) %dopar% { cat(\"x =\", x, \"\\n\");  message(\"x : \", x); sqrt(x) } x = 1  x = 2  x = 3 x : 1  ## <= 1st message x : 2  ## <= 2nd message x : 3  ## <= 3rd message  > str(y) List of 3  $ : num 1  $ : num 1.41  $ : num 1.73"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"capturing-output","dir":"Articles","previous_headings":"","what":"Capturing output","title":"A Future for R: Text and Message Output","text":"capture output produced futures, use capture.output() capturing output elsewhere R. example,","code":"> library(future) > fa <- future({ cat(\"Hello world!\\n\"); print(1:3); 42L }) > stdout <- capture.output(a <- value(fa)) > stdout [1] \"Hello world!\" \"[1] 1 2 3\" > a [1] 42"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"suppressing-messages","dir":"Articles","previous_headings":"","what":"Suppressing messages","title":"A Future for R: Text and Message Output","text":"","code":"> library(future) > plan(multisession) > fa <- future({ message(\"Hello\"); print(1:3); message(\"world!\"); cat(\"ping\\n\"); 42L }) > suppressMessages(a <- value(fa)) [1] 1 2 3 ping > a [1] 42"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"known-limitations","dir":"Articles","previous_headings":"","what":"Known limitations","title":"A Future for R: Text and Message Output","text":"standard output relayed. possible relay output send standard error (stderr), e.g. output cat(..., file = stderr()) lost. due limitation R, preventing us capturing stderr reliable way, particularity across backends. However, note captured messages message() outputted stderr (expected) resignaled/relayed.","code":""},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"example-high-throughput-sequencing","dir":"Articles","previous_headings":"","what":"Example: High-Throughput Sequencing","title":"A Future for R: Future Topologies","text":"Consider high-throughput sequencing (HT-Seq) project 50 human DNA samples one FASTQ file per sample containing raw sequence reads come sequencing machine. data, wish align FASTQ reference genome generate 24 individual BAM files per sample - one per chromosome. layout analysis look like R using futures. default use synchronous futures, without specifications, process sample chromosome sequentially. Next, consider can done following two computer setups: single machine 8 cores compute cluster 3 machines 16 cores","code":"library(future) library(listenv) htseq_align <- function(fq, chr) { chr }  fqs <- dir(pattern = \"[.]fastq$\")  bams <- listenv() for (ss in seq_along(fqs)) {   fq <- fqs[ss]   bams[[ss]] %<-% {     bams_ss <- listenv()     for (cc in 1:24) {       bams_ss[[cc]] %<-% htseq_align(fq, chr = cc)     }     as.list(bams_ss)   } } bams <- as.list(bams)"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"one-multi-core-machine","dir":"Articles","previous_headings":"Example: High-Throughput Sequencing","what":"One multi-core machine","title":"A Future for R: Future Topologies","text":"single machine 8 cores, choose process multiple samples time processing chromosomes sequentially. words, like evaluate outer layer futures using multisession futures inner ones sequential futures. can specified : internals processing multisession future queries availableCores() infer many cores can used simultaneously, need explicitly specify 8 cores available. Comment: Since synchronous default future, skip trailing sequential futures setup, e.g. plan(list(multisession)) just plan(multisession). However, hurt explicit. instead like process sample sequentially chromosomes parallel, can use:","code":"plan(list(multisession, sequential)) plan(list(sequential, multisession))"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"built-in-protection-against-recursive-parallelism","dir":"Articles","previous_headings":"Example: High-Throughput Sequencing > One multi-core machine","what":"Built-in protection against recursive parallelism","title":"A Future for R: Future Topologies","text":"processed either outer inner set future parallel. want process layers parallel? ’s tempting use: Although give error, find inner layer futures processed sequentially just use plan(list(multisession, sequential)). behavior due built-protection nested parallelism. layers run parallel, using 8 cores available machine, running 8 * 8 = 64 parallel processes - sure overload computer. happens internally outer layer, availableCores() equals eight (8), whereas inner layer equals one (1). Now, imagine process outer layer , say, two parallel futures, inner layer four parallel futures. case, end running eight cores (= 2 * 4). can achieved forcing fixed number workers layer: Note -(.) specification inner layer, .e. workers = (4). just specify workers = 4, future framework detect potential user mistake. default prevents nested parallelization allots single CPU core inner layer, .e. availableCores() return one . However, user requests four CPU cores, result unintended 400% CPU overuse. future framework detects discrepancy, large, produce error. example, eight core machine, get following error produced inner layer: Futureverse built-protection, need explicitly override declaring nested workers using -(.) function. basically tells parallel framework “trust us, know ”. minimize risk mistakes make sure setup respects availableCores(). make sure stay within limits current machine, ’s best use something like: However, using nested parallelization single machine, make sure actually efficient using parallelization one layers.","code":"plan(list(multisession, multisession)) plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = I(4)))) > plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) > a %<-% { b %<-% 1 ; b } > a Error in checkNumberOfLocalWorkers(workers) :    Attempting to set up 4 localhost parallel workers with only 1 CPU cores available for this R process (per ‘mc.cores’), which could result in a 400% load. The hard limit is set to 300%. Overusing the CPUs has negative impact on the current R process, but also on all other processes of yours and others running on the same machine. See help(\"parallelly.maxWorkers.localhost\", package = \"parallelly\") for further explanations and how to override the hard limit that triggered this error plan(list(   tweak(multisession, workers = availableCores() %/% 4),   tweak(multisession, workers = I(4)) ))"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"an-ad-hoc-compute-cluster","dir":"Articles","previous_headings":"Example: High-Throughput Sequencing","what":"An ad-hoc compute cluster","title":"A Future for R: Future Topologies","text":"compute cluster 3 machines 16 cores, can run 48 alignment processes parallel. natural setup one machine process one sample parallel. specify : Comment: Multisession futures agile environment, , query machine running find many parallel processes can run time. One possible downside setup might utilize available cores time. alignment shorter chromosomes finish sooner longer ones, means might end sample alignment processes running machine leaving remaining cores idle/unused. alternative set use following setup: cause 24 (= 3*8) samples processed parallel processing two chromosomes time.","code":"nodes <- c(\"n1\", \"n2\", \"n3\") plan(list(tweak(cluster, workers = nodes), multisession)) nodes <- rep(c(\"n1\", \"n2\", \"n3\"), each = 8) plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = I(2)) ))"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"example-a-remote-compute-cluster","dir":"Articles","previous_headings":"","what":"Example: A Remote Compute Cluster","title":"A Future for R: Future Topologies","text":"Imagine access remote compute cluster, login node remote.server.org, cluster three nodes n1, n2, n3. Also, let us assume already set cluster can log via public key authentication via SSH, .e. ssh remote.server.org authentication done automatically. setup, can use nested futures local R session evaluate R expression remote compute cluster three nodes. proof concept illustrating different nested futures evaluated different machines. Try x %<-% { ... } future , say, plan(list(sequential, multisession)) see output .","code":"library(future) library(listenv)  ## Set up access to remote login node (must have Rscript) login <- tweak(cluster, workers = \"remote.server.org\", persistent = TRUE) plan(login)  ## Set up cluster nodes on login node nodes %<-% { .keepme <- parallelly::makeClusterPSOCK(c(\"n1\", \"n2\", \"n3\")) } print(nodes) ## socket cluster with 3 nodes on hosts 'n1', 'n2', 'n3'  ## Specify future topology ## login node -> { cluster nodes } -> { multiple cores } plan(list(   login,   tweak(cluster, workers = nodes),   multisession ))   ## (a) This will be evaluated on the cluster login computer x %<-% {   thost <- Sys.info()[[\"nodename\"]]   tpid <- Sys.getpid()   y <- listenv()   for (task in 1:4) {     ## (b) This will be evaluated on a compute node on the cluster     y[[task]] %<-% {       mhost <- Sys.info()[[\"nodename\"]]       mpid <- Sys.getpid()       z <- listenv()       for (jj in 1:2) {         ## (c) These will be evaluated in separate processes on the same compute node         z[[jj]] %<-% data.frame(task = task,                                 top.host = thost, top.pid = tpid,                                 mid.host = mhost, mid.pid = mpid,                                 host = Sys.info()[[\"nodename\"]],                                 pid = Sys.getpid())       }       Reduce(rbind, z)     }   }   Reduce(rbind, y) }  print(x) ##   task top.host top.pid mid.host mid.pid host    pid ## 1    1    login  391547       n1  391878   n1 393943 ## 2    1    login  391547       n1  391878   n1 393951 ## 3    2    login  391547       n2  392204   n2 393971 ## 4    2    login  391547       n2  392204   n2 393978 ## 5    3    login  391547       n3  392527   n3 394040 ## 6    3    login  391547       n3  392527   n3 394048 ## 7    4    login  391547       n1  391878   n1 393959 ## 8    4    login  391547       n1  391878   n1 393966"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"example-adjust-the-number-of-workers-for-each-cluster-node","dir":"Articles","previous_headings":"","what":"Example: Adjust the Number of Workers for Each Cluster Node","title":"A Future for R: Future Topologies","text":"using number workers used nodes (n1, n2, n3) given value availableCores() nodes. turn, availableCores() typically defaults number cores nodes. Now, imagine want use 50% cores. can done tweaking multisession plan passing function workers; , node use 50% cores available. instance, n1 n2 eight cores, n3 32 cores, nodes use four, four, 16 cores, respectively. Another example : case, node n1 always use two cores, n2 three cores, n3 respect availableCores() returns.","code":"nodes <- c(\"n1\", \"n2\", \"n3\") plan(list(tweak(cluster, workers = nodes), multisession)) halfCores <- function() { max(1, round(0.5 * availableCores())) plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = I(halfCores)) )) customWorkers <- function() {   switch(Sys.info()[[\"nodename\"]],     \"n1\" = 2L,     \"n2\" = 3L,     ## default:     availableCores()   ) } plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = I(customWorkers)) ))"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"missing-globals-false-negatives","dir":"Articles","previous_headings":"Issues with globals and packages","what":"Missing globals (false negatives)","title":"A Future for R: Common Issues with Solutions","text":"global variable used future expression conditionally overrides global variable local one, future framework fails identify global variable therefore fails export , resulting run-time error. example, although works: following work: recommended avoid constructs ambiguous whether variable global local. force variable x always global, insert future expression, e.g. Comment: goal future version package detect globals also expression local-global state variable known run time.","code":"plan(multisession)  reset <- TRUE x <- 1 y %<-% { if (reset) x <- 0; x + 1 } y ## [1] 1 reset <- FALSE x <- 1 y %<-% { if (reset) x <- 0; x + 1 } y ## Error: object 'x' not found reset <- FALSE x <- 1 y %<-% { x; if (reset) x <- 0; x + 1 } y ## [1] 2"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"do-call---function-not-found","dir":"Articles","previous_headings":"Issues with globals and packages > Missing globals (false negatives)","what":"do.call() - function not found","title":"A Future for R: Common Issues with Solutions","text":"calling function using .call() make sure specify function object name. help identify function global object future expression. instance, use instead file_ext() properly located exported. Although may notice difference evaluating futures R session, may become problem use character string instead function object futures evaluated external R sessions, cluster. may also become problem futures evaluated lazy evaluation intended function redefined future resolved. example,","code":"do.call(file_ext, list(\"foo.txt\")) do.call(\"file_ext\", list(\"foo.txt\")) > library(future) > library(listenv) > library(tools) > plan(sequential) > pathnames <- c(\"foo.txt\", \"bar.png\", \"yoo.md\") > res <- listenv() > for (ii in seq_along(pathnames)) { +   res[[ii]] %<-% do.call(\"file_ext\", list(pathnames[ii])) %lazy% TRUE + } > file_ext <- function(...) \"haha!\" > unlist(res) [1] \"haha!\" \"haha!\" \"haha!\""},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"get---object-not-found","dir":"Articles","previous_headings":"Issues with globals and packages > Missing globals (false negatives)","what":"get() - object not found","title":"A Future for R: Common Issues with Solutions","text":"base R function get() can used get value object name. example, get(\"pi\", envir = baseenv()) get value object pi ‘base’ environment, .e. corresponds base::pi. objects named pi exists search path, used get(\"pi\") pi, respectively. unusual see code snippets : attempt call my_sum() via future, get error (future resolved external R process); static code inspection done future expression my_sum(\"\") reveal object global object. expression alone, three objects: function my_sum(), primitive function (, string \"\", none object . future framework also scan three objects globals, example means scans also my_sum(). recursive search globals identify three additional globals, namely, primitive function {, function sum(), function get(), , , none source identify global object. order identified, future framework need built-understanding get(var) works, daunting task, especially need know acts different data types var various choices arguments envir enclos. fact, can often inferred run time, , possible identify objects needed without actually running code. short, possible automatically identify global variables specified via character string. workaround tell future framework additional globals needed. can done via argument globals using: injecting variable beginning future expression, e.g. Note , independently future framework, often bad idea use get(), related functions mget() assign(), R code. Searching archives R forums, R-help R-devel mailing lists, reveal numerous suggestions using . good rule thumb : find using get() code, take step back, reconsider implementation. likely better solution available. example, consider , slightly complex, example: Instead using “free roaming” objects , b, c, ’s better put values list (data frame length); turn allow us perform calculations without use get();","code":"> a <- 1:3 > b <- 4:6 > c <- 3:5 > my_sum <- function(var) { sum(get(var)) } > y <- my_sum(\"a\") > y [1] 6 > library(future) > plan(multisession) > f <- future(my_sum(\"a\")) > y <- value(f) Error in get(var) : object 'a' not found > f <- future(my_sum(\"a\"), globals = structure(TRUE, add = \"a\")) > y <- value(f) > y [1] 6 > f <- future({ a; my_sum(\"a\") }) > y <- value(f) > y [1] 6 > a <- 1:3 > b <- 4:7 > c <- 3:5 > my_sum <- function(var) { sum(get(var)) } > y <- sapply(c(\"a\", \"b\", \"c\"), FUN = my_sum) > y  a  b  c  6 22 12 > data <- list(a = 1:3, b = 4:7, c = 3:5) > my_sum <- function(x) { sum(x) } > y <- sapply(data, FUN = my_sum) > y  a  b  c  6 22 12"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"glueglue---object-not-found","dir":"Articles","previous_headings":"Issues with globals and packages > Missing globals (false negatives)","what":"glue::glue() - object not found","title":"A Future for R: Common Issues with Solutions","text":"future framework fail identify globals declared via character strings. section gives example get() used explains feasible automatically identify string-embedded globals code. Another example, using glue() glue package generate strings dynamically, e.g. Attempt perform via future resolved another R session produce “object found” error; explained previous section, workaround specify additional global variables , can done : alternative solution guide future framework adding missing globals “dummy” variables, e.g.","code":"> library(glue) > a <- 42 > s <- glue(\"The value of a is {a}.\") > s The value of a is 42. > library(glue) > library(future) > plan(multisession) > a <- 42 > s %<-% glue(\"The value of a is {a}.\") > s Error in eval(parse(text = text, keep.source = FALSE), envir) :    object 'a' not found > s %<-% glue(\"The value of a is {a}.\") %globals% structure(TRUE, add = \"a\") > s The value of a is 42. > s %<-% { a; glue(\"The value of a is {a}.\") } > s The value of a is 42."},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"missing-packages-false-negatives","dir":"Articles","previous_headings":"Issues with globals and packages","what":"Missing packages (false negatives)","title":"A Future for R: Common Issues with Solutions","text":"Occasionally, static-code inspection future expression fails identify packages needed evaluated expression. may occur expression uses S3 generic functions part one package whereas required S3 method another package. example, future generic function [ used data.table object DT, requires S3 method [.data.table data.table package. However, future globals packages fail identify data.table required package, results evaluation error: error occurs , contrary master R process, R worker evaluated future expression data.table loaded. Instead evaluation falls back [.data.frame method, want. future framework manages identify data.table required package (goal), can guide future specifying additional packages needed: equivalently Note, use library() loadNamespace() resolve problems. always better use packages approach.","code":"> library(future) > plan(multisession)  > library(data.table) > DT <- data.table(a = LETTERS[1:3], b = 1:3) > y %<-% DT[, sum(b)] > y Error: object 'b' not found > y %<-% DT[, sum(b)] %packages% \"data.table\" > y [1] 6 > f <- future(DT[, sum(b)], packages = \"data.table\") > value(f) [1] 6"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"used-in-an-incorrect-context","dir":"Articles","previous_headings":"","what":"‘…’ used in an incorrect context","title":"A Future for R: Common Issues with Solutions","text":"R, can use ... construct used refer zero arguments. example, can use : makes sure trim na.rm arguments passed mean() function. can also use pass arguments map-reduce calls anonymous functions : Note digits = 3 passed anonymous function via ... argument, passed round(), effectively calling round(X[[1]], digits = 3), round(X[[2]], digits = 3), . take one step , might see things like: case, two levels ... arguments; one my_fcn() one anonymous function. Note ... arguments my_fcn() passed anonymous function specifying ... final argument lapply(). ideal proper way pass .... However, uncommon see ... used global variable anonymous functions. example, might find: also work, ... becomes global variable environment anonymous function. Although know relying global variables bad idea, one often slips . attempt future framework, parallel frameworks, might work. example, using: might result error : Even get error, always good idea make sure ... passed argument way used, e.g.","code":"my_mean <- function(x, ...) mean(x, ...)  y <- my_mean(1:10, trim = 0.1, na.rm = FALSE) X <- rnorm(10) y <- lapply(X, FUN = function(x, ...) {   round(x, ...) }, digits = 3) my_fcn <- function(X, ...) {  ## outer '...'   y <- lapply(X, FUN = function(x, ...) { ## inner '...'     round(x, ...) ## inner '...'   }, ...) ## outer '...'   y }  X <- rnorm(10) y <- my_fcn(X, digits = 3) my_fcn <- function(X, ...) {  ## outer '...'   y <- lapply(X, FUN = function(x) {     round(x, ...) ## outer '...' as global variables   })   y } my_fcn <- function(X, ...) {   y <- future_lapply(X, FUN = function(x) {     round(x, ...)   })   y } Error: '...' used in an incorrect context my_fcn <- function(X, ...) {   y <- future.apply::future_lapply(X, FUN = function(x, ...) {     round(x, ...)   }, ...)   y }"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"non-exportable-objects","dir":"Articles","previous_headings":"","what":"Non-exportable objects","title":"A Future for R: Common Issues with Solutions","text":"Certain types objects tied given R session passed along another R process (“worker”). example non-exportable object XML objects xml2 package. attempt use parallel processing, may get error future evaluated (just invalid results depending used), e.g. future framework can help detect sending future worker; additional details non-exportable objects examples R packages use objects may cause problems parallel processing, see Vignette ‘Non-Exportable Objects’.","code":"> library(future) > plan(multisession) > library(xml2) > xml <- read_xml(\"<body><\/body>\") > f <- future(xml_children(xml)) > value(f) Error: external pointer is not valid > options(future.globals.onReference = \"error\") > f <- future(xml_children(xml)) Error in FALSE :    Detected a non-exportable reference ('externalptr') in one of the globals ('xml' of class 'xml_document') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"trying-to-pass-an-unresolved-future-to-another-future","dir":"Articles","previous_headings":"","what":"Trying to pass an unresolved future to another future","title":"A Future for R: Common Issues with Solutions","text":"possible future resolve another one unless created future trying resolve . instance, following gives error: main R process creates two futures, second future tries retrieve value first one. invalid request second future channel communicate first future; process created future can communicate (*). Note unresolved futures queried way. Thus, solution problem make sure futures resolved passed futures, e.g. works value already collected stored inside future f1 future f2 created. Since value already stored internally, value(f1) readily available everywhere. course, instead using value(f1) second future, readable cleaner simply use v1. typically problem future assignments used. example: reason approach works box second future assignment v1 identified global variable, retrieved. point, v1 promise (“delayed assignment” R), retrieved global variable value resolved v1 becomes regular variable. However, cases future assignments can passed via global variables without resolved. can happen future assignment done element environment (including list environments). instance, previously, can avoided making sure x$resolved first, can one various ways, e.g. dummy <- x$, resolve(x$) force(x$). Footnote: (*) Although sequential futures passed futures part R process resolved share evaluation process, definition Future API invalid regardless future type. conservative approach taken order make future expressions behave consistently regardless type future used.","code":"> library(future) > plan(multisession) > f1 <- future({ Sys.getpid() }) > f2 <- future({ value(f1) }) > v1 <- value(f1) [1] 7464 > v2 <- value(f2) Error: Invalid usage of futures: A future whose value has not yet been collected  can only be queried by the R process (cdd013cb-e045-f4a5-3977-9f064c31f188; pid  1276 on MyMachine) that created it, not by any other R processes (5579f789-e7b6  -bace-c50d-6c7a23ddb5a3; pid 2352 on MyMachine): {; Sys.getpid(); } > f1 <- future({ Sys.getpid() }) > v1 <- value(f1) > v1 [1] 7464 > f2 <- future({ value(f1) }) > v2 <- value(f2) > v2 [1] 7464 > v1 %<-% { Sys.getpid() }) > v2 %<-% { v1 } > v1 [1] 2352 > v2 [1] 2352 > library(listenv) > x <- listenv() > x$a %<-% { Sys.getpid() } > x$b %<-% { x$a } > x$a [1] 2352 > x$b Error: Invalid usage of futures: A future whose value has not yet been collected  can only be queried by the R process (cdd013cb-e045-f4a5-3977-9f064c31f188; pid  1276 on localhost) that created it, not by any other R processes (2ce86ccd-5854  -7a05-1373-e1b20022e4d8; pid 7464 on localhost): {; Sys.getpid(); }"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"capturing-errors-outputting-their-messages-and-returning-a-default-value","dir":"Articles","previous_headings":"Miscellaneous","what":"Capturing errors, outputting their messages, and returning a default value","title":"A Future for R: Common Issues with Solutions","text":"Sometimes function call produce error particular input. cases, might want return default value, say, missing value, instead signaling error. can done using: , res takes value unstable_calc(x), unless produces error, case takes value NA_real_. addition , produce warning whenever get error replace missing value. can : turn error warning message. want just output message without producing warning, can use message(conditionMessage(e)). Importantly, must use just warning(e) message(e), although appears work first glance. , end re-signaling error without interruption. important distinction reveal used within futures. example warning(conditionMessage(e)) work expected, use warning(e) future framework produce error, warning.","code":"res <- tryCatch({   unstable_calc(x) }, error = function(e) {   NA_real_ }) res <- tryCatch({   unstable_calc(x) }, error = function(e) {   warning(conditionMessage(e))   NA_real_ })"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"using-source-in-a-future","dir":"Articles","previous_headings":"Miscellaneous","what":"Using source() in a future","title":"A Future for R: Common Issues with Solutions","text":"Avoid using source() inside futures. always better source external R scripts top main R script, e.g. However, find source script inside future, inside function, make sure specify argument local = TRUE, e.g. source() defaults local = FALSE, side effects. using local = FALSE, functions variables defined R script assigned global environment - calling environment might expect. may make little different calling source() R prompt, another script. However, called inside function, inside local(), inside future, might result unexpected behavior. similar using assign(\"\", 42, envir = globalenv()), known bad practice. safe side, almost always better call source() local = TRUE.","code":"library(future) source(\"./my-script.R\")  f <- future({   ... }) f <- future({   source(\"./my-script.R\", local = TRUE)   ... })"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"clashes-with-other-packages","dir":"Articles","previous_headings":"Miscellaneous","what":"Clashes with other packages","title":"A Future for R: Common Issues with Solutions","text":"Sometimes packages functions operators name future package, packages attached future package, objects mask ones future package. instance, igraph package also defines %<-% operator clashes one future used prompt script (problem inside package explicitly import objects known order). might get: get error %<-% igraph future assignment operator wanted. can confirmed : avoid problem, attach two packages opposite order future comes last thereby overrides igraph, .e. alternative detach future package re-attach , achieve thing: Yet another alternative explicitly override object importing global environment, e.g. case, matter order packages attached always use copy future::`%<-%`.","code":"> library(future) > library(igraph)  Attaching package: 'igraph'  The following objects are masked from 'package:future':      %<-%, %->%  The following objects are masked from 'package:stats':      decompose, spectrum  The following object is masked from 'package:base':      union  > y %<-% { 42 } Error in get(\".igraph.from\", parent.frame()) :    object '.igraph.from' not found > environment(`%<-%`) <environment: namespace:igraph> > library(igraph) > library(future)  Attaching package: 'future'  The following objects are masked from 'package:igraph':  %<-%, %->%  > y %<-% { 42 } > y [1] 42 > detach(\"package:future\") > library(future) > `%<-%` <- future::`%<-%` > y %<-% { 42 } > y [1] 42"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"syntax-error-non-numeric-argument-to-binary-operator","dir":"Articles","previous_headings":"Miscellaneous","what":"Syntax error: “non-numeric argument to binary operator”","title":"A Future for R: Common Issues with Solutions","text":"future assignment operator %<-% binary infix operator, means higher precedence binary operators also higher unary operators R. instance, explains get following error: effectively happening higher priority %<-%, first create future x %<-% 2 try multiply future (value) value runif(1) - makes sense. order properly assign future variable, need put future expression within curly brackets; Parentheses also . details precedence operators R, see Section ‘Infix prefix operators’ ‘R Language Definition’ document.","code":"> x %<-% 2 * runif(1) Error in x %<-% 2 * runif(1) : non-numeric argument to binary operator > x %<-% { 2 * runif(1) } > x [1] 1.030209"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"error-invalid-type-environment-of-argument-with-magrittr","dir":"Articles","previous_headings":"Miscellaneous","what":"Error: invalid ‘type’ (environment) of argument with magrittr","title":"A Future for R: Common Issues with Solutions","text":"Another example future assignment operator %<-% requires curly brackets using magrittr infix operator %>%, e.g. reason error x %<-% 1:100 passed sum() %>%. fix , use:","code":"> library(magrittr) > x %<-% 1:100 %>% sum Error in sum(.) : invalid 'type' (environment) of argument > x %<-% { 1:100 %>% sum } > x [1] 5050"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"r-cmd-check-notes","dir":"Articles","previous_headings":"Miscellaneous","what":"R CMD check NOTEs","title":"A Future for R: Common Issues with Solutions","text":"code inspection run R CMD check recognize future assignment operator %<-% assignment operator, surprising %<-% technically infix operator. means instance use following code package: R CMD check produce NOTE saying: order avoid , can add dummy assignment missing global top function, .e.","code":"foo <- function() {   b <- 3.14   a %<-% { b + 1 }   a } * checking R code for possible problems ... NOTE foo: no visible binding for global variable 'a' Undefined global functions or variables:   a foo <- function() {   a <- NULL ## To please R CMD check   b <- 3.14   a %<-% { b + 1 }   a }"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"a-first-example---file-connections","dir":"Articles","previous_headings":"","what":"A first example - file connections","title":"A Future for R: Non-Exportable Objects","text":"example non-exportable object connection, e.g. file connection. instance, create file connection, work used another R process. try, result “unknown”, e.g. words, output \"world!\" written R worker completely lost. culprit connection uses called external pointer: bound main R process makes sense worker. Ideally, R process worker detect produce informative error message, seen , always occur.","code":"con <- file(\"output.log\", open = \"wb\") cat(\"hello \", file = con) flush(con) readLines(\"output.log\", warn = FALSE) ## [1] \"hello \" library(future) plan(multisession) f <- future({ cat(\"world!\", file = con); flush(con) }) value(f) ## NULL close(con) readLines(\"output.log\", warn = FALSE) ## [1] \"hello \" str(con) ## Classes 'file', 'connection'  atomic [1:1] 3 ##   ..- attr(*, \"conn_id\")=<externalptr>"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"protect-against-non-exportable-objects","dir":"Articles","previous_headings":"","what":"Protect against non-exportable objects","title":"A Future for R: Non-Exportable Objects","text":"help avoiding exporting non-exportable objects mistakes, typically happens global variable non-exportable, future framework provides mechanism automatically detecting objects. enable , : Comment: future.globals.onReference options set \"ignore\" default due extra overhead \"error\" introduces, can significant large nested objects. Furthermore, subclasses external pointers can exported without causing problems.","code":"options(future.globals.onReference = \"error\") f <- future({ cat(\"world!\", file = con); flush(con) }) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('con' of class 'file') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"packages-with-non-exportable-objects","dir":"Articles","previous_headings":"","what":"Packages with non-exportable objects","title":"A Future for R: Non-Exportable Objects","text":"table sections provide examples non-exportable R objects may run trying parallelize code, simply trying reload objects saved previous R session. identify cases, please consider reporting can documented possibly even fixed. illustrated sections ‘Packages rely external pointers’ ‘Packages types non-external objects’ . Importantly, objects external pointer can indeed exported. example, discussed sections ‘False positives - packages exportable external pointers’ end vignette.","code":""},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-parallel","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages with connections","what":"Package: parallel","title":"A Future for R: Non-Exportable Objects","text":"turn options(future.globals.onReference = \"error\"), catch already create future:","code":"library(future) plan(multisession, workers = 2)  cl <- parallel::makeCluster(2L) y <- parSapply(cl, X = 2:3, FUN = sqrt) y ## [1] 1.414214 1.732051  y %<-% parSapply(cl, X = 2:3, FUN = sqrt) y ## Error in summary.connection(connection) : invalid connection y %<-% parSapply(cl, X = 2:3, FUN = sqrt) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('cl' of class 'SOCKcluster') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"packages-that-rely-on-external-pointers","dir":"Articles","previous_headings":"Packages with non-exportable objects","what":"Packages that rely on external pointers","title":"A Future for R: Non-Exportable Objects","text":"object carries external pointer, likely can used R session created. exported used parallel process, likely cause error . shown , examples, setting option future.globals.onReference \"error\" make future scan external pointer:s launching future parallel worker, throw error one detected. However, objects external pointer:s can exported, e.g. data.table objects data.table package one example. words, existence external pointer just suggestion object non-exportable - sufficient condition. examples packages produce non-exportable objects external pointer:s.","code":""},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-arrow","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: arrow","title":"A Future for R: Non-Exportable Objects","text":"arrow package provides efficient -memory storage arrays tables. However, objects transferred -parallel worker. error takes place parallel worker. set options(future.globals.onReference = \"error\") future detect problem sends object parallel worker. said, arrow package provides low-level functions write_to_raw() read_ipc_stream() can used marshal unmarshal arrow objects. example,","code":"library(arrow)  library(future) plan(multisession)  data <- as_arrow_table(iris) f <- future(dim(data)) v <- value(f) #> Error: Invalid <Table>, external pointer to null library(arrow)  library(future) plan(multisession)  data <- as_arrow_table(iris) .data <- write_to_raw(data)      ## marshal f <- future({   data <- read_ipc_stream(.data) ## unmarshal   dim(data) }) v <- value(f) print(v) #> [1] 150   5"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-bigmemory","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: bigmemory","title":"A Future for R: Non-Exportable Objects","text":"bigmemory package provides mechanisms working large matrices can updated -place, helps save memory. example, Note x updated -place. achieved big.matrix objects holds external pointer matrix data stored; try use x parallel worker, parallel worker crashes due bug bigmemory, e.g. can protected setting: gives:","code":"library(bigmemory)  g <- function(x) {   x[1,1] <- 42L   x }  x <- big.matrix(nrow = 3, ncol = 2, type = \"integer\") print(x[1,1]) #> [1] NA  void <- g(x) print(x[1,1]) #> [1] 42 str(x) #> Formal class 'big.matrix' [package \"bigmemory\"] with 1 slot #>   ..@ address:<externalptr> library(bigmemory)  library(future) plan(multisession, workers = 2)  x <- big.matrix(nrow = 3, ncol = 2, type = \"integer\") f <- future(dim(x), packages = \"bigmemory\") value(f) #> Error in unserialize(node$con) :  #>   MultisessionFuture (<none>) failed to receive message results from #> cluster RichSOCKnode #1 (PID 1746676 on localhost 'localhost'). The #> reason reported was 'error reading from connection'. Post-mortem #> diagnostic: No process exists with this PID, i.e. the localhost worker #> is no longer alive. Detected a non-exportable reference #> ('externalptr') in one of the globals ('x' of class 'big.matrix') used #> in the future expression. The total size of the 1 globals exported is #> 696 bytes. There is one global: 'x' (696 bytes of class 'S4') options(future.globals.onReference = \"error\") f <- future(dim(x), packages = \"bigmemory\") #> Error: Detected a non-exportable reference ('externalptr') in one #> of the globals ('x' of class 'big.matrix') used in the future #> expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-cpp11","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: cpp11","title":"A Future for R: Non-Exportable Objects","text":"Another example cpp11, allows us easily create R functions implemented C++, e.g. : However, function exported another R process:","code":"cpp11::cpp_source(code = ' #include \"cpp11/doubles.hpp\" using namespace cpp11;  [[cpp11::register]] int my_length(doubles x) {     return x.size(); } ') x <- rnorm(10) my_length(x) ## [1] 10 library(future) plan(multisession) x <- rnorm(10) n %<-% my_length(x) n #> Error in .Call(\"_code_1748ff617940b9_my_length\", x, PACKAGE = \"code_1748ff617940b9\") : #>   \"_code_1748ff617940b9_my_length\" not available for .Call() for package \"code_1748ff617940b9\""},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-dbi","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: DBI","title":"A Future for R: Non-Exportable Objects","text":"DBI provides unified database interface communication R various database engines. Analogously regular connections R, DBIConnection objects can safely exported another R process, e.g.","code":"library(future) options(future.globals.onReference = \"error\") plan(multisession) library(DBI) con <- dbConnect(RSQLite::SQLite(), \":memory:\") dummy %<-% print(con) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('con' of class 'SQLiteConnection') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-inline","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: inline","title":"A Future for R: Non-Exportable Objects","text":"Another example inline, allows us easily create R functions implemented C C++, e.g. However, attempt call sum_1_to_n() future, get error: :","code":"library(inline) code <- \"   int i;   for (i = 0; i < *n; i++) x[0] = x[0] + (i+1); \" sum_1_to_n <- cfunction(signature(n=\"integer\", x=\"numeric\"), code, language = \"C\", convention = \".C\") y <- sum_1_to_n(10, 0)$x print(y) ## 55 library(future) plan(cluster, workers = 1L) f <- future(sum_1_to_n(10, 0)) v <- value(f) ## Error in .Primitive(\".C\")(<pointer: (nil)>, n = as.integer(n), x = as.double(x)) : ##   NULL value passed as symbol address options(future.globals.onReference = \"error\") f <- future(sum_1_to_n(10, 0)) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'DLLHandle') in one of the globals ('sum_1_to_n' of class 'CFunc') ## used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-keras","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: keras","title":"A Future for R: Non-Exportable Objects","text":"keras package provides R interface Keras, “high-level neural networks API developed focus enabling fast experimentation”. R implementation accesses Keras Python API via reticulate. However, Keras model instances R make use R connections external pointers, prevents exported external R processes. example, attempt use Keras model multisession workers, worker produce run-time error: error message helpful. , turn options(future.globals.onReference = \"error\"), get clues; Functions serialize_model() unserialize_model() keras package can used workaround marshal unmarshal non-exportable keras objects, e.g.","code":"library(keras)  library(future) plan(multisession)  ## Adopted from the 'keras' vignettes inputs <- layer_input(shape = shape(32)) outputs <- layer_dense(inputs, units = 1L) model <- keras_model(inputs, outputs) model <- compile(model, optimizer = \"adam\", loss = \"mean_squared_error\")  test_input <- array(runif(128 * 32), dim = c(128, 32)) test_target <- array(runif(128), dim = c(128, 1)) fit(model, test_input, test_target)  f <- future({   stats::predict(model, test_input) }, seed = TRUE) pred <- value(f) ## Error in do.call(object$predict, args) : ##   'what' must be a function or character string Error: Detected a non-exportable reference ('externalptr') in one of the globals ('model' of class 'keras.engine.functional.Functional') used in the future expression .model <- serialize_model(model)      ## marshal f <- future({   model <- unserialize_model(.model)  ## unmarshal   stats::predict(model, test_input) }, seed = TRUE) rm(.model) ## not needed anymore  pred <- value(f) str(pred) ## num [1:128, 1] 0.6937 -0.048 0.2996 -0.0818 1.0673 ..."},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-magick","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: magick","title":"A Future for R: Non-Exportable Objects","text":"magick package provides R-level API ImageMagick work images. working API, images represented internally external pointers class ‘magick_image’ exported another R process, e.g. set: ’ll see caught even attempting run parallel;","code":"library(future) plan(multisession) library(magick) frink <- magick::image_read(\"https://jeroen.github.io/images/frink.png\") f <- future(image_fill(frink, \"orange\", \"+100+200\", 20)) v <- value(f) ## Error: Image pointer is dead. You cannot save or cache image objects ## between R sessions. options(future.globals.onReference = \"error\") > f <- future(image_fill(frink, \"orange\", \"+100+200\", 20)) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'magick-image') in one of the globals ('frink' of class 'magick-image') ## used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-polars","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: polars","title":"A Future for R: Non-Exportable Objects","text":"polars package provides objects performant processing tabular data. However, objects tied R process created . attempt use parallel worker, end crashing parallel worker: external pointer RPolarsDataFrame object erased transferred another process, polars (>= 0.15.0) detects gives informative error message .","code":"library(future) plan(multisession)  library(polars) data <- as_polars_df(data.frame(x = 1:3)) f <- future(dim(data), packages = \"polars\") v <- value(f) #> Error: Execution halted with the following contexts #>    0: In R: in `$.RPolarsDataFrame` #>    0: During function call [workRSOCK()] #>    1: This Polars object is not valid. Execute `rm(<object>)` to remove #>       the object or restart the R session."},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-raster","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: raster","title":"A Future for R: Non-Exportable Objects","text":"raster package provides methods working spatial data, held ‘RasterLayer’ objects. objects use external pointer. example, Note RasterLayer object s carries external pointer. dig deeper, find attr(s@file, \"con\") file connection opened writing. s passed external worker. contrast, RasterLayer object r problem fine pass worker.","code":"library(future) plan(multisession) options(future.globals.onReference = \"error\")  library(raster) r <- raster(system.file(\"external/test.grd\", package = \"raster\")) tf <- tempfile(fileext = \".grd\") s <- writeStart(r, filename = tf,  overwrite = TRUE)  f <- future({   print(dim(r))   print(dim(s)) }) Error: Detected a non-exportable reference ('externalptr') in one of the globals ('s' of class 'RasterLayer') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-rcpp","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: Rcpp","title":"A Future for R: Non-Exportable Objects","text":"Similarly cpp11, Rcpp can use create R functions implemented C++, e.g. : However, since function uses external pointer internally, pass another R process: can detect protect using:","code":"Rcpp::sourceCpp(code = ' #include <Rcpp.h> using namespace Rcpp;  // [[Rcpp::export]] int my_length(NumericVector x) {     return x.size(); } ') x <- 1:10 my_length(x) ## [1] 10 library(future) plan(multisession) x <- rnorm(10) n %<-% my_length(x) n ## Error in .Call(<pointer: (nil)>, x) : NULL value passed as symbol address options(future.globals.onReference = \"error\") n %<-% my_length(x) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'NativeSymbol') in one of the globals ('my_length' of class 'function') ## used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-reticulate","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: reticulate","title":"A Future for R: Non-Exportable Objects","text":"reticulate package provides methods creating calling Python code within R. one attempt use Python-binding objects package, get errors like: telling future package validate globals , get: Another reticulate example try use Python function create : , , :","code":"library(future) plan(multisession) library(reticulate) os <- import(\"os\") pwd %<-% os$getcwd() pwd ## Error in eval(quote(os$getcwd()), new.env()) : ##   attempt to apply non-function options(future.globals.onReference = \"error\") pwd %<-% os$getcwd() ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('os' of class 'python.builtin.module') used in the future expression cat(\"def twice(x):\\n    return 2*x\\n\", file = \"twice.py\") source_python(\"twice.py\") twice(1.2) ## [1] 2.4 y %<-% twice(1.2) y ## Error in unserialize(node$con) : ##   Failed to retrieve the value of MultisessionFuture from cluster node #1 ##   (on 'localhost').  The reason reported was 'error reading from connection' options(future.globals.onReference = \"error\") y %<-% twice(1.2) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('twice' of class 'python.builtin.function') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-rjava","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: rJava","title":"A Future for R: Non-Exportable Objects","text":"example shows rJava objects exported external R processes. Although error produced, see value d1 Java NULL Object. , can catch using:","code":"library(future) plan(multisession) library(rJava) .jinit() ## Initialize Java VM on master  Double <- J(\"java.lang.Double\") d0 <- new(Double, \"3.14\") d0 ## [1] \"Java-Object{3.14}\"  f <- future({   .jinit() ## Initialize Java VM on worker   new(Double, \"3.14\") }) d1 <- value(f) d1 ## [1] \"Java-Object<null>\" options(future.globals.onReference = \"error\") f <- future({   .jinit() ## Initialize Java VM on worker   new(Double, \"3.14\") }) ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('Double' of class 'jclassName') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-shortread","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: ShortRead","title":"A Future for R: Non-Exportable Objects","text":"ShortRead package Bioconductor implements efficient methods sampling, iterating, reading FASTQ files. helper objects used saved file exported parallel worker, comprise connections non-exportable objects. example illustrates attempt use ‘FastqStreamer’ object created main R session fails used parallel worker: catch earlier, get informative error message, ;","code":"library(future) plan(multisession)  # Adopted from example(\"FastqStreamer\", package = \"ShortRead\") library(ShortRead) sp <- SolexaPath(system.file(\"extdata\", package = \"ShortRead\")) fl <- file.path(analysisPath(sp), \"s_1_sequence.txt\") fs <- FastqStreamer(fl, 50)  reads %<-% yield(fs) reads ## Error in status(update = TRUE) : invalid FastqStreamer options(future.globals.onReference = \"error\")  reads %<-% yield(fs) ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('fs' of class 'FastqStreamer') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-sparklyr","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: sparklyr","title":"A Future for R: Non-Exportable Objects","text":"catch soon possible,","code":"library(future) plan(multisession) library(sparklyr) sc <- spark_connect(master = \"local\")  file <- system.file(\"misc\", \"exDIF.csv\", package = \"utils\") data <- spark_read_csv(sc, \"exDIF\", file) d %<-% dim(data) d ## Error in unserialize(node$con) : ##   Failed to retrieve the value of MultisessionFuture (<none>) from cluster ## SOCKnode #1 (PID 29864 on localhost 'localhost'). The reason reported was ## 'unknown input format'. Post-mortem diagnostic: A process with this PID ## exists, which suggests that the localhost worker is still alive. options(future.globals.onReference = \"error\") d %<-% dim(data) ## Error: Detected a non-exportable reference ('externalptr') in one of ## the globals ('data' of class 'tbl_spark') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-terra","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: terra","title":"A Future for R: Non-Exportable Objects","text":"catch soon possible, Functions wrap() unwrap() terra package can used workaround marshal unmarshal non-exportable terra objects, e.g. details, see help(\"wrap\", package = \"terra\").","code":"library(future) plan(multisession) library(terra)  file <- system.file(\"ex/lux.shp\", package = \"terra\") v <- vect(file) dv %<-% dim(v) dv Error in x@ptr$nrow() : external pointer is not valid  file <- system.file(\"ex/elev.tif\", package = \"terra\") r <- rast(file) dr %<-% dim(r) dr ## Error in .External(list(name = \"CppMethod__invoke_notvoid\", address = <pointer: (nil)>,  : ##  NULL value passed as symbol address options(future.globals.onReference = \"error\")  dv %<-% dim(v) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'RegisteredNativeSymbol') in one of the globals ('v' of class ## 'SpatVector') used in the future expression  dr %<-% dim(data) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'RegisteredNativeSymbol') in one of the globals ('r' of class ## 'SpatRaster') used in the future expression library(future) plan(multisession) library(terra)  file <- system.file(\"ex/lux.shp\", package = \"terra\") v <- vect(file) .v <- wrap(v)      ## marshal dv %<-% {   v <- unwrap(.v)  ## unmarshal   dim(v) } rm(.v) ## not needed anymore dv [1] 12  6 file <- system.file(\"ex/elev.tif\", package = \"terra\") r <- rast(file) .r <- wrap(r)      ## marshal dr %<-% {   r <- unwrap(.r)  ## unmarshal   dim(r) } rm(.r) ## not needed anymore dr [1] 90 95  1"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-udpipe","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: udpipe","title":"A Future for R: Non-Exportable Objects","text":"catch soon possible, Now, indeed possible parallelize udpipe calls. details , see ‘UDPipe Natural Language Processing - Parallel’ vignette comes udpipe package.","code":"library(future) plan(multisession) library(udpipe) udmodel <- udpipe_download_model(language = \"dutch\") udmodel <- udpipe_load_model(file = udmodel$file_model) x %<-% udpipe_annotate(udmodel, x = \"Ik ging op reis en ik nam mee.\") x ## Error in udp_tokenise_tag_parse(object$model, x, doc_id, tokenizer, tagger,  : ##   external pointer is not valid options(future.globals.onReference = \"error\") x %<-% udpipe_annotate(udmodel, x = \"Ik ging op reis en ik nam mee.\") ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('udmodel' of class 'udpipe_model') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-xgboost","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: xgboost","title":"A Future for R: Non-Exportable Objects","text":"xgboost package provides fast gradient-boosting methods. data structures use external pointers. example, works just fine attempt pass ‘xgb.DMatrix’ object train external worker, silently get incorrect value: unfortunate, can least detect : train external pointer, .e. mode(train) == \"externalptr\".","code":"library(future) plan(multisession)  library(xgboost) data(agaricus.train, package = \"xgboost\") train <- xgb.DMatrix(agaricus.train$data, label = agaricus.train$label) class(train) ## [1] \"xgb.DMatrix\"  d <- dim(train) d ## [1] 6513  126 f <- future(dim(train)) d <- value(f) d ## NULL options(future.globals.onReference = \"error\") f <- future(dim(dtrain)) ## Error: Detected a non-exportable reference ('externalptr' of class 'xgb.DMatrix') ## in one of the globals ('dtrain' of class 'xgb.DMatrix') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-xml","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: XML","title":"A Future for R: Non-Exportable Objects","text":"Another example XML objects XML package, may produce evaluation error, even cause R abort used another R process, e.g. example, end exporting XMLInternalElementNode object another R process, longer valid. try use calling xmlGetAttr() , XML causes R crash abort. illustrate ’s going parallel workers, save object file using saveRDS(, \".rds\"), try use another R session, following happens: harsh way telling us export types objects produced XML. Ideally, XML detect give informative error message crash R like . workaround working around marshal problematic objects exporting parallel R process, unmarshal working . example, alternative, generic workaround, always create doc element, XMLInternalDocument object, parallel workers, .e.","code":"library(future) plan(multisession) library(XML) doc <- xmlParse(system.file(\"exampleData\", \"tagnames.xml\", package = \"XML\")) a <- getNodeSet(doc, \"/doc//a[@status]\")[[1]] f <- future(xmlGetAttr(a, \"status\")) value(f) ## Error in unserialize(node$con) : ##   MultisessionFuture (<none>) failed to receive results from cluster ## RichSOCKnode #1 (PID 31541 on localhost 'localhost'). The reason ## reported was 'error reading from connection'. Post-mortem diagnostic: ## No process exists with this PID, i.e. the localhost worker is no ## longer alive. Detected a non-exportable reference ('externalptr' of ## class 'XMLInternalElementNode') in one of the globals ('a' of class ## 'XMLInternalElementNode') used in the future expression. The total ## size of the 1 globals exported is 520 bytes. There is one global: 'a' ## (520 bytes of class 'externalptr') $ R --quiet --vanilla > a <- readRDS(\"a.rds\") > XML::xmlGetAttr(a, \"status\")   *** caught segfault *** address 0x40, cause 'memory not mapped'  Traceback:  1: xmlAttrs.XMLInternalNode(node, addNamespace)  2: xmlAttrs(node, addNamespace)  3: XML::xmlGetAttr(a, \"status\")  Possible actions: 1: abort (with core dump, if enabled) 2: normal R exit 3: exit R without saving workspace 4: exit R saving workspace Selection: library(future) plan(multisession) library(XML) doc <- xmlParse(system.file(\"exampleData\", \"tagnames.xml\", package = \"XML\")) a <- getNodeSet(doc, \"/doc//a[@status]\")[[1]]  ## Marshall the non-exportable XMLInternalElementNode object .a <- xmlSerializeHook(a)      ## marshal  f <- future({   a <- xmlDeserializeHook(.a)  ## unmarshal   xmlGetAttr(a, \"status\") }) value(f) ## [1] \"xyz\" library(future) plan(multisession) library(XML)  f <- future({   doc <- xmlParse(system.file(\"exampleData\", \"tagnames.xml\", package = \"XML\"))   a <- getNodeSet(doc, \"/doc//a[@status]\")[[1]]   xmlGetAttr(a, \"status\") }) value(f) ## [1] \"xyz\""},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-xml2","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: xml2","title":"A Future for R: Non-Exportable Objects","text":"Yet another example XML objects xml2 package, may produce evaluation errors (just invalid results depending used), e.g. future framework can help detect sending future worker; One workaround dealing non-exportable objects look ways encode object can exported, decoded receiving end. xml2, can use xml2::xml_serialize() xml2::xml_unserialize() . can rewrite example can pass xml2 object back forth main R session R workers:","code":"library(future) plan(multisession) library(xml2) doc <- read_xml(\"<body><\/body>\") f <- future(xml_children(doc)) value(f) ## Error: external pointer is not valid options(future.globals.onReference = \"error\") f <- future(xml_children(xml)) ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('xml' of class 'xml_document') used in the future expression ## Encode the 'xml_document' object 'doc' as a 'raw' object .doc <- xml_serialize(doc, connection = NULL)  ## marshal  f <- future({   ## In the future, reconstruct the 'xml_document' object   ## from the 'raw' object   doc <- xml_unserialize(.doc)                 ## unmarshal    ## Continue as usual   children <- xml_children(doc)    ## Send back a 'raw' representation of the 'xml_nodeset'   ## object 'children'   xml_serialize(children, connection = NULL) })  ## Reconstruct the 'xml_nodeset' object in the main R session children <- xml_unserialize(value(f))"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-ncdf4","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages with other types of non-external objects","what":"Package: ncdf4","title":"A Future for R: Non-Exportable Objects","text":"Package ncdf4 provides R API work data live netCDF files. example, can create simple netCDF file holds variable ‘x’: can now use netCDF file next time start R, e.g. However, fail attempt use file, object class ‘ncdf4’, parallel worker, get error: ncdf4 objects make use internal references unique R session created. However, formal external pointer:s, meaning future framework detect . , using options(future.globals.onReference = \"error\") help . workaround open netCDF worker, e.g.","code":"library(ncdf4) x <- ncvar_def(\"x\", units = \"count\", dim = list()) file <- nc_create(\"example.nc\", x) ncvar_put(file, x, 42) nc_close(file) library(ncdf4) file <- nc_open(\"example.nc\") y <- ncvar_get(file) y ## [1] 42 library(future) plan(multisession) library(ncdf4) file <- nc_open(\"example.nc\") f <- future(ncvar_get(file)) y <- value(f) ## Error in R_nc4_inq_varndims: NetCDF: Not a valid ID ## Error in ncvar_ndims(ncid, varid) : error returned from C call library(future) plan(multisession) library(ncdf4) f <- future({   file <- nc_open(\"example.nc\")   value <- ncvar_get(file)   nc_close(file)   value }) y <- value(f) y ## [1] 42"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-data-table","dir":"Articles","previous_headings":"Packages with non-exportable objects > False positives - packages with exportable external pointers","what":"Package data.table","title":"A Future for R: Non-Exportable Objects","text":"data.table package creates objects comprising external pointers. Contrary non-exportable examples, objects can saved file used another R session, exported parallel worker. data.table capable restoring objects valid state. Consider following example: try last step future strict checking references enabled, get error: false positive. relax checks, indeed work:","code":"library(data.table) DT <- data.table(a = 1:3, b = letters[1:3])  ## Extract second row row <- DT[2] print(row) #>    a b #> 1: 2 b library(future) plan(multisession) options(future.globals.onReference = \"error\")  row %<-% DT[2] Error: Detected a non-exportable reference ('externalptr') in one of the globals ('DT' of class 'data.table') used in the future expression options(future.globals.onReference = NULL)  row <- DT[2] print(row) #>    a b #> 1: 2 b"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-rstan","dir":"Articles","previous_headings":"Packages with non-exportable objects > False positives - packages with exportable external pointers","what":"Package rstan","title":"A Future for R: Non-Exportable Objects","text":"rstan package creates objects comprising external pointers. Contrary non-exportable examples, objects can saved file used another R session, exported parallel worker. rstan capable restoring objects valid state. Consider following example example(\"rstan\", package = \"rstan\"): try last step future strict checking references enabled, get error: However, false positive. fit object, class ‘stanfit’, can indeed exported used external R process, e.g.","code":"library(rstan)  code <- \" data {   int<lower=0> N;   real y[N]; }  parameters {   real mu; }  model {   target += normal_lpdf(mu | 0, 10);   target += normal_lpdf(y  | mu, 1); } \"  y <- rnorm(20) data <- list(N = 20, y = y) fit <- stan(model_code = code, model_name = \"example\",             data = data, iter = 2012L, chains = 3L,             sample_file = file.path(tempdir(), \"norm.csv\"))  e <- extract(fit, permuted = FALSE) library(future) plan(multisession) options(future.globals.onReference = \"error\")  e %<-% extract(fit, permuted = FALSE) Error: Detected a non-exportable reference ('externalptr' of class 'DLLHandle') in one of the globals ('fit' of class 'stanfit') used in the future expression options(future.globals.onReference = NULL)  e %<-% extract(fit, permuted = FALSE) str(e) #>  num [1:1006, 1:3, 1:2] -0.3028 -0.4017 -0.3379 -0.2358 0.0443 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ iterations: NULL #>   ..$ chains    : chr [1:3] \"chain:1\" \"chain:2\" \"chain:3\" #>   ..$ parameters: chr [1:2] \"mu\" \"lp__\""},{"path":"https://future.futureverse.org/articles/future-5-startup.html","id":"r-options","dir":"Articles","previous_headings":"","what":"R options","title":"A Future for R: Controlling Default Future Strategy","text":"default strategy resolving futures can controlled via R option future.plan. instance, add ~/.Rprofile startup script, future package resolve futures parallel (asynchronously using available cores), .e. Option future.plan ignored command-line option --parallel (-p) specified.","code":"options(future.plan = \"multisession\") $ Rscript -e \"class(future::plan())\" [1] \"multisession\" \"future\"       \"function\""},{"path":"https://future.futureverse.org/articles/future-5-startup.html","id":"environment-variables","dir":"Articles","previous_headings":"","what":"Environment variables","title":"A Future for R: Controlling Default Future Strategy","text":"alternative using options() setting option future.plan specify system environment variable R_FUTURE_PLAN. set, future package set future.plan accordingly loaded. example, Environment variable R_FUTURE_PLAN ignored either option future.plan command-line option --parallel (-p) specified.","code":"$ export R_FUTURE_PLAN=multisession $ Rscript -e \"class(future::plan())\" [1] \"multisession\" \"future\"       \"function\""},{"path":"https://future.futureverse.org/articles/future-5-startup.html","id":"command-line-options","dir":"Articles","previous_headings":"","what":"Command-line options","title":"A Future for R: Controlling Default Future Strategy","text":"loaded, future package checks command-line option --parallel=ncores (short -p ncores) sets future strategy (via option future.plan) number available cores (via option mc.cores) accordingly. provides convenient mechanism specifying parallel future processing command line. example, start R future interpret wish resolve futures parallel using 2 cores. specifically, get can use command-line option also Rscript, provides convenient mechanism launching future-enhanced R scripts run parallel, e.g. , course, require script uses futures future package. --parallel=1 specified, equivalently -p 1, futures resolved using single process. Specifying command-line options override startup settings.","code":"$ R --quiet --args --parallel=2 > availableCores() mc.cores        2 > class(future::plan()) [1] \"FutureStrategy\" \"tweaked\"        \"multisession\"   \"future\"         \"function\" $ Rscript analysis.R --parallel=4"},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"future-api-backend-specification","dir":"Articles","previous_headings":"","what":"Future API Backend Specification","title":"A Future for R: Future API Backend Specification","text":"Version 0.1.2","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"introduction","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Introduction","title":"A Future for R: Future API Backend Specification","text":"document written serve reference developers developing future backend future framework implemented future package R available CRAN. Future Application Programming Interface (API) three fundamental functions core: f <- future(expr) - create future R expression (non-blocking may blocking) r <- resolved(f) - check whether future resolved (non-blocking) v <- value(f) - retrieve value future (blocking) three functions alone, possible evaluate one R expressions synchronously asynchronously. expressions resolved depends “future backend” use. example, one backend may evaluated expressions sequentially (synchronously) another may evaluated parallel (asynchronously). Regardless backend, value future expression always . fundamental future ecosystem future backends conform Future API specification. Conformance serves guarantor correctness behavior developer use futures software well end-user software. future backend meets requirements can used software use futures internally. example, three functions serve building blocks several higher-level map-reduce APIs. One example [future.apply] package CRAN provides future_lapply(), futurized version lapply() available ‘base’ package. function can used perform lapply-like processing parallel using parallel backend. implementation ‘future.apply’ package 100% invariant parallel backend used. possible future backends conform set rules. Rules documented . supplement specification herein ‘Test Suite Future API Backends’, consists set tests can used validated future backend meets minimal requirements Future API. tests run command-line, R prompt, part package tests backend package. test suite documented implemented future.tests package available CRAN.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"feedback","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Feedback","title":"A Future for R: Future API Backend Specification","text":"find something document missing, unclear, faulty, please report feedback using official issue tracker ‘future’ package https://github.com/futureverse/future. feedback specific test suite, please use official issue tracker ‘future.tests’ package https://github.com/futureverse/future.tests","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"overview-of-the-future-api","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Overview of the Future API","title":"A Future for R: Future API Backend Specification","text":"Future API three fundamental functions core: f <- future(expr) - create future R expression (non-blocking may blocking) r <- resolved(f) - check whether future resolved (non-blocking) v <- value(f) - retrieve value future (blocking) implementation future backend involves several steps. simplicity, lets say call future backend ‘myparallel’. summary, future backend needs implement four API components: constructor function myparallel() inherits class future. function return Future object (defined future package) also inherits S3 class MyParallelFuture non-lazy future created (default lazy = FALSE). default function calls run() Future object returning, unless lazy created. S3 method run() MyParallelFuture starts evaluation future R expression part Future object. method often non-blocking parallel backends, may blocking compute resources exhausted. typically blocking sequential backends. S3 method resolved() MyParallelFuture , non-blocking fashion, returns TRUE future resolved FALSE . S3 method result() MyParallelFuture returns FutureResult object (defined future package) future resolved otherwise fails resolve. future yet resolved, method block future resolved. place, selection using backend future plan, done plan(myparallel) option specifying certain arguments passed myparallel(). plan set, call f <- future(expr) correspond f <- myparallel(expr) call. defaults, myparallel() launch evaluation expr asynchronously returning MyParallelFuture object. calling resolved(f) query whether future expression resolved , underlying S3 method class check parallel worker whether expression resolved . calling value(f), S3 method Future class calls result(f), return FutureResult object future. future yet resolved, call block . errors occurred resolving future expression, value(f) return value expression, recorded backend FutureResult object. evaluation error, value(f) resignal (“relayed”) error. captured conditions standard output also relayed point.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"requirements-for-the-backend-future-api","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Requirements for the backend Future API","title":"A Future for R: Future API Backend Specification","text":"section describes detail requirements four components . requirements given continuation ‘myparallel’ example. otherwise specified, functions mentioned future package.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"constructor-function-creating-a-future","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"Constructor function creating a Future","title":"A Future for R: Future API Backend Specification","text":"constructor function myparallel() creating Future object must inherits class future inherits(myparallel, \"future\") true. constructor function explicit arguments expr, substitute, envir, ..., argument expr expression, argument substitute logical (TRUE FALSE), envir environment. parts ... arguments passed along Future() function. substitute TRUE (default), expr re-evaluated expr <- substitute(expr). Environment envir default parent.frame() used identify global variables. backend supports one worker, also explicit workers argument. currying arguments can specified setting future plan must explicit arguments constructor function appear named elements formals(myparallel). Currying arguments arguments can “tweaked” end-user, e.g. plan(myparallel, workers = 2). value constructor function invisible MyParallelFuture object inherits Future. achieved calling Future(), matching arguments passed along prepending \"MyParallelFuture\" class attribute returned Future object. returning Future object, constructor function launch future , , lazy element Future object (e.g. f$lazy) FALSE (default). constructor function must never evaluate expression expr lazy TRUE. constructor function must update RNG state.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"run-method","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"run() method","title":"A Future for R: Future API Backend Specification","text":"S3 method run() MyParallelFuture takes Future object first argument required. accept additional arguments via ..., currently used. run() method invisibly return Future object, may modified version input Future object. run() method responsible launching future twice. run() called already launched resolved future, informative FutureError error constructed FutureError() function produced. run() method responsible evaluation expression returned getExpression() Future object first argument. evaluation expression respect global variables FutureGlobals object returned globals() Future object first argument. evaluation also respect package names returned packages() Future object first argument. backend provides parallel processing, run() return future soon possible without waiting resolved. workers occupied, run() responsible waiting worker becomes available launch future worker immediatedly return future. run() method may produce FutureError error created FutureError() case fails launch future worker worker terminated unexpectedly. run() method must update RNG state.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"resolved-method","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"resolved() method","title":"A Future for R: Future API Backend Specification","text":"S3 method resolved() MyParallelFuture takes Future object first argument return either TRUE FALSE required. accept additional arguments via ..., currently used. method may called zero times. method return FALSE long future unresolved. may also return FALSE fail establish state future within reasonable time period (“timeout”). return TRUE soon can established future resolved. returned TRUE , succeeding calls return TRUE. resolved() called future yet launched, launch future calling run(). occasion resolved() may block. cases, return promptly. resolved() method may produce FutureError error created FutureError() case communication worker broken worker terminated unexpectedly. resolved() method must update RNG state.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"result-method","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"result() method","title":"A Future for R: Future API Backend Specification","text":"S3 method result() MyParallelFuture takes Future object first argument return FutureResult object required. accept additional arguments via ..., currently used. method may called zero times. result() called future yet launched, launch future calling run(). result() called future yet resolved, block future resolved. value result() value evaluating getExpression() expression run() launched. result() method may produce FutureError error created FutureError() case communication worker broken worker terminated unexpectedly. result() method must update RNG state.","code":""},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"the-future-smell-test","dir":"Articles","previous_headings":"","what":"The future smell test","title":"A Future for R: Best Practices for Package Developers","text":"far common popular future strategy parallelize local machine, .e. plan(multisession). often good enough situations note end-users access multiple machines might want run code using speed beyond single machine can . , avoid far possible making assumption code run local machine. good “smell test” ask : - future code work ends running side world? Regardless performance, answer “Yes”, already embraced core philosophy future framework. answer “Maybe” “”, see can rewrite . instance, future code made assumption access local file system, : can rewrite code load content file set future, : Similarly, avoid future code write local file system parent R session might access file system. keeping future smell test mind writing future code, increase chances code can parallelized ways just local computer. Properly written future code work regardless future strategy end-user picks, e.g. Remember, developers never know compute resources end-user access right now access six month. knows, code might even end running 2,000 cores located Moon twenty years now.","code":"f <- future({   data <- read_tsv(file)   analyze(data) }) data <- read_tsv(file) f <- future({   analyze(data) }) plan(sequential) plan(multisession) plan(cluster, workers = rep(c(\"n1.remote.org\", \"n2.remote.org\", \"n3.remote.org\"), each = 32))"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"avoid-changing-the-future-strategy","dir":"Articles","previous_headings":"","what":"Avoid changing the future strategy","title":"A Future for R: Best Practices for Package Developers","text":"reasons like ones mentioned , refrain setting plan() function. better leave end-user decided want parallelize. One reason can never know context code run. example, might use futures parallelize function call package package code calls package internally. set plan(multisession) internally without undoing, might mess plan() already set breaking parallelization. still think necessary set plan(), make sure undo function exits, also errors. can done using localPlan(), e.g. need setting future strategy within function often comes developers wanting add argument function allows end-user specify whether want run function parallel sequentially. often result code like: way user can use: depending needs. However, another package developer decide call function function, now expose parallel argument users function, e.g. Exposing passing “parallel” argument along can become quite cumbersome. Instead, neater use: let user control whether want parallelize via plan(), e.g. plan(multisession) plan(sequential).","code":"my_fcn <- function(x) {   localPlan(multisession)   y <- analyze(x)   summarize(y) } my_fcn <- function(x, parallel = FALSE) {   if (parallel) {     localPlan(multisession)     y <- future_lapply(x, FUN = analyze) ## from future.apply package   } else {     y <- lapply(x, FUN = analyze)   }   summarize(y) } y <- my_fcn(x, parallel = FALSE) y <- my_fcn(x, parallel = TRUE) their_fcn <- function(x, parallel = FALSE) {   x2 <- preprocess(x)   y <- my_fcn(x2, parallel = parallel)   z <- another_fcn(y)   z } my_fcn <- function(x) {   y <- future_lapply(x, FUN = analyze) ## from future.apply package   summarize(y) }"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"avoid-changing-the-future-options","dir":"Articles","previous_headings":"","what":"Avoid changing the future options","title":"A Future for R: Best Practices for Package Developers","text":"Just like R options, must change R future.* options. end-user set . find tweak one options, make sure undo changes immediately afterward. example, want bump future.globals.maxSize limit creating future, use something like following inside function:","code":"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB on.exit(options(oopts)) f <- future({ expr })  ## Launch a future with large objects"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"writing-examples","dir":"Articles","previous_headings":"","what":"Writing examples","title":"A Future for R: Best Practices for Package Developers","text":"example sets future strategy beginning, make sure reset future strategy plan(sequential) end example. reason switching plan, previous one cleaned . particularly important multisession cluster futures plan(sequential) shut underlying PSOCK clusters. instance, example: forget shut PSOCK cluster, R CMD check ---cran, R CMD check environment variable _R_CHECK_CONNECTIONS_LEFT_OPEN_=true set, produce error reason like display reset future strategy help documentation, still want run, wrap statement Rd \\dontshow{} statement.","code":"## Run the analysis in parallel on the local computer future::plan(\"multisession\")  y <- analyze(\"path/to/file.csv\")  ## Shut down parallel workers future::plan(\"sequential\") $ R CMD check --as-cran mypkg_1.0.tar.gz ... * checking examples ... ERROR Running examples in 'analyze-Ex.R' failed ... > cleanEx() Error: connections left open:       <-localhost:37400 (sockconn)       <-localhost:37400 (sockconn) Execution halted"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"testing-a-package-that-relies-on-futures","dir":"Articles","previous_headings":"","what":"Testing a package that relies on futures","title":"A Future for R: Best Practices for Package Developers","text":"want make sure code works running sequentially well running parallel, often good enough package tests run code : code works setup, can sure global variables properly identified exported workers required packages loaded workers. Always make sure shut parallel ‘multisession’ workers end package test calling: tests written way, can set environment variable R_FUTURE_PLAN=multisession call R CMD check. make default future strategy become ‘multisession’ instead ‘sequential’. example,","code":"plan(multisession) plan(sequential) $ export R_FUTURE_PLAN=multisession $ R CMD check --as-cran mypkg_1.0.tar.gz"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"making-sure-to-stop-parallel-workers","dir":"Articles","previous_headings":"","what":"Making sure to stop parallel workers","title":"A Future for R: Best Practices for Package Developers","text":"creating cluster object, instance via plan(multisession), package help example, package vignette, package test, must _remember stop cluster end examples(*), vignettes, unit tests_. required order leave behind stray parallel cluster workers main R session terminates. Linux macOS, operating system often takes care terminating worker processes forget, MS Windows processes keep running background time , takes 30 days (sic!). R CMD check ---cran indirectly detect stray worker processes MS Windows running R (>= 4.3.0). detected, result placeholder Rscript<hexcode> files left behind temporary directory. check NOTE look (R (>= 4.3.0)) : Rscript<hexcode> files background R worker processes, almost always parallel cluster:s forgot stop end. stop ‘multisession’ workers, call: end examples(*), vignettes, package tests. create cluster manually using make sure stop clusters end using (*) Currently, examples excluded detritus checks. validated R-devel revision 82991 (2022-10-02).","code":"* checking for detritus in the temp directory ... NOTE Found the following files/directories:   'Rscript1058267d0c10' 'Rscriptbd4267d0c10' plan(sequential) cl <- parallelly::makeClusterPSOCK(2) plan(cluster, workers = cl) parallel::stopCluster(cl)"},{"path":"https://future.futureverse.org/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Henrik Bengtsson. Author, maintainer, copyright holder.","code":""},{"path":"https://future.futureverse.org/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Henrik Bengtsson, Unifying Framework Parallel Distributed Processing R using Futures, R Journal (2021) 13:2, pages 208-227, doi:10.32614/RJ-2021-048","code":"@Article{RJ-2021-048,   author = {Henrik Bengtsson},   title = {A Unifying Framework for Parallel and Distributed Processing in R using Futures},   year = {2021},   journal = {The R Journal},   doi = {10.32614/RJ-2021-048},   url = {https://doi.org/10.32614/RJ-2021-048},   pages = {208--227},   volume = {13},   number = {2}, }"},{"path":[]},{"path":"https://future.futureverse.org/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"purpose future package provide simple uniform way evaluating R expressions asynchronously using various resources available user. programming, future abstraction value may available point future. state future can either unresolved resolved. soon resolved, value available instantaneously. value queried future still unresolved, current process blocked future resolved. possible check whether future resolved without blocking. Exactly futures resolved depends strategy used evaluate . instance, future can resolved using sequential strategy, means resolved current R session. strategies may resolve futures asynchronously, instance, evaluating expressions parallel current machine concurrently compute cluster. example illustrating basics futures work. First, consider following code snippet uses plain R code: works assigning value expression variable v print value v. Moreover, expression v evaluated also print message. code snippet modified use futures instead: difference v constructed; plain R use <- whereas futures use %<-%. difference output relayed future resolved () value queried (see Vignette ‘Outputting Text’). futures useful? can choose evaluate future expression separate R process asynchronously simply switching settings : asynchronous futures, current/main R process block, means available processing futures resolved separate processes running background. words, futures provide simple yet powerful construct parallel / distributed processing R. Now, bothered read nitty-gritty details futures, just want try , skip end play Mandelbrot demo using parallel non-parallel evaluation.","code":"> v <- { +   cat(\"Hello world!\\n\") +   3.14 + } Hello world! > v [1] 3.14 > library(future) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14 > library(future) > plan(multisession) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14"},{"path":"https://future.futureverse.org/index.html","id":"implicit-or-explicit-futures","dir":"","previous_headings":"","what":"Implicit or Explicit Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Futures can created either implicitly explicitly. introductory example used implicit futures created via v %<-% { expr } construct. alternative explicit futures using f <- future({ expr }) v <- value(f) constructs. , example alternatively written : Either style future construct works equally(*) well. implicit style similar regular R code written. principle, replace <- %<-% turn assignment future assignment. hand, simplicity can also deceiving, particularly asynchronous futures used. contrast, explicit style makes much clearer futures used, lowers risk mistakes better communicates design others reading code. (*) cases %<-% used without (small) modifications. return Section ‘Constraints using Implicit Futures’ near end document. summarize, explicit futures, use: f <- future({ expr }) - creates future v <- value(f) - gets value future (blocks yet resolved) implicit futures, use: v %<-% { expr } - creates future promise value keep simple, use implicit style rest document, everything discussed also apply explicit futures.","code":"> library(future) > f <- future({ +   cat(\"Hello world!\\n\") +   3.14 + }) > v <- value(f) Hello world! > v [1] 3.14"},{"path":"https://future.futureverse.org/index.html","id":"controlling-how-futures-are-resolved","dir":"","previous_headings":"","what":"Controlling How Futures are Resolved","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"future package implements following types futures: future package designed support additional strategies can implemented well. instance, future.callr package provides future backends evaluates futures background R process utilizing callr package - work similarly multisession futures advantages. Continuing, future.batchtools package provides futures types cluster functions (“backends”) batchtools package supports. Specifically, futures evaluating R expressions via job schedulers Slurm, TORQUE/PBS, Oracle/Sun Grid Engine (SGE) Load Sharing Facility (LSF) also available. default, future expressions evaluated eagerly (= instantaneously) synchronously (current R session). evaluation strategy referred “sequential”. section, go strategies discuss common differ.","code":""},{"path":"https://future.futureverse.org/index.html","id":"consistent-behavior-across-futures","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Consistent Behavior Across Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"going different future strategies, probably helpful clarify objectives Future API (defined future package). programming futures, really matter future strategy used executing code. really know computational resources user access choice evaluation strategy hands user developer. words, code make assumptions type futures used, e.g. synchronous asynchronous. One designs Future API encapsulate differences types futures appear work . despite expressions may evaluated locally current R session across world remote R sessions. Another obvious advantage consistent API behavior among different types futures helps prototyping. Typically one use sequential evaluation building script , later, script fully developed, one may turn asynchronous processing. , defaults different strategies results side effects evaluating future expression similar possible. specifically, following true futures: evaluation done local environment (.e. local({ expr })) assignments affect calling environment. natural evaluating external R process, also enforced evaluating current R session. future constructed, global variables identified. asynchronous evaluation, globals exported R process/session evaluating future expression. sequential futures lazy evaluation (lazy = TRUE), globals “frozen” (cloned local environment future). Also, order protect exporting large objects mistake, built-assertion total size globals less given threshold (controllable via option, cf. help(\"future.options\")). threshold exceeded, informative error thrown. Future expressions evaluated . soon value (error) collected available succeeding requests. example illustrating assignments done local environment: Now ready explore different future strategies.","code":"> plan(sequential) > a <- 1 > x %<-% { +     a <- 2 +     2 * a + } > x [1] 4 > a [1] 1"},{"path":"https://future.futureverse.org/index.html","id":"synchronous-futures","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Synchronous Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Synchronous futures resolved one another commonly R process creates . synchronous future resolved blocks main process resolved.","code":""},{"path":"https://future.futureverse.org/index.html","id":"sequential-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Synchronous Futures","what":"Sequential Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Sequential futures default unless otherwise specified. designed behave similar possible regular R evaluation still fulfilling Future API behaviors. example illustrating properties: Since eager sequential evaluation taking place, three futures resolved instantaneously moment created. Note also pid calling environment, assigned process ID current process, neither overwritten removed. futures evaluated local environment. Since synchronous (uni-)processing used, future b resolved main R process (still local environment), value b pid .","code":"> plan(sequential) > pid <- Sys.getpid() > pid [1] 1437557 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1437557 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1437557"},{"path":"https://future.futureverse.org/index.html","id":"asynchronous-futures","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Asynchronous Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Next, turn asynchronous futures, futures resolved background. design, futures non-blocking, , created calling process available tasks including creating additional futures. calling process tries access value future yet resolved, trying create another asynchronous future available R processes busy serving futures, blocks.","code":""},{"path":"https://future.futureverse.org/index.html","id":"multisession-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multisession Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"start multisession futures supported operating systems. multisession future evaluated background R session running machine calling R process. example multisession evaluation: first thing observe values , c pid previously. However, notice b different . future b evaluated different R process therefore returns different process ID. multisession evaluation used, package launches set R sessions background serve multisession futures evaluating expressions created. background sessions busy serving futures, creation next multisession future blocked background session becomes available . total number background processes launched decided value availableCores(), e.g. particular result tells us mc.cores option set allowed use total two (2) processes including main process. words, settings, two (2) background processes serving multisession futures. availableCores() also agile different options system environment variables. instance, compute cluster schedulers used (e.g. TORQUE/PBS Slurm), set specific environment variable specifying number cores allotted given job; availableCores() acknowledges well. nothing else specified, available cores machine utilized, cf. parallel::detectCores(). details, please see help(\"availableCores\", package = \"parallelly\").","code":"> plan(multisession) > pid <- Sys.getpid() > pid [1] 1437557 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1437616 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1437557 > availableCores() mc.cores         2"},{"path":"https://future.futureverse.org/index.html","id":"multicore-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multicore Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"operating systems R supports forking processes, basically operating system except Windows, alternative spawning R sessions background fork existing R process. use multicore futures, supported, specify: Just like multisession futures, maximum number parallel processes running decided availableCores(), since cases evaluation done local machine. Forking R process can faster working separate R session running background. One reason overhead exporting large globals background session can greater forking, therefore shared memory, used. hand, shared memory read , meaning modifications shared objects one forked processes (“workers”) cause copy operating system. can also happen R garbage collector runs one forked processes. hand, process forking also considered unstable R environments. instance, running R within RStudio process forking may resulting crashed R sessions. , future package disables multicore futures default running RStudio. See help(\"supportsMulticore\") details.","code":"plan(multicore)"},{"path":"https://future.futureverse.org/index.html","id":"cluster-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Cluster Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Cluster futures evaluate expressions ad-hoc cluster (implemented parallel package). instance, assume access three nodes n1, n2 n3, can use asynchronous evaluation : types clusters parallel::makeCluster() creates can used cluster futures. instance, cluster can explicitly set : Also, considered good style shut cluster cl longer needed, , calling parallel::stopCluster(cl). However, shut main process terminated. information set manage clusters, see help(\"makeCluster\", package = \"parallel\"). Clusters created implicitly using plan(cluster, workers = hosts) hosts character vector also shut main R session terminates, future strategy changed, e.g. calling plan(sequential). Note automatic authentication setup (e.g. SSH key pairs), nothing preventing us using approach using cluster remote machines. want run multiple workers node, replicate node name many times number workers run node. example, run three workers n1, one n2, five n3, total nine parallel workers.","code":"> plan(cluster, workers = c(\"n1\", \"n2\", \"n3\")) > pid <- Sys.getpid() > pid [1] 1437557 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1437715 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1437557 cl <- parallel::makeCluster(c(\"n1\", \"n2\", \"n3\")) plan(cluster, workers = cl) > plan(cluster, workers = c(rep(\"n1\", times = 3), \"n2\", rep(\"n3\", times = 5)))"},{"path":"https://future.futureverse.org/index.html","id":"nested-futures-and-evaluation-topologies","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Nested Futures and Evaluation Topologies","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"far discussed can referred “flat topology” futures, , futures created assigned environment. However, nothing stopping us using “nested topology” futures, one set futures may, turn, create another set futures internally . instance, example two “top” futures (b) uses multisession evaluation second future (b) turn uses two internal futures: inspection process IDs, see total three different processes involved resolving futures. main R process (pid 1437557), two processes used (pid 1437804) b (pid 1437805). However, two futures (b1 b2) nested b evaluated R process b. nested futures use sequential evaluation unless otherwise specified. reasons , main reason protects us spawning large number background processes mistake, e.g. via recursive calls. specify different type evaluation topology, first level futures resolved multisession evaluation second level sequential evaluation, can provide list evaluation strategies plan(). First, evaluation strategies can explicitly specified : actually get behavior try multiple levels multisession evaluations; reason , also , protect us launching processes machine can support. Internally, done setting mc.cores = 1 functions like parallel::mclapply() fall back run sequentially. case multisession multicore evaluation. Continuing, start sequential evaluation use multisession evaluation nested futures, get: clearly show b resolved calling process (pid 1437557) whereas two nested futures (b1 b2) resolved two separate R processes (pids 1438017 1438016). said , indeed possible use nested multisession evaluation strategies, explicitly specify (read force) number cores available level. order need “tweak” default settings, can done follows: First, see b resolved different processes (pids 1438105 1438106) calling process (pid 1437557). Second, two nested futures (b1 b2) resolved yet two R processes (pids 1438211 1438212). details working nested futures different evaluation strategies level, see Vignette ‘Futures R: Future Topologies’.","code":"> plan(multisession) > pid <- Sys.getpid() > a %<-% { +     cat(\"Future 'a' ...\\n\") +     Sys.getpid() + } > b %<-% { +     cat(\"Future 'b' ...\\n\") +     b1 %<-% { +         cat(\"Future 'b1' ...\\n\") +         Sys.getpid() +     } +     b2 %<-% { +         cat(\"Future 'b2' ...\\n\") +         Sys.getpid() +     } +     c(b.pid = Sys.getpid(), b1.pid = b1, b2.pid = b2) + } > pid [1] 1437557 > a Future 'a' ... [1] 1437804 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1437805 1437805 1437805 plan(list(multisession, sequential)) > plan(list(multisession, multisession)) [...] > pid [1] 1437557 > a Future 'a' ... [1] 1437901 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1437902 1437902 1437902 > plan(list(sequential, multisession)) [...] > pid [1] 1437557 > a Future 'a' ... [1] 1437557 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1437557 1438017 1438016 > plan(list(tweak(multisession, workers = 2), tweak(multisession,  +     workers = 2))) [...] > pid [1] 1437557 > a Future 'a' ... [1] 1438105 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1438106 1438211 1438212"},{"path":"https://future.futureverse.org/index.html","id":"checking-a-future-without-blocking","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Checking A Future without Blocking","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"possible check whether future resolved without blocking. can done using resolved(f) function, takes explicit future f input. work implicit futures (examples ), can use f <- futureOf() function retrieve explicit future implicit one. example,","code":"> plan(multisession) > a %<-% { +     cat(\"Future 'a' ...\") +     Sys.sleep(2) +     cat(\"done\\n\") +     Sys.getpid() + } > cat(\"Waiting for 'a' to be resolved ...\\n\") Waiting for 'a' to be resolved ... > f <- futureOf(a) > count <- 1 > while (!resolved(f)) { +     cat(count, \"\\n\") +     Sys.sleep(0.2) +     count <- count + 1 + } 1  2  3  4  5  6  7  8  9  10  > cat(\"Waiting for 'a' to be resolved ... DONE\\n\") Waiting for 'a' to be resolved ... DONE > a Future 'a' ...done [1] 1438287"},{"path":"https://future.futureverse.org/index.html","id":"failed-futures","dir":"","previous_headings":"","what":"Failed Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Sometimes future expected. error occurs evaluating future, error propagated thrown error calling environment future value requested. example, use lazy evaluation future generates error, might see something like error thrown time value requested, , try get value generate error (output): see last call call stack gave error, can use backtrace() function(*) future, .e. (*) commonly used traceback() provide relevant information context futures. Furthermore, unfortunately possible see list calls (evaluated expressions) led error; call gave error (due limitation tryCatch() used internally).","code":"> plan(sequential) > b <- \"hello\" > a %<-% { +     cat(\"Future 'a' ...\\n\") +     log(b) + } %lazy% TRUE > cat(\"Everything is still ok although we have created a future that will fail.\\n\") Everything is still ok although we have created a future that will fail. > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function In addition: Warning message: restarting interrupted promise evaluation > backtrace(a) [[1]] log(a)"},{"path":"https://future.futureverse.org/index.html","id":"globals","dir":"","previous_headings":"","what":"Globals","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Whenever R expression evaluated asynchronously (parallel) sequentially via lazy evaluation, global (aka “free”) objects identified passed evaluator. need passed exactly time future created, , lazy evaluation, globals may otherwise change created resolved. asynchronous processing, reason globals need identified can exported process evaluates future. future package tries automate tasks far possible. help globals package, uses static-code inspection identify global variables. global variable identified, captured made available evaluating process. Moreover, global defined package, global exported. Instead, made sure corresponding package attached future evaluated. better reflects setup main R session, also minimizes need exporting globals, saves memory also time bandwidth, especially using remote compute nodes. Finally, clarified identifying globals static code inspection alone challenging problem. always corner cases automatic identification globals fails either false globals identified (less concern) true globals missing (result run-time error possibly wrong results). Vignette ‘Futures R: Common Issues Solutions’ provides examples common cases explains avoid well help package identify globals ignore falsely identified globals. suffice, always possible manually specify global variables names (e.g. globals = c(\"\", \"slow_sum\")) name-value pairs (e.g. globals = list(= 42, slow_sum = my_sum)).","code":""},{"path":"https://future.futureverse.org/index.html","id":"constraints-when-using-implicit-futures","dir":"","previous_headings":"","what":"Constraints when using Implicit Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"one limitation implicit futures exist explicit ones. explicit future just like object R can assigned anywhere/anything. instance, can create several loop assign list, e.g. possible using implicit futures. %<-% assignment operator used cases regular <- assignment operator can used. can used assign future values environments (including calling environment) much like assign(name, value, envir) works. However, can assign implicit futures environments using named indices, e.g. .list(v) blocks futures environment v resolved. values collected returned regular list. numeric indices required, list environments can used. List environments, implemented listenv package, regular environments customized subsetting operators making possible index much like lists can indexed. using list environments otherwise use lists, can also assign implicit futures list-like objects using numeric indices. example, previously, .list(v) blocks futures resolved.","code":"> plan(multisession) > f <- list() > for (ii in 1:3) { +     f[[ii]] <- future({ +         Sys.getpid() +     }) + } > v <- lapply(f, FUN = value) > str(v) List of 3  $ : int 1438377  $ : int 1438378  $ : int 1438377 > plan(multisession) > v <- new.env() > for (name in c(\"a\", \"b\", \"c\")) { +     v[[name]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ a: int 1438485  $ b: int 1438486  $ c: int 1438485 > library(listenv) > plan(multisession) > v <- listenv() > for (ii in 1:3) { +     v[[ii]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ : int 1438582  $ : int 1438583  $ : int 1438582"},{"path":"https://future.futureverse.org/index.html","id":"demos","dir":"","previous_headings":"","what":"Demos","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"see live illustration different types futures evaluated, run Mandelbrot demo package. First, try sequential evaluation, resembles script run futures used. , try multisession evaluation, calculates different Mandelbrot planes using parallel R processes running background. Try, Finally, access multiple machines can try set cluster workers use , e.g.","code":"library(future) plan(sequential) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(multisession) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(cluster, workers = c(\"n2\", \"n5\", \"n6\", \"n6\", \"n9\")) demo(\"mandelbrot\", package = \"future\", ask = FALSE)"},{"path":"https://future.futureverse.org/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"R package future available CRAN can installed R :","code":"install.packages(\"future\")"},{"path":"https://future.futureverse.org/index.html","id":"pre-release-version","dir":"","previous_headings":"Installation","what":"Pre-release version","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"install pre-release version available Git branch develop GitHub, use: install package source.","code":"remotes::install_github(\"futureverse/future\", ref=\"develop\")"},{"path":"https://future.futureverse.org/reference/Future-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A future represents a value that will be available at some point in the future — Future-class","title":"A future represents a value that will be available at some point in the future — Future-class","text":"future abstraction value may available point future.  future can either unresolved resolved, state can checked resolved().  long unresolved, value available.  soon resolved, value available via value().","code":""},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A future represents a value that will be available at some point in the future — Future-class","text":"","code":"Future(   expr = NULL,   envir = parent.frame(),   substitute = TRUE,   stdout = TRUE,   conditions = \"condition\",   globals = list(),   packages = NULL,   seed = FALSE,   lazy = FALSE,   gc = FALSE,   earlySignal = FALSE,   label = NULL,   ... )"},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A future represents a value that will be available at some point in the future — Future-class","text":"expr R expression. envir environment global objects identified. substitute TRUE, argument expr substitute():ed, otherwise . stdout TRUE (default), standard output captured, re-outputted value() called. FALSE, output silenced (sinking null device outputted). Using stdout = structure(TRUE, drop = TRUE) causes captured standard output dropped future object soon relayed. can help decrease overall memory consumed captured output across futures. Using stdout = NA fully avoids intercepting standard output; behavior unhandled standard output depends future backend. conditions character string conditions classes captured relayed.  default relay conditions, including messages warnings.  drop conditions, use conditions = character(0). Errors always relayed. Attribute exclude can used ignore specific classes, e.g. conditions = structure(\"condition\", exclude = \"message\") capture condition classes except inherits message class. Using conditions = structure(..., drop = TRUE) causes captured conditions dropped future object soon relayed, e.g. value(f). can help decrease overall memory consumed captured conditions across futures. Using conditions = NULL (recommended) avoids intercepting conditions, except errors; behavior unhandled conditions depends future backend environment R runs. globals (optional) logical, character vector, named list control globals handled. details, see section 'Globals used future expressions' help future(). packages (optional) character vector specifying packages attached R environment evaluating future. seed (optional) TRUE, random seed, , state random number generator (RNG) set statistically sound random numbers produced (also parallelization). FALSE (default), assumed future expression neither need use random numbers generation. use fixed random seed, specify L'Ecuyer-CMRG seed (seven integer) regular RNG seed (single integer).  latter, L'Ecuyer-CMRG seed automatically created based given seed. Furthermore, FALSE, future monitored make sure use random numbers.  depending value option future.rng.onMisuse, check ignored, informative warning, error produced. seed NULL, effect seed = FALSE without RNG check performed. lazy FALSE (default), future resolved eagerly (starting immediately), otherwise . gc TRUE, garbage collector run (process evaluated future) value future collected. Exactly values collected may depend various factors number free workers whether earlySignal TRUE (frequently) FALSE (less frequently). types futures ignore argument. earlySignal Specified whether conditions signaled soon possible . label character string label attached future. ... Additional named elements future.","code":""},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A future represents a value that will be available at some point in the future — Future-class","text":"Future() returns object class Future.","code":""},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A future represents a value that will be available at some point in the future — Future-class","text":"Future object environment.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/FutureBackend.html","id":null,"dir":"Reference","previous_headings":"","what":"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster — ClusterFutureBackend","title":"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster — ClusterFutureBackend","text":"ClusterFutureBackend resolves futures parallel using PSOCK cluster Configure backend controls futures evaluated launchFuture() runs future backend. interruptFuture() interrupts future backend. stopWorkers() stops backend workers MulticoreFutureBackend resolves futures parallel using forked processing current machine MultisessionFutureBackend resolves futures parallel using PSOCK cluster current machine SequentialFutureBackend resolves futures sequentially current R session","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster — ClusterFutureBackend","text":"","code":"ClusterFutureBackend(   workers = availableWorkers(),   persistent = FALSE,   gc = TRUE,   earlySignal = TRUE,   interrupts = TRUE,   ... )  FutureBackend(   ...,   earlySignal = FALSE,   gc = FALSE,   maxSizeOfObjects = getOption(\"future.globals.maxSize\", +Inf),   interrupts = TRUE,   hooks = FALSE )  launchFuture(backend, future, ...)  listFutures(backend, ...)  interruptFuture(backend, future, ...)  validateFutureGlobals(backend, future, ...)  stopWorkers(backend, ...)  MulticoreFutureBackend(   workers = availableCores(constraints = \"multicore\"),   maxSizeOfObjects = +Inf,   ... )  MultisessionFutureBackend(workers = availableCores(), ...)  SequentialFutureBackend(..., maxSizeOfObjects = +Inf)"},{"path":"https://future.futureverse.org/reference/FutureBackend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster — ClusterFutureBackend","text":"workers ... persistent (deprecated) ... gc Overrides default behavior whether futures trigger garbage collection via gc() parallel worker value collected worker. can help release memory sooner letting R parallel worker decided needed. Releasing memory sooner can help fit parallel workers machine limited amount total memory. (Default: FALSE) earlySignal Overrides default behavior whether futures resignal (\"relay\") conditions captured soon possible, delayed, instance, value() called future. (Default: FALSE) interrupts FALSE, attempts interrupt futures take place backend, even backend supports . maxSizeOfObjects maximum allowed total size, bytes, objects parallel worker allows. can help protect unexpectedly large data transfers parent process parallel workers - data often transferred network, sometimes also includes internet. instance, sit home set future backend workers running remotely university company, might want use protection avoid transferring giga- terabytes data without noticing. (Default: \\(500 \\cdot 1024^2\\) bytes = 500 MiB, unless overridden FutureBackend subclass, R option future.globals.maxSize (sic!)) backend FutureBackend. future Future started. ... (optional) used.","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster — ClusterFutureBackend","text":"FutureBackend() returns FutureBackend object, inherits environment. Specific future backends defined subclasses implementing FutureBackend API. launchFuture() returns launched Future object. interruptFuture() returns interrupted Future object, supported, unmodified future. stopWorkers() returns TRUE workers shut , otherwise FALSE.","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster — ClusterFutureBackend","text":"ClusterFutureBackend selected plan(cluster, workers = workers). MulticoreFutureBackend backend selected plan(multicore, workers = workers). MultisessionFutureBackend backend selected plan(multisession, workers = workers). SequentialFutureBackend selected plan(sequential).","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend.html","id":"the-futurebackend-api","dir":"Reference","previous_headings":"","what":"The FutureBackend API","title":"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster — ClusterFutureBackend","text":"FutureBackend class specifies FutureBackend API, backends must implement comply . Specifically,","code":""},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":null,"dir":"Reference","previous_headings":"","what":"A condition (message, warning, or error) that occurred while orchestrating a future — FutureCondition","title":"A condition (message, warning, or error) that occurred while orchestrating a future — FutureCondition","text":"orchestrating (creating, launching, querying, collection) futures, unexpected run-time errors (types conditions) may occur.  conditions coerced corresponding FutureCondition class help distinguish conditions occur due evaluation future.","code":""},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A condition (message, warning, or error) that occurred while orchestrating a future — FutureCondition","text":"","code":"FutureCondition(message, call = NULL, uuid = future[[\"uuid\"]], future = NULL)  FutureMessage(message, call = NULL, uuid = future[[\"uuid\"]], future = NULL)  FutureWarning(message, call = NULL, uuid = future[[\"uuid\"]], future = NULL)  FutureError(message, call = NULL, uuid = future[[\"uuid\"]], future = NULL)  RngFutureCondition(   message = NULL,   call = NULL,   uuid = future[[\"uuid\"]],   future = NULL )  RngFutureWarning(...)  RngFutureError(...)  UnexpectedFutureResultError(future, hint = NULL)  GlobalEnvMisuseFutureCondition(   message = NULL,   call = NULL,   globalenv = globalenv,   uuid = future[[\"uuid\"]],   future = NULL )  GlobalEnvMisuseFutureWarning(...)  GlobalEnvMisuseFutureError(...)  ConnectionMisuseFutureCondition(   message = NULL,   call = NULL,   differences = NULL,   uuid = future[[\"uuid\"]],   future = NULL )  ConnectionMisuseFutureWarning(...)  ConnectionMisuseFutureError(...)  FutureInterruptError(..., future = NULL)  FutureDroppedError(..., future = NULL)  FutureJournalCondition(   message,   journal,   call = NULL,   uuid = future[[\"uuid\"]],   future = NULL )"},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A condition (message, warning, or error) that occurred while orchestrating a future — FutureCondition","text":"message message condition. call call stack led condition. uuid universally unique identifier future associated FutureCondition. future Future involved. hint (optional) string suggestion might wrong.","code":""},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A condition (message, warning, or error) that occurred while orchestrating a future — FutureCondition","text":"object class FutureCondition inherits class condition FutureMessage, FutureWarning, FutureError inherits FutureCondition. Moreover, FutureError inherits error, FutureWarning warning, FutureMessage message.","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":null,"dir":"Reference","previous_headings":"","what":"A representation of a set of globals used with futures — FutureGlobals","title":"A representation of a set of globals used with futures — FutureGlobals","text":"representation set globals used futures","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A representation of a set of globals used with futures — FutureGlobals","text":"","code":"FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)"},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A representation of a set of globals used with futures — FutureGlobals","text":"object named list. resolved logical indicating whether globals scanned resolved futures . total_size total size globals, known. ... used.","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A representation of a set of globals used with futures — FutureGlobals","text":"object class FutureGlobals.","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A representation of a set of globals used with futures — FutureGlobals","text":"class extends Globals class adding attributes resolved total_size.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":null,"dir":"Reference","previous_headings":"","what":"Results from resolving a future — FutureResult","title":"Results from resolving a future — FutureResult","text":"Results resolving future","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results from resolving a future — FutureResult","text":"","code":"FutureResult(   value = NULL,   visible = TRUE,   stdout = NULL,   conditions = NULL,   rng = FALSE,   ...,   started = .POSIXct(NA_real_),   finished = Sys.time(),   version = \"1.8\" )  # S3 method for class 'FutureResult' as.character(x, ...)  # S3 method for class 'FutureResult' print(x, ...)"},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Results from resolving a future — FutureResult","text":"value value future expression. expression fully resolved (e.g. error) occurred, value NULL. visible TRUE, value visible, otherwise invisible. conditions list zero list elements containing captured condition possibly meta data call stack timestamp. rng TRUE, .Random.seed updated resolving future, otherwise . started, finished POSIXct timestamps evaluation future expression started finished. version version format results. ... (optional) Additional named results returned.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Results from resolving a future — FutureResult","text":"object class FutureResult.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Results from resolving a future — FutureResult","text":"function part backend Future API. function part frontend Future API.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"note-to-developers","dir":"Reference","previous_headings":"","what":"Note to developers","title":"Results from resolving a future — FutureResult","text":"FutureResult structure development may change anytime, e.g. elements may renamed removed.  , please avoid accessing elements directly code.  Feel free reach need code.","code":""},{"path":"https://future.futureverse.org/reference/MulticoreFuture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A multicore future is a future whose value will be resolved asynchronously in a parallel process — MulticoreFuture-class","title":"A multicore future is a future whose value will be resolved asynchronously in a parallel process — MulticoreFuture-class","text":"multicore future future whose value resolved asynchronously parallel process","code":""},{"path":"https://future.futureverse.org/reference/MulticoreFuture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A multicore future is a future whose value will be resolved asynchronously in a parallel process — MulticoreFuture-class","text":"","code":"# S3 method for class 'MulticoreFuture' resolved(x, run = TRUE, timeout = NULL, ...)"},{"path":"https://future.futureverse.org/reference/MulticoreFuture-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A multicore future is a future whose value will be resolved asynchronously in a parallel process — MulticoreFuture-class","text":"MulticoreFuture() returns object class MulticoreFuture.","code":""},{"path":"https://future.futureverse.org/reference/MulticoreFuture-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A multicore future is a future whose value will be resolved asynchronously in a parallel process — MulticoreFuture-class","text":"use 'multicore' futures, use plan(multicore, ...), cf. multicore.","code":""},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process — MultiprocessFuture-class","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process — MultiprocessFuture-class","text":"multiprocess future future whose value resolved asynchronously parallel process","code":""},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process — MultiprocessFuture-class","text":"","code":"MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)"},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process — MultiprocessFuture-class","text":"expr R expression. substitute TRUE, argument expr substitute():ed, otherwise . envir environment global objects identified. ... Additional named elements passed Future().","code":""},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process — MultiprocessFuture-class","text":"MultiprocessFuture() returns object class MultiprocessFuture.","code":""},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"An uniprocess future is a future whose value will be resolved synchronously in the current process — UniprocessFuture-class","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process — UniprocessFuture-class","text":"uniprocess future future whose value resolved synchronously current process","code":""},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process — UniprocessFuture-class","text":"","code":"UniprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)"},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process — UniprocessFuture-class","text":"expr R expression. substitute TRUE, argument expr substitute():ed, otherwise . envir environment global objects identified. ... Additional named elements passed Future().","code":""},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process — UniprocessFuture-class","text":"UniprocessFuture() returns object class UniprocessFuture.","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Back trace the expressions evaluated when an error was caught — backtrace","title":"Back trace the expressions evaluated when an error was caught — backtrace","text":"Back trace expressions evaluated error caught","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Back trace the expressions evaluated when an error was caught — backtrace","text":"","code":"backtrace(future, envir = parent.frame(), ...)"},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Back trace the expressions evaluated when an error was caught — backtrace","text":"future future caught error. envir environment locate future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Back trace the expressions evaluated when an error was caught — backtrace","text":"list future's call stack led error.","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Back trace the expressions evaluated when an error was caught — backtrace","text":"","code":"my_log <- function(x) log(x) foo <- function(...) my_log(...)  f <- future({ foo(\"a\") }) res <- tryCatch({   v <- value(f) }, error = function(ex) {   t <- backtrace(f)   print(t) }) #> [[1]] #> base::tryCatch(base::withCallingHandlers({ #>     NULL #>     base::saveRDS(base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/henrik/RtmpnwMNbc/callr-fun-15fc461647bb67\"),  #>         base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>         quote = TRUE), file = \"/tmp/henrik/RtmpnwMNbc/callr-res-15fc467ee894b\",  #>         compress = FALSE) #>     base::flush(base::stdout()) #>     base::flush(base::stderr()) #>     NULL #>     base::invisible() #> }, error = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/henrik/RtmpnwMNbc/callr-res-15fc467ee894b\",  #>             \".error\")) #>     } #> }, interrupt = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/henrik/RtmpnwMNbc/callr-res-15fc467ee894b\",  #>             \".error\")) #>     } #> }, callr_message = function(e) { #>     base::try(base::signalCondition(e)) #> }), error = function(e) { #>     NULL #>     if (FALSE) { #>         base::try(base::stop(e)) #>     } #>     else { #>         base::invisible() #>     } #> }, interrupt = function(e) { #>     NULL #>     if (FALSE) { #>         e #>     } #>     else { #>         base::invisible() #>     } #> }) #>  #> [[2]] #> tryCatchList(expr, classes, parentenv, handlers) #>  #> [[3]] #> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),  #>     names[nh], parentenv, handlers[[nh]]) #>  #> [[4]] #> doTryCatch(return(expr), name, parentenv, handler) #>  #> [[5]] #> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #>  #> [[6]] #> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #>  #> [[7]] #> doTryCatch(return(expr), name, parentenv, handler) #>  #> [[8]] #> base::withCallingHandlers({ #>     NULL #>     base::saveRDS(base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/henrik/RtmpnwMNbc/callr-fun-15fc461647bb67\"),  #>         base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>         quote = TRUE), file = \"/tmp/henrik/RtmpnwMNbc/callr-res-15fc467ee894b\",  #>         compress = FALSE) #>     base::flush(base::stdout()) #>     base::flush(base::stderr()) #>     NULL #>     base::invisible() #> }, error = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/henrik/RtmpnwMNbc/callr-res-15fc467ee894b\",  #>             \".error\")) #>     } #> }, interrupt = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/henrik/RtmpnwMNbc/callr-res-15fc467ee894b\",  #>             \".error\")) #>     } #> }, callr_message = function(e) { #>     base::try(base::signalCondition(e)) #> }) #>  #> [[9]] #> base::saveRDS(base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/henrik/RtmpnwMNbc/callr-fun-15fc461647bb67\"),  #>     base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>     quote = TRUE), file = \"/tmp/henrik/RtmpnwMNbc/callr-res-15fc467ee894b\",  #>     compress = FALSE) #>  #> [[10]] #> base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/henrik/RtmpnwMNbc/callr-fun-15fc461647bb67\"),  #>     base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>     quote = TRUE) #>  #> [[11]] #> (function (what, args, quote = FALSE, envir = parent.frame())  #> { #>     if (!is.list(args))  #>         stop(\"second argument must be a list\") #>     if (quote)  #>         args <- lapply(args, enquote) #>     .Internal(do.call(what, args, envir)) #> })(base::quote(function (..., cli_colors, hyperlinks, pkgdown_internet)  #> { #>     options(cli.num_colors = cli_colors, cli.hyperlink = hyperlinks,  #>         cli.hyperlink_run = hyperlinks, pkgdown.internet = pkgdown_internet) #>     pkgdown::build_site(...) #> }), base::quote(list(pkg = list(package = \"future\", version = \"1.34.0-9356\",  #>     src_path = \"/tmp/henrik/RtmpnwMNbc/future\", meta = list(url = \"https://future.futureverse.org\",  #>         home = list(links = list(list(text = \"Roadmap/Milestones\",  #>             href = \"https://github.com/futureverse/future/milestones\"),  #>             list(text = \"The Futureverse Project\", href = \"https://www.futureverse.org/\"),  #>             list(text = \"Futureverse User Forum\", href = \"https://github.com/futureverse/future/discussions\"))),  #>         navbar = list(structure = list(right = c(\"futureverse\",  #>         \"pkgs\", \"cran\", \"github\", \"lightswitch\")), components = list( #>             futureverse = list(icon = \"fas fa-home\", href = \"https://www.futureverse.org/\"),  #>             pkgs = list(text = \"Packages\", menu = list(list(text = \"doFuture (map-reduce)\",  #>                 href = \"https://doFuture.futureverse.org\"), list( #>                 text = \"furrr (map-reduce)\", href = \"https://furrr.futureverse.org\"),  #>                 list(text = \"future\", href = \"https://future.futureverse.org\"),  #>                 list(text = \"future.apply (map-reduce)\", href = \"https://future.apply.futureverse.org\"),  #>                 list(text = \"future.batchtools (backend)\", href = \"https://future.batchtools.futureverse.org\"),  #>                 list(text = \"future.callr (backend)\", href = \"https://future.callr.futureverse.org\"),  #>                 list(text = \"future.mirai (backend)\", href = \"https://future.mirai.futureverse.org\"),  #>                 list(text = \"future.tests\", href = \"https://future.tests.futureverse.org\"),  #>                 list(text = \"globals\", href = \"https://globals.futureverse.org\"),  #>                 list(text = \"listenv\", href = \"https://listenv.futureverse.org\"),  #>                 list(text = \"parallelly\", href = \"https://parallelly.futureverse.org\"),  #>                 list(text = \"progressr\", href = \"https://progressr.futureverse.org\"),  #>                 list(text = \"BiocParallel.FutureParam (experimental)\",  #>                   href = \"https://BiocParallel.FutureParam.futureverse.org\"),  #>                 list(text = \"future.tools (experimental)\", href = \"https://future.tools.futureverse.org\"),  #>                 list(text = \"future.mapreduce (experimental)\",  #>                   href = \"https://future.mapreduce.futureverse.org\"),  #>                 list(text = \"marshal (experimental)\", href = \"https://marshal.futureverse.org\"))),  #>             cran = list(icon = \"fab fa-r-project\", href = \"https://cloud.r-project.org/package=future\"))),  #>         template = list(params = list(docsearch = list(api_key = \"aa6e02fc501886fb0f7c91ac4e300456\",  #>             index_name = \"futureverse\", algoliaOptions = list( #>                 facetFilters = \"project:future\")), ganalytics = \"G-SB3EQSD9FR\"),  #>             bootstrap = 5L, `light-switch` = TRUE)), desc = <environment>,  #>     bs_version = 5L, development = list(destination = \"dev\",  #>         mode = \"default\", version_label = \"muted\", in_dev = FALSE,  #>         prefix = \"\"), prefix = \"\", dst_path = \"/tmp/henrik/RtmpnwMNbc/future/docs\",  #>     lang = \"en\", install_metadata = FALSE, figures = list(dev = \"ragg::agg_png\",  #>         dpi = 96L, dev.args = list(), fig.ext = \"png\", fig.width = 7.29166666666667,  #>         fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839,  #>         bg = NULL, other.parameters = list()), repo = list(url = list( #>         home = \"https://github.com/futureverse/future/\", source = \"https://github.com/futureverse/future/blob/HEAD/\",  #>         issue = \"https://github.com/futureverse/future/issues/\",  #>         user = \"https://github.com/\")), topics = list(name = c(`Future-class.Rd` = \"Future-class\",  #>     FutureBackend.Rd = \"ClusterFutureBackend\", FutureCondition.Rd = \"FutureCondition\",  #>     FutureGlobals.Rd = \"FutureGlobals\", FutureResult.Rd = \"FutureResult\",  #>     `MulticoreFuture-class.Rd` = \"MulticoreFuture-class\", `MultiprocessFuture-class.Rd` = \"MultiprocessFuture-class\",  #>     `UniprocessFuture-class.Rd` = \"UniprocessFuture-class\", backtrace.Rd = \"backtrace\",  #>     cluster.Rd = \"cluster\", clusterExportSticky.Rd = \"clusterExportSticky\",  #>     find_references.Rd = \"find_references\", future.Rd = \"future\",  #>     futureAssign.Rd = \"futureAssign\", futureOf.Rd = \"futureOf\",  #>     futureSessionInfo.Rd = \"futureSessionInfo\", futures.Rd = \"futures\",  #>     getExpression.Rd = \"getExpression\", getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>     interrupt.Rd = \"interrupt\", mandelbrot.Rd = \"mandelbrot\",  #>     multicore.Rd = \"multicore\", multisession.Rd = \"multisession\",  #>     nbrOfWorkers.Rd = \"nbrOfWorkers\", nullcon.Rd = \"nullcon\",  #>     plan.Rd = \"plan\", private_length.Rd = \".length\", `re-exports.Rd` = \"re-exports\",  #>     readImmediateConditions.Rd = \"readImmediateConditions\", requestCore.Rd = \"requestCore\",  #>     reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\", resolve.Rd = \"resolve\",  #>     resolved.Rd = \"resolved\", result.Rd = \"result.Future\", run.Rd = \"run.Future\",  #>     save_rds.Rd = \"save_rds\", sequential.Rd = \"sequential\", sessionDetails.Rd = \"sessionDetails\",  #>     signalConditions.Rd = \"signalConditions\", sticky_globals.Rd = \"sticky_globals\",  #>     usedCores.Rd = \"usedCores\", value.Rd = \"value\", `zzz-future.options.Rd` = \"zzz-future.options\" #>     ), file_in = c(\"Future-class.Rd\", \"FutureBackend.Rd\", \"FutureCondition.Rd\",  #>     \"FutureGlobals.Rd\", \"FutureResult.Rd\", \"MulticoreFuture-class.Rd\",  #>     \"MultiprocessFuture-class.Rd\", \"UniprocessFuture-class.Rd\",  #>     \"backtrace.Rd\", \"cluster.Rd\", \"clusterExportSticky.Rd\", \"find_references.Rd\",  #>     \"future.Rd\", \"futureAssign.Rd\", \"futureOf.Rd\", \"futureSessionInfo.Rd\",  #>     \"futures.Rd\", \"getExpression.Rd\", \"getGlobalsAndPackages.Rd\",  #>     \"interrupt.Rd\", \"mandelbrot.Rd\", \"multicore.Rd\", \"multisession.Rd\",  #>     \"nbrOfWorkers.Rd\", \"nullcon.Rd\", \"plan.Rd\", \"private_length.Rd\",  #>     \"re-exports.Rd\", \"readImmediateConditions.Rd\", \"requestCore.Rd\",  #>     \"reset.Rd\", \"resetWorkers.Rd\", \"resolve.Rd\", \"resolved.Rd\",  #>     \"result.Rd\", \"run.Rd\", \"save_rds.Rd\", \"sequential.Rd\", \"sessionDetails.Rd\",  #>     \"signalConditions.Rd\", \"sticky_globals.Rd\", \"usedCores.Rd\",  #>     \"value.Rd\", \"zzz-future.options.Rd\"), file_out = c(\"Future-class.html\",  #>     \"FutureBackend.html\", \"FutureCondition.html\", \"FutureGlobals.html\",  #>     \"FutureResult.html\", \"MulticoreFuture-class.html\", \"MultiprocessFuture-class.html\",  #>     \"UniprocessFuture-class.html\", \"backtrace.html\", \"cluster.html\",  #>     \"clusterExportSticky.html\", \"find_references.html\", \"future.html\",  #>     \"futureAssign.html\", \"futureOf.html\", \"futureSessionInfo.html\",  #>     \"futures.html\", \"getExpression.html\", \"getGlobalsAndPackages.html\",  #>     \"interrupt.html\", \"mandelbrot.html\", \"multicore.html\", \"multisession.html\",  #>     \"nbrOfWorkers.html\", \"nullcon.html\", \"plan.html\", \"private_length.html\",  #>     \"re-exports.html\", \"readImmediateConditions.html\", \"requestCore.html\",  #>     \"reset.html\", \"resetWorkers.html\", \"resolve.html\", \"resolved.html\",  #>     \"result.html\", \"run.html\", \"save_rds.html\", \"sequential.html\",  #>     \"sessionDetails.html\", \"signalConditions.html\", \"sticky_globals.html\",  #>     \"usedCores.html\", \"value.html\", \"zzz-future.options.html\" #>     ), alias = list(`Future-class.Rd` = c(\"Future-class\", \"Future\" #>     ), FutureBackend.Rd = c(\"ClusterFutureBackend\", \"FutureBackend\",  #>     \"launchFuture\", \"listFutures\", \"interruptFuture\", \"validateFutureGlobals\",  #>     \"stopWorkers\", \"MulticoreFutureBackend\", \"MultisessionFutureBackend\",  #>     \"SequentialFutureBackend\"), FutureCondition.Rd = c(\"FutureCondition\",  #>     \"FutureMessage\", \"FutureWarning\", \"FutureError\", \"RngFutureCondition\",  #>     \"RngFutureWarning\", \"RngFutureError\", \"UnexpectedFutureResultError\",  #>     \"GlobalEnvMisuseFutureCondition\", \"GlobalEnvMisuseFutureWarning\",  #>     \"GlobalEnvMisuseFutureError\", \"ConnectionMisuseFutureCondition\",  #>     \"ConnectionMisuseFutureWarning\", \"ConnectionMisuseFutureError\",  #>     \"FutureInterruptError\", \"FutureDroppedError\", \"FutureJournalCondition\" #>     ), FutureGlobals.Rd = c(\"FutureGlobals\", \"as.FutureGlobals\",  #>     \"as.FutureGlobals.FutureGlobals\", \"as.FutureGlobals.Globals\",  #>     \"as.FutureGlobals.list\", \"[.FutureGlobals\", \"c.FutureGlobals\",  #>     \"unique.FutureGlobals\"), FutureResult.Rd = c(\"FutureResult\",  #>     \"as.character.FutureResult\", \"print.FutureResult\"), `MulticoreFuture-class.Rd` = c(\"MulticoreFuture-class\",  #>     \"resolved.MulticoreFuture\"), `MultiprocessFuture-class.Rd` = c(\"MultiprocessFuture-class\",  #>     \"MultiprocessFuture\"), `UniprocessFuture-class.Rd` = c(\"UniprocessFuture-class\",  #>     \"UniprocessFuture\"), backtrace.Rd = \"backtrace\", cluster.Rd = \"cluster\",  #>         clusterExportSticky.Rd = \"clusterExportSticky\", find_references.Rd = c(\"find_references\",  #>         \"assert_no_references\"), future.Rd = c(\"future\", \"futureCall\",  #>         \"minifuture\"), futureAssign.Rd = c(\"futureAssign\", \"%<-%\",  #>         \"%->%\", \"%globals%\", \"%packages%\", \"%seed%\", \"%stdout%\",  #>         \"%conditions%\", \"%lazy%\", \"%label%\", \"%plan%\", \"%tweak%\" #>         ), futureOf.Rd = \"futureOf\", futureSessionInfo.Rd = \"futureSessionInfo\",  #>         futures.Rd = \"futures\", getExpression.Rd = c(\"getExpression\",  #>         \"getExpression.Future\"), getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>         interrupt.Rd = \"interrupt\", mandelbrot.Rd = c(\"mandelbrot\",  #>         \"as.raster.Mandelbrot\", \"plot.Mandelbrot\", \"mandelbrot_tiles\",  #>         \"mandelbrot.matrix\", \"mandelbrot.numeric\"), multicore.Rd = \"multicore\",  #>         multisession.Rd = \"multisession\", nbrOfWorkers.Rd = c(\"nbrOfWorkers\",  #>         \"nbrOfFreeWorkers\"), nullcon.Rd = \"nullcon\", plan.Rd = c(\"plan\",  #>         \"tweak\", \"withPlan\", \"localPlan\"), private_length.Rd = \".length\",  #>         `re-exports.Rd` = c(\"re-exports\", \"as.cluster\", \"availableCores\",  #>         \"availableWorkers\", \"makeClusterPSOCK\", \"supportsMulticore\" #>         ), readImmediateConditions.Rd = c(\"readImmediateConditions\",  #>         \"saveImmediateCondition\"), requestCore.Rd = \"requestCore\",  #>         reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\",  #>         resolve.Rd = \"resolve\", resolved.Rd = \"resolved\", result.Rd = c(\"result.Future\",  #>         \"result\"), run.Rd = c(\"run.Future\", \"run\"), save_rds.Rd = \"save_rds\",  #>         sequential.Rd = c(\"sequential\", \"uniprocess\"), sessionDetails.Rd = \"sessionDetails\",  #>         signalConditions.Rd = \"signalConditions\", sticky_globals.Rd = \"sticky_globals\",  #>         usedCores.Rd = \"usedCores\", value.Rd = c(\"value\", \"value.Future\",  #>         \"value.list\", \"value.listenv\", \"value.environment\"),  #>         `zzz-future.options.Rd` = c(\"zzz-future.options\", \"future.options\",  #>         \"future.startup.script\", \"future.debug\", \"future.demo.mandelbrot.region\",  #>         \"future.demo.mandelbrot.nrow\", \"future.fork.multithreading.enable\",  #>         \"future.globals.maxSize\", \"future.globals.method\", \"future.globals.onMissing\",  #>         \"future.globals.resolve\", \"future.globals.onReference\",  #>         \"future.plan\", \"future.onFutureCondition.keepFuture\",  #>         \"future.resolve.recursive\", \"future.connections.onMisuse\",  #>         \"future.globalenv.onMisuse\", \"future.rng.onMisuse\", \"future.wait.alpha\",  #>         \"future.wait.interval\", \"future.wait.timeout\", \"future.output.windows.reencode\",  #>         \"future.journal\", \"future.globals.objectSize.method\",  #>         \"R_FUTURE_STARTUP_SCRIPT\", \"R_FUTURE_DEBUG\", \"R_FUTURE_DEMO_MANDELBROT_REGION\",  #>         \"R_FUTURE_DEMO_MANDELBROT_NROW\", \"R_FUTURE_FORK_MULTITHREADING_ENABLE\",  #>         \"R_FUTURE_GLOBALS_MAXSIZE\", \"R_FUTURE_GLOBALS_METHOD\",  #>         \"R_FUTURE_GLOBALS_ONMISSING\", \"R_FUTURE_GLOBALS_RESOLVE\",  #>         \"R_FUTURE_GLOBALS_ONREFERENCE\", \"R_FUTURE_PLAN\", \"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\",  #>         \"R_FUTURE_RESOLVE_RECURSIVE\", \"R_FUTURE_CONNECTIONS_ONMISUSE\",  #>         \"R_FUTURE_GLOBALENV_ONMISUSE\", \"R_FUTURE_RNG_ONMISUSE\",  #>         \"R_FUTURE_WAIT_ALPHA\", \"R_FUTURE_WAIT_INTERVAL\", \"R_FUTURE_WAIT_TIMEOUT\",  #>         \"R_FUTURE_RESOLVED_TIMEOUT\", \"R_FUTURE_OUTPUT_WINDOWS_REENCODE\",  #>         \"R_FUTURE_JOURNAL\", \"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\",  #>         \"future.cmdargs\", \".future.R\")), funs = list(`Future-class.Rd` = \"Future()\",  #>         FutureBackend.Rd = c(\"ClusterFutureBackend()\", \"FutureBackend()\",  #>         \"launchFuture()\", \"listFutures()\", \"interruptFuture()\",  #>         \"validateFutureGlobals()\", \"stopWorkers()\", \"MulticoreFutureBackend()\",  #>         \"MultisessionFutureBackend()\", \"SequentialFutureBackend()\" #>         ), FutureCondition.Rd = c(\"FutureCondition()\", \"FutureMessage()\",  #>         \"FutureWarning()\", \"FutureError()\", \"RngFutureCondition()\",  #>         \"RngFutureWarning()\", \"RngFutureError()\", \"UnexpectedFutureResultError()\",  #>         \"GlobalEnvMisuseFutureCondition()\", \"GlobalEnvMisuseFutureWarning()\",  #>         \"GlobalEnvMisuseFutureError()\", \"ConnectionMisuseFutureCondition()\",  #>         \"ConnectionMisuseFutureWarning()\", \"ConnectionMisuseFutureError()\",  #>         \"FutureInterruptError()\", \"FutureDroppedError()\", \"FutureJournalCondition()\" #>         ), FutureGlobals.Rd = \"FutureGlobals()\", FutureResult.Rd = c(\"FutureResult()\",  #>         \"as.character(<i>&lt;FutureResult&gt;<\/i>)\", \"print(<i>&lt;FutureResult&gt;<\/i>)\" #>         ), `MulticoreFuture-class.Rd` = \"resolved(<i>&lt;MulticoreFuture&gt;<\/i>)\",  #>         `MultiprocessFuture-class.Rd` = \"MultiprocessFuture()\",  #>         `UniprocessFuture-class.Rd` = \"UniprocessFuture()\", backtrace.Rd = \"backtrace()\",  #>         cluster.Rd = \"cluster()\", clusterExportSticky.Rd = \"clusterExportSticky()\",  #>         find_references.Rd = c(\"find_references()\", \"assert_no_references()\" #>         ), future.Rd = c(\"future()\", \"futureCall()\", \"minifuture()\" #>         ), futureAssign.Rd = c(\"futureAssign()\", \"`%&lt;-%`\",  #>         \"`%globals%`\", \"`%packages%`\", \"`%seed%`\", \"`%stdout%`\",  #>         \"`%conditions%`\", \"`%lazy%`\", \"`%label%`\", \"`%plan%`\",  #>         \"`%tweak%`\"), futureOf.Rd = \"futureOf()\", futureSessionInfo.Rd = \"futureSessionInfo()\",  #>         futures.Rd = \"futures()\", getExpression.Rd = \"getExpression()\",  #>         getGlobalsAndPackages.Rd = \"getGlobalsAndPackages()\",  #>         interrupt.Rd = \"interrupt()\", mandelbrot.Rd = \"mandelbrot()\",  #>         multicore.Rd = \"multicore()\", multisession.Rd = \"multisession()\",  #>         nbrOfWorkers.Rd = c(\"nbrOfWorkers()\", \"nbrOfFreeWorkers()\" #>         ), nullcon.Rd = \"nullcon()\", plan.Rd = c(\"plan()\", \"tweak()\",  #>         \"withPlan()\", \"localPlan()\"), private_length.Rd = \".length()\",  #>         `re-exports.Rd` = character(0), readImmediateConditions.Rd = c(\"readImmediateConditions()\",  #>         \"saveImmediateCondition()\"), requestCore.Rd = \"requestCore()\",  #>         reset.Rd = \"reset()\", resetWorkers.Rd = \"resetWorkers()\",  #>         resolve.Rd = \"resolve()\", resolved.Rd = \"resolved()\",  #>         result.Rd = \"result(<i>&lt;Future&gt;<\/i>)\", run.Rd = \"run(<i>&lt;Future&gt;<\/i>)\",  #>         save_rds.Rd = \"save_rds()\", sequential.Rd = \"sequential()\",  #>         sessionDetails.Rd = \"sessionDetails()\", signalConditions.Rd = \"signalConditions()\",  #>         sticky_globals.Rd = \"sticky_globals()\", usedCores.Rd = \"usedCores()\",  #>         value.Rd = \"value()\", `zzz-future.options.Rd` = character(0)),  #>         title = c(`Future-class.Rd` = \"A future represents a value that will be available at some point in the future\",  #>         FutureBackend.Rd = \"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster\",  #>         FutureCondition.Rd = \"A condition (message, warning, or error) that occurred while orchestrating a future\",  #>         FutureGlobals.Rd = \"A representation of a set of globals used with futures\",  #>         FutureResult.Rd = \"Results from resolving a future\",  #>         `MulticoreFuture-class.Rd` = \"A multicore future is a future whose value will be resolved asynchronously in a parallel process\",  #>         `MultiprocessFuture-class.Rd` = \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\",  #>         `UniprocessFuture-class.Rd` = \"An uniprocess future is a future whose value will be resolved synchronously in the current process\",  #>         backtrace.Rd = \"Back trace the expressions evaluated when an error was caught\",  #>         cluster.Rd = \"Create a cluster future whose value will be resolved asynchronously in a parallel process\",  #>         clusterExportSticky.Rd = \"Export globals to the sticky-globals environment of the cluster nodes\",  #>         find_references.Rd = \"Get the first or all references of an <span style=\\\"R\\\">R<\/span> object\",  #>         future.Rd = \"Create a future\", futureAssign.Rd = \"Create a future assignment\",  #>         futureOf.Rd = \"Get the future of a future variable\",  #>         futureSessionInfo.Rd = \"Get future-specific session information and validate current backend\",  #>         futures.Rd = \"Get all futures in a container\", getExpression.Rd = \"Inject code for the next type of future to use for nested futures\",  #>         getGlobalsAndPackages.Rd = \"Retrieves global variables of an expression and their associated packages\",  #>         interrupt.Rd = \"Interrupts a running future\", mandelbrot.Rd = \"Mandelbrot convergence counts\",  #>         multicore.Rd = \"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\",  #>         multisession.Rd = \"Create a multisession future whose value will be resolved asynchronously in a parallel <span style=\\\"R\\\">R<\/span> session\",  #>         nbrOfWorkers.Rd = \"Get the number of workers available\",  #>         nullcon.Rd = \"Creates a connection to the system null device\",  #>         plan.Rd = \"Plan how to resolve a future\", private_length.Rd = \"Gets the length of an object without dispatching\",  #>         `re-exports.Rd` = \"Functions Moved to 'parallelly'\",  #>         readImmediateConditions.Rd = \"Writes and Reads 'immediateCondition' RDS Files\",  #>         requestCore.Rd = \"Request a core for multicore processing\",  #>         reset.Rd = \"Reset a finished, failed, or interrupted future to a lazy future\",  #>         resetWorkers.Rd = \"Free up active background workers\",  #>         resolve.Rd = \"Resolve one or more futures synchronously\",  #>         resolved.Rd = \"Check whether a future is resolved or not\",  #>         result.Rd = \"Get the results of a resolved future\", run.Rd = \"Run a future\",  #>         save_rds.Rd = \"Robustly Saves an Object to RDS File Atomically\",  #>         sequential.Rd = \"Create a sequential future whose value will be in the current <span style=\\\"R\\\">R<\/span> session\",  #>         sessionDetails.Rd = \"Outputs details on the current <span style=\\\"R\\\">R<\/span> session\",  #>         signalConditions.Rd = \"Signals Captured Conditions\",  #>         sticky_globals.Rd = \"Place a sticky-globals environment immediately after the global environment\",  #>         usedCores.Rd = \"Get number of cores currently used\",  #>         value.Rd = \"The value of a future or the values of all elements in a container\",  #>         `zzz-future.options.Rd` = \"Options used for futures\"),  #>         rd = list(`Future-class.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>             \"\\n\", list(\"Future-class\"), \"\\n\", list(\"Future-class\"),  #>             \"\\n\", list(\"Future\"), \"\\n\", list(\"A future represents a value that will be available at some point in the future\"),  #>             \"\\n\", list(\"\\n\", \"Future(\\n\", \"  expr = NULL,\\n\",  #>                 \"  envir = parent.frame(),\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  stdout = TRUE,\\n\", \"  conditions = \\\"condition\\\",\\n\",  #>                 \"  globals = list(),\\n\", \"  packages = NULL,\\n\",  #>                 \"  seed = FALSE,\\n\", \"  lazy = FALSE,\\n\", \"  gc = FALSE,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  label = NULL,\\n\",  #>                 \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                 \"expr\"), list(\"An \", list(), \" \", list(\"expression\"),  #>                 \".\")), \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The \",  #>                 list(\"environment\"), \" from where global objects should be\\n\",  #>                 \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                 list(\"If TRUE, argument \", list(\"expr\"), \" is\\n\",  #>                   list(list(\"substitute\"), \"()\"), \":ed, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of conditions classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherits from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression does neither\\n\",  #>                   \"need nor use random numbers generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements of the future.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"Future()\"), \" returns an object of class \",  #>                 list(\"Future\"), \".\\n\"), \"\\n\", list(\"\\n\", \"A \",  #>                 list(\"future\"), \" is an abstraction for a \",  #>                 list(\"value\"), \" that may\\n\", \"available at some point in the future.  A future can either be\\n\",  #>                 list(\"unresolved\"), \" or \", list(\"resolved\"),  #>                 \", a state which can be checked\\n\", \"with \",  #>                 list(list(\"resolved()\")), \".  As long as it is \",  #>                 list(\"unresolved\"), \", the\\n\", \"value is not available.  As soon as it is \",  #>                 list(\"resolved\"), \", the value\\n\", \"is available via \",  #>                 list(list(\"value\"), \"()\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A Future object is itself an \", list(\"environment\"),  #>                 \".\\n\"), \"\\n\", list(\"\\n\", \"One function that creates a Future is \",  #>                 list(list(\"future()\")), \".\\n\", \"It returns a Future that evaluates an \",  #>                 list(), \" expression in the future.\\n\", \"An alternative approach is to use the \",  #>                 list(list(\"%<-%\")), \" infix\\n\", \"assignment operator, which creates a future from the\\n\",  #>                 \"right-hand-side (RHS) \", list(), \" expression and assigns its future value\\n\",  #>                 \"to a variable as a \", list(list(\"promise\")),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureBackend.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-ClusterFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-FutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-MulticoreFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-MultisessionFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-SequentialFutureBackend-class.R\",  #>             \"\\n\", list(\"ClusterFutureBackend\"), \"\\n\", list(\"ClusterFutureBackend\"),  #>             \"\\n\", list(\"FutureBackend\"), \"\\n\", list(\"launchFuture\"),  #>             \"\\n\", list(\"listFutures\"), \"\\n\", list(\"interruptFuture\"),  #>             \"\\n\", list(\"validateFutureGlobals\"), \"\\n\", list(\"stopWorkers\"),  #>             \"\\n\", list(\"MulticoreFutureBackend\"), \"\\n\", list( #>                 \"MultisessionFutureBackend\"), \"\\n\", list(\"SequentialFutureBackend\"),  #>             \"\\n\", list(\"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster\"),  #>             \"\\n\", list(\"\\n\", \"ClusterFutureBackend(\\n\", \"  workers = availableWorkers(),\\n\",  #>                 \"  persistent = FALSE,\\n\", \"  gc = TRUE,\\n\",  #>                 \"  earlySignal = TRUE,\\n\", \"  interrupts = TRUE,\\n\",  #>                 \"  ...\\n\", \")\\n\", \"\\n\", \"FutureBackend(\\n\", \"  ...,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  gc = FALSE,\\n\",  #>                 \"  maxSizeOfObjects = getOption(\\\"future.globals.maxSize\\\", +Inf),\\n\",  #>                 \"  interrupts = TRUE,\\n\", \"  hooks = FALSE\\n\",  #>                 \")\\n\", \"\\n\", \"launchFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"listFutures(backend, ...)\\n\", \"\\n\", \"interruptFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"validateFutureGlobals(backend, future, ...)\\n\",  #>                 \"\\n\", \"stopWorkers(backend, ...)\\n\", \"\\n\", \"MulticoreFutureBackend(\\n\",  #>                 \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                 \"  maxSizeOfObjects = +Inf,\\n\", \"  ...\\n\", \")\\n\",  #>                 \"\\n\", \"MultisessionFutureBackend(workers = availableCores(), ...)\\n\",  #>                 \"\\n\", \"SequentialFutureBackend(..., maxSizeOfObjects = +Inf)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"workers\"), list(\"...\")),  #>                 \"\\n\", \"\\n\", list(list(\"persistent\"), list(\"(deprecated) ...\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"Overrides the default behavior of whether futures should trigger\\n\",  #>                   \"garbage collection via \", list(list(\"gc()\")),  #>                   \" on the parallel worker after the value has\\n\",  #>                   \"been collected from the worker.\\n\", \"This can help to release memory sooner than letting R itself on the parallel\\n\",  #>                   \"worker decided when it is needed. Releasing memory sooner can help to fit\\n\",  #>                   \"more parallel workers on a machine with limited amount of total memory.\\n\",  #>                   \"(Default: \", list(\"FALSE\"), \")\")), \"\\n\", \"\\n\",  #>                 list(list(\"earlySignal\"), list(\"Overrides the default behavior on whether futures\\n\",  #>                   \"should resignal (\\\"relay\\\") conditions captured as soon as possible, or\\n\",  #>                   \"delayed, for instance, until \", list(list( #>                     \"value()\")), \" is called on the future.\\n\",  #>                   \"(Default: \", list(\"FALSE\"), \")\")), \"\\n\", \"\\n\",  #>                 list(list(\"interrupts\"), list(\"If FALSE, attempts to interrupt futures will not take\\n\",  #>                   \"place on this backend, even if the backend supports it.\")),  #>                 \"\\n\", \"\\n\", list(list(\"maxSizeOfObjects\"), list( #>                   \"The maximum allowed total size, in bytes, of all\\n\",  #>                   \"objects to and from the parallel worker allows.\\n\",  #>                   \"This can help to protect against unexpectedly large data transfers between\\n\",  #>                   \"the parent process and the parallel workers - data that is often transferred\\n\",  #>                   \"over the network, which sometimes also includes the internet. For instance,\\n\",  #>                   \"if you sit at home and have set up a future backend with workers running\\n\",  #>                   \"remotely at your university or company, then you might want to use this\\n\",  #>                   \"protection to avoid transferring giga- or terabytes of data without noticing.\\n\",  #>                   \"(Default: \", list(list(\"500 \\\\cdot 1024^2\")),  #>                   \" bytes = 500 MiB, unless overridden by a\\n\",  #>                   \"FutureBackend subclass, or by R option \",  #>                   list(\"future.globals.maxSize\"), \" (sic!))\")),  #>                 \"\\n\", \"\\n\", list(list(\"backend\"), list(\"a \",  #>                   list(\"FutureBackend\"), \".\")), \"\\n\", \"\\n\", list( #>                   list(\"future\"), list(\"a \", list(\"Future\"),  #>                     \" to be started.\")), \"\\n\", \"\\n\", list(list( #>                   list()), list(\"(optional) not used.\")), \"\\n\"),  #>             \"\\n\", list(\"\\n\", list(\"FutureBackend()\"), \" returns a FutureBackend object, which inherits an\\n\",  #>                 \"environment. Specific future backends are defined by subclasses\\n\",  #>                 \"implementing the FutureBackend API.\\n\", \"\\n\",  #>                 list(\"launchFuture()\"), \" returns the launched \",  #>                 list(\"Future\"), \" object.\\n\", \"\\n\", list(\"interruptFuture()\"),  #>                 \" returns the interrupted \", list(\"Future\"),  #>                 \" object,\\n\", \"if supported, other the unmodified future.\\n\",  #>                 \"\\n\", list(\"stopWorkers()\"), \" returns TRUE if the workers were shut down,\\n\",  #>                 \"otherwise FALSE.\\n\"), \"\\n\", list(\"\\n\", \"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster\\n\",  #>                 \"\\n\", \"Configure a backend that controls how and where futures are evaluated\\n\",  #>                 \"\\n\", list(\"launchFuture()\"), \" runs a future on the backend.\\n\",  #>                 \"\\n\", list(\"interruptFuture()\"), \" interrupts a future on the backend.\\n\",  #>                 \"\\n\", list(\"stopWorkers()\"), \" stops backend workers\\n\",  #>                 \"\\n\", \"A MulticoreFutureBackend resolves futures in parallel using forked processing on the current machine\\n\",  #>                 \"\\n\", \"A MultisessionFutureBackend resolves futures in parallel using a PSOCK cluster on the current machine\\n\",  #>                 \"\\n\", \"A SequentialFutureBackend resolves futures sequentially in the current R session\\n\"),  #>             \"\\n\", list(\"\\n\", \"The \", list(\"ClusterFutureBackend\"),  #>                 \" is selected by\\n\", list(\"plan(cluster, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MulticoreFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multicore, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MultisessionFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multisession, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"SequentialFutureBackend\"),  #>                 \" is selected by \", list(\"plan(sequential)\"),  #>                 \".\\n\"), \"\\n\", list(list(\"The FutureBackend API\"),  #>                 list(\"\\n\", \"\\n\", \"The \", list(\"FutureBackend\"),  #>                   \" class specifies FutureBackend API,\\n\", \"that all backends must implement and comply to. Specifically,\\n\")),  #>             \"\\n\", \"\\n\", list(\"internal\"), \"\\n\"), FutureCondition.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureCondition-class.R,\",  #>             \"\\n\", \"%   R/protected_api-journal.R\", \"\\n\", list( #>                 \"FutureCondition\"), \"\\n\", list(\"FutureCondition\"),  #>             \"\\n\", list(\"FutureMessage\"), \"\\n\", list(\"FutureWarning\"),  #>             \"\\n\", list(\"FutureError\"), \"\\n\", list(\"RngFutureCondition\"),  #>             \"\\n\", list(\"RngFutureWarning\"), \"\\n\", list(\"RngFutureError\"),  #>             \"\\n\", list(\"UnexpectedFutureResultError\"), \"\\n\",  #>             list(\"GlobalEnvMisuseFutureCondition\"), \"\\n\", list( #>                 \"GlobalEnvMisuseFutureWarning\"), \"\\n\", list(\"GlobalEnvMisuseFutureError\"),  #>             \"\\n\", list(\"ConnectionMisuseFutureCondition\"), \"\\n\",  #>             list(\"ConnectionMisuseFutureWarning\"), \"\\n\", list( #>                 \"ConnectionMisuseFutureError\"), \"\\n\", list(\"FutureInterruptError\"),  #>             \"\\n\", list(\"FutureDroppedError\"), \"\\n\", list(\"FutureJournalCondition\"),  #>             \"\\n\", list(\"A condition (message, warning, or error) that occurred while orchestrating a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureCondition(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"FutureMessage(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"FutureWarning(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"FutureError(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"RngFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\", \"\\n\", \"RngFutureWarning(...)\\n\",  #>                 \"\\n\", \"RngFutureError(...)\\n\", \"\\n\", \"UnexpectedFutureResultError(future, hint = NULL)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  globalenv = globalenv,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"GlobalEnvMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"ConnectionMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"ConnectionMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"ConnectionMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"FutureInterruptError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureDroppedError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureJournalCondition(\\n\", \"  message,\\n\",  #>                 \"  journal,\\n\", \"  call = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\"), \"\\n\", list(\"\\n\",  #>                 list(list(\"message\"), list(\"A message condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"call\"), list(\"The call stack that led up to the condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"uuid\"), list(\"A universally unique identifier for the future associated with\\n\",  #>                   \"this FutureCondition.\")), \"\\n\", \"\\n\", list( #>                   list(\"future\"), list(\"The \", list(\"Future\"),  #>                     \" involved.\")), \"\\n\", \"\\n\", list(list(\"hint\"),  #>                   list(\"(optional) A string with a suggestion on what might be wrong.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureCondition which inherits from class\\n\",  #>                 list(\"condition\"), \" and FutureMessage, FutureWarning,\\n\",  #>                 \"and FutureError all inherits from FutureCondition.\\n\",  #>                 \"Moreover, a FutureError inherits from \", list( #>                   \"error\"), \",\\n\", \"a FutureWarning from \", list( #>                   \"warning\"), \", and\\n\", \"a FutureMessage from \",  #>                 list(\"message\"), \".\\n\"), \"\\n\", list(\"\\n\", \"While \",  #>                 list(\"orchestrating\"), \" (creating, launching, querying, collection)\\n\",  #>                 \"futures, unexpected run-time errors (and other types of conditions) may\\n\",  #>                 \"occur.  Such conditions are coerced to a corresponding FutureCondition\\n\",  #>                 \"class to help distinguish them from conditions that occur due to the\\n\",  #>                 list(\"evaluation\"), \" of the future.\\n\"), \"\\n\",  #>             list(\"internal\"), \"\\n\"), FutureGlobals.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureGlobals-class.R\",  #>             \"\\n\", list(\"FutureGlobals\"), \"\\n\", list(\"FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals\"), \"\\n\", list(\"as.FutureGlobals.FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals.Globals\"), \"\\n\", list( #>                 \"as.FutureGlobals.list\"), \"\\n\", list(\"[.FutureGlobals\"),  #>             \"\\n\", list(\"c.FutureGlobals\"), \"\\n\", list(\"unique.FutureGlobals\"),  #>             \"\\n\", list(\"A representation of a set of globals used with futures\"),  #>             \"\\n\", list(\"\\n\", \"FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"A named list.\")),  #>                 \"\\n\", \"\\n\", list(list(\"resolved\"), list(\"A logical indicating whether these globals\\n\",  #>                   \"have been scanned for and resolved futures or not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"total_size\"), list(\"The total size of all globals, if known.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class \",  #>                 list(\"FutureGlobals\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A representation of a set of globals used with futures\\n\"),  #>             \"\\n\", list(\"\\n\", \"This class extends the \", list( #>                 \"Globals\"), \" class by adding\\n\", \"attributes \",  #>                 list(\"resolved\"), \" and \", list(\"total_size\"),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureResult.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureResult-class.R\",  #>             \"\\n\", list(\"FutureResult\"), \"\\n\", list(\"FutureResult\"),  #>             \"\\n\", list(\"as.character.FutureResult\"), \"\\n\", list( #>                 \"print.FutureResult\"), \"\\n\", list(\"Results from resolving a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureResult(\\n\", \"  value = NULL,\\n\",  #>                 \"  visible = TRUE,\\n\", \"  stdout = NULL,\\n\",  #>                 \"  conditions = NULL,\\n\", \"  rng = FALSE,\\n\",  #>                 \"  ...,\\n\", \"  started = .POSIXct(NA_real_),\\n\",  #>                 \"  finished = Sys.time(),\\n\", \"  version = \\\"1.8\\\"\\n\",  #>                 \")\\n\", \"\\n\", list(list(\"as.character\"), list( #>                   \"FutureResult\")), \"(x, ...)\\n\", \"\\n\", list( #>                   list(\"print\"), list(\"FutureResult\")), \"(x, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"value\"), list(\"The value of the future expression.\\n\",  #>                 \"If the expression was not fully resolved (e.g. an error) occurred,\\n\",  #>                 \"the the value is \", list(\"NULL\"), \".\")), \"\\n\",  #>                 \"\\n\", list(list(\"visible\"), list(\"If TRUE, the value was visible, otherwise invisible.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A list of zero or more list elements each containing\\n\",  #>                   \"a captured \", list(\"condition\"), \" and possibly more meta data such as the\\n\",  #>                   \"call stack and a timestamp.\")), \"\\n\", \"\\n\",  #>                 list(list(\"rng\"), list(\"If TRUE, the \", list( #>                   \".Random.seed\"), \" was updated from resolving the\\n\",  #>                   \"future, otherwise not.\")), \"\\n\", \"\\n\", list( #>                   list(\"started, finished\"), list(list(\"POSIXct\"),  #>                     \" timestamps\\n\", \"when the evaluation of the future expression was started and finished.\")),  #>                 \"\\n\", \"\\n\", list(list(\"version\"), list(\"The version format of the results.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional named results to be returned.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureResult.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Results from resolving a future\\n\"),  #>             \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                 list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                 list(\"not\"), \" part of the frontend Future API.\\n\"),  #>             \"\\n\", list(list(\"Note to developers\"), list(\"\\n\",  #>                 \"\\n\", \"The FutureResult structure is \", list( #>                   \"under development\"), \" and may change at anytime,\\n\",  #>                 \"e.g. elements may be renamed or removed.  Because of this, please avoid\\n\",  #>                 \"accessing the elements directly in code.  Feel free to reach out if you need\\n\",  #>                 \"to do so in your code.\\n\")), \"\\n\", \"\\n\", list( #>                 \"internal\"), \"\\n\"), `MulticoreFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>             \"\\n\", list(\"MulticoreFuture-class\"), \"\\n\", list(\"MulticoreFuture-class\"),  #>             \"\\n\", list(\"resolved.MulticoreFuture\"), \"\\n\", list( #>                 \"A multicore future is a future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", list(list(\"resolved\"), list(\"MulticoreFuture\")),  #>                 \"(x, run = TRUE, timeout = NULL, ...)\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"MulticoreFuture()\"), \" returns an object of class \",  #>                 list(\"MulticoreFuture\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A multicore future is a future whose value will be resolved asynchronously in a parallel process\\n\"),  #>             \"\\n\", list(list(\"Usage\"), list(\"\\n\", \"\\n\", \"To use 'multicore' futures, use \",  #>                 list(\"plan(multicore, ...)\"), \", cf. \", list( #>                   \"multicore\"), \".\\n\")), \"\\n\", \"\\n\", list(\"internal\"),  #>             \"\\n\"), `MultiprocessFuture-class.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-MultiprocessFutureBackend-class.R\",  #>             \"\\n\", list(\"MultiprocessFuture-class\"), \"\\n\", list( #>                 \"MultiprocessFuture-class\"), \"\\n\", list(\"MultiprocessFuture\"),  #>             \"\\n\", list(\"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", \"MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":ed, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"MultiprocessFuture()\"), \" returns an object of class \",  #>                 list(\"MultiprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), `UniprocessFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-UniprocessFuture-class.R\",  #>             \"\\n\", list(\"UniprocessFuture-class\"), \"\\n\", list( #>                 \"UniprocessFuture-class\"), \"\\n\", list(\"UniprocessFuture\"),  #>             \"\\n\", list(\"An uniprocess future is a future whose value will be resolved synchronously in the current process\"),  #>             \"\\n\", list(\"\\n\", \"UniprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":ed, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"UniprocessFuture()\"), \" returns an object of class \",  #>                 list(\"UniprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"An uniprocess future is a future whose value will be resolved synchronously in the current process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), backtrace.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/utils_api-backtrace.R\",  #>             \"\\n\", list(\"backtrace\"), \"\\n\", list(\"backtrace\"),  #>             \"\\n\", list(\"Back trace the expressions evaluated when an error was caught\"),  #>             \"\\n\", list(\"\\n\", \"backtrace(future, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A future with a caught error.\")),  #>                 \"\\n\", \"\\n\", list(list(\"envir\"), list(\"the environment where to locate the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"A list with the future's call stack that led up to the error.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Back trace the expressions evaluated when an error was caught\\n\"),  #>             \"\\n\", list(\"\\n\", \"my_log <- function(x) log(x)\\n\",  #>                 \"foo <- function(...) my_log(...)\\n\", \"\\n\", \"f <- future({ foo(\\\"a\\\") })\\n\",  #>                 \"res <- tryCatch({\\n\", \"  v <- value(f)\\n\", \"}, error = function(ex) {\\n\",  #>                 \"  t <- backtrace(f)\\n\", \"  print(t)\\n\", \"})\\n\",  #>                 list(\"\\n\", \"## R CMD check: make sure any open connections are closed afterward\\n\",  #>                   \"if (!inherits(plan(\\\"next\\\"), \\\"sequential\\\")) plan(sequential)\\n\"),  #>                 \"\\n\", \"\\n\"), \"\\n\"), cluster.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-ClusterFutureBackend-class.R\",  #>             \"\\n\", list(\"cluster\"), \"\\n\", list(\"cluster\"), \"\\n\",  #>             list(\"Create a cluster future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", \"cluster(\\n\", \"  ...,\\n\", \"  persistent = FALSE,\\n\",  #>                 \"  workers = availableWorkers(),\\n\", \"  gc = FALSE,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  envir = parent.frame()\\n\",  #>                 \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"persistent\"),  #>                 list(\"If FALSE, the evaluation environment is cleared\\n\",  #>                   \"from objects prior to the evaluation of the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"workers\"), list(\"A \",  #>                   list(list(\"cluster\")), \" object,\\n\", \"a character vector of host names, a positive numeric scalar,\\n\",  #>                   \"or a function.\\n\", \"If a character vector or a numeric scalar, a \",  #>                   list(\"cluster\"), \" object\\n\", \"is created using \",  #>                   list(list(\"makeClusterPSOCK\"), \"(workers)\"),  #>                   \".\\n\", \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\\n\",  #>                   \"The function should return any of the above types.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", \"A ClusterFuture.\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A cluster future is a future that uses cluster evaluation,\\n\",  #>                 \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                   \"parallel in another process\"), \".\\n\"), \"\\n\",  #>             list(\"\\n\", \"This function is \", list(\"not\"), \" meant to be called directly.  Instead, the\\n\",  #>                 \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                   list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                 list(\"# Evaluate futures via a single background R process on the local machine\\n\",  #>                   \"plan(cluster, workers = 1)\\n\", \"\\n\", \"# Evaluate futures via two background R processes on the local machine\\n\",  #>                   \"plan(cluster, workers = 2)\\n\", \"\\n\", \"# Evaluate futures via a single R process on another machine on on the\\n\",  #>                   \"# local area network (LAN)\\n\", \"plan(cluster, workers = \\\"raspberry-pi\\\")\\n\",  #>                   \"\\n\", \"# Evaluate futures via a single R process running on a remote machine\\n\",  #>                   \"plan(cluster, workers = \\\"pi.example.org\\\")\\n\",  #>                   \"\\n\", \"# Evaluate futures via four R processes, one running on the local machine,\\n\",  #>                   \"# two running on LAN machine 'n1' and one on a remote machine\\n\",  #>                   \"plan(cluster, workers = c(\\\"localhost\\\", \\\"n1\\\", \\\"n1\\\", \\\"pi.example.org\\\"))\\n\"),  #>                 list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>             \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use cluster futures\\n\",  #>                 \"cl <- parallel::makeCluster(2, timeout = 60)\\n\",  #>                 \"plan(cluster, workers = cl)\\n\", \"\\n\", \"## A global variable\\n\",  #>                 \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                 \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                 \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A cluster future is evaluated in a separate process.\\n\",  #>                 \"## Regardless, changing the value of a global variable will\\n\",  #>                 \"## not affect the result of the future.\\n\",  #>                 \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                 \"print(v)\\n\", \"stopifnot(v == 0)\\n\", \"\\n\", \"## CLEANUP\\n\",  #>                 \"parallel::stopCluster(cl)\\n\", \"\\n\"), \"\\n\"),  #>             \"\\n\"), clusterExportSticky.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>             \"\\n\", list(\"clusterExportSticky\"), \"\\n\", list(\"clusterExportSticky\"),  #>             \"\\n\", list(\"Export globals to the sticky-globals environment of the cluster nodes\"),  #>             \"\\n\", list(\"\\n\", \"clusterExportSticky(cl, globals)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"cl\"), list(\"(cluster) A cluster object as returned by\\n\",  #>                 list(list(\"parallel::makeCluster()\")), \".\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(list) A named list of sticky globals to be exported.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"(invisible; cluster) The cluster object.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Export globals to the sticky-globals environment of the cluster nodes\\n\"),  #>             \"\\n\", list(\"\\n\", \"This requires that the \", list( #>                 \"future\"), \" package is installed on the cluster\\n\",  #>                 \"nodes.\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), find_references.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/utils-marshalling.R\",  #>             \"\\n\", list(\"find_references\"), \"\\n\", list(\"find_references\"),  #>             \"\\n\", list(\"assert_no_references\"), \"\\n\", list(\"Get the first or all references of an \",  #>                 list(), \" object\"), \"\\n\", list(\"\\n\", \"find_references(x, first_only = FALSE)\\n\",  #>                 \"\\n\", \"assert_no_references(\\n\", \"  x,\\n\", \"  action = c(\\\"error\\\", \\\"warning\\\", \\\"message\\\", \\\"string\\\"),\\n\",  #>                 \"  source = c(\\\"globals\\\", \\\"value\\\")\\n\", \")\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"x\"), list(\"The \", list(),  #>                 \" object to be checked.\")), \"\\n\", \"\\n\", list( #>                 list(\"first_only\"), list(\"If \", list(\"TRUE\"),  #>                   \", only the first reference is returned,\\n\",  #>                   \"otherwise all references.\")), \"\\n\", \"\\n\",  #>                 list(list(\"action\"), list(\"Type of action to take if a reference is found.\")),  #>                 \"\\n\", \"\\n\", list(list(\"source\"), list(\"Is the source of \",  #>                   list(\"x\"), \" the globals or the value of the future?\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"find_references()\"),  #>                 \" returns a list of zero or more references\\n\",  #>                 \"identified.\\n\", \"\\n\", \"If a reference is detected, an informative error, warning, message,\\n\",  #>                 \"or a character string is produced, otherwise \",  #>                 list(\"NULL\"), \" is returned\\n\", \"invisibly.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Get the first or all references of an \",  #>                 list(), \" object\\n\", \"\\n\", \"Assert that there are no references among the identified globals\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), future.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/core_api-future.R, R/utils_api-futureCall.R,\",  #>             \"\\n\", \"%   R/utils_api-minifuture.R\", \"\\n\", list( #>                 \"future\"), \"\\n\", list(\"future\"), \"\\n\", list(\"futureCall\"),  #>             \"\\n\", list(\"minifuture\"), \"\\n\", list(\"Create a future\"),  #>             \"\\n\", list(\"\\n\", \"future(\\n\", \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                 \"  substitute = TRUE,\\n\", \"  lazy = FALSE,\\n\",  #>                 \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\", \"  packages = NULL,\\n\",  #>                 \"  stdout = TRUE,\\n\", \"  conditions = \\\"condition\\\",\\n\",  #>                 \"  label = NULL,\\n\", \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  ...\\n\", \")\\n\", \"\\n\", \"futureCall(\\n\", \"  FUN,\\n\",  #>                 \"  args = list(),\\n\", \"  envir = parent.frame(),\\n\",  #>                 \"  lazy = FALSE,\\n\", \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                 \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                 \"  conditions = \\\"condition\\\",\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  label = NULL,\\n\", \"  gc = FALSE,\\n\", \"  ...\\n\",  #>                 \")\\n\", \"\\n\", \"minifuture(\\n\", \"  expr,\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  globals = NULL,\\n\", \"  packages = NULL,\\n\",  #>                 \"  stdout = NA,\\n\", \"  conditions = NULL,\\n\",  #>                 \"  seed = NULL,\\n\", \"  ...,\\n\", \"  envir = parent.frame()\\n\",  #>                 \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"expr\"), list( #>                 \"An \", list(), \" \", list(\"expression\"), \".\")),  #>                 \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The \",  #>                   list(\"environment\"), \" from where global objects should be\\n\",  #>                   \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                   list(\"If TRUE, argument \", list(\"expr\"), \" is\\n\",  #>                     list(list(\"substitute\"), \"()\"), \":ed, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression does neither\\n\",  #>                   \"need nor use random numbers generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of conditions classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherits from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"FUN\"), list(\"A \", list(\"function\"), \" to be evaluated.\")),  #>                 \"\\n\", \"\\n\", list(list(\"args\"), list(\"A \", list( #>                   \"list\"), \" of arguments passed to function \",  #>                   list(\"FUN\"), \".\")), \"\\n\", \"\\n\", list(list(list()),  #>                   list(\"Additional arguments passed to \", list( #>                     list(\"Future()\")), \".\")), \"\\n\"), \"\\n\", list( #>                 \"\\n\", list(\"future()\"), \" returns \", list(\"Future\"),  #>                 \" that evaluates expression \", list(\"expr\"),  #>                 \".\\n\", \"\\n\", list(\"futureCall()\"), \" returns a \",  #>                 list(\"Future\"), \" that calls function \", list( #>                   \"FUN\"), \" with\\n\", \"arguments \", list(\"args\"),  #>                 \".\\n\", \"\\n\", list(\"minifuture(expr)\"), \" creates a future with minimal overhead, by disabling\\n\",  #>                 \"user-friendly behaviors, e.g. automatic identification of global\\n\",  #>                 \"variables and packages needed, and relaying of output.\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"html\"), list(list(list( #>                 \"logo.png\"), list(\"options: style='float: right;' alt='logo' width='120'\")))),  #>                 \"\\n\", \"Creates a future that evaluates an \",  #>                 list(), \" expression or\\n\", \"a future that calls an \",  #>                 list(), \" function with a set of arguments.\\n\",  #>                 \"How, when, and where these futures are evaluated can be configured\\n\",  #>                 \"using \", list(list(\"plan()\")), \" such that it is evaluated in parallel on,\\n\",  #>                 \"for instance, the current machine, on a remote machine, or via a\\n\",  #>                 \"job queue on a compute cluster.\\n\", \"Importantly, any \",  #>                 list(), \" code using futures remains the same regardless\\n\",  #>                 \"on these settings and there is no need to modify the code when\\n\",  #>                 \"switching from, say, sequential to parallel processing.\\n\"),  #>             \"\\n\", list(\"\\n\", \"The state of a future is either unresolved or resolved.\\n\",  #>                 \"The value of a future can be retrieved using \",  #>                 list(\"v <- \", list(\"value\"), \"(f)\"), \".\\n\", \"Querying the value of a non-resolved future will \",  #>                 list(\"block\"), \" the call\\n\", \"until the future is resolved.\\n\",  #>                 \"It is possible to check whether a future is resolved or not\\n\",  #>                 \"without blocking by using \", list(list(\"resolved\"),  #>                   \"(f)\"), \".\\n\", \"\\n\", \"The \", list(\"futureCall()\"),  #>                 \" function works analogously to\\n\", list(list( #>                   \"do.call\"), \"()\"), \", which calls a function with a set of\\n\",  #>                 \"arguments.  The difference is that \", list(\"do.call()\"),  #>                 \" returns the value of\\n\", \"the call whereas \",  #>                 list(\"futureCall()\"), \" returns a future.\\n\"),  #>             \"\\n\", list(list(\"Eager or lazy evaluation\"), list( #>                 \"\\n\", \"\\n\", \"By default, a future is resolved using \",  #>                 list(\"eager\"), \" evaluation\\n\", \"(\", list(\"lazy = FALSE\"),  #>                 \").  This means that the expression starts to\\n\",  #>                 \"be evaluated as soon as the future is created.\\n\",  #>                 \"\\n\", \"As an alternative, the future can be resolved using \",  #>                 list(\"lazy\"), \"\\n\", \"evaluation (\", list(\"lazy = TRUE\"),  #>                 \").  This means that the expression\\n\", \"will only be evaluated when the value of the future is requested.\\n\",  #>                 list(\"Note that this means that the expression may not be evaluated\\n\",  #>                   \"at all - it is guaranteed to be evaluated if the value is requested\"),  #>                 \".\\n\")), \"\\n\", \"\\n\", list(list(\"Globals used by future expressions\"),  #>                 list(\"\\n\", \"\\n\", \"Global objects (short \", list( #>                   \"globals\"), \") are objects (e.g. variables and\\n\",  #>                   \"functions) that are needed in order for the future expression to be\\n\",  #>                   \"evaluated while not being local objects that are defined by the future\\n\",  #>                   \"expression. For example, in\\n\", list(\"\\n\",  #>                     \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b })\\n\"),  #>                   \"\\n\", \"variable \", list(\"a\"), \" is a global of future assignment \",  #>                   list(\"f\"), \" whereas\\n\", list(\"b\"), \" is a local variable.\\n\",  #>                   \"In order for the future to be resolved successfully (and correctly),\\n\",  #>                   \"all globals need to be gathered when the future is created such that\\n\",  #>                   \"they are available whenever and wherever the future is resolved.\\n\",  #>                   \"\\n\", \"The default behavior (\", list(\"globals = TRUE\"),  #>                   \"),\\n\", \"is that globals are automatically identified and gathered.\\n\",  #>                   \"More precisely, globals are identified via code inspection of the\\n\",  #>                   \"future expression \", list(\"expr\"), \" and their values are retrieved with\\n\",  #>                   \"environment \", list(\"envir\"), \" as the starting point (basically via\\n\",  #>                   list(\"get(global, envir = envir, inherits = TRUE)\"),  #>                   \").\\n\", list(\"In most cases, such automatic collection of globals is sufficient\\n\",  #>                     \"and less tedious and error prone than if they are manually specified\"),  #>                   \".\\n\", \"\\n\", \"However, for full control, it is also possible to explicitly specify\\n\",  #>                   \"exactly which the globals are by providing their names as a character\\n\",  #>                   \"vector.\\n\", \"In the above example, we could use\\n\",  #>                   list(\"\\n\", \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b }, globals = \\\"a\\\")\\n\"),  #>                   \"\\n\", \"\\n\", \"Yet another alternative is to explicitly specify also their values\\n\",  #>                   \"using a named list as in\\n\", list(\"\\n\", \"  a <- 42\\n\",  #>                     \"  f <- future({ b <- 2; a * b }, globals = list(a = a))\\n\"),  #>                   \"\\n\", \"or\\n\", list(\"\\n\", \"  f <- future({ b <- 2; a * b }, globals = list(a = 42))\\n\"),  #>                   \"\\n\", \"\\n\", \"Specifying globals explicitly avoids the overhead added from\\n\",  #>                   \"automatically identifying the globals and gathering their values.\\n\",  #>                   \"Furthermore, if we know that the future expression does not make use\\n\",  #>                   \"of any global variables, we can disable the automatic search for\\n\",  #>                   \"globals by using\\n\", list(\"\\n\", \"  f <- future({ a <- 42; b <- 2; a * b }, globals = FALSE)\\n\"),  #>                   \"\\n\", \"\\n\", \"Future expressions often make use of functions from one or more packages.\\n\",  #>                   \"As long as these functions are part of the set of globals, the future\\n\",  #>                   \"package will make sure that those packages are attached when the future\\n\",  #>                   \"is resolved.  Because there is no need for such globals to be frozen\\n\",  #>                   \"or exported, the future package will not export them, which reduces\\n\",  #>                   \"the amount of transferred objects.\\n\", \"For example, in\\n\",  #>                   list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({ median(x) })\\n\"),  #>                   \"\\n\", \"variable \", list(\"x\"), \" and \", list( #>                     \"median()\"), \" are globals, but only \", list( #>                     \"x\"), \"\\n\", \"is exported whereas \", list( #>                     \"median()\"), \", which is part of the \", list( #>                     \"stats\"), \"\\n\", \"package, is not exported.  Instead it is made sure that the \",  #>                   list(\"stats\"), \"\\n\", \"package is on the search path when the future expression is evaluated.\\n\",  #>                   \"Effectively, the above becomes\\n\", list(\"\\n\",  #>                     \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                     \"    library(stats)\\n\", \"    median(x)\\n\",  #>                     \"  })\\n\"), \"\\n\", \"To manually specify this, one can either do\\n\",  #>                   list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                     \"    median(x)\\n\", \"  }, globals = list(x = x, median = stats::median)\\n\"),  #>                   \"\\n\", \"or\\n\", list(\"\\n\", \"  x <- rnorm(1000)\\n\",  #>                     \"  f <- future({\\n\", \"    library(stats)\\n\",  #>                     \"    median(x)\\n\", \"  }, globals = list(x = x))\\n\"),  #>                   \"\\n\", \"Both are effectively the same.\\n\", \"\\n\",  #>                   \"Although rarely needed, a combination of automatic identification and manual\\n\",  #>                   \"specification of globals is supported via attributes \",  #>                   list(\"add\"), \" (to add\\n\", \"false negatives) and \",  #>                   list(\"ignore\"), \" (to ignore false positives) on value\\n\",  #>                   list(\"TRUE\"), \".  For example, with\\n\", list( #>                     \"globals = structure(TRUE, ignore = \\\"b\\\", add = \\\"a\\\")\"),  #>                   \" any globals\\n\", \"automatically identified except \",  #>                   list(\"b\"), \" will be used in addition to\\n\",  #>                   \"global \", list(\"a\"), \".\\n\")), \"\\n\", \"\\n\",  #>             list(\"\\n\", \"## Evaluate futures in parallel\\n\", \"plan(multisession)\\n\",  #>                 \"\\n\", \"## Data\\n\", \"x <- rnorm(100)\\n\", \"y <- 2 * x + 0.2 + rnorm(100)\\n\",  #>                 \"w <- 1 + x ^ 2\\n\", \"\\n\", \"\\n\", \"## EXAMPLE: Regular assignments (evaluated sequentially)\\n\",  #>                 \"fitA <- lm(y ~ x, weights = w)      ## with offset\\n\",  #>                 \"fitB <- lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                 \"fitC <- {\\n\", \"  w <- 1 + abs(x)  ## Different weights\\n\",  #>                 \"  lm(y ~ x, weights = w)\\n\", \"}\\n\", \"print(fitA)\\n\",  #>                 \"print(fitB)\\n\", \"print(fitC)\\n\", \"\\n\", \"\\n\",  #>                 \"## EXAMPLE: Future assignments (evaluated in parallel)\\n\",  #>                 \"fitA %<-% lm(y ~ x, weights = w)      ## with offset\\n\",  #>                 \"fitB %<-% lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                 \"fitC %<-% {\\n\", \"  w <- 1 + abs(x)\\n\", \"  lm(y ~ x, weights = w)\\n\",  #>                 \"}\\n\", \"print(fitA)\\n\", \"print(fitB)\\n\", \"print(fitC)\\n\",  #>                 \"\\n\", \"\\n\", \"## EXAMPLE: Explicitly create futures (evaluated in parallel)\\n\",  #>                 \"## and retrieve their values\\n\", \"fA <- future( lm(y ~ x, weights = w) )\\n\",  #>                 \"fB <- future( lm(y ~ x - 1, weights = w) )\\n\",  #>                 \"fC <- future({\\n\", \"  w <- 1 + abs(x)\\n\", \"  lm(y ~ x, weights = w)\\n\",  #>                 \"})\\n\", \"fitA <- value(fA)\\n\", \"fitB <- value(fB)\\n\",  #>                 \"fitC <- value(fC)\\n\", \"print(fitA)\\n\", \"print(fitB)\\n\",  #>                 \"print(fitC)\\n\", \"\\n\", list(\"\\n\", \"## Make sure to \\\"close\\\" an multisession workers on Windows\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\", \"## EXAMPLE: futureCall() and do.call()\\n\",  #>                 \"x <- 1:100\\n\", \"y0 <- do.call(sum, args = list(x))\\n\",  #>                 \"print(y0)\\n\", \"\\n\", \"f1 <- futureCall(sum, args = list(x))\\n\",  #>                 \"y1 <- value(f1)\\n\", \"print(y1)\\n\"), \"\\n\", list( #>                 \"\\n\", \"How, when and where futures are resolved is given by the\\n\",  #>                 list(\"future strategy\"), \", which can be set by the end user using the\\n\",  #>                 list(list(\"plan()\")), \" function.  The future strategy must not be\\n\",  #>                 \"set by the developer, e.g. it must not be called within a package.\\n\"),  #>             \"\\n\", list(\"\\n\", \"The future logo was designed by Dan LaBar and tweaked by Henrik Bengtsson.\\n\"),  #>             \"\\n\"), futureAssign.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/delayed_api-futureAssign.R,\",  #>             \"\\n\", \"%   R/infix_api-01-futureAssign_OP.R, R/infix_api-02-globals_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-03-seed_OP.R, R/infix_api-04-stdout_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-05-conditions_OP.R, R/infix_api-06-lazy_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-07-label_OP.R, R/infix_api-08-plan_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-09-tweak_OP.R\", \"\\n\", list( #>                 \"futureAssign\"), \"\\n\", list(\"futureAssign\"),  #>             \"\\n\", list(\"%<-%\"), \"\\n\", list(\"%->%\"), \"\\n\", list( #>                 \"%globals%\"), \"\\n\", list(\"%packages%\"), \"\\n\",  #>             list(\"%seed%\"), \"\\n\", list(\"%stdout%\"), \"\\n\", list( #>                 \"%conditions%\"), \"\\n\", list(\"%lazy%\"), \"\\n\",  #>             list(\"%label%\"), \"\\n\", list(\"%plan%\"), \"\\n\", list( #>                 \"%tweak%\"), \"\\n\", list(\"Create a future assignment\"),  #>             \"\\n\", list(\"\\n\", \"futureAssign(\\n\", \"  x,\\n\", \"  value,\\n\",  #>                 \"  envir = parent.frame(),\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  lazy = FALSE,\\n\", \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                 \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                 \"  conditions = \\\"condition\\\",\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  label = NULL,\\n\", \"  gc = FALSE,\\n\", \"  ...,\\n\",  #>                 \"  assign.env = envir\\n\", \")\\n\", \"\\n\", \"x %<-% value\\n\",  #>                 \"\\n\", \"fassignment %globals% globals\\n\", \"fassignment %packages% packages\\n\",  #>                 \"\\n\", \"fassignment %seed% seed\\n\", \"\\n\", \"fassignment %stdout% capture\\n\",  #>                 \"\\n\", \"fassignment %conditions% capture\\n\", \"\\n\",  #>                 \"fassignment %lazy% lazy\\n\", \"\\n\", \"fassignment %label% label\\n\",  #>                 \"\\n\", \"fassignment %plan% strategy\\n\", \"\\n\",  #>                 \"fassignment %tweak% tweaks\\n\"), \"\\n\", list(\"\\n\",  #>                 list(list(\"x\"), list(\"the name of a future variable, which will hold the value\\n\",  #>                   \"of the future expression (as a promise).\")),  #>                 \"\\n\", \"\\n\", list(list(\"value\"), list(\"An \", list(),  #>                   \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":ed, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression does neither\\n\",  #>                   \"need nor use random numbers generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of conditions classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherits from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"assign.env\"), list(\"The \",  #>                   list(\"environment\"), \" to which the variable\\n\",  #>                   \"should be assigned.\")), \"\\n\", \"\\n\", list(list( #>                   \"fassignment\"), list(\"The future assignment, e.g.\\n\",  #>                   list(\"x %<-% { expr }\"), \".\")), \"\\n\", \"\\n\",  #>                 list(list(\"capture\"), list(\"If TRUE, the standard output will be captured, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"strategy\"), list(\"The mechanism for how the future should be\\n\",  #>                   \"resolved. See \", list(list(\"plan()\")), \" for further details.\")),  #>                 \"\\n\", \"\\n\", list(list(\"tweaks\"), list(\"A named list (or vector) with arguments that\\n\",  #>                   \"should be changed relative to the current strategy.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional arguments passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"futureAssign()\"), \" and \", list( #>                 \"x %<-% expr\"), \" returns the \", list(\"Future\"),  #>                 \" invisibly,\\n\", \"e.g. \", list(\"f <- futureAssign(\\\"x\\\", expr)\"),  #>                 \" and \", list(\"f <- (x %<-% expr)\"), \".\\n\"),  #>             \"\\n\", list(\"\\n\", list(\"x %<-% value\"), \" (also known as a \\\"future assignment\\\") and\\n\",  #>                 list(\"futureAssign(\\\"x\\\", value)\"), \" create a \",  #>                 list(\"Future\"), \" that evaluates the expression\\n\",  #>                 \"(\", list(\"value\"), \") and binds it to variable \",  #>                 list(\"x\"), \" (as a\\n\", list(\"promise\"), \"). The expression is evaluated in parallel\\n\",  #>                 \"in the background. Later on, when \", list(\"x\"),  #>                 \" is first queried, the value of future\\n\", \"is automatically retrieved as it were a regular variable and \",  #>                 list(\"x\"), \" is\\n\", \"materialized as a regular value.\\n\"),  #>             \"\\n\", list(\"\\n\", \"For a future created via a future assignment, \",  #>                 list(\"x %<-% value\"), \" or\\n\", list(\"futureAssign(\\\"x\\\", value)\"),  #>                 \", the value is bound to a promise, which when\\n\",  #>                 \"queried will internally call \", list(list(\"value()\")),  #>                 \"  on the future and which will then\\n\", \"be resolved into a regular variable bound to that value. For example, with\\n\",  #>                 \"future assignment \", list(\"x %<-% value\"), \", the first time variable \",  #>                 list(\"x\"), \" is queried\\n\", \"the call blocks if, and only if, the future is not yet resolved. As soon\\n\",  #>                 \"as it is resolved, and any succeeding queries, querying \",  #>                 list(\"x\"), \" will\\n\", \"immediately give the value.\\n\",  #>                 \"\\n\", \"The future assignment construct \", list( #>                   \"x %<-% value\"), \" is not a formal assignment\\n\",  #>                 \"per se, but a binary infix operator on objects \",  #>                 list(\"x\"), \" and expression \", list(\"value\"),  #>                 \".\\n\", \"However, by using non-standard evaluation, this constructs can emulate an\\n\",  #>                 \"assignment operator similar to \", list(\"x <- value\"),  #>                 \". Due to \", list(), \"'s precedence rules\\n\",  #>                 \"of operators, future expressions often need to be explicitly bracketed,\\n\",  #>                 \"e.g. \", list(\"x %<-% { a + b }\"), \".\\n\"), \"\\n\",  #>             list(list(\"Adjust future arguments of a future assignment\"),  #>                 list(\"\\n\", \"\\n\", \"\\n\", list(list(\"future()\")),  #>                   \" and \", list(list(\"futureAssign()\")), \" take serveral arguments that can be used\\n\",  #>                   \"to explicitly specify what global variables and packages the future should\\n\",  #>                   \"use. They can also be used to override default behaviors of the future,\\n\",  #>                   \"e.g. whether output should be relayed or not. When using a future\\n\",  #>                   \"assignment, these arguments can be specified via corresponding\\n\",  #>                   \"assignment expression.  For example, \", list( #>                     \"x %<-% { rnorm(10) } %seed% TRUE\"), \"\\n\",  #>                   \"corresponds to \", list(\"futureAssign(\\\"x\\\", { rnorm(10) }, seed = TRUE)\"),  #>                   \". Here are\\n\", \"a several examples.\\n\", \"\\n\",  #>                   \"To explicitly specify variables and functions that a future assignment\\n\",  #>                   \"should use, use \", list(\"%globals%\"), \". To explicitly specify which packages need\\n\",  #>                   \"to be attacheed for the evaluate to success, use \",  #>                   list(\"%packages%\"), \". For\\n\", \"example,\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x <- rnorm(1000)\\n\", \"> y %<-% { median(x) } %globals% list(x = x) %packages% \\\"stats\\\"\\n\",  #>                     \"> y\\n\", \"[1] -0.03956372\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"The \", list(\"median()\"), \" function is part of the 'stats' package.\\n\",  #>                   \"\\n\", \"To declare that you will generate random numbers, use \",  #>                   list(\"%seed%\"), \", e.g.\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { rnorm(3) } %seed% TRUE\\n\",  #>                     \"> x\\n\", \"[1] -0.2590562 -1.2262495  0.8858702\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"To disable relaying of standard output (e.g. \",  #>                   list(\"print()\"), \", \", list(\"cat()\"), \", and\\n\",  #>                   list(\"str()\"), \"), while keeping relaying of conditions (e.g. \",  #>                   list(\"message()\"), \" and\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %stdout% FALSE\\n\",  #>                     \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hi there\\n\",  #>                     \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To disable relaying of conditions, use \",  #>                   list(\"%conditions%\"), \", e.g.\\n\", \"\\n\", list( #>                     list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %conditions% character(0)\\n\",  #>                     \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                     \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { print(1:10); message(\\\"Hello\\\"); 42 } %stdout% FALSE\\n\",  #>                     \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                     \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To create a future without launching in such that it will only be\\n\",  #>                   \"processed if the value is really needed, use \",  #>                   list(\"%lazy%\"), \", e.g.\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { Sys.sleep(5); 42 } %lazy% TRUE\\n\",  #>                     \"> y <- sum(1:10)\\n\", \"> system.time(z <- x + y)\\n\",  #>                     \"  user  system elapsed \\n\", \"  0.004   0.000   5.008\\n\",  #>                     \"> z\\n\", \"[1] 97\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\")), \"\\n\", \"\\n\",  #>             list(list(\"Error handling\"), list(\"\\n\", \"\\n\", \"\\n\",  #>                 \"Because future assignments are promises, errors produced by the the\\n\",  #>                 \"future expression will not be signaled until the value of the future is\\n\",  #>                 \"requested. For example, if you create a future assignment that produce\\n\",  #>                 \"an error, you will not be affected by the error until you \\\"touch\\\" the\\n\",  #>                 \"future-assignment variable. For example,\\n\",  #>                 \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                 list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> y <- sum(1:10)\\n\",  #>                   \"> z <- x + y\\n\", \"Error in eval(quote({ : boom\\n\"),  #>                 list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\")),  #>             \"\\n\", \"\\n\", list(list(\"Use alternative future backend for future assignment\"),  #>                 list(\"\\n\", \"\\n\", \"\\n\", \"Futures are evaluated on the future backend that the user has specified\\n\",  #>                   \"by \", list(list(\"plan()\")), \". With regular futures, we can temporarily use another future\\n\",  #>                   \"backend by wrapping our code in \", list(\"[withPlan()]\"),  #>                   \", of temporarily inside a\\n\", \"function using \",  #>                   list(\"[localPlan()]\"), \". To achieve the same for a specific\\n\",  #>                   \"future assignment, use \", list(\"%plan%\"),  #>                   \", e.g.\\n\", \"\\n\", list(list(\"html\"), list(list( #>                     \"<div class=\\\"sourceCode\\\">\"))), list(\"> plan(multisession)\\n\",  #>                     \"> x %<-% { 42 }\\n\", \"> y %<-% { 13 } %plan% sequential\\n\",  #>                     \"> z <- x + y\\n\", \"> z\\n\", \"[1] 55\\n\"), list( #>                     list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"Here \", list(\"x\"), \" is resolved in the background via the \",  #>                   list(\"multisession\"), \" backend,\\n\", \"whereas \",  #>                   list(\"y\"), \" is resolved sequentially in the main R session.\\n\")),  #>             \"\\n\", \"\\n\", list(list(\"Getting the future object of a future assignment\"),  #>                 list(\"\\n\", \"\\n\", \"\\n\", \"The underlying \", list( #>                   \"Future\"), \" of a future variable \", list(\"x\"),  #>                   \" can be retrieved without\\n\", \"blocking using \",  #>                   list(\"f <- \", list(\"futureOf\"), \"(x)\"), \", e.g.\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> f_x <- futureOf(x)\\n\",  #>                     \"> resolved(f_x)\\n\", \"[1] TRUE\\n\", \"> x\\n\",  #>                     \"Error in eval(quote({ : boom\\n\", \"> value(f_x)\\n\",  #>                     \"Error in eval(quote({ : boom\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"Technically, both the future and the variable (promise) are assigned at\\n\",  #>                   \"the same time to environment \", list(\"assign.env\"),  #>                   \" where the name of the future is\\n\", list( #>                     \".future_<name>\"), \".\\n\")), \"\\n\", \"\\n\"),  #>             futureOf.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/delayed_api-futureOf.R\",  #>                 \"\\n\", list(\"futureOf\"), \"\\n\", list(\"futureOf\"),  #>                 \"\\n\", list(\"Get the future of a future variable\"),  #>                 \"\\n\", list(\"\\n\", \"futureOf(\\n\", \"  var = NULL,\\n\",  #>                   \"  envir = parent.frame(),\\n\", \"  mustExist = TRUE,\\n\",  #>                   \"  default = NA,\\n\", \"  drop = FALSE\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"var\"), list(\"the variable.  If NULL, all futures in the\\n\",  #>                   \"environment are returned.\")), \"\\n\", \"\\n\",  #>                   list(list(\"envir\"), list(\"the environment where to search from.\")),  #>                   \"\\n\", \"\\n\", list(list(\"mustExist\"), list(\"If TRUE and the variable does not exists, then\\n\",  #>                     \"an informative error is thrown, otherwise NA is returned.\")),  #>                   \"\\n\", \"\\n\", list(list(\"default\"), list(\"the default value if future was not found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"if TRUE and \",  #>                     list(\"var\"), \" is NULL, then returned list\\n\",  #>                     \"only contains futures, otherwise also \",  #>                     list(\"default\"), \" values.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \" (or \", list( #>                   \"default\"), \").\\n\", \"If \", list(\"var\"), \" is NULL, then a named list of Future:s are returned.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Get the future of a future variable that has been created directly\\n\",  #>                   \"or indirectly via \", list(list(\"future()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"a %<-% { 1 }\\n\",  #>                   \"\\n\", \"f <- futureOf(a)\\n\", \"print(f)\\n\", \"\\n\",  #>                   \"b %<-% { 2 }\\n\", \"\\n\", \"f <- futureOf(b)\\n\",  #>                   \"print(f)\\n\", \"\\n\", \"## All futures\\n\", \"fs <- futureOf()\\n\",  #>                   \"print(fs)\\n\", \"\\n\", \"\\n\", \"## Futures part of environment\\n\",  #>                   \"env <- new.env()\\n\", \"env$c %<-% { 3 }\\n\",  #>                   \"\\n\", \"f <- futureOf(env$c)\\n\", \"print(f)\\n\",  #>                   \"\\n\", \"f2 <- futureOf(c, envir = env)\\n\", \"print(f2)\\n\",  #>                   \"\\n\", \"f3 <- futureOf(\\\"c\\\", envir = env)\\n\",  #>                   \"print(f3)\\n\", \"\\n\", \"fs <- futureOf(envir = env)\\n\",  #>                   \"print(fs)\\n\"), \"\\n\"), futureSessionInfo.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-futureSessionInfo.R\",  #>                 \"\\n\", list(\"futureSessionInfo\"), \"\\n\", list(\"futureSessionInfo\"),  #>                 \"\\n\", list(\"Get future-specific session information and validate current backend\"),  #>                 \"\\n\", list(\"\\n\", \"futureSessionInfo(test = TRUE, anonymize = TRUE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"test\"), list(\"If TRUE, one or more futures are created to query workers\\n\",  #>                   \"and validate their information.\")), \"\\n\",  #>                   \"\\n\", list(list(\"anonymize\"), list(\"If TRUE, user names and host names are anonymized.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Nothing.\\n\"), \"\\n\",  #>                 list(\"\\n\", \"Get future-specific session information and validate current backend\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession, workers = 2)\\n\",  #>                   \"futureSessionInfo()\\n\", \"plan(sequential)\\n\"),  #>                 \"\\n\"), futures.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-futures.R\",  #>                 \"\\n\", list(\"futures\"), \"\\n\", list(\"futures\"),  #>                 \"\\n\", list(\"Get all futures in a container\"),  #>                 \"\\n\", list(\"\\n\", \"futures(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"An environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"An object of same type as \",  #>                   list(\"x\"), \" and with the same names\\n\", \"and/or dimensions, if set.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets all futures in an environment, a list, or a list environment\\n\",  #>                   \"and returns an object of the same class (and dimensions).\\n\",  #>                   \"Non-future elements are returned as is.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is useful for retrieve futures that were created via\\n\",  #>                   \"future assignments (\", list(\"%<-%\"), \") and therefore stored as promises.\\n\",  #>                   \"This function turns such promises into standard \",  #>                   list(\"Future\"), \"\\n\", \"objects.\\n\"), \"\\n\"),  #>             getExpression.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"getExpression\"), \"\\n\", list(\"getExpression\"),  #>                 \"\\n\", list(\"getExpression.Future\"), \"\\n\", list( #>                   \"Inject code for the next type of future to use for nested futures\"),  #>                 \"\\n\", list(\"\\n\", \"getExpression(future, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"Current future.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A future expression with code injected to set what\\n\",  #>                   \"type of future to use for nested futures, iff any.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Inject code for the next type of future to use for nested futures\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If no next future strategy is specified, the default is to\\n\",  #>                   \"use \", list(\"sequential\"), \" futures.  This conservative approach protects\\n\",  #>                   \"against spawning off recursive futures by mistake, especially\\n\",  #>                   list(\"multicore\"), \" and \", list(\"multisession\"),  #>                   \" ones.\\n\", \"The default will also set \", list( #>                     \"options(mc.cores = 1L)\"), \" (*) so that\\n\",  #>                   \"no parallel \", list(), \" processes are spawned off by functions such as\\n\",  #>                   list(\"parallel::mclapply()\"), \" and friends.\\n\",  #>                   \"\\n\", \"Currently it is not possible to specify what type of nested\\n\",  #>                   \"futures to be used, meaning the above default will always be\\n\",  #>                   \"used.\\n\", \"See \", list(list(\"https://github.com/futureverse/future/issues/37\"),  #>                     list(\"Issue #37\")), \"\\n\", \"for plans on adding support for custom nested future types.\\n\",  #>                   \"\\n\", \"(*) Ideally we would set \", list(\"mc.cores = 0\"),  #>                   \" but that will unfortunately\\n\", \"cause \",  #>                   list(\"mclapply()\"), \" and friends to generate an error saying\\n\",  #>                   \"\\\"'mc.cores' must be >= 1\\\".  Ideally those functions should\\n\",  #>                   \"fall back to using the non-multicore alternative in this\\n\",  #>                   \"case, e.g. \", list(\"mclapply(...)\"), \" => \",  #>                   list(\"lapply(...)\"), \".\\n\", \"See \", list(\"https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7\"),  #>                   \"\\n\", \"for a discussion on this.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), getGlobalsAndPackages.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-globals.R\",  #>                 \"\\n\", list(\"getGlobalsAndPackages\"), \"\\n\", list( #>                   \"getGlobalsAndPackages\"), \"\\n\", list(\"Retrieves global variables of an expression and their associated packages\"),  #>                 \"\\n\", list(\"\\n\", \"getGlobalsAndPackages(\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  tweak = tweakExpression,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  locals = getOption(\\\"future.globals.globalsOf.locals\\\", TRUE),\\n\",  #>                   \"  resolve = getOption(\\\"future.globals.resolve\\\"),\\n\",  #>                   \"  persistent = FALSE,\\n\", \"  maxSize = getOption(\\\"future.globals.maxSize\\\", 500 * 1024^2),\\n\",  #>                   \"  onReference = getOption(\\\"future.globals.onReference\\\", \\\"ignore\\\"),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"expr\"), list(\"An \", list(), \" expression whose globals should be found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The environment from which globals should be searched.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tweak\"), list(\"(optional) A function that takes an expression and returned a modified one.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, a named list, or a \",  #>                     list(\"Globals\"), \" object.  If TRUE, globals are identified by code inspection based on \",  #>                     list(\"expr\"), \" and \", list(\"tweak\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If FALSE, no globals are used.  If a character vector, then globals are identified by lookup based their names \",  #>                     list(\"globals\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If a named list or a Globals object, the globals are used as is.\")),  #>                   \"\\n\", \"\\n\", list(list(\"locals\"), list(\"Should globals part of any \\\"local\\\" environment of\\n\",  #>                     \"a function be included or not?\")), \"\\n\",  #>                   \"\\n\", list(list(\"resolve\"), list(\"If TRUE, any future that is a global variables (or part of one) is resolved and replaced by a \\\"constant\\\" future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"persistent\"), list(\"If TRUE, non-existing globals (= identified in expression but not found in memory) are always silently ignored and assumed to be existing in the evaluation environment.  If FALSE, non-existing globals are by default ignore, but may also trigger an informative error if option \",  #>                     list(\"future.globals.onMissing\"), \" in \",  #>                     list(\"\\\"error\\\"\"), \" (should only be used for troubleshooting).\")),  #>                   \"\\n\", \"\\n\", list(list(\"maxSize\"), list(\"The maximum allowed total size (in bytes) of globals---for\\n\",  #>                     \"the purpose of preventing too large exports / transfers happening by\\n\",  #>                     \"mistake.  If the total size of the global objects are greater than this\\n\",  #>                     \"limit, an informative error message is produced. If\\n\",  #>                     list(\"maxSize = +Inf\"), \", then this assertion is skipped. (Default: 500 MiB).\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A named list with elements \",  #>                   list(\"expr\"), \" (the tweaked expression), \",  #>                   list(\"globals\"), \" (a named list of class \",  #>                   list(\"FutureGlobals\"), \") and \", list(\"packages\"),  #>                   \" (a character string).\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Retrieves global variables of an expression and their associated packages\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Internally, \", list(list(\"globalsOf\"),  #>                   \"()\"), \" is used to identify globals and associated packages from the expression.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), interrupt.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-interrupt.R\",  #>                 \"\\n\", list(\"interrupt\"), \"\\n\", list(\"interrupt\"),  #>                 \"\\n\", list(\"Interrupts a running future\"), \"\\n\",  #>                 list(\"\\n\", \"interrupt(x, ...)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"A Future.\")), \"\\n\",  #>                   \"\\n\", list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"interrupt()\"),  #>                   \" returns the \", list(\"Future\"), \" flagged as \\\"interrupted\\\",\\n\",  #>                   \"if the backend supports interrupting futures.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Attempts to interrupt a running future. If the backend does\\n\",  #>                   \"not support interrupting futures, nothing is done.\\n\"),  #>                 \"\\n\"), mandelbrot.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/demo_api-mandelbrot.R\",  #>                 \"\\n\", list(\"mandelbrot\"), \"\\n\", list(\"mandelbrot\"),  #>                 \"\\n\", list(\"as.raster.Mandelbrot\"), \"\\n\", list( #>                   \"plot.Mandelbrot\"), \"\\n\", list(\"mandelbrot_tiles\"),  #>                 \"\\n\", list(\"mandelbrot.matrix\"), \"\\n\", list(\"mandelbrot.numeric\"),  #>                 \"\\n\", list(\"Mandelbrot convergence counts\"),  #>                 \"\\n\", list(\"\\n\", \"mandelbrot(...)\\n\", \"\\n\", list( #>                   list(\"mandelbrot\"), list(\"matrix\")), \"(Z, maxIter = 200L, tau = 2, ...)\\n\",  #>                   \"\\n\", list(list(\"mandelbrot\"), list(\"numeric\")),  #>                   \"(\\n\", \"  xmid = -0.75,\\n\", \"  ymid = 0,\\n\",  #>                   \"  side = 3,\\n\", \"  resolution = 400L,\\n\",  #>                   \"  maxIter = 200L,\\n\", \"  tau = 2,\\n\", \"  ...\\n\",  #>                   \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"Z\"), list( #>                   \"A complex matrix for which convergence\\n\",  #>                   \"counts should be calculated.\")), \"\\n\", \"\\n\",  #>                   list(list(\"maxIter\"), list(\"Maximum number of iterations per bin.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tau\"), list(\"A threshold; the radius when calling\\n\",  #>                     \"divergence (Mod(z) > tau).\")), \"\\n\", \"\\n\",  #>                   list(list(\"xmid, ymid, side, resolution\"),  #>                     list(\"Alternative specification of\\n\", \"the complex plane \",  #>                       list(\"Z\"), \", where\\n\", list(\"mean(Re(Z)) == xmid\"),  #>                       \",\\n\", list(\"mean(Im(Z)) == ymid\"), \",\\n\",  #>                       list(\"diff(range(Re(Z))) == side\"), \",\\n\",  #>                       list(\"diff(range(Im(Z))) == side\"), \", and\\n\",  #>                       list(\"dim(Z) == c(resolution, resolution)\"),  #>                       \".\")), \"\\n\"), \"\\n\", list(\"\\n\", \"Returns an integer matrix (of class Mandelbrot) with\\n\",  #>                   \"non-negative counts.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Mandelbrot convergence counts\\n\"), \"\\n\", list( #>                   \"\\n\", \"counts <- mandelbrot(xmid = -0.75, ymid = 0, side = 3)\\n\",  #>                   \"str(counts)\\n\", list(\"\\n\", \"plot(counts)\\n\"),  #>                   \"\\n\", \"\\n\", list(\"\\n\", \"demo(\\\"mandelbrot\\\", package = \\\"future\\\", ask = FALSE)\\n\"),  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"The internal Mandelbrot algorithm was inspired by and\\n\",  #>                   \"adopted from similar GPL code of Martin Maechler available\\n\",  #>                   \"from ftp://stat.ethz.ch/U/maechler/R/ on 2005-02-18 (sic!).\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), multicore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"multicore\"), \"\\n\", list(\"multicore\"),  #>                 \"\\n\", list(\"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\"),  #>                 \"\\n\", list(\"\\n\", \"multicore(\\n\", \"  ...,\\n\",  #>                   \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                   \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                   \"  envir = parent.frame()\\n\", \")\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                     \"evaluated the future) only after the value of the future is collected.\\n\",  #>                     \"Exactly when the values are collected may depend on various factors such\\n\",  #>                     \"as number of free workers and whether \",  #>                     list(\"earlySignal\"), \" is TRUE (more\\n\",  #>                     \"frequently) or FALSE (less frequently).\\n\",  #>                     list(\"Some types of futures ignore this argument.\"))),  #>                   \"\\n\", \"\\n\", list(list(\"earlySignal\"), list( #>                     \"Specified whether conditions should be signaled as soon\\n\",  #>                     \"as possible or not.\")), \"\\n\", \"\\n\", list( #>                     list(\"envir\"), list(\"The \", list(\"environment\"),  #>                       \" from where global objects should be\\n\",  #>                       \"identified.\")), \"\\n\", \"\\n\", list(list( #>                     list()), list(\"Additional named elements to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \".\\n\", \"If \",  #>                   list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"sequential future. To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\\n\", \"This is also the case whenever multicore processing is not supported,\\n\",  #>                   \"e.g. on Windows.\\n\"), \"\\n\", list(\"\\n\", \"A multicore future is a future that uses multicore evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another process\"), \".\\n\"), \"\\n\",  #>                 list(\"\\n\", \"This function is \", list(\"not\"),  #>                   \" meant to be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many forked\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multicore)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two forked processes\\n\",  #>                     \"plan(multicore, workers = 2)\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\"), \"\\n\",  #>                 list(list(\"Support for forked (\\\"multicore\\\") processing\"),  #>                   list(\"\\n\", \"\\n\", \"Not all operating systems support process forking and thereby not multicore\\n\",  #>                     \"futures.  For instance, forking is not supported on Microsoft Windows.\\n\",  #>                     \"Moreover, process forking may break some R environments such as RStudio.\\n\",  #>                     \"Because of this, the future package disables process forking also in\\n\",  #>                     \"such cases.  See \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \" for details.\\n\", \"Trying to create multicore futures on non-supported systems or when\\n\",  #>                     \"forking is disabled will result in multicore futures falling back to\\n\",  #>                     \"becoming \", list(\"sequential\"), \" futures.  If used in RStudio, there will be an\\n\",  #>                     \"informative warning:\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"> plan(multicore)\\n\", \"Warning message:\\n\",  #>                       \"In supportsMulticoreAndRStudio(...) :\\n\",  #>                       \"  [ONE-TIME WARNING] Forked processing ('multicore') is not supported when\\n\",  #>                       \"running R from RStudio because it is considered unstable. For more details,\\n\",  #>                       \"how to control forked processing or not, and how to silence this warning in\\n\",  #>                       \"future R sessions, see ?parallelly::supportsMulticore\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(\"\\n\", \"## Use multicore futures\\n\",  #>                   \"plan(multicore)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multicore future is evaluated in a separate forked\\n\",  #>                   \"## process.  Changing the value of a global variable\\n\",  #>                   \"## will not affect the result of the future.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\",  #>                 list(\"\\n\", \"For processing in multiple background \",  #>                   list(), \" sessions, see\\n\", list(\"multisession\"),  #>                   \" futures.\\n\", \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\", \"Use \", list(list(\"availableCores\"),  #>                     \"(\\\"multicore\\\") > 1L\"), \" to check\\n\", \"whether multicore futures are supported or not on the current\\n\",  #>                   \"system.\\n\"), \"\\n\"), multisession.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MultisessionFutureBackend-class.R\",  #>                 \"\\n\", list(\"multisession\"), \"\\n\", list(\"multisession\"),  #>                 \"\\n\", list(\"Create a multisession future whose value will be resolved asynchronously in a parallel \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"multisession(\\n\",  #>                   \"  ...,\\n\", \"  workers = availableCores(),\\n\",  #>                   \"  lazy = FALSE,\\n\", \"  rscript_libs = .libPaths(),\\n\",  #>                   \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                   \"  envir = parent.frame()\\n\", \")\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                     \"eagerly (starting immediately), otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"rscript_libs\"), list( #>                     \"A character vector of \", list(), \" package library folders that\\n\",  #>                     \"the workers should use.  The default is \",  #>                     list(\".libPaths()\"), \" so that multisession\\n\",  #>                     \"workers inherits the same library path as the main \",  #>                     list(), \" session.\\n\", \"To avoid this, use \",  #>                     list(\"plan(multisession, ..., rscript_libs = NULL)\"),  #>                     \".\\n\", list(\"Important: Note that the library path is set on the workers when they are\\n\",  #>                       \"created, i.e. when \", list(\"plan(multisession)\"),  #>                       \" is called.  Any changes to\\n\", list(\".libPaths()\"),  #>                       \" in the main R session after the workers have been created\\n\",  #>                       \"will have no effect.\"), \"\\n\", \"This is passed down as-is to \",  #>                     list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(\"gc\"), list( #>                     \"If TRUE, the garbage collector run (in the process that\\n\",  #>                     \"evaluated the future) only after the value of the future is collected.\\n\",  #>                     \"Exactly when the values are collected may depend on various factors such\\n\",  #>                     \"as number of free workers and whether \",  #>                     list(\"earlySignal\"), \" is TRUE (more\\n\",  #>                     \"frequently) or FALSE (less frequently).\\n\",  #>                     list(\"Some types of futures ignore this argument.\"))),  #>                   \"\\n\", \"\\n\", list(list(\"earlySignal\"), list( #>                     \"Specified whether conditions should be signaled as soon\\n\",  #>                     \"as possible or not.\")), \"\\n\", \"\\n\", list( #>                     list(\"envir\"), list(\"The \", list(\"environment\"),  #>                       \" from where global objects should be\\n\",  #>                       \"identified.\")), \"\\n\", \"\\n\", list(list( #>                     list()), list(\"Additional arguments passed to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A MultisessionFuture.\\n\", \"If \",  #>                   list(\"workers == 1\"), \", then all processing is done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"lazy future.  To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", \"A multisession future is a future that uses multisession evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another \", list(), \" session\"),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"This function is \",  #>                   list(\"not\"), \" meant to be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many background\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multisession)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two background\\n\",  #>                     \"# processes\\n\", \"plan(multisession, workers = 2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"The background \", list(), \" sessions (the \\\"workers\\\") are created using\\n\",  #>                   list(list(\"makeClusterPSOCK()\")), \".\\n\", \"\\n\",  #>                   \"For the total number of\\n\", list(), \" sessions available including the current/main \",  #>                   list(), \" process, see\\n\", list(list(\"parallelly::availableCores()\")),  #>                   \".\\n\", \"\\n\", \"A multisession future is a special type of cluster future.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use multisession futures\\n\",  #>                   \"plan(multisession)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multisession future is evaluated in a separate R session.\\n\",  #>                   \"## Changing the value of a global variable will not affect\\n\",  #>                   \"## the result of the future.\\n\", \"a <- 7\\n\",  #>                   \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\", \"print(v)\\n\",  #>                   \"stopifnot(v == 0)\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\"), \"\\n\", list(\"\\n\",  #>                   \"For processing in multiple forked \", list(),  #>                   \" sessions, see\\n\", list(\"multicore\"), \" futures.\\n\",  #>                   \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\"), \"\\n\"), nbrOfWorkers.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-nbrOfWorkers.R\",  #>                 \"\\n\", list(\"nbrOfWorkers\"), \"\\n\", list(\"nbrOfWorkers\"),  #>                 \"\\n\", list(\"nbrOfFreeWorkers\"), \"\\n\", list(\"Get the number of workers available\"),  #>                 \"\\n\", list(\"\\n\", \"nbrOfWorkers(evaluator = NULL)\\n\",  #>                   \"\\n\", \"nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"evaluator\"), list( #>                   \"A future evaluator function.\\n\", \"If NULL (default), the current evaluator as returned\\n\",  #>                   \"by \", list(list(\"plan()\")), \" is used.\")),  #>                   \"\\n\", \"\\n\", list(list(\"background\"), list(\"If TRUE, only workers that can process a future in the\\n\",  #>                     \"background are considered.  If FALSE, also workers running in the main \",  #>                     list(), \"\\n\", \"process are considered, e.g. when using the 'sequential' backend.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used; reserved for future use.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"nbrOfWorkers()\"),  #>                   \" returns a positive number in \", list(list( #>                     \"{1, 2, 3, ...}\")), \", which\\n\", \"for some future backends may also be \",  #>                   list(\"+Inf\"), \".\\n\", \"\\n\", list(\"nbrOfFreeWorkers()\"),  #>                   \" returns a non-negative number in\\n\", list( #>                     list(\"{0, 1, 2, 3, ...}\")), \" which is less than or equal to \",  #>                   list(\"nbrOfWorkers()\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get the number of workers available\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession)\\n\", \"nbrOfWorkers()  ## == availableCores()\\n\",  #>                   \"\\n\", \"plan(sequential)\\n\", \"nbrOfWorkers()  ## == 1\\n\"),  #>                 \"\\n\"), nullcon.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\"nullcon\"), \"\\n\", list(\"nullcon\"),  #>                 \"\\n\", list(\"Creates a connection to the system null device\"),  #>                 \"\\n\", list(\"\\n\", \"nullcon()\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Returns a open, binary \", list(list(\"base::connection()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Creates a connection to the system null device\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), plan.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R, R/utils_api-tweak.R,\",  #>                 \"\\n\", \"%   R/utils_api-withPlan.R\", \"\\n\", list( #>                   \"plan\"), \"\\n\", list(\"plan\"), \"\\n\", list(\"tweak\"),  #>                 \"\\n\", list(\"withPlan\"), \"\\n\", list(\"localPlan\"),  #>                 \"\\n\", list(\"Plan how to resolve a future\"), \"\\n\",  #>                 list(\"\\n\", \"plan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  ...,\\n\", \"  substitute = TRUE,\\n\", \"  .skip = FALSE,\\n\",  #>                   \"  .call = TRUE,\\n\", \"  .cleanup = NA,\\n\",  #>                   \"  .init = TRUE\\n\", \")\\n\", \"\\n\", \"tweak(strategy, ..., penvir = parent.frame())\\n\",  #>                   \"\\n\", \"withPlan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  .cleanup = NA,\\n\", \"  substitute = TRUE,\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", \"localPlan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  .cleanup = NA,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  ...\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"strategy\"), list( #>                   \"An existing future function or the name of one.\")),  #>                   \"\\n\", \"\\n\", list(list(\"substitute\"), list(\"If \",  #>                     list(\"TRUE\"), \", the \", list(\"strategy\"),  #>                     \" expression is\\n\", list(\"substitute()\"),  #>                     \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\".skip\"), list(\"(internal) If \", list( #>                       \"TRUE\"), \", then attempts to set a strategy\\n\",  #>                       \"that is the same as what is currently in use, will be skipped.\")),  #>                   \"\\n\", \"\\n\", list(list(\".call\"), list(\"(internal) Used for recording the call to this function.\")),  #>                   \"\\n\", \"\\n\", list(list(\".cleanup\"), list(\"(internal) Used to stop implicitly started clusters.\")),  #>                   \"\\n\", \"\\n\", list(list(\".init\"), list(\"(internal) Used to initiate workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"penvir\"), list(\"The environment used when searching for a future\\n\",  #>                     \"function by its name.\")), \"\\n\", \"\\n\", list( #>                     list(\"expr\"), list(\"An R expression to be evaluated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The environment where the future plan should be set and the expression evaluated.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Named arguments to replace the defaults of existing\\n\",  #>                     \"arguments.\")), \"\\n\"), \"\\n\", list(\"\\n\", list( #>                   \"plan()\"), \" returns a the previous plan invisibly if a new strategy\\n\",  #>                   \"is chosen, otherwise it returns the current one visibly.\\n\",  #>                   \"\\n\", \"a future function.\\n\", \"\\n\", list(\"withPlan()\"),  #>                   \" returns the value of the expression evaluated invisibly.\\n\",  #>                   \"\\n\", list(\"localPlan()\"), \" returns the current future plan before applying the temporary one.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function allows \", list( #>                   \"the user\"), \" to plan the future, more specifically,\\n\",  #>                   \"it specifies how \", list(list(\"future()\")),  #>                   \":s are resolved,\\n\", \"e.g. sequentially or in parallel.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The default strategy is \",  #>                   list(list(\"sequential\")), \", but the default can be\\n\",  #>                   \"configured by option \", list(\"future.plan\"),  #>                   \" and, if that is not set,\\n\", \"system environment variable \",  #>                   list(\"R_FUTURE_PLAN\"), \".\\n\", \"To reset the strategy back to the default, use \",  #>                   list(\"plan(\\\"default\\\")\"), \".\\n\"), \"\\n\", list( #>                   list(\"Built-in evaluation strategies\"), list( #>                     \"\\n\", \"\\n\", \"The \", list(\"future\"), \" package provides the following built-in backends:\\n\",  #>                     \"\\n\", list(\"\\n\", list(list(list(list(\"sequential\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures sequentially in the current \",  #>                       list(), \" process, e.g.\\n\", list(\"plan(sequential)\"),  #>                       \".\\n\")), \"\\n\", list(list(list(list(\"multisession\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                       list(), \" sessions running in the background on the same machine, e.g.\\n\",  #>                       list(\"plan(multisession)\"), \" and \", list( #>                         \"plan(multisession, workers = 2)\"), \".\\n\")),  #>                       \"\\n\", list(list(list(list(\"multicore\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(\"forked\"), \" \", list(), \" processes running in the background on\\n\",  #>                         \"the same machine, e.g.\\n\", list(\"plan(multicore)\"),  #>                         \" and \", list(\"plan(multicore, workers = 2)\"),  #>                         \".\\n\", \"This backend is not supported on Windows.\\n\")),  #>                       \"\\n\", list(list(list(list(\"cluster\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(), \" sessions running typically on one or more machines, e.g.\\n\",  #>                         list(\"plan(cluster)\"), \", \", list(\"plan(cluster, workers = 2)\"),  #>                         \", and\\n\", list(\"plan(cluster, workers = c(\\\"n1\\\", \\\"n1\\\", \\\"n2\\\", \\\"server.remote.org\\\"))\"),  #>                         \".\\n\")), \"\\n\"), \"\\n\", \"\\n\", \"Other package provide additional evaluation strategies.\\n\",  #>                     \"For example, the \", list(\"future.callr\"),  #>                     \" package implements an alternative\\n\", \"to the \",  #>                     list(\"multisession\"), \" backend on top of the \",  #>                     list(\"callr\"), \" package, e.g.\\n\", list(\"plan(future.callr::callr, workers = 2)\"),  #>                     \".\\n\", \"Another example is the \", list(\"future.batchtools\"),  #>                     \" package, which implements,\\n\", \"on top of the \",  #>                     list(\"batchtools\"), \" package, e.g.\\n\", list( #>                       \"plan(future.batchtools::batchtools_slurm)\"),  #>                     \".\\n\", \"These types of futures are resolved via job schedulers, which typically\\n\",  #>                     \"are available on high-performance compute (HPC) clusters, e.g. LSF,\\n\",  #>                     \"Slurm, TORQUE/PBS, Sun Grid Engine, and OpenLava.\\n\",  #>                     \"\\n\", \"To \\\"close\\\" any background workers (e.g. \",  #>                     list(\"multisession\"), \"), change\\n\", \"the plan to something different; \",  #>                     list(\"plan(sequential)\"), \" is recommended\\n\",  #>                     \"for this.\\n\")), \"\\n\", \"\\n\", list(list(\"For package developers\"),  #>                   list(\"\\n\", \"\\n\", \"Please refrain from modifying the future strategy inside your packages /\\n\",  #>                     \"functions, i.e. do not call \", list(\"plan()\"),  #>                     \" in your code. Instead, leave\\n\", \"the control on what backend to use to the end user. This idea is part of\\n\",  #>                     \"the core philosophy of the future framework---as a developer you can never\\n\",  #>                     \"know what future backends the user have access to. Moreover, by not making\\n\",  #>                     \"any assumptions about what backends are available, your code will also work\\n\",  #>                     \"automatically with any new backends developed after you wrote your code.\\n\",  #>                     \"\\n\", \"If you think it is necessary to modify the future strategy within a\\n\",  #>                     \"function, then make sure to undo the changes when exiting the function.\\n\",  #>                     \"This can be archived by using \", list(list( #>                       \"localPlan()\")), \", e.g.\\n\", \"\\n\", list( #>                       \"\\n\", \"  my_fcn <- function(x) {\\n\", \"    localPlan(multisession)\\n\",  #>                       \"    y <- analyze(x)\\n\", \"    summarize(y)\\n\",  #>                       \"  }\\n\"), \"\\n\", \"\\n\", \"This is important because the end-user might have already set the future\\n\",  #>                     \"strategy elsewhere for other purposes and will most likely not known that\\n\",  #>                     \"calling your function will break their setup.\\n\",  #>                     list(\"Remember, your package and its functions might be used in a greater\\n\",  #>                       \"context where multiple packages and functions are involved and those might\\n\",  #>                       \"also rely on the future framework, so it is important to avoid stepping on\\n\",  #>                       \"others' toes.\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Using plan() in scripts and vignettes\"),  #>                   list(\"\\n\", \"\\n\", \"When writing scripts or vignettes that use futures, try to place any\\n\",  #>                     \"call to \", list(\"plan()\"), \" as far up (i.e. as early on) in the code as possible.\\n\",  #>                     \"This will help users to quickly identify where the future plan is set up\\n\",  #>                     \"and allow them to modify it to their computational resources.\\n\",  #>                     \"Even better is to leave it to the user to set the \",  #>                     list(\"plan()\"), \" prior to\\n\", list(\"source()\"),  #>                     \":ing the script or running the vignette.\\n\",  #>                     \"If a \", list(list(\".future.R\")), \" exists in the current directory and / or in\\n\",  #>                     \"the user's home directory, it is sourced when the \",  #>                     list(\"future\"), \" package is\\n\", list(\"loaded\"),  #>                     \". Because of this, the \", list(\".future.R\"),  #>                     \" file provides a\\n\", \"convenient place for users to set the \",  #>                     list(\"plan()\"), \".\\n\", \"This behavior can be controlled via an \",  #>                     list(), \" option---see\\n\", list(\"future options\"),  #>                     \" for more details.\\n\")), \"\\n\", \"\\n\", list( #>                   \"\\n\", \"a <- b <- c <- NA_real_\\n\", \"\\n\", \"# An sequential future\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A sequential future with lazy evaluation\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"}, lazy = TRUE)\\n\", \"y <- value(f)\\n\", \"print(y)\\n\",  #>                   \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A multicore future (specified as a string)\\n\",  #>                   \"plan(\\\"multicore\\\")\\n\", \"f <- future({\\n\",  #>                   \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"## Multisession futures gives an error on R CMD check on\\n\",  #>                   \"## Windows (but not Linux or macOS) for unknown reasons.\\n\",  #>                   \"## The same code works in package tests.\\n\",  #>                   list(\"\\n\", \"\\n\", \"# A multisession future (specified via a string variable)\\n\",  #>                     \"plan(\\\"future::multisession\\\")\\n\", \"f <- future({\\n\",  #>                     \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                     \"  a * b * c\\n\", \"})\\n\", \"y <- value(f)\\n\",  #>                     \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                     \"\\n\"), \"\\n\", \"\\n\", \"\\n\", \"## Explicitly specifying number of workers\\n\",  #>                   \"## (default is parallelly::availableCores())\\n\",  #>                   \"plan(multicore, workers = 2)\\n\", \"message(\\\"Number of parallel workers: \\\", nbrOfWorkers())\\n\",  #>                   \"\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\", list(\"\\n\", \"Use \",  #>                   list(list(\"plan()\")), \" to set a future to become the\\n\",  #>                   \"new default strategy.\\n\"), \"\\n\"), private_length.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\".length\"), \"\\n\", list(\".length\"),  #>                 \"\\n\", list(\"Gets the length of an object without dispatching\"),  #>                 \"\\n\", list(\"\\n\", \".length(x)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"Any \", list(),  #>                     \" object.\")), \"\\n\"), \"\\n\", list(\"\\n\", \"A non-negative integer.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets the length of an object without dispatching\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function returns \", list( #>                   \"length(unclass(x))\"), \", but tries to avoid\\n\",  #>                   \"calling \", list(\"unclass(x)\"), \" unless necessary.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\".subset\"), \"()\"),  #>                   \" and \", list(list(\".subset2\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), `re-exports.Rd` = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/000.re-exports.R\",  #>                 \"\\n\", list(\"re-exports\"), \"\\n\", list(\"re-exports\"),  #>                 \"\\n\", list(\"as.cluster\"), \"\\n\", list(\"availableCores\"),  #>                 \"\\n\", list(\"availableWorkers\"), \"\\n\", list(\"makeClusterPSOCK\"),  #>                 \"\\n\", list(\"supportsMulticore\"), \"\\n\", list(\"Functions Moved to 'parallelly'\"),  #>                 \"\\n\", list(\"\\n\", \"The following function used to be part of \",  #>                   list(\"future\"), \" but has since\\n\", \"been migrated to \",  #>                   list(\"parallelly\"), \".  The migration started with\\n\",  #>                   list(\"future\"), \" 1.20.0 (November 2020).  They were moved because they\\n\",  #>                   \"are also useful outside of the \", list(\"future\"),  #>                   \" framework.\\n\"), \"\\n\", list(\"\\n\", list(\"If you are using any of these from the \",  #>                   list(\"future\"), \" package, please\\n\", \"switch to use the ones from the \",  #>                   list(\"parallelly\"), \" package. Thank you!\"),  #>                   \"\\n\", list(\"\\n\", list(), \" \", list(list(\"parallelly::as.cluster()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::autoStopCluster()\")),  #>                     \"   (no longer re-exported)\\n\", list(), \" \",  #>                     list(list(\"parallelly::availableCores()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                     \"    (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                     \"     (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \"\\n\"), \"\\n\", \"\\n\", \"For backward-compatible reasons, \",  #>                   list(\"some\"), \" of these functions remain\\n\",  #>                   \"available as exact copies also from this package (as re-exports), e.g.\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- parallelly::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"can still be accessed as:\\n\", \"\\n\",  #>                   list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- future::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", list(\"Note that it is the goal to remove all of the above from this package.\"),  #>                   \"\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), readImmediateConditions.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"readImmediateConditions\"), \"\\n\",  #>                 list(\"readImmediateConditions\"), \"\\n\", list(\"saveImmediateCondition\"),  #>                 \"\\n\", list(\"Writes and Reads 'immediateCondition' RDS Files\"),  #>                 \"\\n\", list(\"\\n\", \"readImmediateConditions(\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir(),\\n\", \"  pattern = \\\"[.]rds$\\\",\\n\",  #>                   \"  include = getOption(\\\"future.relay.immediate\\\", \\\"immediateCondition\\\"),\\n\",  #>                   \"  signal = FALSE,\\n\", \"  remove = TRUE\\n\",  #>                   \")\\n\", \"\\n\", \"saveImmediateCondition(\\n\", \"  cond,\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir()\\n\", \")\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"path\"), list(\"(character string) The folder where the RDS files are.\")),  #>                   \"\\n\", \"\\n\", list(list(\"pattern\"), list(\"(character string) A regular expression selecting\\n\",  #>                     \"the RDS files to be read.\")), \"\\n\", \"\\n\",  #>                   list(list(\"include\"), list(\"(character vector) The class or classes of the objects\\n\",  #>                     \"to be kept.\")), \"\\n\", \"\\n\", list(list(\"signal\"),  #>                     list(\"(logical) If TRUE, the condition read are signaled.\")),  #>                   \"\\n\", \"\\n\", list(list(\"remove\"), list(\"(logical) If TRUE, the RDS files used are removed on exit.\")),  #>                   \"\\n\", \"\\n\", list(list(\"cond\"), list(\"A condition of class \",  #>                     list(\"immediateCondition\"), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"readImmediateConditions()\"),  #>                   \" returns a \", list(\"base::list\"), \" of\\n\",  #>                   list(\"immediateCondition\"), \" objects.\\n\",  #>                   \"\\n\", list(\"saveImmediateCondition()\"), \" returns, invisibly, the pathname of\\n\",  #>                   \"the RDS written.\\n\"), \"\\n\", list(\"\\n\", \"Writes and Reads 'immediateCondition' RDS Files\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), requestCore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"requestCore\"), \"\\n\", list(\"requestCore\"),  #>                 \"\\n\", list(\"Request a core for multicore processing\"),  #>                 \"\\n\", list(\"\\n\", \"requestCore(await, workers = availableCores(), timeout, delta, alpha)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"await\"), list(\"A function used to try to \\\"collect\\\"\\n\",  #>                   \"finished multicore subprocesses.\")), \"\\n\",  #>                   \"\\n\", list(list(\"workers\"), list(\"Total number of workers available.\")),  #>                   \"\\n\", \"\\n\", list(list(\"timeout\"), list(\"Maximum waiting time (in seconds) allowed\\n\",  #>                     \"before a timeout error is generated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"delta\"), list(\"Then base interval (in seconds) to wait\\n\",  #>                     \"between each try.\")), \"\\n\", \"\\n\", list(list( #>                     \"alpha\"), list(\"A multiplicative factor used to increase\\n\",  #>                     \"the wait interval after each try.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Invisible TRUE. If no cores are available after\\n\",  #>                   \"extensive waiting, then a timeout error is thrown.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If no cores are available, the current process\\n\",  #>                   \"blocks until a core is available.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), reset.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-reset.R\",  #>                 \"\\n\", list(\"reset\"), \"\\n\", list(\"reset\"), \"\\n\",  #>                 list(\"Reset a finished, failed, or interrupted future to a lazy future\"),  #>                 \"\\n\", list(\"\\n\", \"reset(x, ...)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"A Future.\")), \"\\n\",  #>                   \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"reset()\"), \" returns a lazy, vanilla \",  #>                   list(\"Future\"), \" that can be relaunched.\\n\",  #>                   \"Resetting a running future results in a \",  #>                   list(\"FutureError\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                   \"A future that has successfully completed, has been interrupted, or\\n\",  #>                   \"failed due to an error, can be relaunched after resetting it.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"A lazy, vanilla \", list(\"Future\"),  #>                   \" can be reused in another R session. For\\n\",  #>                   \"instance, if we do:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"a <- 2\\n\", \"f <- future(42 * a, lazy = TRUE)\\n\",  #>                     \"saveRDS(f, \\\"myfuture.rds\\\")\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"Then we can read and evaluate the future in another R session using:\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"f <- readRDS(\\\"myfuture.rds\\\")\\n\",  #>                     \"v <- value(f)\\n\", \"print(v)\\n\", \"#> [1] 84\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"## Like mean(), but fails 90% of the time\\n\",  #>                   \"shaky_mean <- function(x) {\\n\", \"  if (as.double(Sys.time()) %% 1 < 0.90) stop(\\\"boom\\\")\\n\",  #>                   \"  mean(x)\\n\", \"}\\n\", \"\\n\", \"x <- rnorm(100)\\n\",  #>                   \"\\n\", \"## Calculate the mean of 'x' with a risk of failing randomly\\n\",  #>                   \"f <- future({ shaky_mean(x) })\\n\", \"\\n\", \"## Relaunch until success\\n\",  #>                   \"repeat({\\n\", \"  v <- tryCatch(value(f), error = identity)\\n\",  #>                   \"  if (!inherits(v, \\\"error\\\")) break\\n\", \"  message(\\\"Resetting failed future, and retry in 0.1 seconds\\\")\\n\",  #>                   \"  f <- reset(f)\\n\", \"  Sys.sleep(0.1)\\n\",  #>                   \"})\\n\", \"cat(\\\"mean:\\\", v, \\\"\\\\n\\\")\\n\"), \"\\n\"),  #>             resetWorkers.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R\",  #>                 \"\\n\", list(\"resetWorkers\"), \"\\n\", list(\"resetWorkers\"),  #>                 \"\\n\", list(\"Free up active background workers\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"A FutureStrategy.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Free up active background workers\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function will resolve any active futures that is currently\\n\",  #>                   \"being evaluated on background workers.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(plan())\\n\", \"\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), resolve.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-resolve.R\",  #>                 \"\\n\", list(\"resolve\"), \"\\n\", list(\"resolve\"),  #>                 \"\\n\", list(\"Resolve one or more futures synchronously\"),  #>                 \"\\n\", list(\"\\n\", \"resolve(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  result = FALSE,\\n\",  #>                   \"  stdout = FALSE,\\n\", \"  signal = FALSE,\\n\",  #>                   \"  force = FALSE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"x\"), list(\"A \", list(\"Future\"), \" to be resolved, or a list, an environment, or a\\n\",  #>                   \"list environment of futures to be resolved.\")),  #>                   \"\\n\", \"\\n\", list(list(\"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"result\"), list(\"(internal) If TRUE, the results are \",  #>                     list(\"retrieved\"), \", otherwise not.\\n\",  #>                     \"Note that this only collects the results from the parallel worker, which\\n\",  #>                     \"can help lower the overall latency if there are multiple concurrent futures.\\n\",  #>                     \"This does \", list(\"not\"), \" return the collected results.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"(internal) If TRUE, captured standard output is relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"signal\"), list(\"(internal) If TRUE, captured \",  #>                     list(\"conditions\"), \" are relayed,\\n\", \"otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed is relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns \", list(\"x\"), \" (regardless of subsetting or not).\\n\",  #>                   \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is produced.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"This function provides an efficient mechanism for waiting for multiple\\n\",  #>                   \"futures in a container (e.g. list or environment) to be resolved while in\\n\",  #>                   \"the meanwhile retrieving values of already resolved futures.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is resolves synchronously, i.e. it blocks until \",  #>                   list(\"x\"), \" and\\n\", \"any containing futures are resolved.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"To resolve a future \", list( #>                   \"variable\"), \", first retrieve its\\n\", list( #>                   \"Future\"), \" object using \", list(list(\"futureOf()\")),  #>                   \", e.g.\\n\", list(\"resolve(futureOf(x))\"), \".\\n\"),  #>                 \"\\n\"), resolved.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-resolved.R\",  #>                 \"\\n\", list(\"resolved\"), \"\\n\", list(\"resolved\"),  #>                 \"\\n\", list(\"Check whether a future is resolved or not\"),  #>                 \"\\n\", list(\"\\n\", \"resolved(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"A \", list(\"Future\"),  #>                   \", a list, or an environment (which also\\n\",  #>                   \"includes \", list(\"list environment\"), \").\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A logical of the same length and dimensions as \",  #>                   list(\"x\"), \".\\n\", \"Each element is TRUE unless the corresponding element is a\\n\",  #>                   \"non-resolved future in case it is FALSE.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Check whether a future is resolved or not\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This method needs to be implemented by the class that implement\\n\",  #>                   \"the Future API.  The implementation should return either TRUE or FALSE\\n\",  #>                   \"and must never throw an error (except for \",  #>                   list(\"FutureError\"), \":s which indicate\\n\",  #>                   \"significant, often unrecoverable infrastructure problems).\\n\",  #>                   \"It should also be possible to use the method for polling the\\n\",  #>                   \"future until it is resolved (without having to wait infinitely long),\\n\",  #>                   \"e.g. \", list(\"while (!resolved(future)) Sys.sleep(5)\"),  #>                   \".\\n\"), \"\\n\"), result.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"result.Future\"), \"\\n\", list(\"result.Future\"),  #>                 \"\\n\", list(\"result\"), \"\\n\", list(\"Get the results of a resolved future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"result\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"FutureResult\"),  #>                   \" object.\\n\"), \"\\n\", list(\"\\n\", \"Get the results of a resolved future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                   list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                   list(\"not\"), \" part of the frontend Future API.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), run.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"run.Future\"), \"\\n\", list(\"run.Future\"),  #>                 \"\\n\", list(\"run\"), \"\\n\", list(\"Run a future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"run\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"Future\"),  #>                   \" object.\\n\"), \"\\n\", list(\"\\n\", \"Run a future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function can only be called once per future.\\n\",  #>                   \"Further calls will result in an informative error.\\n\",  #>                   \"If a future is not run when its value is queried,\\n\",  #>                   \"then it is run at that point.\\n\"), \"\\n\", list( #>                   \"internal\"), \"\\n\"), save_rds.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"save_rds\"), \"\\n\", list(\"save_rds\"),  #>                 \"\\n\", list(\"Robustly Saves an Object to RDS File Atomically\"),  #>                 \"\\n\", list(\"\\n\", \"save_rds(object, pathname, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"The \",  #>                   list(), \" object to be save.\")), \"\\n\", \"\\n\",  #>                   list(list(\"pathname\"), list(\"RDS file to written.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional arguments passed to \",  #>                     list(list(\"base::saveRDS()\")), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The pathname of the RDS written.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Robustly Saves an Object to RDS File Atomically\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Uses \", list(\"base::saveRDS\"),  #>                   \" internally but writes the object atomically by first\\n\",  #>                   \"writing to a temporary file which is then renamed.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sequential.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-SequentialFutureBackend-class.R\",  #>                 \"\\n\", list(\"sequential\"), \"\\n\", list(\"sequential\"),  #>                 \"\\n\", list(\"uniprocess\"), \"\\n\", list(\"Create a sequential future whose value will be in the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sequential(..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                   \"\\n\", \"\\n\", list(list(\"earlySignal\"), list( #>                     \"Specified whether conditions should be signaled as soon\\n\",  #>                     \"as possible or not.\")), \"\\n\", \"\\n\", list( #>                     list(\"envir\"), list(\"The \", list(\"environment\"),  #>                       \" from where global objects should be\\n\",  #>                       \"identified.\")), \"\\n\", \"\\n\", list(list( #>                     list()), list(\"Additional named elements to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \".\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A sequential future is a future that is evaluated sequentially in the\\n\",  #>                   \"current \", list(), \" session similarly to how \",  #>                   list(), \" expressions are evaluated in \", list(),  #>                   \".\\n\", \"The only difference to \", list(), \" itself is that globals are validated\\n\",  #>                   \"by default just as for all other types of futures in this package.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is \", list(\"not\"),  #>                   \" meant to be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures sequentially in the current R process\\n\",  #>                     \"plan(sequential)\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\"), \"\\n\", list( #>                   \"\\n\", \"## Use sequential futures\\n\", \"plan(sequential)\\n\",  #>                   \"\\n\", \"## A global variable\\n\", \"a <- 0\\n\",  #>                   \"\\n\", \"## Create a sequential future\\n\", \"f <- future({\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"\\n\", \"## Since 'a' is a global variable in future 'f' which\\n\",  #>                   \"## is eagerly resolved (default), this global has already\\n\",  #>                   \"## been resolved / incorporated, and any changes to 'a'\\n\",  #>                   \"## at this point will _not_ affect the value of 'f'.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\"),  #>             sessionDetails.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-sessionDetails.R\",  #>                 \"\\n\", list(\"sessionDetails\"), \"\\n\", list(\"sessionDetails\"),  #>                 \"\\n\", list(\"Outputs details on the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sessionDetails(env = FALSE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"env\"), list(\"If TRUE, \",  #>                   list(\"Sys.getenv()\"), \" information is returned.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Invisibly a list of all details.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Outputs details on the current \",  #>                   list(), \" session\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), signalConditions.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-signalConditions.R\",  #>                 \"\\n\", list(\"signalConditions\"), \"\\n\", list(\"signalConditions\"),  #>                 \"\\n\", list(\"Signals Captured Conditions\"), \"\\n\",  #>                 list(\"\\n\", \"signalConditions(\\n\", \"  future,\\n\",  #>                   \"  include = \\\"condition\\\",\\n\", \"  exclude = NULL,\\n\",  #>                   \"  resignal = TRUE,\\n\", \"  ...\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A resolved \",  #>                   list(\"Future\"), \".\")), \"\\n\", \"\\n\", list(list( #>                   \"include\"), list(\"A character string of \",  #>                   list(\"condition\"), \"\\n\", \"classes to signal.\")),  #>                   \"\\n\", \"\\n\", list(list(\"exclude\"), list(\"A character string of \",  #>                     list(\"condition\"), \"\\n\", \"classes \", list( #>                       \"not\"), \" to signal.\")), \"\\n\", \"\\n\", list( #>                     list(\"resignal\"), list(\"If TRUE, then already signaled conditions are signaled\\n\",  #>                       \"again, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns the \", list(\"Future\"),  #>                   \" where conditioned that were signaled\\n\",  #>                   \"have been flagged to have been signaled.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Captured conditions that meet the \",  #>                   list(\"include\"), \" and \", list(\"exclude\"),  #>                   \"\\n\", \"requirements are signaled \", list(\"in the order as they were captured\"),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Conditions are signaled by\\n\",  #>                   list(list(\"signalCondition\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sticky_globals.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>                 \"\\n\", list(\"sticky_globals\"), \"\\n\", list(\"sticky_globals\"),  #>                 \"\\n\", list(\"Place a sticky-globals environment immediately after the global environment\"),  #>                 \"\\n\", list(\"\\n\", \"sticky_globals(erase = FALSE, name = \\\"future:sticky_globals\\\", pos = 2L)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"erase\"), list(\"(logical) If TRUE, the environment is erased, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"name\"), list(\"(character) The name of the environment on the \",  #>                     list(\"base::search\"), \"\\n\", \"path.\")), \"\\n\",  #>                   \"\\n\", list(list(\"pos\"), list(\"(integer) The position on the search path where the\\n\",  #>                     \"environment should be positioned.  If \",  #>                     list(\"pos == 0L\"), \", then the environment\\n\",  #>                     \"is detached, if it exists.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"(invisible; environment) The environment.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Place a sticky-globals environment immediately after the global environment\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), usedCores.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"usedCores\"), \"\\n\", list(\"usedCores\"),  #>                 \"\\n\", list(\"Get number of cores currently used\"),  #>                 \"\\n\", list(\"\\n\", \"usedCores()\\n\"), \"\\n\", list( #>                   \"\\n\", \"A non-negative integer.\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get number of children (and don't count the current process)\\n\",  #>                   \"used by the current \", list(), \" session.  The number of children\\n\",  #>                   \"is the total number of subprocesses launched by this\\n\",  #>                   \"process that are still running and whose values have yet\\n\",  #>                   \"not been collected.\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), value.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-value.R\",  #>                 \"\\n\", list(\"value\"), \"\\n\", list(\"value\"), \"\\n\",  #>                 list(\"value.Future\"), \"\\n\", list(\"value.list\"),  #>                 \"\\n\", list(\"value.listenv\"), \"\\n\", list(\"value.environment\"),  #>                 \"\\n\", list(\"The value of a future or the values of all elements in a container\"),  #>                 \"\\n\", list(\"\\n\", \"value(...)\\n\", \"\\n\", list(list( #>                   \"value\"), list(\"Future\")), \"(future, stdout = TRUE, signal = TRUE, drop = FALSE, ...)\\n\",  #>                   \"\\n\", list(list(\"value\"), list(\"list\")), \"(\\n\",  #>                   \"  x,\\n\", \"  idxs = NULL,\\n\", \"  recursive = 0,\\n\",  #>                   \"  reduce = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  signal = TRUE,\\n\", \"  interrupt = TRUE,\\n\",  #>                   \"  inorder = TRUE,\\n\", \"  drop = FALSE,\\n\",  #>                   \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"listenv\")), \"(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  reduce = NULL,\\n\",  #>                   \"  stdout = TRUE,\\n\", \"  signal = TRUE,\\n\",  #>                   \"  interrupt = TRUE,\\n\", \"  inorder = TRUE,\\n\",  #>                   \"  drop = FALSE,\\n\", \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"environment\")), \"(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"future, x\"), list(\"A \",  #>                   list(\"Future\"), \", an environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE, standard output captured while resolving futures\\n\",  #>                     \"is relayed, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(\"signal\"), list(\"If TRUE, \", list( #>                     \"conditions\"), \" captured while resolving\\n\",  #>                     \"futures are relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"If TRUE, resolved futures are minimized in size and invalidated\\n\",  #>                     \"as soon the as their values have been collected and any output and\\n\",  #>                     \"conditions have been relayed.\\n\", \"Combining \",  #>                     list(\"drop = TRUE\"), \" with \", list(\"inorder = FALSE\"),  #>                     \" reduces the memory use\\n\", \"sooner, especially avoiding the risk of holding on to future values until\\n\",  #>                     \"the very end.\")), \"\\n\", \"\\n\", list(list( #>                     \"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"reduce\"), list(\"An optional function for reducing all the values.\\n\",  #>                     \"Optional attribute \", list(\"init\"), \" can be used to set initial value for the\\n\",  #>                     \"reduction. If not specified, the first value will be used as the\\n\",  #>                     \"initial value.\\n\", \"Reduction of values is done as soon as possible, but always in the\\n\",  #>                     \"same order as \", list(\"x\"), \", unless \",  #>                     list(\"inorder\"), \" is FALSE.\")), \"\\n\", \"\\n\",  #>                   list(list(\"interrupt\"), list(\"If TRUE and \",  #>                     list(\"signal\"), \" is TRUE, non-resolved futures are\\n\",  #>                     \"interrupted as soon as an error is detected in one of the futures,\\n\",  #>                     \"before signaling the error.\")), \"\\n\", \"\\n\",  #>                   list(list(\"inorder\"), list(\"If TRUE, then standard output and conditions are relayed,\\n\",  #>                     \"and value reduction, is done in the order the futures occur in \",  #>                     list(\"x\"), \", but\\n\", \"always as soon as possible. This is achieved by buffering the details\\n\",  #>                     \"until they can be released. By setting \",  #>                     list(\"inorder = FALSE\"), \", no buffering\\n\",  #>                     \"takes place and everything is relayed and reduced as soon as a new future\\n\",  #>                     \"is resolved. Regardlessly, the values are always returned in the same\\n\",  #>                     \"order as \", list(\"x\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed is relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"value()\"), \" of a Future object returns the value of the future, which can\\n\",  #>                   \"be any type of \", list(), \" object.\\n\", \"\\n\",  #>                   list(\"value()\"), \" of a list, an environment, or a list environment returns an\\n\",  #>                   \"object with the same number of elements and of the same class.\\n\",  #>                   \"Names and dimension attributes are preserved, if available.\\n\",  #>                   \"All future elements are replaced by their corresponding \",  #>                   list(\"value()\"), \" values.\\n\", \"For all other elements, the existing object is kept as-is.\\n\",  #>                   \"\\n\", \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is relayed. Any remaining, non-resolved futures in \",  #>                   list(\"x\"), \" are\\n\", \"interrupted, prior to signalling such an error.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets the value of a future or the values of all elements (including futures)\\n\",  #>                   \"in a container such as a list, an environment, or a list environment.\\n\",  #>                   \"If one or more futures is unresolved, then this function blocks until all\\n\",  #>                   \"queried futures are resolved.\\n\"), \"\\n\", list( #>                   \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## A single future\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"x <- sample(100, size = 50)\\n\", \"f <- future(mean(x))\\n\",  #>                   \"v <- value(f)\\n\", \"message(\\\"The average of 50 random numbers in [1,100] is: \\\", v)\\n\",  #>                   \"\\n\", \"\\n\", \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## Ten futures\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"xs <- replicate(10, { list(sample(100, size = 50)) })\\n\",  #>                   \"fs <- lapply(xs, function(x) { future(mean(x)) })\\n\",  #>                   \"\\n\", \"## The 10 values as a list (because 'fs' is a list)\\n\",  #>                   \"vs <- value(fs)\\n\", \"message(\\\"The ten averages are:\\\")\\n\",  #>                   \"str(vs)\\n\", \"\\n\", \"## The 10 values as a vector (by manually unlisting)\\n\",  #>                   \"vs <- value(fs)\\n\", \"vs <- unlist(vs)\\n\",  #>                   \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## The values as a vector (by reducing)\\n\",  #>                   \"vs <- value(fs, reduce = `c`)\\n\", \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## Calculate the sum of the averages (by reducing)\\n\",  #>                   \"total <- value(fs, reduce = `sum`)\\n\", \"message(\\\"The sum of the ten averages is: \\\", total)\\n\"),  #>                 \"\\n\"), `zzz-future.options.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-options.R\",  #>                 \"\\n\", list(\"zzz-future.options\"), \"\\n\", list( #>                   \"zzz-future.options\"), \"\\n\", list(\"future.options\"),  #>                 \"\\n\", list(\"future.startup.script\"), \"\\n\", list( #>                   \"future.debug\"), \"\\n\", list(\"future.demo.mandelbrot.region\"),  #>                 \"\\n\", list(\"future.demo.mandelbrot.nrow\"), \"\\n\",  #>                 list(\"future.fork.multithreading.enable\"), \"\\n\",  #>                 list(\"future.globals.maxSize\"), \"\\n\", list(\"future.globals.method\"),  #>                 \"\\n\", list(\"future.globals.onMissing\"), \"\\n\",  #>                 list(\"future.globals.resolve\"), \"\\n\", list(\"future.globals.onReference\"),  #>                 \"\\n\", list(\"future.plan\"), \"\\n\", list(\"future.onFutureCondition.keepFuture\"),  #>                 \"\\n\", list(\"future.resolve.recursive\"), \"\\n\",  #>                 list(\"future.connections.onMisuse\"), \"\\n\", list( #>                   \"future.globalenv.onMisuse\"), \"\\n\", list(\"future.rng.onMisuse\"),  #>                 \"\\n\", list(\"future.wait.alpha\"), \"\\n\", list(\"future.wait.interval\"),  #>                 \"\\n\", list(\"future.wait.timeout\"), \"\\n\", list( #>                   \"future.output.windows.reencode\"), \"\\n\", list( #>                   \"future.journal\"), \"\\n\", list(\"future.globals.objectSize.method\"),  #>                 \"\\n\", list(\"R_FUTURE_STARTUP_SCRIPT\"), \"\\n\",  #>                 list(\"R_FUTURE_DEBUG\"), \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_REGION\"),  #>                 \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_NROW\"),  #>                 \"\\n\", list(\"R_FUTURE_FORK_MULTITHREADING_ENABLE\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_MAXSIZE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_METHOD\"), \"\\n\", list(\"R_FUTURE_GLOBALS_ONMISSING\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_RESOLVE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_ONREFERENCE\"), \"\\n\", list( #>                   \"R_FUTURE_PLAN\"), \"\\n\", list(\"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\"),  #>                 \"\\n\", list(\"R_FUTURE_RESOLVE_RECURSIVE\"), \"\\n\",  #>                 list(\"R_FUTURE_CONNECTIONS_ONMISUSE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALENV_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_RNG_ONMISUSE\"), \"\\n\", list(\"R_FUTURE_WAIT_ALPHA\"),  #>                 \"\\n\", list(\"R_FUTURE_WAIT_INTERVAL\"), \"\\n\", list( #>                   \"R_FUTURE_WAIT_TIMEOUT\"), \"\\n\", list(\"R_FUTURE_RESOLVED_TIMEOUT\"),  #>                 \"\\n\", list(\"R_FUTURE_OUTPUT_WINDOWS_REENCODE\"),  #>                 \"\\n\", list(\"R_FUTURE_JOURNAL\"), \"\\n\", list(\"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\"),  #>                 \"\\n\", list(\"future.cmdargs\"), \"\\n\", list(\".future.R\"),  #>                 \"\\n\", list(\"Options used for futures\"), \"\\n\",  #>                 list(\"\\n\", \"Below are the \", list(), \" options and environment variables that are used by the\\n\",  #>                   list(\"future\"), \" package and packages enhancing it.\",  #>                   list(), \"\\n\", list(), \"\\n\", list(\"WARNING: Note that the names and the default values of these options may\\n\",  #>                     \"change in future versions of the package.  Please use with care until\\n\",  #>                     \"further notice.\"), \"\\n\"), \"\\n\", list(list( #>                   \"Packages must not change future options\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Just like for other R options, as a package developer you must \",  #>                     list(\"not\"), \" change\\n\", \"any of the below \",  #>                     list(\"future.*\"), \" options.  Only the end-user should set these.\\n\",  #>                     \"If you find yourself having to tweak one of the options, make sure to\\n\",  #>                     \"undo your changes immediately afterward.  For example, if you want to\\n\",  #>                     \"bump up the \", list(\"future.globals.maxSize\"),  #>                     \" limit when creating a future,\\n\", \"use something like the following inside your function:\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB\\n\",  #>                       \"on.exit(options(oopts))\\n\", \"f <- future({ expr })  ## Launch a future with large objects\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(list(\"Settings moved to the 'parallelly' package\"),  #>                   list(\"\\n\", \"\\n\", \"Several functions have been moved to the \",  #>                     list(\"parallelly\"), \" package:\\n\", list(\"\\n\",  #>                       list(), \" \", list(list(\"parallelly::availableCores()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                       \"\\n\"), \"\\n\", \"\\n\", \"The options and environment variables controlling those have been adjusted\\n\",  #>                     \"accordingly to have different prefixes.\\n\",  #>                     \"For example, option \", list(\"future.fork.enable\"),  #>                     \" has been renamed to\\n\", list(\"parallelly.fork.enable\"),  #>                     \" and the corresponding environment variable\\n\",  #>                     list(\"R_FUTURE_FORK_ENABLE\"), \" has been renamed to\\n\",  #>                     list(\"R_PARALLELLY_FORK_ENABLE\"), \".\\n\",  #>                     \"For backward compatibility reasons, the \",  #>                     list(\"parallelly\"), \" package will\\n\", \"support both versions for a long foreseeable time.\\n\",  #>                     \"See the \", list(\"parallelly::parallelly.options\"),  #>                     \" page for the settings.\\n\")), \"\\n\", \"\\n\",  #>                 list(list(\"Options for controlling futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.plan\"), \":\"), list(\"(character string or future function) Default future strategy plan used unless otherwise specified via \",  #>                     list(list(\"plan()\")), \". This will also be the future plan set when calling \",  #>                     list(\"plan(\\\"default\\\")\"), \".  If not specified, this option may be set when the \",  #>                     list(\"future\"), \" package is \", list(\"loaded\"),  #>                     \" if command-line option \", list(\"--parallel=ncores\"),  #>                     \" (short \", list(\"-p ncores\"), \") is specified; if \",  #>                     list(\"ncores > 1\"), \", then option \", list( #>                       \"future.plan\"), \" is set to \", list(\"multisession\"),  #>                     \" otherwise \", list(\"sequential\"), \" (in addition to option \",  #>                     list(\"mc.cores\"), \" being set to \", list( #>                       \"ncores\"), \", if \", list(\"ncores >= 1\"),  #>                     \"). (Default: \", list(\"sequential\"), \")\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.maxSize\"),  #>                       \":\"), list(\"(numeric) Maximum allowed total size (in bytes) of global variables identified. This is used to protect against exporting too large objects to parallel workers by mistake. Transfering large objects over a network, or over the internet, can be slow and therefore introduce a large bottleneck that increases the overall processing time. It can also result in large egress or ingress costs, which may exist on some systems. If set of \",  #>                       list(\"+Inf\"), \", then the check for large globals is skipped. (Default: \",  #>                       list(\"500 * 1024 ^ 2\"), \" = 500 MiB)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.onReference\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) Controls whether the identified globals should be scanned for so called \",  #>                       list(\"references\"), \" (e.g. external pointers and connections) or not.  It is unlikely that another \",  #>                       list(), \" process (\\\"worker\\\") can use a global that uses a internal reference of the master \",  #>                       list(), \" process---we call such objects \",  #>                       list(\"non-exportable globals\"), \".\\n\",  #>                       \"If this option is \", list(\"\\\"error\\\"\"),  #>                       \", an informative error message is produced if a non-exportable global is detected.\\n\",  #>                       \"If \", list(\"\\\"warning\\\"\"), \", a warning is produced, but the processing will continue; it is likely that the future will be resolved with a run-time error unless processed in the master \",  #>                       list(), \" process (e.g. \", list(\"plan(sequential)\"),  #>                       \" and \", list(\"plan(multicore)\"), \").\\n\",  #>                       \"If \", list(\"\\\"ignore\\\"\"), \", no scan is performed.\\n\",  #>                       \"(Default: \", list(\"\\\"ignore\\\"\"), \" but may change)\\n\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.resolve.recursive\"),  #>                       \":\"), list(\"(integer) An integer specifying the maximum recursive depth to which futures should be resolved. If negative, nothing is resolved.  If \",  #>                       list(\"0\"), \", only the future itself is resolved.  If \",  #>                       list(\"1\"), \", the future and any of its elements that are futures are resolved, and so on. If \",  #>                       list(\"+Inf\"), \", infinite search depth is used. (Default: \",  #>                       list(\"0\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.rng.onMisuse\"), \": (\", list( #>                         \"beta feature - may change\"), \")\"), list( #>                       \"(character string) If random numbers are used in futures, then parallel (L'Ecuyer-CMRG) RNG should be used in order to get statistical sound RNGs. The defaults in the future framework assume that \",  #>                       list(\"no\"), \" random number generation (RNG) is taken place in the future expression because L'Ecuyer-CMRG RNGs come with an unnecessary overhead if not needed.  To protect against mistakes, the future framework attempts to detect when random numbers are used despite L'Ecuyer-CMRG RNGs are not in place.  If this is detected, and \",  #>                       list(\"future.rng.onMisuse = \\\"error\\\"\"),  #>                       \", then an informative error message is produced.  If \",  #>                       list(\"\\\"warning\\\"\"), \", then a warning message is produced.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed. (Default: \",  #>                       list(\"\\\"warning\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                     list(list(list(\"future.connections.onMisuse\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) A future must close any connections it opens and must not close connections it did not open. If such misuse is detected and this option is set to \",  #>                       list(\"\\\"error\\\"\"), \", \", list(\"value()\"),  #>                       \" will produce an error with details. If it is set to \",  #>                       list(\"\\\"warning\\\"\"), \", a warning is produced. If \",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed. (Default: \",  #>                       list(\"\\\"warning\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                     list(list(list(\"future.globalenv.onMisuse\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) Assigning variables to the global environment for the purpose of using the variable at a later time makes no sense with futures, because the next future may be evaluated in different R process.  To protect against mistakes, the future framework attempts to detect when variables are added to the global environment.  If this is detected, and \",  #>                       list(\"future.globalenv.onMisuse = \\\"error\\\"\"),  #>                       \", then an informative error message is produced.  If \",  #>                       list(\"\\\"warning\\\"\"), \", then a warning message is produced.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed. (Default: \",  #>                       list(\"\\\"ignore\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                     list(list(list(\"future.onFutureCondition.keepFuture\"),  #>                       \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                       \", a \", list(\"FutureCondition\"), \" keeps a copy of the \",  #>                       list(\"Future\"), \" object that triggered the condition. If \",  #>                       list(\"FALSE\"), \", it is dropped. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.wait.timeout\"), \":\"), list( #>                       \"(numeric) Maximum waiting time (in seconds) for a future to resolve or for a free worker to become available before a timeout error is generated. (Default: \",  #>                       list(\"30 * 24 * 60 * 60\"), \" (= 30 days))\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.interval\"),  #>                       \":\"), list(\"(numeric) Initial interval (in\\n\",  #>                       \"seconds) between polls. This controls the polling frequency for finding\\n\",  #>                       \"an available worker when all workers are currently busy. It also controls\\n\",  #>                       \"the polling frequency of \", list(\"resolve()\"),  #>                       \". (Default: \", list(\"0.01\"), \" = 1 ms)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.alpha\"),  #>                       \":\"), list(\"(numeric) Positive scale factor used to increase the interval after each poll. (Default: \",  #>                       list(\"1.01\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for debugging futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.debug\"), \":\"), list(\"(logical) If \",  #>                     list(\"TRUE\"), \", extensive debug messages are generated. (Default: \",  #>                     list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for controlling package startup\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.startup.script\"), \":\"), list(\"(character vector or a logical) Specifies zero of more future startup scripts to be sourced when the \",  #>                     list(\"future\"), \" package is \", list(\"attached\"),  #>                     \". It is only the first existing script that is sourced. If none of the specified files exist, nothing is sourced---there will be neither a warning nor an error.\\n\",  #>                     \"If this option is not specified, environment variable \",  #>                     list(\"R_FUTURE_STARTUP_SCRIPT\"), \" is considered, where multiple scripts may be separated by either a colon (\",  #>                     list(\":\"), \") or a semicolon (\", list(\";\"),  #>                     \"). If neither is set, or either is set to \",  #>                     list(\"TRUE\"), \", the default is to look for a \",  #>                     list(\".future.R\"), \" script in the current directory and then in the user's home directory.  To disable future startup scripts, set the option or the environment variable to \",  #>                     list(\"FALSE\"), \".  \", list(\"Importantly\"),  #>                     \", this option is \", list(\"always\"), \" set to \",  #>                     list(\"FALSE\"), \" if the \", list(\"future\"),  #>                     \" package is loaded as part of a future expression being evaluated, e.g. in a background process. In order words, they are sourced in the main \",  #>                     list(), \" process but not in future processes. (Default: \",  #>                     list(\"TRUE\"), \" in main \", list(), \" process and \",  #>                     list(\"FALSE\"), \" in future processes / during future evaluation)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.cmdargs\"),  #>                       \":\"), list(\"(character vector) Overrides \",  #>                       list(list(\"commandArgs\"), \"()\"), \" when the \",  #>                       list(\"future\"), \" package is \", list(\"loaded\"),  #>                       \".\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Options for configuring low-level system behaviors\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", list(\"\\n\", list(list( #>                     list(\"future.fork.multithreading.enable\"),  #>                     \" (\", list(\"beta feature - may change\"),  #>                     \"):\"), list(\"(logical) Enable or disable \",  #>                     list(\"multi-threading\"), \" while using \",  #>                     list(\"forked\"), \" parallel processing.  If \",  #>                     list(\"FALSE\"), \", different multi-thread library settings are overridden such that they run in single-thread mode. Specifically, multi-threading will be disabled for OpenMP (which requires the \",  #>                     list(\"RhpcBLASctl\"), \" package) and for \",  #>                     list(\"RcppParallel\"), \". If \", list(\"TRUE\"),  #>                     \", or not set (the default), multi-threading is allowed.  Parallelization via multi-threaded processing (done in native code by some packages and external libraries) while at the same time using forked (aka \\\"multicore\\\") parallel processing is known to unstable.  Note that this is not only true when using \",  #>                     list(\"plan(multicore)\"), \" but also when using, for instance, \",  #>                     list(list(\"mclapply\"), \"()\"), \" of the \",  #>                     list(\"parallel\"), \" package. (Default: not set)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.output.windows.reencode\"),  #>                       \":\"), list(\"(logical) Enable or disable re-encoding of UTF-8 symbols that were incorrectly encoded while captured.  In R (< 4.2.0) and on older versions of MS Windows, R cannot capture UTF-8 symbols as-is when they are captured from the standard output.  For examples, a UTF-8 check mark symbol (\",  #>                       list(\"\\\"\\\\u2713\\\"\"), \") would be relayed as \",  #>                       list(\"\\\"<U+2713>\\\"\"), \" (a string with eight ASCII characters).  Setting this option to \",  #>                       list(\"TRUE\"), \" will cause \", list(\"value()\"),  #>                       \" to attempt to recover the intended UTF-8 symbols from \",  #>                       list(\"<U+nnnn>\"), \" string components, if, and only if, the string was captured by a future resolved on MS Windows. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\"), \"\\n\", \"\\n\",  #>                     \"See also \", list(\"parallelly::parallelly.options\"),  #>                     \".\\n\")), \"\\n\", \"\\n\", list(list(\"Options for demos\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.demo.mandelbrot.region\"), \":\"), list( #>                     \"(integer) Either a named list of \", list( #>                       list(\"mandelbrot()\")), \" arguments or an integer in {1, 2, 3} specifying a predefined Mandelbrot region. (Default: \",  #>                     list(\"1L\"), \")\")), \"\\n\", \"\\n\", list(list( #>                     list(\"future.demo.mandelbrot.nrow\"), \":\"),  #>                     list(\"(integer) Number of rows and columns of tiles. (Default: \",  #>                       list(\"3L\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Deprecated or for internal prototyping\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"The following options exists only for troubleshooting purposes and must not\\n\",  #>                     \"be used in production.  If used, there is a risk that the results are\\n\",  #>                     \"non-reproducible if processed elsewhere.  To lower the risk of them being\\n\",  #>                     \"used by mistake, they are marked as deprecated and will produce warnings\\n\",  #>                     \"if set.\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                       \"future.globals.onMissing\"), \":\"), list( #>                       \"(character string) Action to take when non-existing global variables (\\\"globals\\\" or \\\"unknowns\\\") are identified when the future is created.  If \",  #>                       list(\"\\\"error\\\"\"), \", an error is generated immediately.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no action is taken and an attempt to evaluate the future expression will be made.  The latter is useful when there is a risk for false-positive globals being identified, e.g. when future expression contains non-standard evaluation (NSE).  (Default: \",  #>                       list(\"\\\"ignore\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.method\"),  #>                         \":\"), list(\"(character string) Method used to identify globals. For details, see \",  #>                         list(list(\"globalsOf\"), \"()\"), \". (Default: \",  #>                         list(\"\\\"ordered\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.resolve\"),  #>                         \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                         \", globals that are \", list(list(\"Future\")),  #>                         \" objects (typically created as \", list( #>                           \"explicit\"), \" futures) will be resolved and have their values (using \",  #>                         list(\"value()\"), \") collected.  Because searching for unresolved futures among globals (including their content) can be expensive, the default is not to do it and instead leave it to the run-time checks that assert proper ownership when resolving futures and collecting their values. (Default: \",  #>                         list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Environment variables that set R options\"),  #>                   list(\"\\n\", \"\\n\", \"All of the above \", list(),  #>                     \" \", list(\"future.*\"), \" options can be set by corresponding\\n\",  #>                     \"environment variable \", list(\"R_FUTURE_*\"),  #>                     \" \", list(\"when the \", list(\"future\"), \" package is\\n\",  #>                       \"loaded\"), \". This means that those environment variables must be set before\\n\",  #>                     \"the \", list(\"future\"), \" package is loaded in order to have an effect.\\n\",  #>                     \"For example, if \", list(\"R_FUTURE_RNG_ONMISUSE=\\\"ignore\\\"\"),  #>                     \", then option\\n\", list(\"future.rng.onMisuse\"),  #>                     \" is set to \", list(\"\\\"ignore\\\"\"), \" (character string).\\n\",  #>                     \"Similarly, if \", list(\"R_FUTURE_GLOBALS_MAXSIZE=\\\"50000000\\\"\"),  #>                     \", then option\\n\", list(\"future.globals.maxSize\"),  #>                     \" is set to \", list(\"50000000\"), \" (numeric).\\n\")),  #>                 \"\\n\", \"\\n\", list(\"\\n\", \"# Allow at most 5 MB globals per futures\\n\",  #>                   \"options(future.globals.maxSize = 5e6)\\n\",  #>                   \"\\n\", \"# Be strict; catch all RNG mistakes\\n\",  #>                   \"options(future.rng.onMisuse = \\\"error\\\")\\n\",  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"To set \", list(),  #>                   \" options or environment variables when \",  #>                   list(), \" starts (even before the \", list(\"future\"),  #>                   \" package is loaded), see the \", list(\"Startup\"),  #>                   \" help page.  The \", list(list(\"https://cran.r-project.org/package=startup\"),  #>                     list(list(\"startup\"))), \" package provides a friendly mechanism for configurating \",  #>                   list(), \"'s startup process.\\n\"), \"\\n\")), source = list( #>             `Future-class.Rd` = \"R/backend_api-Future-class.R\",  #>             FutureBackend.Rd = c(\"R/backend_api-ClusterFutureBackend-class.R\",  #>             \"R/backend_api-FutureBackend-class.R\", \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             \"R/backend_api-MultisessionFutureBackend-class.R\",  #>             \"R/backend_api-SequentialFutureBackend-class.R\"),  #>             FutureCondition.Rd = c(\"R/protected_api-FutureCondition-class.R\",  #>             \"R/protected_api-journal.R\"), FutureGlobals.Rd = \"R/protected_api-FutureGlobals-class.R\",  #>             FutureResult.Rd = \"R/protected_api-FutureResult-class.R\",  #>             `MulticoreFuture-class.Rd` = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             `MultiprocessFuture-class.Rd` = \"R/backend_api-MultiprocessFutureBackend-class.R\",  #>             `UniprocessFuture-class.Rd` = \"R/backend_api-UniprocessFuture-class.R\",  #>             backtrace.Rd = \"R/utils_api-backtrace.R\", cluster.Rd = \"R/backend_api-ClusterFutureBackend-class.R\",  #>             clusterExportSticky.Rd = \"R/utils-sticky_globals.R\",  #>             find_references.Rd = \"R/utils-marshalling.R\", future.Rd = c(\"R/core_api-future.R\",  #>             \"R/utils_api-futureCall.R\", \"R/utils_api-minifuture.R\" #>             ), futureAssign.Rd = c(\"R/delayed_api-futureAssign.R\",  #>             \"R/infix_api-01-futureAssign_OP.R\", \"R/infix_api-02-globals_OP.R\",  #>             \"R/infix_api-03-seed_OP.R\", \"R/infix_api-04-stdout_OP.R\",  #>             \"R/infix_api-05-conditions_OP.R\", \"R/infix_api-06-lazy_OP.R\",  #>             \"R/infix_api-07-label_OP.R\", \"R/infix_api-08-plan_OP.R\",  #>             \"R/infix_api-09-tweak_OP.R\"), futureOf.Rd = \"R/delayed_api-futureOf.R\",  #>             futureSessionInfo.Rd = \"R/utils_api-futureSessionInfo.R\",  #>             futures.Rd = \"R/protected_api-futures.R\", getExpression.Rd = \"R/backend_api-Future-class.R\",  #>             getGlobalsAndPackages.Rd = \"R/protected_api-globals.R\",  #>             interrupt.Rd = \"R/core_api-interrupt.R\", mandelbrot.Rd = \"R/demo_api-mandelbrot.R\",  #>             multicore.Rd = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             multisession.Rd = \"R/backend_api-MultisessionFutureBackend-class.R\",  #>             nbrOfWorkers.Rd = \"R/utils_api-nbrOfWorkers.R\", nullcon.Rd = \"R/utils-basic.R\",  #>             plan.Rd = c(\"R/utils_api-plan.R\", \"R/utils_api-tweak.R\",  #>             \"R/utils_api-withPlan.R\"), private_length.Rd = \"R/utils-basic.R\",  #>             `re-exports.Rd` = \"R/000.re-exports.R\", readImmediateConditions.Rd = \"R/utils-immediateCondition.R\",  #>             requestCore.Rd = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             reset.Rd = \"R/core_api-reset.R\", resetWorkers.Rd = \"R/utils_api-plan.R\",  #>             resolve.Rd = \"R/protected_api-resolve.R\", resolved.Rd = \"R/core_api-resolved.R\",  #>             result.Rd = \"R/backend_api-Future-class.R\", run.Rd = \"R/backend_api-Future-class.R\",  #>             save_rds.Rd = \"R/utils-immediateCondition.R\", sequential.Rd = \"R/backend_api-SequentialFutureBackend-class.R\",  #>             sessionDetails.Rd = \"R/utils_api-sessionDetails.R\",  #>             signalConditions.Rd = \"R/protected_api-signalConditions.R\",  #>             sticky_globals.Rd = \"R/utils-sticky_globals.R\", usedCores.Rd = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             value.Rd = \"R/core_api-value.R\", `zzz-future.options.Rd` = \"R/utils-options.R\"),  #>         keywords = list(\"internal\", \"internal\", \"internal\", \"internal\",  #>             \"internal\", \"internal\", \"internal\", \"internal\", character(0),  #>             character(0), \"internal\", \"internal\", character(0),  #>             character(0), character(0), character(0), character(0),  #>             \"internal\", \"internal\", character(0), \"internal\",  #>             character(0), character(0), character(0), \"internal\",  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             \"internal\", character(0), \"internal\", character(0),  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             \"internal\", character(0), character(0)), concepts = list( #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0)),  #>         internal = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,  #>         TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE,  #>         FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE,  #>         FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE,  #>         FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE,  #>         TRUE, FALSE, FALSE), lifecycle = list(NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL)), tutorials = list( #>         name = character(0), file_out = character(0), title = character(0),  #>         pagetitle = character(0), url = character(0)), vignettes = list( #>         name = c(\"future-1-overview\", \"future-2-output\", \"future-3-topologies\",  #>         \"future-4-issues\", \"future-4-non-exportable-objects\",  #>         \"future-5-startup\", \"future-6-future-api-backend-specification\",  #>         \"future-7-for-package-developers\", \"future-8-how-future-is-validated\" #>         ), type = c(\"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\",  #>         \"rmd\", \"rmd\", \"rmd\"), file_in = c(\"vignettes/future-1-overview.Rmd\",  #>         \"vignettes/future-2-output.Rmd\", \"vignettes/future-3-topologies.Rmd\",  #>         \"vignettes/future-4-issues.Rmd\", \"vignettes/future-4-non-exportable-objects.Rmd\",  #>         \"vignettes/future-5-startup.Rmd\", \"vignettes/future-6-future-api-backend-specification.Rmd\",  #>         \"vignettes/future-7-for-package-developers.Rmd\", \"vignettes/future-8-how-future-is-validated.Rmd\" #>         ), file_out = c(\"articles/future-1-overview.html\", \"articles/future-2-output.html\",  #>         \"articles/future-3-topologies.html\", \"articles/future-4-issues.html\",  #>         \"articles/future-4-non-exportable-objects.html\", \"articles/future-5-startup.html\",  #>         \"articles/future-6-future-api-backend-specification.html\",  #>         \"articles/future-7-for-package-developers.html\", \"articles/future-8-how-future-is-validated.html\" #>         ), title = c(\"A Future for R: A Comprehensive Overview\",  #>         \"A Future for R: Text and Message Output\", \"A Future for R: Future Topologies\",  #>         \"A Future for R: Common Issues with Solutions\", \"A Future for R: Non-Exportable Objects\",  #>         \"A Future for R: Controlling Default Future Strategy\",  #>         \"A Future for R: Future API Backend Specification\", \"A Future for R: Best Practices for Package Developers\",  #>         \"A Future for R: How the Future Framework is Validated\" #>         ), description = c(NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_), depth = c(1L, 1L, 1L,  #>         1L, 1L, 1L, 1L, 1L, 1L))), examples = TRUE, run_dont_run = FALSE,  #>     seed = 1014L, lazy = FALSE, override = list(), install = FALSE,  #>     preview = FALSE, new_process = FALSE, devel = FALSE, cli_colors = 16777216L,  #>     hyperlinks = TRUE, pkgdown_internet = TRUE)), envir = base::quote(<environment>),  #>     quote = base::quote(TRUE)) #>  #> [[12]] #> (function (..., cli_colors, hyperlinks, pkgdown_internet)  #> { #>     options(cli.num_colors = cli_colors, cli.hyperlink = hyperlinks,  #>         cli.hyperlink_run = hyperlinks, pkgdown.internet = pkgdown_internet) #>     pkgdown::build_site(...) #> })(pkg = base::quote(list(package = \"future\", version = \"1.34.0-9356\",  #>     src_path = \"/tmp/henrik/RtmpnwMNbc/future\", meta = list(url = \"https://future.futureverse.org\",  #>         home = list(links = list(list(text = \"Roadmap/Milestones\",  #>             href = \"https://github.com/futureverse/future/milestones\"),  #>             list(text = \"The Futureverse Project\", href = \"https://www.futureverse.org/\"),  #>             list(text = \"Futureverse User Forum\", href = \"https://github.com/futureverse/future/discussions\"))),  #>         navbar = list(structure = list(right = c(\"futureverse\",  #>         \"pkgs\", \"cran\", \"github\", \"lightswitch\")), components = list( #>             futureverse = list(icon = \"fas fa-home\", href = \"https://www.futureverse.org/\"),  #>             pkgs = list(text = \"Packages\", menu = list(list(text = \"doFuture (map-reduce)\",  #>                 href = \"https://doFuture.futureverse.org\"), list( #>                 text = \"furrr (map-reduce)\", href = \"https://furrr.futureverse.org\"),  #>                 list(text = \"future\", href = \"https://future.futureverse.org\"),  #>                 list(text = \"future.apply (map-reduce)\", href = \"https://future.apply.futureverse.org\"),  #>                 list(text = \"future.batchtools (backend)\", href = \"https://future.batchtools.futureverse.org\"),  #>                 list(text = \"future.callr (backend)\", href = \"https://future.callr.futureverse.org\"),  #>                 list(text = \"future.mirai (backend)\", href = \"https://future.mirai.futureverse.org\"),  #>                 list(text = \"future.tests\", href = \"https://future.tests.futureverse.org\"),  #>                 list(text = \"globals\", href = \"https://globals.futureverse.org\"),  #>                 list(text = \"listenv\", href = \"https://listenv.futureverse.org\"),  #>                 list(text = \"parallelly\", href = \"https://parallelly.futureverse.org\"),  #>                 list(text = \"progressr\", href = \"https://progressr.futureverse.org\"),  #>                 list(text = \"BiocParallel.FutureParam (experimental)\",  #>                   href = \"https://BiocParallel.FutureParam.futureverse.org\"),  #>                 list(text = \"future.tools (experimental)\", href = \"https://future.tools.futureverse.org\"),  #>                 list(text = \"future.mapreduce (experimental)\",  #>                   href = \"https://future.mapreduce.futureverse.org\"),  #>                 list(text = \"marshal (experimental)\", href = \"https://marshal.futureverse.org\"))),  #>             cran = list(icon = \"fab fa-r-project\", href = \"https://cloud.r-project.org/package=future\"))),  #>         template = list(params = list(docsearch = list(api_key = \"aa6e02fc501886fb0f7c91ac4e300456\",  #>             index_name = \"futureverse\", algoliaOptions = list( #>                 facetFilters = \"project:future\")), ganalytics = \"G-SB3EQSD9FR\"),  #>             bootstrap = 5L, `light-switch` = TRUE)), desc = <environment>,  #>     bs_version = 5L, development = list(destination = \"dev\",  #>         mode = \"default\", version_label = \"muted\", in_dev = FALSE,  #>         prefix = \"\"), prefix = \"\", dst_path = \"/tmp/henrik/RtmpnwMNbc/future/docs\",  #>     lang = \"en\", install_metadata = FALSE, figures = list(dev = \"ragg::agg_png\",  #>         dpi = 96L, dev.args = list(), fig.ext = \"png\", fig.width = 7.29166666666667,  #>         fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839,  #>         bg = NULL, other.parameters = list()), repo = list(url = list( #>         home = \"https://github.com/futureverse/future/\", source = \"https://github.com/futureverse/future/blob/HEAD/\",  #>         issue = \"https://github.com/futureverse/future/issues/\",  #>         user = \"https://github.com/\")), topics = list(name = c(`Future-class.Rd` = \"Future-class\",  #>     FutureBackend.Rd = \"ClusterFutureBackend\", FutureCondition.Rd = \"FutureCondition\",  #>     FutureGlobals.Rd = \"FutureGlobals\", FutureResult.Rd = \"FutureResult\",  #>     `MulticoreFuture-class.Rd` = \"MulticoreFuture-class\", `MultiprocessFuture-class.Rd` = \"MultiprocessFuture-class\",  #>     `UniprocessFuture-class.Rd` = \"UniprocessFuture-class\", backtrace.Rd = \"backtrace\",  #>     cluster.Rd = \"cluster\", clusterExportSticky.Rd = \"clusterExportSticky\",  #>     find_references.Rd = \"find_references\", future.Rd = \"future\",  #>     futureAssign.Rd = \"futureAssign\", futureOf.Rd = \"futureOf\",  #>     futureSessionInfo.Rd = \"futureSessionInfo\", futures.Rd = \"futures\",  #>     getExpression.Rd = \"getExpression\", getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>     interrupt.Rd = \"interrupt\", mandelbrot.Rd = \"mandelbrot\",  #>     multicore.Rd = \"multicore\", multisession.Rd = \"multisession\",  #>     nbrOfWorkers.Rd = \"nbrOfWorkers\", nullcon.Rd = \"nullcon\",  #>     plan.Rd = \"plan\", private_length.Rd = \".length\", `re-exports.Rd` = \"re-exports\",  #>     readImmediateConditions.Rd = \"readImmediateConditions\", requestCore.Rd = \"requestCore\",  #>     reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\", resolve.Rd = \"resolve\",  #>     resolved.Rd = \"resolved\", result.Rd = \"result.Future\", run.Rd = \"run.Future\",  #>     save_rds.Rd = \"save_rds\", sequential.Rd = \"sequential\", sessionDetails.Rd = \"sessionDetails\",  #>     signalConditions.Rd = \"signalConditions\", sticky_globals.Rd = \"sticky_globals\",  #>     usedCores.Rd = \"usedCores\", value.Rd = \"value\", `zzz-future.options.Rd` = \"zzz-future.options\" #>     ), file_in = c(\"Future-class.Rd\", \"FutureBackend.Rd\", \"FutureCondition.Rd\",  #>     \"FutureGlobals.Rd\", \"FutureResult.Rd\", \"MulticoreFuture-class.Rd\",  #>     \"MultiprocessFuture-class.Rd\", \"UniprocessFuture-class.Rd\",  #>     \"backtrace.Rd\", \"cluster.Rd\", \"clusterExportSticky.Rd\", \"find_references.Rd\",  #>     \"future.Rd\", \"futureAssign.Rd\", \"futureOf.Rd\", \"futureSessionInfo.Rd\",  #>     \"futures.Rd\", \"getExpression.Rd\", \"getGlobalsAndPackages.Rd\",  #>     \"interrupt.Rd\", \"mandelbrot.Rd\", \"multicore.Rd\", \"multisession.Rd\",  #>     \"nbrOfWorkers.Rd\", \"nullcon.Rd\", \"plan.Rd\", \"private_length.Rd\",  #>     \"re-exports.Rd\", \"readImmediateConditions.Rd\", \"requestCore.Rd\",  #>     \"reset.Rd\", \"resetWorkers.Rd\", \"resolve.Rd\", \"resolved.Rd\",  #>     \"result.Rd\", \"run.Rd\", \"save_rds.Rd\", \"sequential.Rd\", \"sessionDetails.Rd\",  #>     \"signalConditions.Rd\", \"sticky_globals.Rd\", \"usedCores.Rd\",  #>     \"value.Rd\", \"zzz-future.options.Rd\"), file_out = c(\"Future-class.html\",  #>     \"FutureBackend.html\", \"FutureCondition.html\", \"FutureGlobals.html\",  #>     \"FutureResult.html\", \"MulticoreFuture-class.html\", \"MultiprocessFuture-class.html\",  #>     \"UniprocessFuture-class.html\", \"backtrace.html\", \"cluster.html\",  #>     \"clusterExportSticky.html\", \"find_references.html\", \"future.html\",  #>     \"futureAssign.html\", \"futureOf.html\", \"futureSessionInfo.html\",  #>     \"futures.html\", \"getExpression.html\", \"getGlobalsAndPackages.html\",  #>     \"interrupt.html\", \"mandelbrot.html\", \"multicore.html\", \"multisession.html\",  #>     \"nbrOfWorkers.html\", \"nullcon.html\", \"plan.html\", \"private_length.html\",  #>     \"re-exports.html\", \"readImmediateConditions.html\", \"requestCore.html\",  #>     \"reset.html\", \"resetWorkers.html\", \"resolve.html\", \"resolved.html\",  #>     \"result.html\", \"run.html\", \"save_rds.html\", \"sequential.html\",  #>     \"sessionDetails.html\", \"signalConditions.html\", \"sticky_globals.html\",  #>     \"usedCores.html\", \"value.html\", \"zzz-future.options.html\" #>     ), alias = list(`Future-class.Rd` = c(\"Future-class\", \"Future\" #>     ), FutureBackend.Rd = c(\"ClusterFutureBackend\", \"FutureBackend\",  #>     \"launchFuture\", \"listFutures\", \"interruptFuture\", \"validateFutureGlobals\",  #>     \"stopWorkers\", \"MulticoreFutureBackend\", \"MultisessionFutureBackend\",  #>     \"SequentialFutureBackend\"), FutureCondition.Rd = c(\"FutureCondition\",  #>     \"FutureMessage\", \"FutureWarning\", \"FutureError\", \"RngFutureCondition\",  #>     \"RngFutureWarning\", \"RngFutureError\", \"UnexpectedFutureResultError\",  #>     \"GlobalEnvMisuseFutureCondition\", \"GlobalEnvMisuseFutureWarning\",  #>     \"GlobalEnvMisuseFutureError\", \"ConnectionMisuseFutureCondition\",  #>     \"ConnectionMisuseFutureWarning\", \"ConnectionMisuseFutureError\",  #>     \"FutureInterruptError\", \"FutureDroppedError\", \"FutureJournalCondition\" #>     ), FutureGlobals.Rd = c(\"FutureGlobals\", \"as.FutureGlobals\",  #>     \"as.FutureGlobals.FutureGlobals\", \"as.FutureGlobals.Globals\",  #>     \"as.FutureGlobals.list\", \"[.FutureGlobals\", \"c.FutureGlobals\",  #>     \"unique.FutureGlobals\"), FutureResult.Rd = c(\"FutureResult\",  #>     \"as.character.FutureResult\", \"print.FutureResult\"), `MulticoreFuture-class.Rd` = c(\"MulticoreFuture-class\",  #>     \"resolved.MulticoreFuture\"), `MultiprocessFuture-class.Rd` = c(\"MultiprocessFuture-class\",  #>     \"MultiprocessFuture\"), `UniprocessFuture-class.Rd` = c(\"UniprocessFuture-class\",  #>     \"UniprocessFuture\"), backtrace.Rd = \"backtrace\", cluster.Rd = \"cluster\",  #>         clusterExportSticky.Rd = \"clusterExportSticky\", find_references.Rd = c(\"find_references\",  #>         \"assert_no_references\"), future.Rd = c(\"future\", \"futureCall\",  #>         \"minifuture\"), futureAssign.Rd = c(\"futureAssign\", \"%<-%\",  #>         \"%->%\", \"%globals%\", \"%packages%\", \"%seed%\", \"%stdout%\",  #>         \"%conditions%\", \"%lazy%\", \"%label%\", \"%plan%\", \"%tweak%\" #>         ), futureOf.Rd = \"futureOf\", futureSessionInfo.Rd = \"futureSessionInfo\",  #>         futures.Rd = \"futures\", getExpression.Rd = c(\"getExpression\",  #>         \"getExpression.Future\"), getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>         interrupt.Rd = \"interrupt\", mandelbrot.Rd = c(\"mandelbrot\",  #>         \"as.raster.Mandelbrot\", \"plot.Mandelbrot\", \"mandelbrot_tiles\",  #>         \"mandelbrot.matrix\", \"mandelbrot.numeric\"), multicore.Rd = \"multicore\",  #>         multisession.Rd = \"multisession\", nbrOfWorkers.Rd = c(\"nbrOfWorkers\",  #>         \"nbrOfFreeWorkers\"), nullcon.Rd = \"nullcon\", plan.Rd = c(\"plan\",  #>         \"tweak\", \"withPlan\", \"localPlan\"), private_length.Rd = \".length\",  #>         `re-exports.Rd` = c(\"re-exports\", \"as.cluster\", \"availableCores\",  #>         \"availableWorkers\", \"makeClusterPSOCK\", \"supportsMulticore\" #>         ), readImmediateConditions.Rd = c(\"readImmediateConditions\",  #>         \"saveImmediateCondition\"), requestCore.Rd = \"requestCore\",  #>         reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\",  #>         resolve.Rd = \"resolve\", resolved.Rd = \"resolved\", result.Rd = c(\"result.Future\",  #>         \"result\"), run.Rd = c(\"run.Future\", \"run\"), save_rds.Rd = \"save_rds\",  #>         sequential.Rd = c(\"sequential\", \"uniprocess\"), sessionDetails.Rd = \"sessionDetails\",  #>         signalConditions.Rd = \"signalConditions\", sticky_globals.Rd = \"sticky_globals\",  #>         usedCores.Rd = \"usedCores\", value.Rd = c(\"value\", \"value.Future\",  #>         \"value.list\", \"value.listenv\", \"value.environment\"),  #>         `zzz-future.options.Rd` = c(\"zzz-future.options\", \"future.options\",  #>         \"future.startup.script\", \"future.debug\", \"future.demo.mandelbrot.region\",  #>         \"future.demo.mandelbrot.nrow\", \"future.fork.multithreading.enable\",  #>         \"future.globals.maxSize\", \"future.globals.method\", \"future.globals.onMissing\",  #>         \"future.globals.resolve\", \"future.globals.onReference\",  #>         \"future.plan\", \"future.onFutureCondition.keepFuture\",  #>         \"future.resolve.recursive\", \"future.connections.onMisuse\",  #>         \"future.globalenv.onMisuse\", \"future.rng.onMisuse\", \"future.wait.alpha\",  #>         \"future.wait.interval\", \"future.wait.timeout\", \"future.output.windows.reencode\",  #>         \"future.journal\", \"future.globals.objectSize.method\",  #>         \"R_FUTURE_STARTUP_SCRIPT\", \"R_FUTURE_DEBUG\", \"R_FUTURE_DEMO_MANDELBROT_REGION\",  #>         \"R_FUTURE_DEMO_MANDELBROT_NROW\", \"R_FUTURE_FORK_MULTITHREADING_ENABLE\",  #>         \"R_FUTURE_GLOBALS_MAXSIZE\", \"R_FUTURE_GLOBALS_METHOD\",  #>         \"R_FUTURE_GLOBALS_ONMISSING\", \"R_FUTURE_GLOBALS_RESOLVE\",  #>         \"R_FUTURE_GLOBALS_ONREFERENCE\", \"R_FUTURE_PLAN\", \"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\",  #>         \"R_FUTURE_RESOLVE_RECURSIVE\", \"R_FUTURE_CONNECTIONS_ONMISUSE\",  #>         \"R_FUTURE_GLOBALENV_ONMISUSE\", \"R_FUTURE_RNG_ONMISUSE\",  #>         \"R_FUTURE_WAIT_ALPHA\", \"R_FUTURE_WAIT_INTERVAL\", \"R_FUTURE_WAIT_TIMEOUT\",  #>         \"R_FUTURE_RESOLVED_TIMEOUT\", \"R_FUTURE_OUTPUT_WINDOWS_REENCODE\",  #>         \"R_FUTURE_JOURNAL\", \"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\",  #>         \"future.cmdargs\", \".future.R\")), funs = list(`Future-class.Rd` = \"Future()\",  #>         FutureBackend.Rd = c(\"ClusterFutureBackend()\", \"FutureBackend()\",  #>         \"launchFuture()\", \"listFutures()\", \"interruptFuture()\",  #>         \"validateFutureGlobals()\", \"stopWorkers()\", \"MulticoreFutureBackend()\",  #>         \"MultisessionFutureBackend()\", \"SequentialFutureBackend()\" #>         ), FutureCondition.Rd = c(\"FutureCondition()\", \"FutureMessage()\",  #>         \"FutureWarning()\", \"FutureError()\", \"RngFutureCondition()\",  #>         \"RngFutureWarning()\", \"RngFutureError()\", \"UnexpectedFutureResultError()\",  #>         \"GlobalEnvMisuseFutureCondition()\", \"GlobalEnvMisuseFutureWarning()\",  #>         \"GlobalEnvMisuseFutureError()\", \"ConnectionMisuseFutureCondition()\",  #>         \"ConnectionMisuseFutureWarning()\", \"ConnectionMisuseFutureError()\",  #>         \"FutureInterruptError()\", \"FutureDroppedError()\", \"FutureJournalCondition()\" #>         ), FutureGlobals.Rd = \"FutureGlobals()\", FutureResult.Rd = c(\"FutureResult()\",  #>         \"as.character(<i>&lt;FutureResult&gt;<\/i>)\", \"print(<i>&lt;FutureResult&gt;<\/i>)\" #>         ), `MulticoreFuture-class.Rd` = \"resolved(<i>&lt;MulticoreFuture&gt;<\/i>)\",  #>         `MultiprocessFuture-class.Rd` = \"MultiprocessFuture()\",  #>         `UniprocessFuture-class.Rd` = \"UniprocessFuture()\", backtrace.Rd = \"backtrace()\",  #>         cluster.Rd = \"cluster()\", clusterExportSticky.Rd = \"clusterExportSticky()\",  #>         find_references.Rd = c(\"find_references()\", \"assert_no_references()\" #>         ), future.Rd = c(\"future()\", \"futureCall()\", \"minifuture()\" #>         ), futureAssign.Rd = c(\"futureAssign()\", \"`%&lt;-%`\",  #>         \"`%globals%`\", \"`%packages%`\", \"`%seed%`\", \"`%stdout%`\",  #>         \"`%conditions%`\", \"`%lazy%`\", \"`%label%`\", \"`%plan%`\",  #>         \"`%tweak%`\"), futureOf.Rd = \"futureOf()\", futureSessionInfo.Rd = \"futureSessionInfo()\",  #>         futures.Rd = \"futures()\", getExpression.Rd = \"getExpression()\",  #>         getGlobalsAndPackages.Rd = \"getGlobalsAndPackages()\",  #>         interrupt.Rd = \"interrupt()\", mandelbrot.Rd = \"mandelbrot()\",  #>         multicore.Rd = \"multicore()\", multisession.Rd = \"multisession()\",  #>         nbrOfWorkers.Rd = c(\"nbrOfWorkers()\", \"nbrOfFreeWorkers()\" #>         ), nullcon.Rd = \"nullcon()\", plan.Rd = c(\"plan()\", \"tweak()\",  #>         \"withPlan()\", \"localPlan()\"), private_length.Rd = \".length()\",  #>         `re-exports.Rd` = character(0), readImmediateConditions.Rd = c(\"readImmediateConditions()\",  #>         \"saveImmediateCondition()\"), requestCore.Rd = \"requestCore()\",  #>         reset.Rd = \"reset()\", resetWorkers.Rd = \"resetWorkers()\",  #>         resolve.Rd = \"resolve()\", resolved.Rd = \"resolved()\",  #>         result.Rd = \"result(<i>&lt;Future&gt;<\/i>)\", run.Rd = \"run(<i>&lt;Future&gt;<\/i>)\",  #>         save_rds.Rd = \"save_rds()\", sequential.Rd = \"sequential()\",  #>         sessionDetails.Rd = \"sessionDetails()\", signalConditions.Rd = \"signalConditions()\",  #>         sticky_globals.Rd = \"sticky_globals()\", usedCores.Rd = \"usedCores()\",  #>         value.Rd = \"value()\", `zzz-future.options.Rd` = character(0)),  #>         title = c(`Future-class.Rd` = \"A future represents a value that will be available at some point in the future\",  #>         FutureBackend.Rd = \"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster\",  #>         FutureCondition.Rd = \"A condition (message, warning, or error) that occurred while orchestrating a future\",  #>         FutureGlobals.Rd = \"A representation of a set of globals used with futures\",  #>         FutureResult.Rd = \"Results from resolving a future\",  #>         `MulticoreFuture-class.Rd` = \"A multicore future is a future whose value will be resolved asynchronously in a parallel process\",  #>         `MultiprocessFuture-class.Rd` = \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\",  #>         `UniprocessFuture-class.Rd` = \"An uniprocess future is a future whose value will be resolved synchronously in the current process\",  #>         backtrace.Rd = \"Back trace the expressions evaluated when an error was caught\",  #>         cluster.Rd = \"Create a cluster future whose value will be resolved asynchronously in a parallel process\",  #>         clusterExportSticky.Rd = \"Export globals to the sticky-globals environment of the cluster nodes\",  #>         find_references.Rd = \"Get the first or all references of an <span style=\\\"R\\\">R<\/span> object\",  #>         future.Rd = \"Create a future\", futureAssign.Rd = \"Create a future assignment\",  #>         futureOf.Rd = \"Get the future of a future variable\",  #>         futureSessionInfo.Rd = \"Get future-specific session information and validate current backend\",  #>         futures.Rd = \"Get all futures in a container\", getExpression.Rd = \"Inject code for the next type of future to use for nested futures\",  #>         getGlobalsAndPackages.Rd = \"Retrieves global variables of an expression and their associated packages\",  #>         interrupt.Rd = \"Interrupts a running future\", mandelbrot.Rd = \"Mandelbrot convergence counts\",  #>         multicore.Rd = \"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\",  #>         multisession.Rd = \"Create a multisession future whose value will be resolved asynchronously in a parallel <span style=\\\"R\\\">R<\/span> session\",  #>         nbrOfWorkers.Rd = \"Get the number of workers available\",  #>         nullcon.Rd = \"Creates a connection to the system null device\",  #>         plan.Rd = \"Plan how to resolve a future\", private_length.Rd = \"Gets the length of an object without dispatching\",  #>         `re-exports.Rd` = \"Functions Moved to 'parallelly'\",  #>         readImmediateConditions.Rd = \"Writes and Reads 'immediateCondition' RDS Files\",  #>         requestCore.Rd = \"Request a core for multicore processing\",  #>         reset.Rd = \"Reset a finished, failed, or interrupted future to a lazy future\",  #>         resetWorkers.Rd = \"Free up active background workers\",  #>         resolve.Rd = \"Resolve one or more futures synchronously\",  #>         resolved.Rd = \"Check whether a future is resolved or not\",  #>         result.Rd = \"Get the results of a resolved future\", run.Rd = \"Run a future\",  #>         save_rds.Rd = \"Robustly Saves an Object to RDS File Atomically\",  #>         sequential.Rd = \"Create a sequential future whose value will be in the current <span style=\\\"R\\\">R<\/span> session\",  #>         sessionDetails.Rd = \"Outputs details on the current <span style=\\\"R\\\">R<\/span> session\",  #>         signalConditions.Rd = \"Signals Captured Conditions\",  #>         sticky_globals.Rd = \"Place a sticky-globals environment immediately after the global environment\",  #>         usedCores.Rd = \"Get number of cores currently used\",  #>         value.Rd = \"The value of a future or the values of all elements in a container\",  #>         `zzz-future.options.Rd` = \"Options used for futures\"),  #>         rd = list(`Future-class.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>             \"\\n\", list(\"Future-class\"), \"\\n\", list(\"Future-class\"),  #>             \"\\n\", list(\"Future\"), \"\\n\", list(\"A future represents a value that will be available at some point in the future\"),  #>             \"\\n\", list(\"\\n\", \"Future(\\n\", \"  expr = NULL,\\n\",  #>                 \"  envir = parent.frame(),\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  stdout = TRUE,\\n\", \"  conditions = \\\"condition\\\",\\n\",  #>                 \"  globals = list(),\\n\", \"  packages = NULL,\\n\",  #>                 \"  seed = FALSE,\\n\", \"  lazy = FALSE,\\n\", \"  gc = FALSE,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  label = NULL,\\n\",  #>                 \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                 \"expr\"), list(\"An \", list(), \" \", list(\"expression\"),  #>                 \".\")), \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The \",  #>                 list(\"environment\"), \" from where global objects should be\\n\",  #>                 \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                 list(\"If TRUE, argument \", list(\"expr\"), \" is\\n\",  #>                   list(list(\"substitute\"), \"()\"), \":ed, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of conditions classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherits from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression does neither\\n\",  #>                   \"need nor use random numbers generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements of the future.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"Future()\"), \" returns an object of class \",  #>                 list(\"Future\"), \".\\n\"), \"\\n\", list(\"\\n\", \"A \",  #>                 list(\"future\"), \" is an abstraction for a \",  #>                 list(\"value\"), \" that may\\n\", \"available at some point in the future.  A future can either be\\n\",  #>                 list(\"unresolved\"), \" or \", list(\"resolved\"),  #>                 \", a state which can be checked\\n\", \"with \",  #>                 list(list(\"resolved()\")), \".  As long as it is \",  #>                 list(\"unresolved\"), \", the\\n\", \"value is not available.  As soon as it is \",  #>                 list(\"resolved\"), \", the value\\n\", \"is available via \",  #>                 list(list(\"value\"), \"()\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A Future object is itself an \", list(\"environment\"),  #>                 \".\\n\"), \"\\n\", list(\"\\n\", \"One function that creates a Future is \",  #>                 list(list(\"future()\")), \".\\n\", \"It returns a Future that evaluates an \",  #>                 list(), \" expression in the future.\\n\", \"An alternative approach is to use the \",  #>                 list(list(\"%<-%\")), \" infix\\n\", \"assignment operator, which creates a future from the\\n\",  #>                 \"right-hand-side (RHS) \", list(), \" expression and assigns its future value\\n\",  #>                 \"to a variable as a \", list(list(\"promise\")),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureBackend.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-ClusterFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-FutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-MulticoreFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-MultisessionFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-SequentialFutureBackend-class.R\",  #>             \"\\n\", list(\"ClusterFutureBackend\"), \"\\n\", list(\"ClusterFutureBackend\"),  #>             \"\\n\", list(\"FutureBackend\"), \"\\n\", list(\"launchFuture\"),  #>             \"\\n\", list(\"listFutures\"), \"\\n\", list(\"interruptFuture\"),  #>             \"\\n\", list(\"validateFutureGlobals\"), \"\\n\", list(\"stopWorkers\"),  #>             \"\\n\", list(\"MulticoreFutureBackend\"), \"\\n\", list( #>                 \"MultisessionFutureBackend\"), \"\\n\", list(\"SequentialFutureBackend\"),  #>             \"\\n\", list(\"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster\"),  #>             \"\\n\", list(\"\\n\", \"ClusterFutureBackend(\\n\", \"  workers = availableWorkers(),\\n\",  #>                 \"  persistent = FALSE,\\n\", \"  gc = TRUE,\\n\",  #>                 \"  earlySignal = TRUE,\\n\", \"  interrupts = TRUE,\\n\",  #>                 \"  ...\\n\", \")\\n\", \"\\n\", \"FutureBackend(\\n\", \"  ...,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  gc = FALSE,\\n\",  #>                 \"  maxSizeOfObjects = getOption(\\\"future.globals.maxSize\\\", +Inf),\\n\",  #>                 \"  interrupts = TRUE,\\n\", \"  hooks = FALSE\\n\",  #>                 \")\\n\", \"\\n\", \"launchFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"listFutures(backend, ...)\\n\", \"\\n\", \"interruptFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"validateFutureGlobals(backend, future, ...)\\n\",  #>                 \"\\n\", \"stopWorkers(backend, ...)\\n\", \"\\n\", \"MulticoreFutureBackend(\\n\",  #>                 \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                 \"  maxSizeOfObjects = +Inf,\\n\", \"  ...\\n\", \")\\n\",  #>                 \"\\n\", \"MultisessionFutureBackend(workers = availableCores(), ...)\\n\",  #>                 \"\\n\", \"SequentialFutureBackend(..., maxSizeOfObjects = +Inf)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"workers\"), list(\"...\")),  #>                 \"\\n\", \"\\n\", list(list(\"persistent\"), list(\"(deprecated) ...\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"Overrides the default behavior of whether futures should trigger\\n\",  #>                   \"garbage collection via \", list(list(\"gc()\")),  #>                   \" on the parallel worker after the value has\\n\",  #>                   \"been collected from the worker.\\n\", \"This can help to release memory sooner than letting R itself on the parallel\\n\",  #>                   \"worker decided when it is needed. Releasing memory sooner can help to fit\\n\",  #>                   \"more parallel workers on a machine with limited amount of total memory.\\n\",  #>                   \"(Default: \", list(\"FALSE\"), \")\")), \"\\n\", \"\\n\",  #>                 list(list(\"earlySignal\"), list(\"Overrides the default behavior on whether futures\\n\",  #>                   \"should resignal (\\\"relay\\\") conditions captured as soon as possible, or\\n\",  #>                   \"delayed, for instance, until \", list(list( #>                     \"value()\")), \" is called on the future.\\n\",  #>                   \"(Default: \", list(\"FALSE\"), \")\")), \"\\n\", \"\\n\",  #>                 list(list(\"interrupts\"), list(\"If FALSE, attempts to interrupt futures will not take\\n\",  #>                   \"place on this backend, even if the backend supports it.\")),  #>                 \"\\n\", \"\\n\", list(list(\"maxSizeOfObjects\"), list( #>                   \"The maximum allowed total size, in bytes, of all\\n\",  #>                   \"objects to and from the parallel worker allows.\\n\",  #>                   \"This can help to protect against unexpectedly large data transfers between\\n\",  #>                   \"the parent process and the parallel workers - data that is often transferred\\n\",  #>                   \"over the network, which sometimes also includes the internet. For instance,\\n\",  #>                   \"if you sit at home and have set up a future backend with workers running\\n\",  #>                   \"remotely at your university or company, then you might want to use this\\n\",  #>                   \"protection to avoid transferring giga- or terabytes of data without noticing.\\n\",  #>                   \"(Default: \", list(list(\"500 \\\\cdot 1024^2\")),  #>                   \" bytes = 500 MiB, unless overridden by a\\n\",  #>                   \"FutureBackend subclass, or by R option \",  #>                   list(\"future.globals.maxSize\"), \" (sic!))\")),  #>                 \"\\n\", \"\\n\", list(list(\"backend\"), list(\"a \",  #>                   list(\"FutureBackend\"), \".\")), \"\\n\", \"\\n\", list( #>                   list(\"future\"), list(\"a \", list(\"Future\"),  #>                     \" to be started.\")), \"\\n\", \"\\n\", list(list( #>                   list()), list(\"(optional) not used.\")), \"\\n\"),  #>             \"\\n\", list(\"\\n\", list(\"FutureBackend()\"), \" returns a FutureBackend object, which inherits an\\n\",  #>                 \"environment. Specific future backends are defined by subclasses\\n\",  #>                 \"implementing the FutureBackend API.\\n\", \"\\n\",  #>                 list(\"launchFuture()\"), \" returns the launched \",  #>                 list(\"Future\"), \" object.\\n\", \"\\n\", list(\"interruptFuture()\"),  #>                 \" returns the interrupted \", list(\"Future\"),  #>                 \" object,\\n\", \"if supported, other the unmodified future.\\n\",  #>                 \"\\n\", list(\"stopWorkers()\"), \" returns TRUE if the workers were shut down,\\n\",  #>                 \"otherwise FALSE.\\n\"), \"\\n\", list(\"\\n\", \"A ClusterFutureBackend resolves futures in parallel using any PSOCK cluster\\n\",  #>                 \"\\n\", \"Configure a backend that controls how and where futures are evaluated\\n\",  #>                 \"\\n\", list(\"launchFuture()\"), \" runs a future on the backend.\\n\",  #>                 \"\\n\", list(\"interruptFuture()\"), \" interrupts a future on the backend.\\n\",  #>                 \"\\n\", list(\"stopWorkers()\"), \" stops backend workers\\n\",  #>                 \"\\n\", \"A MulticoreFutureBackend resolves futures in parallel using forked processing on the current machine\\n\",  #>                 \"\\n\", \"A MultisessionFutureBackend resolves futures in parallel using a PSOCK cluster on the current machine\\n\",  #>                 \"\\n\", \"A SequentialFutureBackend resolves futures sequentially in the current R session\\n\"),  #>             \"\\n\", list(\"\\n\", \"The \", list(\"ClusterFutureBackend\"),  #>                 \" is selected by\\n\", list(\"plan(cluster, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MulticoreFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multicore, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MultisessionFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multisession, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"SequentialFutureBackend\"),  #>                 \" is selected by \", list(\"plan(sequential)\"),  #>                 \".\\n\"), \"\\n\", list(list(\"The FutureBackend API\"),  #>                 list(\"\\n\", \"\\n\", \"The \", list(\"FutureBackend\"),  #>                   \" class specifies FutureBackend API,\\n\", \"that all backends must implement and comply to. Specifically,\\n\")),  #>             \"\\n\", \"\\n\", list(\"internal\"), \"\\n\"), FutureCondition.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureCondition-class.R,\",  #>             \"\\n\", \"%   R/protected_api-journal.R\", \"\\n\", list( #>                 \"FutureCondition\"), \"\\n\", list(\"FutureCondition\"),  #>             \"\\n\", list(\"FutureMessage\"), \"\\n\", list(\"FutureWarning\"),  #>             \"\\n\", list(\"FutureError\"), \"\\n\", list(\"RngFutureCondition\"),  #>             \"\\n\", list(\"RngFutureWarning\"), \"\\n\", list(\"RngFutureError\"),  #>             \"\\n\", list(\"UnexpectedFutureResultError\"), \"\\n\",  #>             list(\"GlobalEnvMisuseFutureCondition\"), \"\\n\", list( #>                 \"GlobalEnvMisuseFutureWarning\"), \"\\n\", list(\"GlobalEnvMisuseFutureError\"),  #>             \"\\n\", list(\"ConnectionMisuseFutureCondition\"), \"\\n\",  #>             list(\"ConnectionMisuseFutureWarning\"), \"\\n\", list( #>                 \"ConnectionMisuseFutureError\"), \"\\n\", list(\"FutureInterruptError\"),  #>             \"\\n\", list(\"FutureDroppedError\"), \"\\n\", list(\"FutureJournalCondition\"),  #>             \"\\n\", list(\"A condition (message, warning, or error) that occurred while orchestrating a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureCondition(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"FutureMessage(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"FutureWarning(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"FutureError(message, call = NULL, uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"RngFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\", \"\\n\", \"RngFutureWarning(...)\\n\",  #>                 \"\\n\", \"RngFutureError(...)\\n\", \"\\n\", \"UnexpectedFutureResultError(future, hint = NULL)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  globalenv = globalenv,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"GlobalEnvMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"ConnectionMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"ConnectionMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"ConnectionMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"FutureInterruptError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureDroppedError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureJournalCondition(\\n\", \"  message,\\n\",  #>                 \"  journal,\\n\", \"  call = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\"), \"\\n\", list(\"\\n\",  #>                 list(list(\"message\"), list(\"A message condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"call\"), list(\"The call stack that led up to the condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"uuid\"), list(\"A universally unique identifier for the future associated with\\n\",  #>                   \"this FutureCondition.\")), \"\\n\", \"\\n\", list( #>                   list(\"future\"), list(\"The \", list(\"Future\"),  #>                     \" involved.\")), \"\\n\", \"\\n\", list(list(\"hint\"),  #>                   list(\"(optional) A string with a suggestion on what might be wrong.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureCondition which inherits from class\\n\",  #>                 list(\"condition\"), \" and FutureMessage, FutureWarning,\\n\",  #>                 \"and FutureError all inherits from FutureCondition.\\n\",  #>                 \"Moreover, a FutureError inherits from \", list( #>                   \"error\"), \",\\n\", \"a FutureWarning from \", list( #>                   \"warning\"), \", and\\n\", \"a FutureMessage from \",  #>                 list(\"message\"), \".\\n\"), \"\\n\", list(\"\\n\", \"While \",  #>                 list(\"orchestrating\"), \" (creating, launching, querying, collection)\\n\",  #>                 \"futures, unexpected run-time errors (and other types of conditions) may\\n\",  #>                 \"occur.  Such conditions are coerced to a corresponding FutureCondition\\n\",  #>                 \"class to help distinguish them from conditions that occur due to the\\n\",  #>                 list(\"evaluation\"), \" of the future.\\n\"), \"\\n\",  #>             list(\"internal\"), \"\\n\"), FutureGlobals.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureGlobals-class.R\",  #>             \"\\n\", list(\"FutureGlobals\"), \"\\n\", list(\"FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals\"), \"\\n\", list(\"as.FutureGlobals.FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals.Globals\"), \"\\n\", list( #>                 \"as.FutureGlobals.list\"), \"\\n\", list(\"[.FutureGlobals\"),  #>             \"\\n\", list(\"c.FutureGlobals\"), \"\\n\", list(\"unique.FutureGlobals\"),  #>             \"\\n\", list(\"A representation of a set of globals used with futures\"),  #>             \"\\n\", list(\"\\n\", \"FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"A named list.\")),  #>                 \"\\n\", \"\\n\", list(list(\"resolved\"), list(\"A logical indicating whether these globals\\n\",  #>                   \"have been scanned for and resolved futures or not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"total_size\"), list(\"The total size of all globals, if known.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class \",  #>                 list(\"FutureGlobals\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A representation of a set of globals used with futures\\n\"),  #>             \"\\n\", list(\"\\n\", \"This class extends the \", list( #>                 \"Globals\"), \" class by adding\\n\", \"attributes \",  #>                 list(\"resolved\"), \" and \", list(\"total_size\"),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureResult.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureResult-class.R\",  #>             \"\\n\", list(\"FutureResult\"), \"\\n\", list(\"FutureResult\"),  #>             \"\\n\", list(\"as.character.FutureResult\"), \"\\n\", list( #>                 \"print.FutureResult\"), \"\\n\", list(\"Results from resolving a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureResult(\\n\", \"  value = NULL,\\n\",  #>                 \"  visible = TRUE,\\n\", \"  stdout = NULL,\\n\",  #>                 \"  conditions = NULL,\\n\", \"  rng = FALSE,\\n\",  #>                 \"  ...,\\n\", \"  started = .POSIXct(NA_real_),\\n\",  #>                 \"  finished = Sys.time(),\\n\", \"  version = \\\"1.8\\\"\\n\",  #>                 \")\\n\", \"\\n\", list(list(\"as.character\"), list( #>                   \"FutureResult\")), \"(x, ...)\\n\", \"\\n\", list( #>                   list(\"print\"), list(\"FutureResult\")), \"(x, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"value\"), list(\"The value of the future expression.\\n\",  #>                 \"If the expression was not fully resolved (e.g. an error) occurred,\\n\",  #>                 \"the the value is \", list(\"NULL\"), \".\")), \"\\n\",  #>                 \"\\n\", list(list(\"visible\"), list(\"If TRUE, the value was visible, otherwise invisible.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A list of zero or more list elements each containing\\n\",  #>                   \"a captured \", list(\"condition\"), \" and possibly more meta data such as the\\n\",  #>                   \"call stack and a timestamp.\")), \"\\n\", \"\\n\",  #>                 list(list(\"rng\"), list(\"If TRUE, the \", list( #>                   \".Random.seed\"), \" was updated from resolving the\\n\",  #>                   \"future, otherwise not.\")), \"\\n\", \"\\n\", list( #>                   list(\"started, finished\"), list(list(\"POSIXct\"),  #>                     \" timestamps\\n\", \"when the evaluation of the future expression was started and finished.\")),  #>                 \"\\n\", \"\\n\", list(list(\"version\"), list(\"The version format of the results.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional named results to be returned.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureResult.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Results from resolving a future\\n\"),  #>             \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                 list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                 list(\"not\"), \" part of the frontend Future API.\\n\"),  #>             \"\\n\", list(list(\"Note to developers\"), list(\"\\n\",  #>                 \"\\n\", \"The FutureResult structure is \", list( #>                   \"under development\"), \" and may change at anytime,\\n\",  #>                 \"e.g. elements may be renamed or removed.  Because of this, please avoid\\n\",  #>                 \"accessing the elements directly in code.  Feel free to reach out if you need\\n\",  #>                 \"to do so in your code.\\n\")), \"\\n\", \"\\n\", list( #>                 \"internal\"), \"\\n\"), `MulticoreFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>             \"\\n\", list(\"MulticoreFuture-class\"), \"\\n\", list(\"MulticoreFuture-class\"),  #>             \"\\n\", list(\"resolved.MulticoreFuture\"), \"\\n\", list( #>                 \"A multicore future is a future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", list(list(\"resolved\"), list(\"MulticoreFuture\")),  #>                 \"(x, run = TRUE, timeout = NULL, ...)\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"MulticoreFuture()\"), \" returns an object of class \",  #>                 list(\"MulticoreFuture\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A multicore future is a future whose value will be resolved asynchronously in a parallel process\\n\"),  #>             \"\\n\", list(list(\"Usage\"), list(\"\\n\", \"\\n\", \"To use 'multicore' futures, use \",  #>                 list(\"plan(multicore, ...)\"), \", cf. \", list( #>                   \"multicore\"), \".\\n\")), \"\\n\", \"\\n\", list(\"internal\"),  #>             \"\\n\"), `MultiprocessFuture-class.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-MultiprocessFutureBackend-class.R\",  #>             \"\\n\", list(\"MultiprocessFuture-class\"), \"\\n\", list( #>                 \"MultiprocessFuture-class\"), \"\\n\", list(\"MultiprocessFuture\"),  #>             \"\\n\", list(\"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", \"MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":ed, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"MultiprocessFuture()\"), \" returns an object of class \",  #>                 list(\"MultiprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), `UniprocessFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-UniprocessFuture-class.R\",  #>             \"\\n\", list(\"UniprocessFuture-class\"), \"\\n\", list( #>                 \"UniprocessFuture-class\"), \"\\n\", list(\"UniprocessFuture\"),  #>             \"\\n\", list(\"An uniprocess future is a future whose value will be resolved synchronously in the current process\"),  #>             \"\\n\", list(\"\\n\", \"UniprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":ed, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"UniprocessFuture()\"), \" returns an object of class \",  #>                 list(\"UniprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"An uniprocess future is a future whose value will be resolved synchronously in the current process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), backtrace.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/utils_api-backtrace.R\",  #>             \"\\n\", list(\"backtrace\"), \"\\n\", list(\"backtrace\"),  #>             \"\\n\", list(\"Back trace the expressions evaluated when an error was caught\"),  #>             \"\\n\", list(\"\\n\", \"backtrace(future, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A future with a caught error.\")),  #>                 \"\\n\", \"\\n\", list(list(\"envir\"), list(\"the environment where to locate the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"A list with the future's call stack that led up to the error.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Back trace the expressions evaluated when an error was caught\\n\"),  #>             \"\\n\", list(\"\\n\", \"my_log <- function(x) log(x)\\n\",  #>                 \"foo <- function(...) my_log(...)\\n\", \"\\n\", \"f <- future({ foo(\\\"a\\\") })\\n\",  #>                 \"res <- tryCatch({\\n\", \"  v <- value(f)\\n\", \"}, error = function(ex) {\\n\",  #>                 \"  t <- backtrace(f)\\n\", \"  print(t)\\n\", \"})\\n\",  #>                 list(\"\\n\", \"## R CMD check: make sure any open connections are closed afterward\\n\",  #>                   \"if (!inherits(plan(\\\"next\\\"), \\\"sequential\\\")) plan(sequential)\\n\"),  #>                 \"\\n\", \"\\n\"), \"\\n\"), cluster.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-ClusterFutureBackend-class.R\",  #>             \"\\n\", list(\"cluster\"), \"\\n\", list(\"cluster\"), \"\\n\",  #>             list(\"Create a cluster future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", \"cluster(\\n\", \"  ...,\\n\", \"  persistent = FALSE,\\n\",  #>                 \"  workers = availableWorkers(),\\n\", \"  gc = FALSE,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  envir = parent.frame()\\n\",  #>                 \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"persistent\"),  #>                 list(\"If FALSE, the evaluation environment is cleared\\n\",  #>                   \"from objects prior to the evaluation of the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"workers\"), list(\"A \",  #>                   list(list(\"cluster\")), \" object,\\n\", \"a character vector of host names, a positive numeric scalar,\\n\",  #>                   \"or a function.\\n\", \"If a character vector or a numeric scalar, a \",  #>                   list(\"cluster\"), \" object\\n\", \"is created using \",  #>                   list(list(\"makeClusterPSOCK\"), \"(workers)\"),  #>                   \".\\n\", \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\\n\",  #>                   \"The function should return any of the above types.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", \"A ClusterFuture.\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A cluster future is a future that uses cluster evaluation,\\n\",  #>                 \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                   \"parallel in another process\"), \".\\n\"), \"\\n\",  #>             list(\"\\n\", \"This function is \", list(\"not\"), \" meant to be called directly.  Instead, the\\n\",  #>                 \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                   list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                 list(\"# Evaluate futures via a single background R process on the local machine\\n\",  #>                   \"plan(cluster, workers = 1)\\n\", \"\\n\", \"# Evaluate futures via two background R processes on the local machine\\n\",  #>                   \"plan(cluster, workers = 2)\\n\", \"\\n\", \"# Evaluate futures via a single R process on another machine on on the\\n\",  #>                   \"# local area network (LAN)\\n\", \"plan(cluster, workers = \\\"raspberry-pi\\\")\\n\",  #>                   \"\\n\", \"# Evaluate futures via a single R process running on a remote machine\\n\",  #>                   \"plan(cluster, workers = \\\"pi.example.org\\\")\\n\",  #>                   \"\\n\", \"# Evaluate futures via four R processes, one running on the local machine,\\n\",  #>                   \"# two running on LAN machine 'n1' and one on a remote machine\\n\",  #>                   \"plan(cluster, workers = c(\\\"localhost\\\", \\\"n1\\\", \\\"n1\\\", \\\"pi.example.org\\\"))\\n\"),  #>                 list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>             \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use cluster futures\\n\",  #>                 \"cl <- parallel::makeCluster(2, timeout = 60)\\n\",  #>                 \"plan(cluster, workers = cl)\\n\", \"\\n\", \"## A global variable\\n\",  #>                 \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                 \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                 \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A cluster future is evaluated in a separate process.\\n\",  #>                 \"## Regardless, changing the value of a global variable will\\n\",  #>                 \"## not affect the result of the future.\\n\",  #>                 \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                 \"print(v)\\n\", \"stopifnot(v == 0)\\n\", \"\\n\", \"## CLEANUP\\n\",  #>                 \"parallel::stopCluster(cl)\\n\", \"\\n\"), \"\\n\"),  #>             \"\\n\"), clusterExportSticky.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>             \"\\n\", list(\"clusterExportSticky\"), \"\\n\", list(\"clusterExportSticky\"),  #>             \"\\n\", list(\"Export globals to the sticky-globals environment of the cluster nodes\"),  #>             \"\\n\", list(\"\\n\", \"clusterExportSticky(cl, globals)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"cl\"), list(\"(cluster) A cluster object as returned by\\n\",  #>                 list(list(\"parallel::makeCluster()\")), \".\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(list) A named list of sticky globals to be exported.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"(invisible; cluster) The cluster object.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Export globals to the sticky-globals environment of the cluster nodes\\n\"),  #>             \"\\n\", list(\"\\n\", \"This requires that the \", list( #>                 \"future\"), \" package is installed on the cluster\\n\",  #>                 \"nodes.\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), find_references.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/utils-marshalling.R\",  #>             \"\\n\", list(\"find_references\"), \"\\n\", list(\"find_references\"),  #>             \"\\n\", list(\"assert_no_references\"), \"\\n\", list(\"Get the first or all references of an \",  #>                 list(), \" object\"), \"\\n\", list(\"\\n\", \"find_references(x, first_only = FALSE)\\n\",  #>                 \"\\n\", \"assert_no_references(\\n\", \"  x,\\n\", \"  action = c(\\\"error\\\", \\\"warning\\\", \\\"message\\\", \\\"string\\\"),\\n\",  #>                 \"  source = c(\\\"globals\\\", \\\"value\\\")\\n\", \")\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"x\"), list(\"The \", list(),  #>                 \" object to be checked.\")), \"\\n\", \"\\n\", list( #>                 list(\"first_only\"), list(\"If \", list(\"TRUE\"),  #>                   \", only the first reference is returned,\\n\",  #>                   \"otherwise all references.\")), \"\\n\", \"\\n\",  #>                 list(list(\"action\"), list(\"Type of action to take if a reference is found.\")),  #>                 \"\\n\", \"\\n\", list(list(\"source\"), list(\"Is the source of \",  #>                   list(\"x\"), \" the globals or the value of the future?\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"find_references()\"),  #>                 \" returns a list of zero or more references\\n\",  #>                 \"identified.\\n\", \"\\n\", \"If a reference is detected, an informative error, warning, message,\\n\",  #>                 \"or a character string is produced, otherwise \",  #>                 list(\"NULL\"), \" is returned\\n\", \"invisibly.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Get the first or all references of an \",  #>                 list(), \" object\\n\", \"\\n\", \"Assert that there are no references among the identified globals\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), future.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/core_api-future.R, R/utils_api-futureCall.R,\",  #>             \"\\n\", \"%   R/utils_api-minifuture.R\", \"\\n\", list( #>                 \"future\"), \"\\n\", list(\"future\"), \"\\n\", list(\"futureCall\"),  #>             \"\\n\", list(\"minifuture\"), \"\\n\", list(\"Create a future\"),  #>             \"\\n\", list(\"\\n\", \"future(\\n\", \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                 \"  substitute = TRUE,\\n\", \"  lazy = FALSE,\\n\",  #>                 \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\", \"  packages = NULL,\\n\",  #>                 \"  stdout = TRUE,\\n\", \"  conditions = \\\"condition\\\",\\n\",  #>                 \"  label = NULL,\\n\", \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  ...\\n\", \")\\n\", \"\\n\", \"futureCall(\\n\", \"  FUN,\\n\",  #>                 \"  args = list(),\\n\", \"  envir = parent.frame(),\\n\",  #>                 \"  lazy = FALSE,\\n\", \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                 \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                 \"  conditions = \\\"condition\\\",\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  label = NULL,\\n\", \"  gc = FALSE,\\n\", \"  ...\\n\",  #>                 \")\\n\", \"\\n\", \"minifuture(\\n\", \"  expr,\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  globals = NULL,\\n\", \"  packages = NULL,\\n\",  #>                 \"  stdout = NA,\\n\", \"  conditions = NULL,\\n\",  #>                 \"  seed = NULL,\\n\", \"  ...,\\n\", \"  envir = parent.frame()\\n\",  #>                 \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"expr\"), list( #>                 \"An \", list(), \" \", list(\"expression\"), \".\")),  #>                 \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The \",  #>                   list(\"environment\"), \" from where global objects should be\\n\",  #>                   \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                   list(\"If TRUE, argument \", list(\"expr\"), \" is\\n\",  #>                     list(list(\"substitute\"), \"()\"), \":ed, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression does neither\\n\",  #>                   \"need nor use random numbers generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of conditions classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherits from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"FUN\"), list(\"A \", list(\"function\"), \" to be evaluated.\")),  #>                 \"\\n\", \"\\n\", list(list(\"args\"), list(\"A \", list( #>                   \"list\"), \" of arguments passed to function \",  #>                   list(\"FUN\"), \".\")), \"\\n\", \"\\n\", list(list(list()),  #>                   list(\"Additional arguments passed to \", list( #>                     list(\"Future()\")), \".\")), \"\\n\"), \"\\n\", list( #>                 \"\\n\", list(\"future()\"), \" returns \", list(\"Future\"),  #>                 \" that evaluates expression \", list(\"expr\"),  #>                 \".\\n\", \"\\n\", list(\"futureCall()\"), \" returns a \",  #>                 list(\"Future\"), \" that calls function \", list( #>                   \"FUN\"), \" with\\n\", \"arguments \", list(\"args\"),  #>                 \".\\n\", \"\\n\", list(\"minifuture(expr)\"), \" creates a future with minimal overhead, by disabling\\n\",  #>                 \"user-friendly behaviors, e.g. automatic identification of global\\n\",  #>                 \"variables and packages needed, and relaying of output.\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"html\"), list(list(list( #>                 \"logo.png\"), list(\"options: style='float: right;' alt='logo' width='120'\")))),  #>                 \"\\n\", \"Creates a future that evaluates an \",  #>                 list(), \" expression or\\n\", \"a future that calls an \",  #>                 list(), \" function with a set of arguments.\\n\",  #>                 \"How, when, and where these futures are evaluated can be configured\\n\",  #>                 \"using \", list(list(\"plan()\")), \" such that it is evaluated in parallel on,\\n\",  #>                 \"for instance, the current machine, on a remote machine, or via a\\n\",  #>                 \"job queue on a compute cluster.\\n\", \"Importantly, any \",  #>                 list(), \" code using futures remains the same regardless\\n\",  #>                 \"on these settings and there is no need to modify the code when\\n\",  #>                 \"switching from, say, sequential to parallel processing.\\n\"),  #>             \"\\n\", list(\"\\n\", \"The state of a future is either unresolved or resolved.\\n\",  #>                 \"The value of a future can be retrieved using \",  #>                 list(\"v <- \", list(\"value\"), \"(f)\"), \".\\n\", \"Querying the value of a non-resolved future will \",  #>                 list(\"block\"), \" the call\\n\", \"until the future is resolved.\\n\",  #>                 \"It is possible to check whether a future is resolved or not\\n\",  #>                 \"without blocking by using \", list(list(\"resolved\"),  #>                   \"(f)\"), \".\\n\", \"\\n\", \"The \", list(\"futureCall()\"),  #>                 \" function works analogously to\\n\", list(list( #>                   \"do.call\"), \"()\"), \", which calls a function with a set of\\n\",  #>                 \"arguments.  The difference is that \", list(\"do.call()\"),  #>                 \" returns the value of\\n\", \"the call whereas \",  #>                 list(\"futureCall()\"), \" returns a future.\\n\"),  #>             \"\\n\", list(list(\"Eager or lazy evaluation\"), list( #>                 \"\\n\", \"\\n\", \"By default, a future is resolved using \",  #>                 list(\"eager\"), \" evaluation\\n\", \"(\", list(\"lazy = FALSE\"),  #>                 \").  This means that the expression starts to\\n\",  #>                 \"be evaluated as soon as the future is created.\\n\",  #>                 \"\\n\", \"As an alternative, the future can be resolved using \",  #>                 list(\"lazy\"), \"\\n\", \"evaluation (\", list(\"lazy = TRUE\"),  #>                 \").  This means that the expression\\n\", \"will only be evaluated when the value of the future is requested.\\n\",  #>                 list(\"Note that this means that the expression may not be evaluated\\n\",  #>                   \"at all - it is guaranteed to be evaluated if the value is requested\"),  #>                 \".\\n\")), \"\\n\", \"\\n\", list(list(\"Globals used by future expressions\"),  #>                 list(\"\\n\", \"\\n\", \"Global objects (short \", list( #>                   \"globals\"), \") are objects (e.g. variables and\\n\",  #>                   \"functions) that are needed in order for the future expression to be\\n\",  #>                   \"evaluated while not being local objects that are defined by the future\\n\",  #>                   \"expression. For example, in\\n\", list(\"\\n\",  #>                     \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b })\\n\"),  #>                   \"\\n\", \"variable \", list(\"a\"), \" is a global of future assignment \",  #>                   list(\"f\"), \" whereas\\n\", list(\"b\"), \" is a local variable.\\n\",  #>                   \"In order for the future to be resolved successfully (and correctly),\\n\",  #>                   \"all globals need to be gathered when the future is created such that\\n\",  #>                   \"they are available whenever and wherever the future is resolved.\\n\",  #>                   \"\\n\", \"The default behavior (\", list(\"globals = TRUE\"),  #>                   \"),\\n\", \"is that globals are automatically identified and gathered.\\n\",  #>                   \"More precisely, globals are identified via code inspection of the\\n\",  #>                   \"future expression \", list(\"expr\"), \" and their values are retrieved with\\n\",  #>                   \"environment \", list(\"envir\"), \" as the starting point (basically via\\n\",  #>                   list(\"get(global, envir = envir, inherits = TRUE)\"),  #>                   \").\\n\", list(\"In most cases, such automatic collection of globals is sufficient\\n\",  #>                     \"and less tedious and error prone than if they are manually specified\"),  #>                   \".\\n\", \"\\n\", \"However, for full control, it is also possible to explicitly specify\\n\",  #>                   \"exactly which the globals are by providing their names as a character\\n\",  #>                   \"vector.\\n\", \"In the above example, we could use\\n\",  #>                   list(\"\\n\", \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b }, globals = \\\"a\\\")\\n\"),  #>                   \"\\n\", \"\\n\", \"Yet another alternative is to explicitly specify also their values\\n\",  #>                   \"using a named list as in\\n\", list(\"\\n\", \"  a <- 42\\n\",  #>                     \"  f <- future({ b <- 2; a * b }, globals = list(a = a))\\n\"),  #>                   \"\\n\", \"or\\n\", list(\"\\n\", \"  f <- future({ b <- 2; a * b }, globals = list(a = 42))\\n\"),  #>                   \"\\n\", \"\\n\", \"Specifying globals explicitly avoids the overhead added from\\n\",  #>                   \"automatically identifying the globals and gathering their values.\\n\",  #>                   \"Furthermore, if we know that the future expression does not make use\\n\",  #>                   \"of any global variables, we can disable the automatic search for\\n\",  #>                   \"globals by using\\n\", list(\"\\n\", \"  f <- future({ a <- 42; b <- 2; a * b }, globals = FALSE)\\n\"),  #>                   \"\\n\", \"\\n\", \"Future expressions often make use of functions from one or more packages.\\n\",  #>                   \"As long as these functions are part of the set of globals, the future\\n\",  #>                   \"package will make sure that those packages are attached when the future\\n\",  #>                   \"is resolved.  Because there is no need for such globals to be frozen\\n\",  #>                   \"or exported, the future package will not export them, which reduces\\n\",  #>                   \"the amount of transferred objects.\\n\", \"For example, in\\n\",  #>                   list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({ median(x) })\\n\"),  #>                   \"\\n\", \"variable \", list(\"x\"), \" and \", list( #>                     \"median()\"), \" are globals, but only \", list( #>                     \"x\"), \"\\n\", \"is exported whereas \", list( #>                     \"median()\"), \", which is part of the \", list( #>                     \"stats\"), \"\\n\", \"package, is not exported.  Instead it is made sure that the \",  #>                   list(\"stats\"), \"\\n\", \"package is on the search path when the future expression is evaluated.\\n\",  #>                   \"Effectively, the above becomes\\n\", list(\"\\n\",  #>                     \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                     \"    library(stats)\\n\", \"    median(x)\\n\",  #>                     \"  })\\n\"), \"\\n\", \"To manually specify this, one can either do\\n\",  #>                   list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                     \"    median(x)\\n\", \"  }, globals = list(x = x, median = stats::median)\\n\"),  #>                   \"\\n\", \"or\\n\", list(\"\\n\", \"  x <- rnorm(1000)\\n\",  #>                     \"  f <- future({\\n\", \"    library(stats)\\n\",  #>                     \"    median(x)\\n\", \"  }, globals = list(x = x))\\n\"),  #>                   \"\\n\", \"Both are effectively the same.\\n\", \"\\n\",  #>                   \"Although rarely needed, a combination of automatic identification and manual\\n\",  #>                   \"specification of globals is supported via attributes \",  #>                   list(\"add\"), \" (to add\\n\", \"false negatives) and \",  #>                   list(\"ignore\"), \" (to ignore false positives) on value\\n\",  #>                   list(\"TRUE\"), \".  For example, with\\n\", list( #>                     \"globals = structure(TRUE, ignore = \\\"b\\\", add = \\\"a\\\")\"),  #>                   \" any globals\\n\", \"automatically identified except \",  #>                   list(\"b\"), \" will be used in addition to\\n\",  #>                   \"global \", list(\"a\"), \".\\n\")), \"\\n\", \"\\n\",  #>             list(\"\\n\", \"## Evaluate futures in parallel\\n\", \"plan(multisession)\\n\",  #>                 \"\\n\", \"## Data\\n\", \"x <- rnorm(100)\\n\", \"y <- 2 * x + 0.2 + rnorm(100)\\n\",  #>                 \"w <- 1 + x ^ 2\\n\", \"\\n\", \"\\n\", \"## EXAMPLE: Regular assignments (evaluated sequentially)\\n\",  #>                 \"fitA <- lm(y ~ x, weights = w)      ## with offset\\n\",  #>                 \"fitB <- lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                 \"fitC <- {\\n\", \"  w <- 1 + abs(x)  ## Different weights\\n\",  #>                 \"  lm(y ~ x, weights = w)\\n\", \"}\\n\", \"print(fitA)\\n\",  #>                 \"print(fitB)\\n\", \"print(fitC)\\n\", \"\\n\", \"\\n\",  #>                 \"## EXAMPLE: Future assignments (evaluated in parallel)\\n\",  #>                 \"fitA %<-% lm(y ~ x, weights = w)      ## with offset\\n\",  #>                 \"fitB %<-% lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                 \"fitC %<-% {\\n\", \"  w <- 1 + abs(x)\\n\", \"  lm(y ~ x, weights = w)\\n\",  #>                 \"}\\n\", \"print(fitA)\\n\", \"print(fitB)\\n\", \"print(fitC)\\n\",  #>                 \"\\n\", \"\\n\", \"## EXAMPLE: Explicitly create futures (evaluated in parallel)\\n\",  #>                 \"## and retrieve their values\\n\", \"fA <- future( lm(y ~ x, weights = w) )\\n\",  #>                 \"fB <- future( lm(y ~ x - 1, weights = w) )\\n\",  #>                 \"fC <- future({\\n\", \"  w <- 1 + abs(x)\\n\", \"  lm(y ~ x, weights = w)\\n\",  #>                 \"})\\n\", \"fitA <- value(fA)\\n\", \"fitB <- value(fB)\\n\",  #>                 \"fitC <- value(fC)\\n\", \"print(fitA)\\n\", \"print(fitB)\\n\",  #>                 \"print(fitC)\\n\", \"\\n\", list(\"\\n\", \"## Make sure to \\\"close\\\" an multisession workers on Windows\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\", \"## EXAMPLE: futureCall() and do.call()\\n\",  #>                 \"x <- 1:100\\n\", \"y0 <- do.call(sum, args = list(x))\\n\",  #>                 \"print(y0)\\n\", \"\\n\", \"f1 <- futureCall(sum, args = list(x))\\n\",  #>                 \"y1 <- value(f1)\\n\", \"print(y1)\\n\"), \"\\n\", list( #>                 \"\\n\", \"How, when and where futures are resolved is given by the\\n\",  #>                 list(\"future strategy\"), \", which can be set by the end user using the\\n\",  #>                 list(list(\"plan()\")), \" function.  The future strategy must not be\\n\",  #>                 \"set by the developer, e.g. it must not be called within a package.\\n\"),  #>             \"\\n\", list(\"\\n\", \"The future logo was designed by Dan LaBar and tweaked by Henrik Bengtsson.\\n\"),  #>             \"\\n\"), futureAssign.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/delayed_api-futureAssign.R,\",  #>             \"\\n\", \"%   R/infix_api-01-futureAssign_OP.R, R/infix_api-02-globals_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-03-seed_OP.R, R/infix_api-04-stdout_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-05-conditions_OP.R, R/infix_api-06-lazy_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-07-label_OP.R, R/infix_api-08-plan_OP.R,\",  #>             \"\\n\", \"%   R/infix_api-09-tweak_OP.R\", \"\\n\", list( #>                 \"futureAssign\"), \"\\n\", list(\"futureAssign\"),  #>             \"\\n\", list(\"%<-%\"), \"\\n\", list(\"%->%\"), \"\\n\", list( #>                 \"%globals%\"), \"\\n\", list(\"%packages%\"), \"\\n\",  #>             list(\"%seed%\"), \"\\n\", list(\"%stdout%\"), \"\\n\", list( #>                 \"%conditions%\"), \"\\n\", list(\"%lazy%\"), \"\\n\",  #>             list(\"%label%\"), \"\\n\", list(\"%plan%\"), \"\\n\", list( #>                 \"%tweak%\"), \"\\n\", list(\"Create a future assignment\"),  #>             \"\\n\", list(\"\\n\", \"futureAssign(\\n\", \"  x,\\n\", \"  value,\\n\",  #>                 \"  envir = parent.frame(),\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  lazy = FALSE,\\n\", \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                 \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                 \"  conditions = \\\"condition\\\",\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  label = NULL,\\n\", \"  gc = FALSE,\\n\", \"  ...,\\n\",  #>                 \"  assign.env = envir\\n\", \")\\n\", \"\\n\", \"x %<-% value\\n\",  #>                 \"\\n\", \"fassignment %globals% globals\\n\", \"fassignment %packages% packages\\n\",  #>                 \"\\n\", \"fassignment %seed% seed\\n\", \"\\n\", \"fassignment %stdout% capture\\n\",  #>                 \"\\n\", \"fassignment %conditions% capture\\n\", \"\\n\",  #>                 \"fassignment %lazy% lazy\\n\", \"\\n\", \"fassignment %label% label\\n\",  #>                 \"\\n\", \"fassignment %plan% strategy\\n\", \"\\n\",  #>                 \"fassignment %tweak% tweaks\\n\"), \"\\n\", list(\"\\n\",  #>                 list(list(\"x\"), list(\"the name of a future variable, which will hold the value\\n\",  #>                   \"of the future expression (as a promise).\")),  #>                 \"\\n\", \"\\n\", list(list(\"value\"), list(\"An \", list(),  #>                   \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":ed, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression does neither\\n\",  #>                   \"need nor use random numbers generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of conditions classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherits from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"earlySignal\"), list(\"Specified whether conditions should be signaled as soon\\n\",  #>                   \"as possible or not.\")), \"\\n\", \"\\n\", list(list( #>                   \"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                 \"\\n\", \"\\n\", list(list(\"assign.env\"), list(\"The \",  #>                   list(\"environment\"), \" to which the variable\\n\",  #>                   \"should be assigned.\")), \"\\n\", \"\\n\", list(list( #>                   \"fassignment\"), list(\"The future assignment, e.g.\\n\",  #>                   list(\"x %<-% { expr }\"), \".\")), \"\\n\", \"\\n\",  #>                 list(list(\"capture\"), list(\"If TRUE, the standard output will be captured, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"strategy\"), list(\"The mechanism for how the future should be\\n\",  #>                   \"resolved. See \", list(list(\"plan()\")), \" for further details.\")),  #>                 \"\\n\", \"\\n\", list(list(\"tweaks\"), list(\"A named list (or vector) with arguments that\\n\",  #>                   \"should be changed relative to the current strategy.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional arguments passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"futureAssign()\"), \" and \", list( #>                 \"x %<-% expr\"), \" returns the \", list(\"Future\"),  #>                 \" invisibly,\\n\", \"e.g. \", list(\"f <- futureAssign(\\\"x\\\", expr)\"),  #>                 \" and \", list(\"f <- (x %<-% expr)\"), \".\\n\"),  #>             \"\\n\", list(\"\\n\", list(\"x %<-% value\"), \" (also known as a \\\"future assignment\\\") and\\n\",  #>                 list(\"futureAssign(\\\"x\\\", value)\"), \" create a \",  #>                 list(\"Future\"), \" that evaluates the expression\\n\",  #>                 \"(\", list(\"value\"), \") and binds it to variable \",  #>                 list(\"x\"), \" (as a\\n\", list(\"promise\"), \"). The expression is evaluated in parallel\\n\",  #>                 \"in the background. Later on, when \", list(\"x\"),  #>                 \" is first queried, the value of future\\n\", \"is automatically retrieved as it were a regular variable and \",  #>                 list(\"x\"), \" is\\n\", \"materialized as a regular value.\\n\"),  #>             \"\\n\", list(\"\\n\", \"For a future created via a future assignment, \",  #>                 list(\"x %<-% value\"), \" or\\n\", list(\"futureAssign(\\\"x\\\", value)\"),  #>                 \", the value is bound to a promise, which when\\n\",  #>                 \"queried will internally call \", list(list(\"value()\")),  #>                 \"  on the future and which will then\\n\", \"be resolved into a regular variable bound to that value. For example, with\\n\",  #>                 \"future assignment \", list(\"x %<-% value\"), \", the first time variable \",  #>                 list(\"x\"), \" is queried\\n\", \"the call blocks if, and only if, the future is not yet resolved. As soon\\n\",  #>                 \"as it is resolved, and any succeeding queries, querying \",  #>                 list(\"x\"), \" will\\n\", \"immediately give the value.\\n\",  #>                 \"\\n\", \"The future assignment construct \", list( #>                   \"x %<-% value\"), \" is not a formal assignment\\n\",  #>                 \"per se, but a binary infix operator on objects \",  #>                 list(\"x\"), \" and expression \", list(\"value\"),  #>                 \".\\n\", \"However, by using non-standard evaluation, this constructs can emulate an\\n\",  #>                 \"assignment operator similar to \", list(\"x <- value\"),  #>                 \". Due to \", list(), \"'s precedence rules\\n\",  #>                 \"of operators, future expressions often need to be explicitly bracketed,\\n\",  #>                 \"e.g. \", list(\"x %<-% { a + b }\"), \".\\n\"), \"\\n\",  #>             list(list(\"Adjust future arguments of a future assignment\"),  #>                 list(\"\\n\", \"\\n\", \"\\n\", list(list(\"future()\")),  #>                   \" and \", list(list(\"futureAssign()\")), \" take serveral arguments that can be used\\n\",  #>                   \"to explicitly specify what global variables and packages the future should\\n\",  #>                   \"use. They can also be used to override default behaviors of the future,\\n\",  #>                   \"e.g. whether output should be relayed or not. When using a future\\n\",  #>                   \"assignment, these arguments can be specified via corresponding\\n\",  #>                   \"assignment expression.  For example, \", list( #>                     \"x %<-% { rnorm(10) } %seed% TRUE\"), \"\\n\",  #>                   \"corresponds to \", list(\"futureAssign(\\\"x\\\", { rnorm(10) }, seed = TRUE)\"),  #>                   \". Here are\\n\", \"a several examples.\\n\", \"\\n\",  #>                   \"To explicitly specify variables and functions that a future assignment\\n\",  #>                   \"should use, use \", list(\"%globals%\"), \". To explicitly specify which packages need\\n\",  #>                   \"to be attacheed for the evaluate to success, use \",  #>                   list(\"%packages%\"), \". For\\n\", \"example,\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x <- rnorm(1000)\\n\", \"> y %<-% { median(x) } %globals% list(x = x) %packages% \\\"stats\\\"\\n\",  #>                     \"> y\\n\", \"[1] -0.03956372\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"The \", list(\"median()\"), \" function is part of the 'stats' package.\\n\",  #>                   \"\\n\", \"To declare that you will generate random numbers, use \",  #>                   list(\"%seed%\"), \", e.g.\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { rnorm(3) } %seed% TRUE\\n\",  #>                     \"> x\\n\", \"[1] -0.2590562 -1.2262495  0.8858702\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"To disable relaying of standard output (e.g. \",  #>                   list(\"print()\"), \", \", list(\"cat()\"), \", and\\n\",  #>                   list(\"str()\"), \"), while keeping relaying of conditions (e.g. \",  #>                   list(\"message()\"), \" and\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %stdout% FALSE\\n\",  #>                     \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hi there\\n\",  #>                     \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To disable relaying of conditions, use \",  #>                   list(\"%conditions%\"), \", e.g.\\n\", \"\\n\", list( #>                     list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %conditions% character(0)\\n\",  #>                     \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                     \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { print(1:10); message(\\\"Hello\\\"); 42 } %stdout% FALSE\\n\",  #>                     \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                     \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To create a future without launching in such that it will only be\\n\",  #>                   \"processed if the value is really needed, use \",  #>                   list(\"%lazy%\"), \", e.g.\\n\", \"\\n\", list(list( #>                     \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { Sys.sleep(5); 42 } %lazy% TRUE\\n\",  #>                     \"> y <- sum(1:10)\\n\", \"> system.time(z <- x + y)\\n\",  #>                     \"  user  system elapsed \\n\", \"  0.004   0.000   5.008\\n\",  #>                     \"> z\\n\", \"[1] 97\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\")), \"\\n\", \"\\n\",  #>             list(list(\"Error handling\"), list(\"\\n\", \"\\n\", \"\\n\",  #>                 \"Because future assignments are promises, errors produced by the the\\n\",  #>                 \"future expression will not be signaled until the value of the future is\\n\",  #>                 \"requested. For example, if you create a future assignment that produce\\n\",  #>                 \"an error, you will not be affected by the error until you \\\"touch\\\" the\\n\",  #>                 \"future-assignment variable. For example,\\n\",  #>                 \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                 list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> y <- sum(1:10)\\n\",  #>                   \"> z <- x + y\\n\", \"Error in eval(quote({ : boom\\n\"),  #>                 list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\")),  #>             \"\\n\", \"\\n\", list(list(\"Use alternative future backend for future assignment\"),  #>                 list(\"\\n\", \"\\n\", \"\\n\", \"Futures are evaluated on the future backend that the user has specified\\n\",  #>                   \"by \", list(list(\"plan()\")), \". With regular futures, we can temporarily use another future\\n\",  #>                   \"backend by wrapping our code in \", list(\"[withPlan()]\"),  #>                   \", of temporarily inside a\\n\", \"function using \",  #>                   list(\"[localPlan()]\"), \". To achieve the same for a specific\\n\",  #>                   \"future assignment, use \", list(\"%plan%\"),  #>                   \", e.g.\\n\", \"\\n\", list(list(\"html\"), list(list( #>                     \"<div class=\\\"sourceCode\\\">\"))), list(\"> plan(multisession)\\n\",  #>                     \"> x %<-% { 42 }\\n\", \"> y %<-% { 13 } %plan% sequential\\n\",  #>                     \"> z <- x + y\\n\", \"> z\\n\", \"[1] 55\\n\"), list( #>                     list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"Here \", list(\"x\"), \" is resolved in the background via the \",  #>                   list(\"multisession\"), \" backend,\\n\", \"whereas \",  #>                   list(\"y\"), \" is resolved sequentially in the main R session.\\n\")),  #>             \"\\n\", \"\\n\", list(list(\"Getting the future object of a future assignment\"),  #>                 list(\"\\n\", \"\\n\", \"\\n\", \"The underlying \", list( #>                   \"Future\"), \" of a future variable \", list(\"x\"),  #>                   \" can be retrieved without\\n\", \"blocking using \",  #>                   list(\"f <- \", list(\"futureOf\"), \"(x)\"), \", e.g.\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> f_x <- futureOf(x)\\n\",  #>                     \"> resolved(f_x)\\n\", \"[1] TRUE\\n\", \"> x\\n\",  #>                     \"Error in eval(quote({ : boom\\n\", \"> value(f_x)\\n\",  #>                     \"Error in eval(quote({ : boom\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"Technically, both the future and the variable (promise) are assigned at\\n\",  #>                   \"the same time to environment \", list(\"assign.env\"),  #>                   \" where the name of the future is\\n\", list( #>                     \".future_<name>\"), \".\\n\")), \"\\n\", \"\\n\"),  #>             futureOf.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/delayed_api-futureOf.R\",  #>                 \"\\n\", list(\"futureOf\"), \"\\n\", list(\"futureOf\"),  #>                 \"\\n\", list(\"Get the future of a future variable\"),  #>                 \"\\n\", list(\"\\n\", \"futureOf(\\n\", \"  var = NULL,\\n\",  #>                   \"  envir = parent.frame(),\\n\", \"  mustExist = TRUE,\\n\",  #>                   \"  default = NA,\\n\", \"  drop = FALSE\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"var\"), list(\"the variable.  If NULL, all futures in the\\n\",  #>                   \"environment are returned.\")), \"\\n\", \"\\n\",  #>                   list(list(\"envir\"), list(\"the environment where to search from.\")),  #>                   \"\\n\", \"\\n\", list(list(\"mustExist\"), list(\"If TRUE and the variable does not exists, then\\n\",  #>                     \"an informative error is thrown, otherwise NA is returned.\")),  #>                   \"\\n\", \"\\n\", list(list(\"default\"), list(\"the default value if future was not found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"if TRUE and \",  #>                     list(\"var\"), \" is NULL, then returned list\\n\",  #>                     \"only contains futures, otherwise also \",  #>                     list(\"default\"), \" values.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \" (or \", list( #>                   \"default\"), \").\\n\", \"If \", list(\"var\"), \" is NULL, then a named list of Future:s are returned.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Get the future of a future variable that has been created directly\\n\",  #>                   \"or indirectly via \", list(list(\"future()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"a %<-% { 1 }\\n\",  #>                   \"\\n\", \"f <- futureOf(a)\\n\", \"print(f)\\n\", \"\\n\",  #>                   \"b %<-% { 2 }\\n\", \"\\n\", \"f <- futureOf(b)\\n\",  #>                   \"print(f)\\n\", \"\\n\", \"## All futures\\n\", \"fs <- futureOf()\\n\",  #>                   \"print(fs)\\n\", \"\\n\", \"\\n\", \"## Futures part of environment\\n\",  #>                   \"env <- new.env()\\n\", \"env$c %<-% { 3 }\\n\",  #>                   \"\\n\", \"f <- futureOf(env$c)\\n\", \"print(f)\\n\",  #>                   \"\\n\", \"f2 <- futureOf(c, envir = env)\\n\", \"print(f2)\\n\",  #>                   \"\\n\", \"f3 <- futureOf(\\\"c\\\", envir = env)\\n\",  #>                   \"print(f3)\\n\", \"\\n\", \"fs <- futureOf(envir = env)\\n\",  #>                   \"print(fs)\\n\"), \"\\n\"), futureSessionInfo.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-futureSessionInfo.R\",  #>                 \"\\n\", list(\"futureSessionInfo\"), \"\\n\", list(\"futureSessionInfo\"),  #>                 \"\\n\", list(\"Get future-specific session information and validate current backend\"),  #>                 \"\\n\", list(\"\\n\", \"futureSessionInfo(test = TRUE, anonymize = TRUE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"test\"), list(\"If TRUE, one or more futures are created to query workers\\n\",  #>                   \"and validate their information.\")), \"\\n\",  #>                   \"\\n\", list(list(\"anonymize\"), list(\"If TRUE, user names and host names are anonymized.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Nothing.\\n\"), \"\\n\",  #>                 list(\"\\n\", \"Get future-specific session information and validate current backend\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession, workers = 2)\\n\",  #>                   \"futureSessionInfo()\\n\", \"plan(sequential)\\n\"),  #>                 \"\\n\"), futures.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-futures.R\",  #>                 \"\\n\", list(\"futures\"), \"\\n\", list(\"futures\"),  #>                 \"\\n\", list(\"Get all futures in a container\"),  #>                 \"\\n\", list(\"\\n\", \"futures(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"An environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"An object of same type as \",  #>                   list(\"x\"), \" and with the same names\\n\", \"and/or dimensions, if set.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets all futures in an environment, a list, or a list environment\\n\",  #>                   \"and returns an object of the same class (and dimensions).\\n\",  #>                   \"Non-future elements are returned as is.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is useful for retrieve futures that were created via\\n\",  #>                   \"future assignments (\", list(\"%<-%\"), \") and therefore stored as promises.\\n\",  #>                   \"This function turns such promises into standard \",  #>                   list(\"Future\"), \"\\n\", \"objects.\\n\"), \"\\n\"),  #>             getExpression.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"getExpression\"), \"\\n\", list(\"getExpression\"),  #>                 \"\\n\", list(\"getExpression.Future\"), \"\\n\", list( #>                   \"Inject code for the next type of future to use for nested futures\"),  #>                 \"\\n\", list(\"\\n\", \"getExpression(future, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"Current future.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A future expression with code injected to set what\\n\",  #>                   \"type of future to use for nested futures, iff any.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Inject code for the next type of future to use for nested futures\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If no next future strategy is specified, the default is to\\n\",  #>                   \"use \", list(\"sequential\"), \" futures.  This conservative approach protects\\n\",  #>                   \"against spawning off recursive futures by mistake, especially\\n\",  #>                   list(\"multicore\"), \" and \", list(\"multisession\"),  #>                   \" ones.\\n\", \"The default will also set \", list( #>                     \"options(mc.cores = 1L)\"), \" (*) so that\\n\",  #>                   \"no parallel \", list(), \" processes are spawned off by functions such as\\n\",  #>                   list(\"parallel::mclapply()\"), \" and friends.\\n\",  #>                   \"\\n\", \"Currently it is not possible to specify what type of nested\\n\",  #>                   \"futures to be used, meaning the above default will always be\\n\",  #>                   \"used.\\n\", \"See \", list(list(\"https://github.com/futureverse/future/issues/37\"),  #>                     list(\"Issue #37\")), \"\\n\", \"for plans on adding support for custom nested future types.\\n\",  #>                   \"\\n\", \"(*) Ideally we would set \", list(\"mc.cores = 0\"),  #>                   \" but that will unfortunately\\n\", \"cause \",  #>                   list(\"mclapply()\"), \" and friends to generate an error saying\\n\",  #>                   \"\\\"'mc.cores' must be >= 1\\\".  Ideally those functions should\\n\",  #>                   \"fall back to using the non-multicore alternative in this\\n\",  #>                   \"case, e.g. \", list(\"mclapply(...)\"), \" => \",  #>                   list(\"lapply(...)\"), \".\\n\", \"See \", list(\"https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7\"),  #>                   \"\\n\", \"for a discussion on this.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), getGlobalsAndPackages.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-globals.R\",  #>                 \"\\n\", list(\"getGlobalsAndPackages\"), \"\\n\", list( #>                   \"getGlobalsAndPackages\"), \"\\n\", list(\"Retrieves global variables of an expression and their associated packages\"),  #>                 \"\\n\", list(\"\\n\", \"getGlobalsAndPackages(\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  tweak = tweakExpression,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  locals = getOption(\\\"future.globals.globalsOf.locals\\\", TRUE),\\n\",  #>                   \"  resolve = getOption(\\\"future.globals.resolve\\\"),\\n\",  #>                   \"  persistent = FALSE,\\n\", \"  maxSize = getOption(\\\"future.globals.maxSize\\\", 500 * 1024^2),\\n\",  #>                   \"  onReference = getOption(\\\"future.globals.onReference\\\", \\\"ignore\\\"),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"expr\"), list(\"An \", list(), \" expression whose globals should be found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The environment from which globals should be searched.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tweak\"), list(\"(optional) A function that takes an expression and returned a modified one.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, a named list, or a \",  #>                     list(\"Globals\"), \" object.  If TRUE, globals are identified by code inspection based on \",  #>                     list(\"expr\"), \" and \", list(\"tweak\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If FALSE, no globals are used.  If a character vector, then globals are identified by lookup based their names \",  #>                     list(\"globals\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If a named list or a Globals object, the globals are used as is.\")),  #>                   \"\\n\", \"\\n\", list(list(\"locals\"), list(\"Should globals part of any \\\"local\\\" environment of\\n\",  #>                     \"a function be included or not?\")), \"\\n\",  #>                   \"\\n\", list(list(\"resolve\"), list(\"If TRUE, any future that is a global variables (or part of one) is resolved and replaced by a \\\"constant\\\" future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"persistent\"), list(\"If TRUE, non-existing globals (= identified in expression but not found in memory) are always silently ignored and assumed to be existing in the evaluation environment.  If FALSE, non-existing globals are by default ignore, but may also trigger an informative error if option \",  #>                     list(\"future.globals.onMissing\"), \" in \",  #>                     list(\"\\\"error\\\"\"), \" (should only be used for troubleshooting).\")),  #>                   \"\\n\", \"\\n\", list(list(\"maxSize\"), list(\"The maximum allowed total size (in bytes) of globals---for\\n\",  #>                     \"the purpose of preventing too large exports / transfers happening by\\n\",  #>                     \"mistake.  If the total size of the global objects are greater than this\\n\",  #>                     \"limit, an informative error message is produced. If\\n\",  #>                     list(\"maxSize = +Inf\"), \", then this assertion is skipped. (Default: 500 MiB).\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A named list with elements \",  #>                   list(\"expr\"), \" (the tweaked expression), \",  #>                   list(\"globals\"), \" (a named list of class \",  #>                   list(\"FutureGlobals\"), \") and \", list(\"packages\"),  #>                   \" (a character string).\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Retrieves global variables of an expression and their associated packages\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Internally, \", list(list(\"globalsOf\"),  #>                   \"()\"), \" is used to identify globals and associated packages from the expression.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), interrupt.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-interrupt.R\",  #>                 \"\\n\", list(\"interrupt\"), \"\\n\", list(\"interrupt\"),  #>                 \"\\n\", list(\"Interrupts a running future\"), \"\\n\",  #>                 list(\"\\n\", \"interrupt(x, ...)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"A Future.\")), \"\\n\",  #>                   \"\\n\", list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"interrupt()\"),  #>                   \" returns the \", list(\"Future\"), \" flagged as \\\"interrupted\\\",\\n\",  #>                   \"if the backend supports interrupting futures.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Attempts to interrupt a running future. If the backend does\\n\",  #>                   \"not support interrupting futures, nothing is done.\\n\"),  #>                 \"\\n\"), mandelbrot.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/demo_api-mandelbrot.R\",  #>                 \"\\n\", list(\"mandelbrot\"), \"\\n\", list(\"mandelbrot\"),  #>                 \"\\n\", list(\"as.raster.Mandelbrot\"), \"\\n\", list( #>                   \"plot.Mandelbrot\"), \"\\n\", list(\"mandelbrot_tiles\"),  #>                 \"\\n\", list(\"mandelbrot.matrix\"), \"\\n\", list(\"mandelbrot.numeric\"),  #>                 \"\\n\", list(\"Mandelbrot convergence counts\"),  #>                 \"\\n\", list(\"\\n\", \"mandelbrot(...)\\n\", \"\\n\", list( #>                   list(\"mandelbrot\"), list(\"matrix\")), \"(Z, maxIter = 200L, tau = 2, ...)\\n\",  #>                   \"\\n\", list(list(\"mandelbrot\"), list(\"numeric\")),  #>                   \"(\\n\", \"  xmid = -0.75,\\n\", \"  ymid = 0,\\n\",  #>                   \"  side = 3,\\n\", \"  resolution = 400L,\\n\",  #>                   \"  maxIter = 200L,\\n\", \"  tau = 2,\\n\", \"  ...\\n\",  #>                   \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"Z\"), list( #>                   \"A complex matrix for which convergence\\n\",  #>                   \"counts should be calculated.\")), \"\\n\", \"\\n\",  #>                   list(list(\"maxIter\"), list(\"Maximum number of iterations per bin.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tau\"), list(\"A threshold; the radius when calling\\n\",  #>                     \"divergence (Mod(z) > tau).\")), \"\\n\", \"\\n\",  #>                   list(list(\"xmid, ymid, side, resolution\"),  #>                     list(\"Alternative specification of\\n\", \"the complex plane \",  #>                       list(\"Z\"), \", where\\n\", list(\"mean(Re(Z)) == xmid\"),  #>                       \",\\n\", list(\"mean(Im(Z)) == ymid\"), \",\\n\",  #>                       list(\"diff(range(Re(Z))) == side\"), \",\\n\",  #>                       list(\"diff(range(Im(Z))) == side\"), \", and\\n\",  #>                       list(\"dim(Z) == c(resolution, resolution)\"),  #>                       \".\")), \"\\n\"), \"\\n\", list(\"\\n\", \"Returns an integer matrix (of class Mandelbrot) with\\n\",  #>                   \"non-negative counts.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Mandelbrot convergence counts\\n\"), \"\\n\", list( #>                   \"\\n\", \"counts <- mandelbrot(xmid = -0.75, ymid = 0, side = 3)\\n\",  #>                   \"str(counts)\\n\", list(\"\\n\", \"plot(counts)\\n\"),  #>                   \"\\n\", \"\\n\", list(\"\\n\", \"demo(\\\"mandelbrot\\\", package = \\\"future\\\", ask = FALSE)\\n\"),  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"The internal Mandelbrot algorithm was inspired by and\\n\",  #>                   \"adopted from similar GPL code of Martin Maechler available\\n\",  #>                   \"from ftp://stat.ethz.ch/U/maechler/R/ on 2005-02-18 (sic!).\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), multicore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"multicore\"), \"\\n\", list(\"multicore\"),  #>                 \"\\n\", list(\"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\"),  #>                 \"\\n\", list(\"\\n\", \"multicore(\\n\", \"  ...,\\n\",  #>                   \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                   \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                   \"  envir = parent.frame()\\n\", \")\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                     \"evaluated the future) only after the value of the future is collected.\\n\",  #>                     \"Exactly when the values are collected may depend on various factors such\\n\",  #>                     \"as number of free workers and whether \",  #>                     list(\"earlySignal\"), \" is TRUE (more\\n\",  #>                     \"frequently) or FALSE (less frequently).\\n\",  #>                     list(\"Some types of futures ignore this argument.\"))),  #>                   \"\\n\", \"\\n\", list(list(\"earlySignal\"), list( #>                     \"Specified whether conditions should be signaled as soon\\n\",  #>                     \"as possible or not.\")), \"\\n\", \"\\n\", list( #>                     list(\"envir\"), list(\"The \", list(\"environment\"),  #>                       \" from where global objects should be\\n\",  #>                       \"identified.\")), \"\\n\", \"\\n\", list(list( #>                     list()), list(\"Additional named elements to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \".\\n\", \"If \",  #>                   list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"sequential future. To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\\n\", \"This is also the case whenever multicore processing is not supported,\\n\",  #>                   \"e.g. on Windows.\\n\"), \"\\n\", list(\"\\n\", \"A multicore future is a future that uses multicore evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another process\"), \".\\n\"), \"\\n\",  #>                 list(\"\\n\", \"This function is \", list(\"not\"),  #>                   \" meant to be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many forked\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multicore)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two forked processes\\n\",  #>                     \"plan(multicore, workers = 2)\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\"), \"\\n\",  #>                 list(list(\"Support for forked (\\\"multicore\\\") processing\"),  #>                   list(\"\\n\", \"\\n\", \"Not all operating systems support process forking and thereby not multicore\\n\",  #>                     \"futures.  For instance, forking is not supported on Microsoft Windows.\\n\",  #>                     \"Moreover, process forking may break some R environments such as RStudio.\\n\",  #>                     \"Because of this, the future package disables process forking also in\\n\",  #>                     \"such cases.  See \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \" for details.\\n\", \"Trying to create multicore futures on non-supported systems or when\\n\",  #>                     \"forking is disabled will result in multicore futures falling back to\\n\",  #>                     \"becoming \", list(\"sequential\"), \" futures.  If used in RStudio, there will be an\\n\",  #>                     \"informative warning:\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"> plan(multicore)\\n\", \"Warning message:\\n\",  #>                       \"In supportsMulticoreAndRStudio(...) :\\n\",  #>                       \"  [ONE-TIME WARNING] Forked processing ('multicore') is not supported when\\n\",  #>                       \"running R from RStudio because it is considered unstable. For more details,\\n\",  #>                       \"how to control forked processing or not, and how to silence this warning in\\n\",  #>                       \"future R sessions, see ?parallelly::supportsMulticore\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(\"\\n\", \"## Use multicore futures\\n\",  #>                   \"plan(multicore)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multicore future is evaluated in a separate forked\\n\",  #>                   \"## process.  Changing the value of a global variable\\n\",  #>                   \"## will not affect the result of the future.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\",  #>                 list(\"\\n\", \"For processing in multiple background \",  #>                   list(), \" sessions, see\\n\", list(\"multisession\"),  #>                   \" futures.\\n\", \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\", \"Use \", list(list(\"availableCores\"),  #>                     \"(\\\"multicore\\\") > 1L\"), \" to check\\n\", \"whether multicore futures are supported or not on the current\\n\",  #>                   \"system.\\n\"), \"\\n\"), multisession.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MultisessionFutureBackend-class.R\",  #>                 \"\\n\", list(\"multisession\"), \"\\n\", list(\"multisession\"),  #>                 \"\\n\", list(\"Create a multisession future whose value will be resolved asynchronously in a parallel \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"multisession(\\n\",  #>                   \"  ...,\\n\", \"  workers = availableCores(),\\n\",  #>                   \"  lazy = FALSE,\\n\", \"  rscript_libs = .libPaths(),\\n\",  #>                   \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                   \"  envir = parent.frame()\\n\", \")\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                     \"eagerly (starting immediately), otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"rscript_libs\"), list( #>                     \"A character vector of \", list(), \" package library folders that\\n\",  #>                     \"the workers should use.  The default is \",  #>                     list(\".libPaths()\"), \" so that multisession\\n\",  #>                     \"workers inherits the same library path as the main \",  #>                     list(), \" session.\\n\", \"To avoid this, use \",  #>                     list(\"plan(multisession, ..., rscript_libs = NULL)\"),  #>                     \".\\n\", list(\"Important: Note that the library path is set on the workers when they are\\n\",  #>                       \"created, i.e. when \", list(\"plan(multisession)\"),  #>                       \" is called.  Any changes to\\n\", list(\".libPaths()\"),  #>                       \" in the main R session after the workers have been created\\n\",  #>                       \"will have no effect.\"), \"\\n\", \"This is passed down as-is to \",  #>                     list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(\"gc\"), list( #>                     \"If TRUE, the garbage collector run (in the process that\\n\",  #>                     \"evaluated the future) only after the value of the future is collected.\\n\",  #>                     \"Exactly when the values are collected may depend on various factors such\\n\",  #>                     \"as number of free workers and whether \",  #>                     list(\"earlySignal\"), \" is TRUE (more\\n\",  #>                     \"frequently) or FALSE (less frequently).\\n\",  #>                     list(\"Some types of futures ignore this argument.\"))),  #>                   \"\\n\", \"\\n\", list(list(\"earlySignal\"), list( #>                     \"Specified whether conditions should be signaled as soon\\n\",  #>                     \"as possible or not.\")), \"\\n\", \"\\n\", list( #>                     list(\"envir\"), list(\"The \", list(\"environment\"),  #>                       \" from where global objects should be\\n\",  #>                       \"identified.\")), \"\\n\", \"\\n\", list(list( #>                     list()), list(\"Additional arguments passed to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A MultisessionFuture.\\n\", \"If \",  #>                   list(\"workers == 1\"), \", then all processing is done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"lazy future.  To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", \"A multisession future is a future that uses multisession evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another \", list(), \" session\"),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"This function is \",  #>                   list(\"not\"), \" meant to be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many background\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multisession)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two background\\n\",  #>                     \"# processes\\n\", \"plan(multisession, workers = 2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"The background \", list(), \" sessions (the \\\"workers\\\") are created using\\n\",  #>                   list(list(\"makeClusterPSOCK()\")), \".\\n\", \"\\n\",  #>                   \"For the total number of\\n\", list(), \" sessions available including the current/main \",  #>                   list(), \" process, see\\n\", list(list(\"parallelly::availableCores()\")),  #>                   \".\\n\", \"\\n\", \"A multisession future is a special type of cluster future.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use multisession futures\\n\",  #>                   \"plan(multisession)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multisession future is evaluated in a separate R session.\\n\",  #>                   \"## Changing the value of a global variable will not affect\\n\",  #>                   \"## the result of the future.\\n\", \"a <- 7\\n\",  #>                   \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\", \"print(v)\\n\",  #>                   \"stopifnot(v == 0)\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\"), \"\\n\", list(\"\\n\",  #>                   \"For processing in multiple forked \", list(),  #>                   \" sessions, see\\n\", list(\"multicore\"), \" futures.\\n\",  #>                   \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\"), \"\\n\"), nbrOfWorkers.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-nbrOfWorkers.R\",  #>                 \"\\n\", list(\"nbrOfWorkers\"), \"\\n\", list(\"nbrOfWorkers\"),  #>                 \"\\n\", list(\"nbrOfFreeWorkers\"), \"\\n\", list(\"Get the number of workers available\"),  #>                 \"\\n\", list(\"\\n\", \"nbrOfWorkers(evaluator = NULL)\\n\",  #>                   \"\\n\", \"nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"evaluator\"), list( #>                   \"A future evaluator function.\\n\", \"If NULL (default), the current evaluator as returned\\n\",  #>                   \"by \", list(list(\"plan()\")), \" is used.\")),  #>                   \"\\n\", \"\\n\", list(list(\"background\"), list(\"If TRUE, only workers that can process a future in the\\n\",  #>                     \"background are considered.  If FALSE, also workers running in the main \",  #>                     list(), \"\\n\", \"process are considered, e.g. when using the 'sequential' backend.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used; reserved for future use.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"nbrOfWorkers()\"),  #>                   \" returns a positive number in \", list(list( #>                     \"{1, 2, 3, ...}\")), \", which\\n\", \"for some future backends may also be \",  #>                   list(\"+Inf\"), \".\\n\", \"\\n\", list(\"nbrOfFreeWorkers()\"),  #>                   \" returns a non-negative number in\\n\", list( #>                     list(\"{0, 1, 2, 3, ...}\")), \" which is less than or equal to \",  #>                   list(\"nbrOfWorkers()\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get the number of workers available\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession)\\n\", \"nbrOfWorkers()  ## == availableCores()\\n\",  #>                   \"\\n\", \"plan(sequential)\\n\", \"nbrOfWorkers()  ## == 1\\n\"),  #>                 \"\\n\"), nullcon.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\"nullcon\"), \"\\n\", list(\"nullcon\"),  #>                 \"\\n\", list(\"Creates a connection to the system null device\"),  #>                 \"\\n\", list(\"\\n\", \"nullcon()\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Returns a open, binary \", list(list(\"base::connection()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Creates a connection to the system null device\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), plan.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R, R/utils_api-tweak.R,\",  #>                 \"\\n\", \"%   R/utils_api-withPlan.R\", \"\\n\", list( #>                   \"plan\"), \"\\n\", list(\"plan\"), \"\\n\", list(\"tweak\"),  #>                 \"\\n\", list(\"withPlan\"), \"\\n\", list(\"localPlan\"),  #>                 \"\\n\", list(\"Plan how to resolve a future\"), \"\\n\",  #>                 list(\"\\n\", \"plan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  ...,\\n\", \"  substitute = TRUE,\\n\", \"  .skip = FALSE,\\n\",  #>                   \"  .call = TRUE,\\n\", \"  .cleanup = NA,\\n\",  #>                   \"  .init = TRUE\\n\", \")\\n\", \"\\n\", \"tweak(strategy, ..., penvir = parent.frame())\\n\",  #>                   \"\\n\", \"withPlan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  .cleanup = NA,\\n\", \"  substitute = TRUE,\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", \"localPlan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  .cleanup = NA,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  ...\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"strategy\"), list( #>                   \"An existing future function or the name of one.\")),  #>                   \"\\n\", \"\\n\", list(list(\"substitute\"), list(\"If \",  #>                     list(\"TRUE\"), \", the \", list(\"strategy\"),  #>                     \" expression is\\n\", list(\"substitute()\"),  #>                     \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\".skip\"), list(\"(internal) If \", list( #>                       \"TRUE\"), \", then attempts to set a strategy\\n\",  #>                       \"that is the same as what is currently in use, will be skipped.\")),  #>                   \"\\n\", \"\\n\", list(list(\".call\"), list(\"(internal) Used for recording the call to this function.\")),  #>                   \"\\n\", \"\\n\", list(list(\".cleanup\"), list(\"(internal) Used to stop implicitly started clusters.\")),  #>                   \"\\n\", \"\\n\", list(list(\".init\"), list(\"(internal) Used to initiate workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"penvir\"), list(\"The environment used when searching for a future\\n\",  #>                     \"function by its name.\")), \"\\n\", \"\\n\", list( #>                     list(\"expr\"), list(\"An R expression to be evaluated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The environment where the future plan should be set and the expression evaluated.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Named arguments to replace the defaults of existing\\n\",  #>                     \"arguments.\")), \"\\n\"), \"\\n\", list(\"\\n\", list( #>                   \"plan()\"), \" returns a the previous plan invisibly if a new strategy\\n\",  #>                   \"is chosen, otherwise it returns the current one visibly.\\n\",  #>                   \"\\n\", \"a future function.\\n\", \"\\n\", list(\"withPlan()\"),  #>                   \" returns the value of the expression evaluated invisibly.\\n\",  #>                   \"\\n\", list(\"localPlan()\"), \" returns the current future plan before applying the temporary one.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function allows \", list( #>                   \"the user\"), \" to plan the future, more specifically,\\n\",  #>                   \"it specifies how \", list(list(\"future()\")),  #>                   \":s are resolved,\\n\", \"e.g. sequentially or in parallel.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The default strategy is \",  #>                   list(list(\"sequential\")), \", but the default can be\\n\",  #>                   \"configured by option \", list(\"future.plan\"),  #>                   \" and, if that is not set,\\n\", \"system environment variable \",  #>                   list(\"R_FUTURE_PLAN\"), \".\\n\", \"To reset the strategy back to the default, use \",  #>                   list(\"plan(\\\"default\\\")\"), \".\\n\"), \"\\n\", list( #>                   list(\"Built-in evaluation strategies\"), list( #>                     \"\\n\", \"\\n\", \"The \", list(\"future\"), \" package provides the following built-in backends:\\n\",  #>                     \"\\n\", list(\"\\n\", list(list(list(list(\"sequential\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures sequentially in the current \",  #>                       list(), \" process, e.g.\\n\", list(\"plan(sequential)\"),  #>                       \".\\n\")), \"\\n\", list(list(list(list(\"multisession\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                       list(), \" sessions running in the background on the same machine, e.g.\\n\",  #>                       list(\"plan(multisession)\"), \" and \", list( #>                         \"plan(multisession, workers = 2)\"), \".\\n\")),  #>                       \"\\n\", list(list(list(list(\"multicore\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(\"forked\"), \" \", list(), \" processes running in the background on\\n\",  #>                         \"the same machine, e.g.\\n\", list(\"plan(multicore)\"),  #>                         \" and \", list(\"plan(multicore, workers = 2)\"),  #>                         \".\\n\", \"This backend is not supported on Windows.\\n\")),  #>                       \"\\n\", list(list(list(list(\"cluster\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(), \" sessions running typically on one or more machines, e.g.\\n\",  #>                         list(\"plan(cluster)\"), \", \", list(\"plan(cluster, workers = 2)\"),  #>                         \", and\\n\", list(\"plan(cluster, workers = c(\\\"n1\\\", \\\"n1\\\", \\\"n2\\\", \\\"server.remote.org\\\"))\"),  #>                         \".\\n\")), \"\\n\"), \"\\n\", \"\\n\", \"Other package provide additional evaluation strategies.\\n\",  #>                     \"For example, the \", list(\"future.callr\"),  #>                     \" package implements an alternative\\n\", \"to the \",  #>                     list(\"multisession\"), \" backend on top of the \",  #>                     list(\"callr\"), \" package, e.g.\\n\", list(\"plan(future.callr::callr, workers = 2)\"),  #>                     \".\\n\", \"Another example is the \", list(\"future.batchtools\"),  #>                     \" package, which implements,\\n\", \"on top of the \",  #>                     list(\"batchtools\"), \" package, e.g.\\n\", list( #>                       \"plan(future.batchtools::batchtools_slurm)\"),  #>                     \".\\n\", \"These types of futures are resolved via job schedulers, which typically\\n\",  #>                     \"are available on high-performance compute (HPC) clusters, e.g. LSF,\\n\",  #>                     \"Slurm, TORQUE/PBS, Sun Grid Engine, and OpenLava.\\n\",  #>                     \"\\n\", \"To \\\"close\\\" any background workers (e.g. \",  #>                     list(\"multisession\"), \"), change\\n\", \"the plan to something different; \",  #>                     list(\"plan(sequential)\"), \" is recommended\\n\",  #>                     \"for this.\\n\")), \"\\n\", \"\\n\", list(list(\"For package developers\"),  #>                   list(\"\\n\", \"\\n\", \"Please refrain from modifying the future strategy inside your packages /\\n\",  #>                     \"functions, i.e. do not call \", list(\"plan()\"),  #>                     \" in your code. Instead, leave\\n\", \"the control on what backend to use to the end user. This idea is part of\\n\",  #>                     \"the core philosophy of the future framework---as a developer you can never\\n\",  #>                     \"know what future backends the user have access to. Moreover, by not making\\n\",  #>                     \"any assumptions about what backends are available, your code will also work\\n\",  #>                     \"automatically with any new backends developed after you wrote your code.\\n\",  #>                     \"\\n\", \"If you think it is necessary to modify the future strategy within a\\n\",  #>                     \"function, then make sure to undo the changes when exiting the function.\\n\",  #>                     \"This can be archived by using \", list(list( #>                       \"localPlan()\")), \", e.g.\\n\", \"\\n\", list( #>                       \"\\n\", \"  my_fcn <- function(x) {\\n\", \"    localPlan(multisession)\\n\",  #>                       \"    y <- analyze(x)\\n\", \"    summarize(y)\\n\",  #>                       \"  }\\n\"), \"\\n\", \"\\n\", \"This is important because the end-user might have already set the future\\n\",  #>                     \"strategy elsewhere for other purposes and will most likely not known that\\n\",  #>                     \"calling your function will break their setup.\\n\",  #>                     list(\"Remember, your package and its functions might be used in a greater\\n\",  #>                       \"context where multiple packages and functions are involved and those might\\n\",  #>                       \"also rely on the future framework, so it is important to avoid stepping on\\n\",  #>                       \"others' toes.\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Using plan() in scripts and vignettes\"),  #>                   list(\"\\n\", \"\\n\", \"When writing scripts or vignettes that use futures, try to place any\\n\",  #>                     \"call to \", list(\"plan()\"), \" as far up (i.e. as early on) in the code as possible.\\n\",  #>                     \"This will help users to quickly identify where the future plan is set up\\n\",  #>                     \"and allow them to modify it to their computational resources.\\n\",  #>                     \"Even better is to leave it to the user to set the \",  #>                     list(\"plan()\"), \" prior to\\n\", list(\"source()\"),  #>                     \":ing the script or running the vignette.\\n\",  #>                     \"If a \", list(list(\".future.R\")), \" exists in the current directory and / or in\\n\",  #>                     \"the user's home directory, it is sourced when the \",  #>                     list(\"future\"), \" package is\\n\", list(\"loaded\"),  #>                     \". Because of this, the \", list(\".future.R\"),  #>                     \" file provides a\\n\", \"convenient place for users to set the \",  #>                     list(\"plan()\"), \".\\n\", \"This behavior can be controlled via an \",  #>                     list(), \" option---see\\n\", list(\"future options\"),  #>                     \" for more details.\\n\")), \"\\n\", \"\\n\", list( #>                   \"\\n\", \"a <- b <- c <- NA_real_\\n\", \"\\n\", \"# An sequential future\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A sequential future with lazy evaluation\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"}, lazy = TRUE)\\n\", \"y <- value(f)\\n\", \"print(y)\\n\",  #>                   \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A multicore future (specified as a string)\\n\",  #>                   \"plan(\\\"multicore\\\")\\n\", \"f <- future({\\n\",  #>                   \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"## Multisession futures gives an error on R CMD check on\\n\",  #>                   \"## Windows (but not Linux or macOS) for unknown reasons.\\n\",  #>                   \"## The same code works in package tests.\\n\",  #>                   list(\"\\n\", \"\\n\", \"# A multisession future (specified via a string variable)\\n\",  #>                     \"plan(\\\"future::multisession\\\")\\n\", \"f <- future({\\n\",  #>                     \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                     \"  a * b * c\\n\", \"})\\n\", \"y <- value(f)\\n\",  #>                     \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                     \"\\n\"), \"\\n\", \"\\n\", \"\\n\", \"## Explicitly specifying number of workers\\n\",  #>                   \"## (default is parallelly::availableCores())\\n\",  #>                   \"plan(multicore, workers = 2)\\n\", \"message(\\\"Number of parallel workers: \\\", nbrOfWorkers())\\n\",  #>                   \"\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\", list(\"\\n\", \"Use \",  #>                   list(list(\"plan()\")), \" to set a future to become the\\n\",  #>                   \"new default strategy.\\n\"), \"\\n\"), private_length.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\".length\"), \"\\n\", list(\".length\"),  #>                 \"\\n\", list(\"Gets the length of an object without dispatching\"),  #>                 \"\\n\", list(\"\\n\", \".length(x)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"Any \", list(),  #>                     \" object.\")), \"\\n\"), \"\\n\", list(\"\\n\", \"A non-negative integer.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets the length of an object without dispatching\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function returns \", list( #>                   \"length(unclass(x))\"), \", but tries to avoid\\n\",  #>                   \"calling \", list(\"unclass(x)\"), \" unless necessary.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\".subset\"), \"()\"),  #>                   \" and \", list(list(\".subset2\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), `re-exports.Rd` = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/000.re-exports.R\",  #>                 \"\\n\", list(\"re-exports\"), \"\\n\", list(\"re-exports\"),  #>                 \"\\n\", list(\"as.cluster\"), \"\\n\", list(\"availableCores\"),  #>                 \"\\n\", list(\"availableWorkers\"), \"\\n\", list(\"makeClusterPSOCK\"),  #>                 \"\\n\", list(\"supportsMulticore\"), \"\\n\", list(\"Functions Moved to 'parallelly'\"),  #>                 \"\\n\", list(\"\\n\", \"The following function used to be part of \",  #>                   list(\"future\"), \" but has since\\n\", \"been migrated to \",  #>                   list(\"parallelly\"), \".  The migration started with\\n\",  #>                   list(\"future\"), \" 1.20.0 (November 2020).  They were moved because they\\n\",  #>                   \"are also useful outside of the \", list(\"future\"),  #>                   \" framework.\\n\"), \"\\n\", list(\"\\n\", list(\"If you are using any of these from the \",  #>                   list(\"future\"), \" package, please\\n\", \"switch to use the ones from the \",  #>                   list(\"parallelly\"), \" package. Thank you!\"),  #>                   \"\\n\", list(\"\\n\", list(), \" \", list(list(\"parallelly::as.cluster()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::autoStopCluster()\")),  #>                     \"   (no longer re-exported)\\n\", list(), \" \",  #>                     list(list(\"parallelly::availableCores()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                     \"    (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                     \"     (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \"\\n\"), \"\\n\", \"\\n\", \"For backward-compatible reasons, \",  #>                   list(\"some\"), \" of these functions remain\\n\",  #>                   \"available as exact copies also from this package (as re-exports), e.g.\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- parallelly::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"can still be accessed as:\\n\", \"\\n\",  #>                   list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- future::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", list(\"Note that it is the goal to remove all of the above from this package.\"),  #>                   \"\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), readImmediateConditions.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"readImmediateConditions\"), \"\\n\",  #>                 list(\"readImmediateConditions\"), \"\\n\", list(\"saveImmediateCondition\"),  #>                 \"\\n\", list(\"Writes and Reads 'immediateCondition' RDS Files\"),  #>                 \"\\n\", list(\"\\n\", \"readImmediateConditions(\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir(),\\n\", \"  pattern = \\\"[.]rds$\\\",\\n\",  #>                   \"  include = getOption(\\\"future.relay.immediate\\\", \\\"immediateCondition\\\"),\\n\",  #>                   \"  signal = FALSE,\\n\", \"  remove = TRUE\\n\",  #>                   \")\\n\", \"\\n\", \"saveImmediateCondition(\\n\", \"  cond,\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir()\\n\", \")\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"path\"), list(\"(character string) The folder where the RDS files are.\")),  #>                   \"\\n\", \"\\n\", list(list(\"pattern\"), list(\"(character string) A regular expression selecting\\n\",  #>                     \"the RDS files to be read.\")), \"\\n\", \"\\n\",  #>                   list(list(\"include\"), list(\"(character vector) The class or classes of the objects\\n\",  #>                     \"to be kept.\")), \"\\n\", \"\\n\", list(list(\"signal\"),  #>                     list(\"(logical) If TRUE, the condition read are signaled.\")),  #>                   \"\\n\", \"\\n\", list(list(\"remove\"), list(\"(logical) If TRUE, the RDS files used are removed on exit.\")),  #>                   \"\\n\", \"\\n\", list(list(\"cond\"), list(\"A condition of class \",  #>                     list(\"immediateCondition\"), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"readImmediateConditions()\"),  #>                   \" returns a \", list(\"base::list\"), \" of\\n\",  #>                   list(\"immediateCondition\"), \" objects.\\n\",  #>                   \"\\n\", list(\"saveImmediateCondition()\"), \" returns, invisibly, the pathname of\\n\",  #>                   \"the RDS written.\\n\"), \"\\n\", list(\"\\n\", \"Writes and Reads 'immediateCondition' RDS Files\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), requestCore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"requestCore\"), \"\\n\", list(\"requestCore\"),  #>                 \"\\n\", list(\"Request a core for multicore processing\"),  #>                 \"\\n\", list(\"\\n\", \"requestCore(await, workers = availableCores(), timeout, delta, alpha)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"await\"), list(\"A function used to try to \\\"collect\\\"\\n\",  #>                   \"finished multicore subprocesses.\")), \"\\n\",  #>                   \"\\n\", list(list(\"workers\"), list(\"Total number of workers available.\")),  #>                   \"\\n\", \"\\n\", list(list(\"timeout\"), list(\"Maximum waiting time (in seconds) allowed\\n\",  #>                     \"before a timeout error is generated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"delta\"), list(\"Then base interval (in seconds) to wait\\n\",  #>                     \"between each try.\")), \"\\n\", \"\\n\", list(list( #>                     \"alpha\"), list(\"A multiplicative factor used to increase\\n\",  #>                     \"the wait interval after each try.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Invisible TRUE. If no cores are available after\\n\",  #>                   \"extensive waiting, then a timeout error is thrown.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If no cores are available, the current process\\n\",  #>                   \"blocks until a core is available.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), reset.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-reset.R\",  #>                 \"\\n\", list(\"reset\"), \"\\n\", list(\"reset\"), \"\\n\",  #>                 list(\"Reset a finished, failed, or interrupted future to a lazy future\"),  #>                 \"\\n\", list(\"\\n\", \"reset(x, ...)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"A Future.\")), \"\\n\",  #>                   \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"reset()\"), \" returns a lazy, vanilla \",  #>                   list(\"Future\"), \" that can be relaunched.\\n\",  #>                   \"Resetting a running future results in a \",  #>                   list(\"FutureError\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                   \"A future that has successfully completed, has been interrupted, or\\n\",  #>                   \"failed due to an error, can be relaunched after resetting it.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"A lazy, vanilla \", list(\"Future\"),  #>                   \" can be reused in another R session. For\\n\",  #>                   \"instance, if we do:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"a <- 2\\n\", \"f <- future(42 * a, lazy = TRUE)\\n\",  #>                     \"saveRDS(f, \\\"myfuture.rds\\\")\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"Then we can read and evaluate the future in another R session using:\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"f <- readRDS(\\\"myfuture.rds\\\")\\n\",  #>                     \"v <- value(f)\\n\", \"print(v)\\n\", \"#> [1] 84\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"## Like mean(), but fails 90% of the time\\n\",  #>                   \"shaky_mean <- function(x) {\\n\", \"  if (as.double(Sys.time()) %% 1 < 0.90) stop(\\\"boom\\\")\\n\",  #>                   \"  mean(x)\\n\", \"}\\n\", \"\\n\", \"x <- rnorm(100)\\n\",  #>                   \"\\n\", \"## Calculate the mean of 'x' with a risk of failing randomly\\n\",  #>                   \"f <- future({ shaky_mean(x) })\\n\", \"\\n\", \"## Relaunch until success\\n\",  #>                   \"repeat({\\n\", \"  v <- tryCatch(value(f), error = identity)\\n\",  #>                   \"  if (!inherits(v, \\\"error\\\")) break\\n\", \"  message(\\\"Resetting failed future, and retry in 0.1 seconds\\\")\\n\",  #>                   \"  f <- reset(f)\\n\", \"  Sys.sleep(0.1)\\n\",  #>                   \"})\\n\", \"cat(\\\"mean:\\\", v, \\\"\\\\n\\\")\\n\"), \"\\n\"),  #>             resetWorkers.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R\",  #>                 \"\\n\", list(\"resetWorkers\"), \"\\n\", list(\"resetWorkers\"),  #>                 \"\\n\", list(\"Free up active background workers\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"A FutureStrategy.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Free up active background workers\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function will resolve any active futures that is currently\\n\",  #>                   \"being evaluated on background workers.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(plan())\\n\", \"\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), resolve.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-resolve.R\",  #>                 \"\\n\", list(\"resolve\"), \"\\n\", list(\"resolve\"),  #>                 \"\\n\", list(\"Resolve one or more futures synchronously\"),  #>                 \"\\n\", list(\"\\n\", \"resolve(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  result = FALSE,\\n\",  #>                   \"  stdout = FALSE,\\n\", \"  signal = FALSE,\\n\",  #>                   \"  force = FALSE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"x\"), list(\"A \", list(\"Future\"), \" to be resolved, or a list, an environment, or a\\n\",  #>                   \"list environment of futures to be resolved.\")),  #>                   \"\\n\", \"\\n\", list(list(\"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"result\"), list(\"(internal) If TRUE, the results are \",  #>                     list(\"retrieved\"), \", otherwise not.\\n\",  #>                     \"Note that this only collects the results from the parallel worker, which\\n\",  #>                     \"can help lower the overall latency if there are multiple concurrent futures.\\n\",  #>                     \"This does \", list(\"not\"), \" return the collected results.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"(internal) If TRUE, captured standard output is relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"signal\"), list(\"(internal) If TRUE, captured \",  #>                     list(\"conditions\"), \" are relayed,\\n\", \"otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed is relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns \", list(\"x\"), \" (regardless of subsetting or not).\\n\",  #>                   \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is produced.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"This function provides an efficient mechanism for waiting for multiple\\n\",  #>                   \"futures in a container (e.g. list or environment) to be resolved while in\\n\",  #>                   \"the meanwhile retrieving values of already resolved futures.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is resolves synchronously, i.e. it blocks until \",  #>                   list(\"x\"), \" and\\n\", \"any containing futures are resolved.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"To resolve a future \", list( #>                   \"variable\"), \", first retrieve its\\n\", list( #>                   \"Future\"), \" object using \", list(list(\"futureOf()\")),  #>                   \", e.g.\\n\", list(\"resolve(futureOf(x))\"), \".\\n\"),  #>                 \"\\n\"), resolved.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-resolved.R\",  #>                 \"\\n\", list(\"resolved\"), \"\\n\", list(\"resolved\"),  #>                 \"\\n\", list(\"Check whether a future is resolved or not\"),  #>                 \"\\n\", list(\"\\n\", \"resolved(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"A \", list(\"Future\"),  #>                   \", a list, or an environment (which also\\n\",  #>                   \"includes \", list(\"list environment\"), \").\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A logical of the same length and dimensions as \",  #>                   list(\"x\"), \".\\n\", \"Each element is TRUE unless the corresponding element is a\\n\",  #>                   \"non-resolved future in case it is FALSE.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Check whether a future is resolved or not\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This method needs to be implemented by the class that implement\\n\",  #>                   \"the Future API.  The implementation should return either TRUE or FALSE\\n\",  #>                   \"and must never throw an error (except for \",  #>                   list(\"FutureError\"), \":s which indicate\\n\",  #>                   \"significant, often unrecoverable infrastructure problems).\\n\",  #>                   \"It should also be possible to use the method for polling the\\n\",  #>                   \"future until it is resolved (without having to wait infinitely long),\\n\",  #>                   \"e.g. \", list(\"while (!resolved(future)) Sys.sleep(5)\"),  #>                   \".\\n\"), \"\\n\"), result.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"result.Future\"), \"\\n\", list(\"result.Future\"),  #>                 \"\\n\", list(\"result\"), \"\\n\", list(\"Get the results of a resolved future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"result\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"FutureResult\"),  #>                   \" object.\\n\"), \"\\n\", list(\"\\n\", \"Get the results of a resolved future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                   list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                   list(\"not\"), \" part of the frontend Future API.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), run.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"run.Future\"), \"\\n\", list(\"run.Future\"),  #>                 \"\\n\", list(\"run\"), \"\\n\", list(\"Run a future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"run\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"Future\"),  #>                   \" object.\\n\"), \"\\n\", list(\"\\n\", \"Run a future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function can only be called once per future.\\n\",  #>                   \"Further calls will result in an informative error.\\n\",  #>                   \"If a future is not run when its value is queried,\\n\",  #>                   \"then it is run at that point.\\n\"), \"\\n\", list( #>                   \"internal\"), \"\\n\"), save_rds.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"save_rds\"), \"\\n\", list(\"save_rds\"),  #>                 \"\\n\", list(\"Robustly Saves an Object to RDS File Atomically\"),  #>                 \"\\n\", list(\"\\n\", \"save_rds(object, pathname, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"The \",  #>                   list(), \" object to be save.\")), \"\\n\", \"\\n\",  #>                   list(list(\"pathname\"), list(\"RDS file to written.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional arguments passed to \",  #>                     list(list(\"base::saveRDS()\")), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The pathname of the RDS written.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Robustly Saves an Object to RDS File Atomically\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Uses \", list(\"base::saveRDS\"),  #>                   \" internally but writes the object atomically by first\\n\",  #>                   \"writing to a temporary file which is then renamed.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sequential.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-SequentialFutureBackend-class.R\",  #>                 \"\\n\", list(\"sequential\"), \"\\n\", list(\"sequential\"),  #>                 \"\\n\", list(\"uniprocess\"), \"\\n\", list(\"Create a sequential future whose value will be in the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sequential(..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"gc\"), list(\"If TRUE, the garbage collector run (in the process that\\n\",  #>                   \"evaluated the future) only after the value of the future is collected.\\n\",  #>                   \"Exactly when the values are collected may depend on various factors such\\n\",  #>                   \"as number of free workers and whether \", list( #>                     \"earlySignal\"), \" is TRUE (more\\n\", \"frequently) or FALSE (less frequently).\\n\",  #>                   list(\"Some types of futures ignore this argument.\"))),  #>                   \"\\n\", \"\\n\", list(list(\"earlySignal\"), list( #>                     \"Specified whether conditions should be signaled as soon\\n\",  #>                     \"as possible or not.\")), \"\\n\", \"\\n\", list( #>                     list(\"envir\"), list(\"The \", list(\"environment\"),  #>                       \" from where global objects should be\\n\",  #>                       \"identified.\")), \"\\n\", \"\\n\", list(list( #>                     list()), list(\"Additional named elements to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \".\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A sequential future is a future that is evaluated sequentially in the\\n\",  #>                   \"current \", list(), \" session similarly to how \",  #>                   list(), \" expressions are evaluated in \", list(),  #>                   \".\\n\", \"The only difference to \", list(), \" itself is that globals are validated\\n\",  #>                   \"by default just as for all other types of futures in this package.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is \", list(\"not\"),  #>                   \" meant to be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures sequentially in the current R process\\n\",  #>                     \"plan(sequential)\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\"), \"\\n\", list( #>                   \"\\n\", \"## Use sequential futures\\n\", \"plan(sequential)\\n\",  #>                   \"\\n\", \"## A global variable\\n\", \"a <- 0\\n\",  #>                   \"\\n\", \"## Create a sequential future\\n\", \"f <- future({\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"\\n\", \"## Since 'a' is a global variable in future 'f' which\\n\",  #>                   \"## is eagerly resolved (default), this global has already\\n\",  #>                   \"## been resolved / incorporated, and any changes to 'a'\\n\",  #>                   \"## at this point will _not_ affect the value of 'f'.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\"),  #>             sessionDetails.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-sessionDetails.R\",  #>                 \"\\n\", list(\"sessionDetails\"), \"\\n\", list(\"sessionDetails\"),  #>                 \"\\n\", list(\"Outputs details on the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sessionDetails(env = FALSE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"env\"), list(\"If TRUE, \",  #>                   list(\"Sys.getenv()\"), \" information is returned.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Invisibly a list of all details.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Outputs details on the current \",  #>                   list(), \" session\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), signalConditions.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-signalConditions.R\",  #>                 \"\\n\", list(\"signalConditions\"), \"\\n\", list(\"signalConditions\"),  #>                 \"\\n\", list(\"Signals Captured Conditions\"), \"\\n\",  #>                 list(\"\\n\", \"signalConditions(\\n\", \"  future,\\n\",  #>                   \"  include = \\\"condition\\\",\\n\", \"  exclude = NULL,\\n\",  #>                   \"  resignal = TRUE,\\n\", \"  ...\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A resolved \",  #>                   list(\"Future\"), \".\")), \"\\n\", \"\\n\", list(list( #>                   \"include\"), list(\"A character string of \",  #>                   list(\"condition\"), \"\\n\", \"classes to signal.\")),  #>                   \"\\n\", \"\\n\", list(list(\"exclude\"), list(\"A character string of \",  #>                     list(\"condition\"), \"\\n\", \"classes \", list( #>                       \"not\"), \" to signal.\")), \"\\n\", \"\\n\", list( #>                     list(\"resignal\"), list(\"If TRUE, then already signaled conditions are signaled\\n\",  #>                       \"again, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns the \", list(\"Future\"),  #>                   \" where conditioned that were signaled\\n\",  #>                   \"have been flagged to have been signaled.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Captured conditions that meet the \",  #>                   list(\"include\"), \" and \", list(\"exclude\"),  #>                   \"\\n\", \"requirements are signaled \", list(\"in the order as they were captured\"),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Conditions are signaled by\\n\",  #>                   list(list(\"signalCondition\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sticky_globals.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>                 \"\\n\", list(\"sticky_globals\"), \"\\n\", list(\"sticky_globals\"),  #>                 \"\\n\", list(\"Place a sticky-globals environment immediately after the global environment\"),  #>                 \"\\n\", list(\"\\n\", \"sticky_globals(erase = FALSE, name = \\\"future:sticky_globals\\\", pos = 2L)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"erase\"), list(\"(logical) If TRUE, the environment is erased, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"name\"), list(\"(character) The name of the environment on the \",  #>                     list(\"base::search\"), \"\\n\", \"path.\")), \"\\n\",  #>                   \"\\n\", list(list(\"pos\"), list(\"(integer) The position on the search path where the\\n\",  #>                     \"environment should be positioned.  If \",  #>                     list(\"pos == 0L\"), \", then the environment\\n\",  #>                     \"is detached, if it exists.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"(invisible; environment) The environment.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Place a sticky-globals environment immediately after the global environment\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), usedCores.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"usedCores\"), \"\\n\", list(\"usedCores\"),  #>                 \"\\n\", list(\"Get number of cores currently used\"),  #>                 \"\\n\", list(\"\\n\", \"usedCores()\\n\"), \"\\n\", list( #>                   \"\\n\", \"A non-negative integer.\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get number of children (and don't count the current process)\\n\",  #>                   \"used by the current \", list(), \" session.  The number of children\\n\",  #>                   \"is the total number of subprocesses launched by this\\n\",  #>                   \"process that are still running and whose values have yet\\n\",  #>                   \"not been collected.\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), value.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-value.R\",  #>                 \"\\n\", list(\"value\"), \"\\n\", list(\"value\"), \"\\n\",  #>                 list(\"value.Future\"), \"\\n\", list(\"value.list\"),  #>                 \"\\n\", list(\"value.listenv\"), \"\\n\", list(\"value.environment\"),  #>                 \"\\n\", list(\"The value of a future or the values of all elements in a container\"),  #>                 \"\\n\", list(\"\\n\", \"value(...)\\n\", \"\\n\", list(list( #>                   \"value\"), list(\"Future\")), \"(future, stdout = TRUE, signal = TRUE, drop = FALSE, ...)\\n\",  #>                   \"\\n\", list(list(\"value\"), list(\"list\")), \"(\\n\",  #>                   \"  x,\\n\", \"  idxs = NULL,\\n\", \"  recursive = 0,\\n\",  #>                   \"  reduce = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  signal = TRUE,\\n\", \"  interrupt = TRUE,\\n\",  #>                   \"  inorder = TRUE,\\n\", \"  drop = FALSE,\\n\",  #>                   \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"listenv\")), \"(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  reduce = NULL,\\n\",  #>                   \"  stdout = TRUE,\\n\", \"  signal = TRUE,\\n\",  #>                   \"  interrupt = TRUE,\\n\", \"  inorder = TRUE,\\n\",  #>                   \"  drop = FALSE,\\n\", \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"environment\")), \"(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"future, x\"), list(\"A \",  #>                   list(\"Future\"), \", an environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE, standard output captured while resolving futures\\n\",  #>                     \"is relayed, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(\"signal\"), list(\"If TRUE, \", list( #>                     \"conditions\"), \" captured while resolving\\n\",  #>                     \"futures are relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"If TRUE, resolved futures are minimized in size and invalidated\\n\",  #>                     \"as soon the as their values have been collected and any output and\\n\",  #>                     \"conditions have been relayed.\\n\", \"Combining \",  #>                     list(\"drop = TRUE\"), \" with \", list(\"inorder = FALSE\"),  #>                     \" reduces the memory use\\n\", \"sooner, especially avoiding the risk of holding on to future values until\\n\",  #>                     \"the very end.\")), \"\\n\", \"\\n\", list(list( #>                     \"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"reduce\"), list(\"An optional function for reducing all the values.\\n\",  #>                     \"Optional attribute \", list(\"init\"), \" can be used to set initial value for the\\n\",  #>                     \"reduction. If not specified, the first value will be used as the\\n\",  #>                     \"initial value.\\n\", \"Reduction of values is done as soon as possible, but always in the\\n\",  #>                     \"same order as \", list(\"x\"), \", unless \",  #>                     list(\"inorder\"), \" is FALSE.\")), \"\\n\", \"\\n\",  #>                   list(list(\"interrupt\"), list(\"If TRUE and \",  #>                     list(\"signal\"), \" is TRUE, non-resolved futures are\\n\",  #>                     \"interrupted as soon as an error is detected in one of the futures,\\n\",  #>                     \"before signaling the error.\")), \"\\n\", \"\\n\",  #>                   list(list(\"inorder\"), list(\"If TRUE, then standard output and conditions are relayed,\\n\",  #>                     \"and value reduction, is done in the order the futures occur in \",  #>                     list(\"x\"), \", but\\n\", \"always as soon as possible. This is achieved by buffering the details\\n\",  #>                     \"until they can be released. By setting \",  #>                     list(\"inorder = FALSE\"), \", no buffering\\n\",  #>                     \"takes place and everything is relayed and reduced as soon as a new future\\n\",  #>                     \"is resolved. Regardlessly, the values are always returned in the same\\n\",  #>                     \"order as \", list(\"x\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed is relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"value()\"), \" of a Future object returns the value of the future, which can\\n\",  #>                   \"be any type of \", list(), \" object.\\n\", \"\\n\",  #>                   list(\"value()\"), \" of a list, an environment, or a list environment returns an\\n\",  #>                   \"object with the same number of elements and of the same class.\\n\",  #>                   \"Names and dimension attributes are preserved, if available.\\n\",  #>                   \"All future elements are replaced by their corresponding \",  #>                   list(\"value()\"), \" values.\\n\", \"For all other elements, the existing object is kept as-is.\\n\",  #>                   \"\\n\", \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is relayed. Any remaining, non-resolved futures in \",  #>                   list(\"x\"), \" are\\n\", \"interrupted, prior to signalling such an error.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets the value of a future or the values of all elements (including futures)\\n\",  #>                   \"in a container such as a list, an environment, or a list environment.\\n\",  #>                   \"If one or more futures is unresolved, then this function blocks until all\\n\",  #>                   \"queried futures are resolved.\\n\"), \"\\n\", list( #>                   \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## A single future\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"x <- sample(100, size = 50)\\n\", \"f <- future(mean(x))\\n\",  #>                   \"v <- value(f)\\n\", \"message(\\\"The average of 50 random numbers in [1,100] is: \\\", v)\\n\",  #>                   \"\\n\", \"\\n\", \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## Ten futures\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"xs <- replicate(10, { list(sample(100, size = 50)) })\\n\",  #>                   \"fs <- lapply(xs, function(x) { future(mean(x)) })\\n\",  #>                   \"\\n\", \"## The 10 values as a list (because 'fs' is a list)\\n\",  #>                   \"vs <- value(fs)\\n\", \"message(\\\"The ten averages are:\\\")\\n\",  #>                   \"str(vs)\\n\", \"\\n\", \"## The 10 values as a vector (by manually unlisting)\\n\",  #>                   \"vs <- value(fs)\\n\", \"vs <- unlist(vs)\\n\",  #>                   \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## The values as a vector (by reducing)\\n\",  #>                   \"vs <- value(fs, reduce = `c`)\\n\", \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## Calculate the sum of the averages (by reducing)\\n\",  #>                   \"total <- value(fs, reduce = `sum`)\\n\", \"message(\\\"The sum of the ten averages is: \\\", total)\\n\"),  #>                 \"\\n\"), `zzz-future.options.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-options.R\",  #>                 \"\\n\", list(\"zzz-future.options\"), \"\\n\", list( #>                   \"zzz-future.options\"), \"\\n\", list(\"future.options\"),  #>                 \"\\n\", list(\"future.startup.script\"), \"\\n\", list( #>                   \"future.debug\"), \"\\n\", list(\"future.demo.mandelbrot.region\"),  #>                 \"\\n\", list(\"future.demo.mandelbrot.nrow\"), \"\\n\",  #>                 list(\"future.fork.multithreading.enable\"), \"\\n\",  #>                 list(\"future.globals.maxSize\"), \"\\n\", list(\"future.globals.method\"),  #>                 \"\\n\", list(\"future.globals.onMissing\"), \"\\n\",  #>                 list(\"future.globals.resolve\"), \"\\n\", list(\"future.globals.onReference\"),  #>                 \"\\n\", list(\"future.plan\"), \"\\n\", list(\"future.onFutureCondition.keepFuture\"),  #>                 \"\\n\", list(\"future.resolve.recursive\"), \"\\n\",  #>                 list(\"future.connections.onMisuse\"), \"\\n\", list( #>                   \"future.globalenv.onMisuse\"), \"\\n\", list(\"future.rng.onMisuse\"),  #>                 \"\\n\", list(\"future.wait.alpha\"), \"\\n\", list(\"future.wait.interval\"),  #>                 \"\\n\", list(\"future.wait.timeout\"), \"\\n\", list( #>                   \"future.output.windows.reencode\"), \"\\n\", list( #>                   \"future.journal\"), \"\\n\", list(\"future.globals.objectSize.method\"),  #>                 \"\\n\", list(\"R_FUTURE_STARTUP_SCRIPT\"), \"\\n\",  #>                 list(\"R_FUTURE_DEBUG\"), \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_REGION\"),  #>                 \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_NROW\"),  #>                 \"\\n\", list(\"R_FUTURE_FORK_MULTITHREADING_ENABLE\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_MAXSIZE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_METHOD\"), \"\\n\", list(\"R_FUTURE_GLOBALS_ONMISSING\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_RESOLVE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_ONREFERENCE\"), \"\\n\", list( #>                   \"R_FUTURE_PLAN\"), \"\\n\", list(\"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\"),  #>                 \"\\n\", list(\"R_FUTURE_RESOLVE_RECURSIVE\"), \"\\n\",  #>                 list(\"R_FUTURE_CONNECTIONS_ONMISUSE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALENV_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_RNG_ONMISUSE\"), \"\\n\", list(\"R_FUTURE_WAIT_ALPHA\"),  #>                 \"\\n\", list(\"R_FUTURE_WAIT_INTERVAL\"), \"\\n\", list( #>                   \"R_FUTURE_WAIT_TIMEOUT\"), \"\\n\", list(\"R_FUTURE_RESOLVED_TIMEOUT\"),  #>                 \"\\n\", list(\"R_FUTURE_OUTPUT_WINDOWS_REENCODE\"),  #>                 \"\\n\", list(\"R_FUTURE_JOURNAL\"), \"\\n\", list(\"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\"),  #>                 \"\\n\", list(\"future.cmdargs\"), \"\\n\", list(\".future.R\"),  #>                 \"\\n\", list(\"Options used for futures\"), \"\\n\",  #>                 list(\"\\n\", \"Below are the \", list(), \" options and environment variables that are used by the\\n\",  #>                   list(\"future\"), \" package and packages enhancing it.\",  #>                   list(), \"\\n\", list(), \"\\n\", list(\"WARNING: Note that the names and the default values of these options may\\n\",  #>                     \"change in future versions of the package.  Please use with care until\\n\",  #>                     \"further notice.\"), \"\\n\"), \"\\n\", list(list( #>                   \"Packages must not change future options\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Just like for other R options, as a package developer you must \",  #>                     list(\"not\"), \" change\\n\", \"any of the below \",  #>                     list(\"future.*\"), \" options.  Only the end-user should set these.\\n\",  #>                     \"If you find yourself having to tweak one of the options, make sure to\\n\",  #>                     \"undo your changes immediately afterward.  For example, if you want to\\n\",  #>                     \"bump up the \", list(\"future.globals.maxSize\"),  #>                     \" limit when creating a future,\\n\", \"use something like the following inside your function:\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB\\n\",  #>                       \"on.exit(options(oopts))\\n\", \"f <- future({ expr })  ## Launch a future with large objects\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(list(\"Settings moved to the 'parallelly' package\"),  #>                   list(\"\\n\", \"\\n\", \"Several functions have been moved to the \",  #>                     list(\"parallelly\"), \" package:\\n\", list(\"\\n\",  #>                       list(), \" \", list(list(\"parallelly::availableCores()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                       \"\\n\"), \"\\n\", \"\\n\", \"The options and environment variables controlling those have been adjusted\\n\",  #>                     \"accordingly to have different prefixes.\\n\",  #>                     \"For example, option \", list(\"future.fork.enable\"),  #>                     \" has been renamed to\\n\", list(\"parallelly.fork.enable\"),  #>                     \" and the corresponding environment variable\\n\",  #>                     list(\"R_FUTURE_FORK_ENABLE\"), \" has been renamed to\\n\",  #>                     list(\"R_PARALLELLY_FORK_ENABLE\"), \".\\n\",  #>                     \"For backward compatibility reasons, the \",  #>                     list(\"parallelly\"), \" package will\\n\", \"support both versions for a long foreseeable time.\\n\",  #>                     \"See the \", list(\"parallelly::parallelly.options\"),  #>                     \" page for the settings.\\n\")), \"\\n\", \"\\n\",  #>                 list(list(\"Options for controlling futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.plan\"), \":\"), list(\"(character string or future function) Default future strategy plan used unless otherwise specified via \",  #>                     list(list(\"plan()\")), \". This will also be the future plan set when calling \",  #>                     list(\"plan(\\\"default\\\")\"), \".  If not specified, this option may be set when the \",  #>                     list(\"future\"), \" package is \", list(\"loaded\"),  #>                     \" if command-line option \", list(\"--parallel=ncores\"),  #>                     \" (short \", list(\"-p ncores\"), \") is specified; if \",  #>                     list(\"ncores > 1\"), \", then option \", list( #>                       \"future.plan\"), \" is set to \", list(\"multisession\"),  #>                     \" otherwise \", list(\"sequential\"), \" (in addition to option \",  #>                     list(\"mc.cores\"), \" being set to \", list( #>                       \"ncores\"), \", if \", list(\"ncores >= 1\"),  #>                     \"). (Default: \", list(\"sequential\"), \")\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.maxSize\"),  #>                       \":\"), list(\"(numeric) Maximum allowed total size (in bytes) of global variables identified. This is used to protect against exporting too large objects to parallel workers by mistake. Transfering large objects over a network, or over the internet, can be slow and therefore introduce a large bottleneck that increases the overall processing time. It can also result in large egress or ingress costs, which may exist on some systems. If set of \",  #>                       list(\"+Inf\"), \", then the check for large globals is skipped. (Default: \",  #>                       list(\"500 * 1024 ^ 2\"), \" = 500 MiB)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.onReference\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) Controls whether the identified globals should be scanned for so called \",  #>                       list(\"references\"), \" (e.g. external pointers and connections) or not.  It is unlikely that another \",  #>                       list(), \" process (\\\"worker\\\") can use a global that uses a internal reference of the master \",  #>                       list(), \" process---we call such objects \",  #>                       list(\"non-exportable globals\"), \".\\n\",  #>                       \"If this option is \", list(\"\\\"error\\\"\"),  #>                       \", an informative error message is produced if a non-exportable global is detected.\\n\",  #>                       \"If \", list(\"\\\"warning\\\"\"), \", a warning is produced, but the processing will continue; it is likely that the future will be resolved with a run-time error unless processed in the master \",  #>                       list(), \" process (e.g. \", list(\"plan(sequential)\"),  #>                       \" and \", list(\"plan(multicore)\"), \").\\n\",  #>                       \"If \", list(\"\\\"ignore\\\"\"), \", no scan is performed.\\n\",  #>                       \"(Default: \", list(\"\\\"ignore\\\"\"), \" but may change)\\n\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.resolve.recursive\"),  #>                       \":\"), list(\"(integer) An integer specifying the maximum recursive depth to which futures should be resolved. If negative, nothing is resolved.  If \",  #>                       list(\"0\"), \", only the future itself is resolved.  If \",  #>                       list(\"1\"), \", the future and any of its elements that are futures are resolved, and so on. If \",  #>                       list(\"+Inf\"), \", infinite search depth is used. (Default: \",  #>                       list(\"0\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.rng.onMisuse\"), \": (\", list( #>                         \"beta feature - may change\"), \")\"), list( #>                       \"(character string) If random numbers are used in futures, then parallel (L'Ecuyer-CMRG) RNG should be used in order to get statistical sound RNGs. The defaults in the future framework assume that \",  #>                       list(\"no\"), \" random number generation (RNG) is taken place in the future expression because L'Ecuyer-CMRG RNGs come with an unnecessary overhead if not needed.  To protect against mistakes, the future framework attempts to detect when random numbers are used despite L'Ecuyer-CMRG RNGs are not in place.  If this is detected, and \",  #>                       list(\"future.rng.onMisuse = \\\"error\\\"\"),  #>                       \", then an informative error message is produced.  If \",  #>                       list(\"\\\"warning\\\"\"), \", then a warning message is produced.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed. (Default: \",  #>                       list(\"\\\"warning\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                     list(list(list(\"future.connections.onMisuse\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) A future must close any connections it opens and must not close connections it did not open. If such misuse is detected and this option is set to \",  #>                       list(\"\\\"error\\\"\"), \", \", list(\"value()\"),  #>                       \" will produce an error with details. If it is set to \",  #>                       list(\"\\\"warning\\\"\"), \", a warning is produced. If \",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed. (Default: \",  #>                       list(\"\\\"warning\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                     list(list(list(\"future.globalenv.onMisuse\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) Assigning variables to the global environment for the purpose of using the variable at a later time makes no sense with futures, because the next future may be evaluated in different R process.  To protect against mistakes, the future framework attempts to detect when variables are added to the global environment.  If this is detected, and \",  #>                       list(\"future.globalenv.onMisuse = \\\"error\\\"\"),  #>                       \", then an informative error message is produced.  If \",  #>                       list(\"\\\"warning\\\"\"), \", then a warning message is produced.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed. (Default: \",  #>                       list(\"\\\"ignore\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                     list(list(list(\"future.onFutureCondition.keepFuture\"),  #>                       \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                       \", a \", list(\"FutureCondition\"), \" keeps a copy of the \",  #>                       list(\"Future\"), \" object that triggered the condition. If \",  #>                       list(\"FALSE\"), \", it is dropped. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.wait.timeout\"), \":\"), list( #>                       \"(numeric) Maximum waiting time (in seconds) for a future to resolve or for a free worker to become available before a timeout error is generated. (Default: \",  #>                       list(\"30 * 24 * 60 * 60\"), \" (= 30 days))\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.interval\"),  #>                       \":\"), list(\"(numeric) Initial interval (in\\n\",  #>                       \"seconds) between polls. This controls the polling frequency for finding\\n\",  #>                       \"an available worker when all workers are currently busy. It also controls\\n\",  #>                       \"the polling frequency of \", list(\"resolve()\"),  #>                       \". (Default: \", list(\"0.01\"), \" = 1 ms)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.alpha\"),  #>                       \":\"), list(\"(numeric) Positive scale factor used to increase the interval after each poll. (Default: \",  #>                       list(\"1.01\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for debugging futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.debug\"), \":\"), list(\"(logical) If \",  #>                     list(\"TRUE\"), \", extensive debug messages are generated. (Default: \",  #>                     list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for controlling package startup\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.startup.script\"), \":\"), list(\"(character vector or a logical) Specifies zero of more future startup scripts to be sourced when the \",  #>                     list(\"future\"), \" package is \", list(\"attached\"),  #>                     \". It is only the first existing script that is sourced. If none of the specified files exist, nothing is sourced---there will be neither a warning nor an error.\\n\",  #>                     \"If this option is not specified, environment variable \",  #>                     list(\"R_FUTURE_STARTUP_SCRIPT\"), \" is considered, where multiple scripts may be separated by either a colon (\",  #>                     list(\":\"), \") or a semicolon (\", list(\";\"),  #>                     \"). If neither is set, or either is set to \",  #>                     list(\"TRUE\"), \", the default is to look for a \",  #>                     list(\".future.R\"), \" script in the current directory and then in the user's home directory.  To disable future startup scripts, set the option or the environment variable to \",  #>                     list(\"FALSE\"), \".  \", list(\"Importantly\"),  #>                     \", this option is \", list(\"always\"), \" set to \",  #>                     list(\"FALSE\"), \" if the \", list(\"future\"),  #>                     \" package is loaded as part of a future expression being evaluated, e.g. in a background process. In order words, they are sourced in the main \",  #>                     list(), \" process but not in future processes. (Default: \",  #>                     list(\"TRUE\"), \" in main \", list(), \" process and \",  #>                     list(\"FALSE\"), \" in future processes / during future evaluation)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.cmdargs\"),  #>                       \":\"), list(\"(character vector) Overrides \",  #>                       list(list(\"commandArgs\"), \"()\"), \" when the \",  #>                       list(\"future\"), \" package is \", list(\"loaded\"),  #>                       \".\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Options for configuring low-level system behaviors\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", list(\"\\n\", list(list( #>                     list(\"future.fork.multithreading.enable\"),  #>                     \" (\", list(\"beta feature - may change\"),  #>                     \"):\"), list(\"(logical) Enable or disable \",  #>                     list(\"multi-threading\"), \" while using \",  #>                     list(\"forked\"), \" parallel processing.  If \",  #>                     list(\"FALSE\"), \", different multi-thread library settings are overridden such that they run in single-thread mode. Specifically, multi-threading will be disabled for OpenMP (which requires the \",  #>                     list(\"RhpcBLASctl\"), \" package) and for \",  #>                     list(\"RcppParallel\"), \". If \", list(\"TRUE\"),  #>                     \", or not set (the default), multi-threading is allowed.  Parallelization via multi-threaded processing (done in native code by some packages and external libraries) while at the same time using forked (aka \\\"multicore\\\") parallel processing is known to unstable.  Note that this is not only true when using \",  #>                     list(\"plan(multicore)\"), \" but also when using, for instance, \",  #>                     list(list(\"mclapply\"), \"()\"), \" of the \",  #>                     list(\"parallel\"), \" package. (Default: not set)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.output.windows.reencode\"),  #>                       \":\"), list(\"(logical) Enable or disable re-encoding of UTF-8 symbols that were incorrectly encoded while captured.  In R (< 4.2.0) and on older versions of MS Windows, R cannot capture UTF-8 symbols as-is when they are captured from the standard output.  For examples, a UTF-8 check mark symbol (\",  #>                       list(\"\\\"\\\\u2713\\\"\"), \") would be relayed as \",  #>                       list(\"\\\"<U+2713>\\\"\"), \" (a string with eight ASCII characters).  Setting this option to \",  #>                       list(\"TRUE\"), \" will cause \", list(\"value()\"),  #>                       \" to attempt to recover the intended UTF-8 symbols from \",  #>                       list(\"<U+nnnn>\"), \" string components, if, and only if, the string was captured by a future resolved on MS Windows. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\"), \"\\n\", \"\\n\",  #>                     \"See also \", list(\"parallelly::parallelly.options\"),  #>                     \".\\n\")), \"\\n\", \"\\n\", list(list(\"Options for demos\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.demo.mandelbrot.region\"), \":\"), list( #>                     \"(integer) Either a named list of \", list( #>                       list(\"mandelbrot()\")), \" arguments or an integer in {1, 2, 3} specifying a predefined Mandelbrot region. (Default: \",  #>                     list(\"1L\"), \")\")), \"\\n\", \"\\n\", list(list( #>                     list(\"future.demo.mandelbrot.nrow\"), \":\"),  #>                     list(\"(integer) Number of rows and columns of tiles. (Default: \",  #>                       list(\"3L\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Deprecated or for internal prototyping\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"The following options exists only for troubleshooting purposes and must not\\n\",  #>                     \"be used in production.  If used, there is a risk that the results are\\n\",  #>                     \"non-reproducible if processed elsewhere.  To lower the risk of them being\\n\",  #>                     \"used by mistake, they are marked as deprecated and will produce warnings\\n\",  #>                     \"if set.\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                       \"future.globals.onMissing\"), \":\"), list( #>                       \"(character string) Action to take when non-existing global variables (\\\"globals\\\" or \\\"unknowns\\\") are identified when the future is created.  If \",  #>                       list(\"\\\"error\\\"\"), \", an error is generated immediately.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no action is taken and an attempt to evaluate the future expression will be made.  The latter is useful when there is a risk for false-positive globals being identified, e.g. when future expression contains non-standard evaluation (NSE).  (Default: \",  #>                       list(\"\\\"ignore\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.method\"),  #>                         \":\"), list(\"(character string) Method used to identify globals. For details, see \",  #>                         list(list(\"globalsOf\"), \"()\"), \". (Default: \",  #>                         list(\"\\\"ordered\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.resolve\"),  #>                         \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                         \", globals that are \", list(list(\"Future\")),  #>                         \" objects (typically created as \", list( #>                           \"explicit\"), \" futures) will be resolved and have their values (using \",  #>                         list(\"value()\"), \") collected.  Because searching for unresolved futures among globals (including their content) can be expensive, the default is not to do it and instead leave it to the run-time checks that assert proper ownership when resolving futures and collecting their values. (Default: \",  #>                         list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Environment variables that set R options\"),  #>                   list(\"\\n\", \"\\n\", \"All of the above \", list(),  #>                     \" \", list(\"future.*\"), \" options can be set by corresponding\\n\",  #>                     \"environment variable \", list(\"R_FUTURE_*\"),  #>                     \" \", list(\"when the \", list(\"future\"), \" package is\\n\",  #>                       \"loaded\"), \". This means that those environment variables must be set before\\n\",  #>                     \"the \", list(\"future\"), \" package is loaded in order to have an effect.\\n\",  #>                     \"For example, if \", list(\"R_FUTURE_RNG_ONMISUSE=\\\"ignore\\\"\"),  #>                     \", then option\\n\", list(\"future.rng.onMisuse\"),  #>                     \" is set to \", list(\"\\\"ignore\\\"\"), \" (character string).\\n\",  #>                     \"Similarly, if \", list(\"R_FUTURE_GLOBALS_MAXSIZE=\\\"50000000\\\"\"),  #>                     \", then option\\n\", list(\"future.globals.maxSize\"),  #>                     \" is set to \", list(\"50000000\"), \" (numeric).\\n\")),  #>                 \"\\n\", \"\\n\", list(\"\\n\", \"# Allow at most 5 MB globals per futures\\n\",  #>                   \"options(future.globals.maxSize = 5e6)\\n\",  #>                   \"\\n\", \"# Be strict; catch all RNG mistakes\\n\",  #>                   \"options(future.rng.onMisuse = \\\"error\\\")\\n\",  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"To set \", list(),  #>                   \" options or environment variables when \",  #>                   list(), \" starts (even before the \", list(\"future\"),  #>                   \" package is loaded), see the \", list(\"Startup\"),  #>                   \" help page.  The \", list(list(\"https://cran.r-project.org/package=startup\"),  #>                     list(list(\"startup\"))), \" package provides a friendly mechanism for configurating \",  #>                   list(), \"'s startup process.\\n\"), \"\\n\")), source = list( #>             `Future-class.Rd` = \"R/backend_api-Future-class.R\",  #>             FutureBackend.Rd = c(\"R/backend_api-ClusterFutureBackend-class.R\",  #>             \"R/backend_api-FutureBackend-class.R\", \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             \"R/backend_api-MultisessionFutureBackend-class.R\",  #>             \"R/backend_api-SequentialFutureBackend-class.R\"),  #>             FutureCondition.Rd = c(\"R/protected_api-FutureCondition-class.R\",  #>             \"R/protected_api-journal.R\"), FutureGlobals.Rd = \"R/protected_api-FutureGlobals-class.R\",  #>             FutureResult.Rd = \"R/protected_api-FutureResult-class.R\",  #>             `MulticoreFuture-class.Rd` = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             `MultiprocessFuture-class.Rd` = \"R/backend_api-MultiprocessFutureBackend-class.R\",  #>             `UniprocessFuture-class.Rd` = \"R/backend_api-UniprocessFuture-class.R\",  #>             backtrace.Rd = \"R/utils_api-backtrace.R\", cluster.Rd = \"R/backend_api-ClusterFutureBackend-class.R\",  #>             clusterExportSticky.Rd = \"R/utils-sticky_globals.R\",  #>             find_references.Rd = \"R/utils-marshalling.R\", future.Rd = c(\"R/core_api-future.R\",  #>             \"R/utils_api-futureCall.R\", \"R/utils_api-minifuture.R\" #>             ), futureAssign.Rd = c(\"R/delayed_api-futureAssign.R\",  #>             \"R/infix_api-01-futureAssign_OP.R\", \"R/infix_api-02-globals_OP.R\",  #>             \"R/infix_api-03-seed_OP.R\", \"R/infix_api-04-stdout_OP.R\",  #>             \"R/infix_api-05-conditions_OP.R\", \"R/infix_api-06-lazy_OP.R\",  #>             \"R/infix_api-07-label_OP.R\", \"R/infix_api-08-plan_OP.R\",  #>             \"R/infix_api-09-tweak_OP.R\"), futureOf.Rd = \"R/delayed_api-futureOf.R\",  #>             futureSessionInfo.Rd = \"R/utils_api-futureSessionInfo.R\",  #>             futures.Rd = \"R/protected_api-futures.R\", getExpression.Rd = \"R/backend_api-Future-class.R\",  #>             getGlobalsAndPackages.Rd = \"R/protected_api-globals.R\",  #>             interrupt.Rd = \"R/core_api-interrupt.R\", mandelbrot.Rd = \"R/demo_api-mandelbrot.R\",  #>             multicore.Rd = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             multisession.Rd = \"R/backend_api-MultisessionFutureBackend-class.R\",  #>             nbrOfWorkers.Rd = \"R/utils_api-nbrOfWorkers.R\", nullcon.Rd = \"R/utils-basic.R\",  #>             plan.Rd = c(\"R/utils_api-plan.R\", \"R/utils_api-tweak.R\",  #>             \"R/utils_api-withPlan.R\"), private_length.Rd = \"R/utils-basic.R\",  #>             `re-exports.Rd` = \"R/000.re-exports.R\", readImmediateConditions.Rd = \"R/utils-immediateCondition.R\",  #>             requestCore.Rd = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             reset.Rd = \"R/core_api-reset.R\", resetWorkers.Rd = \"R/utils_api-plan.R\",  #>             resolve.Rd = \"R/protected_api-resolve.R\", resolved.Rd = \"R/core_api-resolved.R\",  #>             result.Rd = \"R/backend_api-Future-class.R\", run.Rd = \"R/backend_api-Future-class.R\",  #>             save_rds.Rd = \"R/utils-immediateCondition.R\", sequential.Rd = \"R/backend_api-SequentialFutureBackend-class.R\",  #>             sessionDetails.Rd = \"R/utils_api-sessionDetails.R\",  #>             signalConditions.Rd = \"R/protected_api-signalConditions.R\",  #>             sticky_globals.Rd = \"R/utils-sticky_globals.R\", usedCores.Rd = \"R/backend_api-MulticoreFutureBackend-class.R\",  #>             value.Rd = \"R/core_api-value.R\", `zzz-future.options.Rd` = \"R/utils-options.R\"),  #>         keywords = list(\"internal\", \"internal\", \"internal\", \"internal\",  #>             \"internal\", \"internal\", \"internal\", \"internal\", character(0),  #>             character(0), \"internal\", \"internal\", character(0),  #>             character(0), character(0), character(0), character(0),  #>             \"internal\", \"internal\", character(0), \"internal\",  #>             character(0), character(0), character(0), \"internal\",  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             \"internal\", character(0), \"internal\", character(0),  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             \"internal\", character(0), character(0)), concepts = list( #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0)),  #>         internal = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,  #>         TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE,  #>         FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE,  #>         FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE,  #>         FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE,  #>         TRUE, FALSE, FALSE), lifecycle = list(NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL)), tutorials = list( #>         name = character(0), file_out = character(0), title = character(0),  #>         pagetitle = character(0), url = character(0)), vignettes = list( #>         name = c(\"future-1-overview\", \"future-2-output\", \"future-3-topologies\",  #>         \"future-4-issues\", \"future-4-non-exportable-objects\",  #>         \"future-5-startup\", \"future-6-future-api-backend-specification\",  #>         \"future-7-for-package-developers\", \"future-8-how-future-is-validated\" #>         ), type = c(\"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\",  #>         \"rmd\", \"rmd\", \"rmd\"), file_in = c(\"vignettes/future-1-overview.Rmd\",  #>         \"vignettes/future-2-output.Rmd\", \"vignettes/future-3-topologies.Rmd\",  #>         \"vignettes/future-4-issues.Rmd\", \"vignettes/future-4-non-exportable-objects.Rmd\",  #>         \"vignettes/future-5-startup.Rmd\", \"vignettes/future-6-future-api-backend-specification.Rmd\",  #>         \"vignettes/future-7-for-package-developers.Rmd\", \"vignettes/future-8-how-future-is-validated.Rmd\" #>         ), file_out = c(\"articles/future-1-overview.html\", \"articles/future-2-output.html\",  #>         \"articles/future-3-topologies.html\", \"articles/future-4-issues.html\",  #>         \"articles/future-4-non-exportable-objects.html\", \"articles/future-5-startup.html\",  #>         \"articles/future-6-future-api-backend-specification.html\",  #>         \"articles/future-7-for-package-developers.html\", \"articles/future-8-how-future-is-validated.html\" #>         ), title = c(\"A Future for R: A Comprehensive Overview\",  #>         \"A Future for R: Text and Message Output\", \"A Future for R: Future Topologies\",  #>         \"A Future for R: Common Issues with Solutions\", \"A Future for R: Non-Exportable Objects\",  #>         \"A Future for R: Controlling Default Future Strategy\",  #>         \"A Future for R: Future API Backend Specification\", \"A Future for R: Best Practices for Package Developers\",  #>         \"A Future for R: How the Future Framework is Validated\" #>         ), description = c(NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_), depth = c(1L, 1L, 1L,  #>         1L, 1L, 1L, 1L, 1L, 1L)))), examples = base::quote(TRUE),  #>     run_dont_run = base::quote(FALSE), seed = base::quote(1014L),  #>     lazy = base::quote(FALSE), override = base::quote(list()),  #>     install = base::quote(FALSE), preview = base::quote(FALSE),  #>     new_process = base::quote(FALSE), devel = base::quote(FALSE),  #>     cli_colors = base::quote(16777216L), hyperlinks = base::quote(TRUE),  #>     pkgdown_internet = base::quote(TRUE)) #>  #> [[13]] #> pkgdown::build_site(...) #>  #> [[14]] #> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run,  #>     seed = seed, lazy = lazy, override = override, preview = preview,  #>     devel = devel) #>  #> [[15]] #> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run,  #>     seed = seed, override = override, preview = FALSE, devel = devel) #>  #> [[16]] #> unwrap_purrr_error(purrr::map(topics, build_reference_topic,  #>     pkg = pkg, lazy = lazy, examples_env = examples_env, run_dont_run = run_dont_run)) #>  #> [[17]] #> withCallingHandlers(code, purrr_error_indexed = function(err) { #>     cnd_signal(err$parent) #> }) #>  #> [[18]] #> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy,  #>     examples_env = examples_env, run_dont_run = run_dont_run) #>  #> [[19]] #> map_(\"list\", .x, .f, ..., .progress = .progress) #>  #> [[20]] #> with_indexed_errors(i = i, names = names, error_call = .purrr_error_call,  #>     call_with_cleanup(map_impl, environment(), .type, .progress,  #>         n, names, i)) #>  #> [[21]] #> withCallingHandlers(expr, error = function(cnd) { #>     if (i == 0L) { #>     } #>     else { #>         message <- c(i = \"In index: {i}.\") #>         if (!is.null(names) && !is.na(names[[i]]) && names[[i]] !=  #>             \"\") { #>             name <- names[[i]] #>             message <- c(message, i = \"With name: {name}.\") #>         } #>         else { #>             name <- NULL #>         } #>         cli::cli_abort(message, location = i, name = name, parent = cnd,  #>             call = error_call, class = \"purrr_error_indexed\") #>     } #> }) #>  #> [[22]] #> call_with_cleanup(map_impl, environment(), .type, .progress,  #>     n, names, i) #>  #> [[23]] #> .f(.x[[i]], ...) #>  #> [[24]] #> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env,  #>     run_dont_run = run_dont_run), error = function(err) { #>     cli::cli_abort(\"Failed to parse Rd in {.file {topic$file_in}}\",  #>         parent = err, call = quote(build_reference())) #> }) #>  #> [[25]] #> data_reference_topic(topic, pkg, examples_env = examples_env,  #>     run_dont_run = run_dont_run) #>  #> [[26]] #> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env)) NULL else new.env(parent = examples_env),  #>     topic = tools::file_path_sans_ext(topic$file_in), run_dont_run = run_dont_run) #>  #> [[27]] #> highlight_examples(code, topic, env = env) #>  #> [[28]] #> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic,  #>     env = eval_env, output_handler = handler) #>  #> [[29]] #> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #>  #> [[30]] #> withRestarts(with_handlers({ #>     for (expr in tle$exprs) { #>         ev <- withVisible(eval(expr, envir)) #>         watcher$capture_plot_and_output() #>         watcher$print_value(ev$value, ev$visible, envir) #>     } #>     TRUE #> }, handlers), eval_continue = function() TRUE, eval_stop = function() FALSE) #>  #> [[31]] #> withRestartList(expr, restarts) #>  #> [[32]] #> withOneRestart(withRestartList(expr, restarts[-nr]), restarts[[nr]]) #>  #> [[33]] #> doWithOneRestart(return(expr), restart) #>  #> [[34]] #> withRestartList(expr, restarts[-nr]) #>  #> [[35]] #> withOneRestart(expr, restarts[[1L]]) #>  #> [[36]] #> doWithOneRestart(return(expr), restart) #>  #> [[37]] #> with_handlers({ #>     for (expr in tle$exprs) { #>         ev <- withVisible(eval(expr, envir)) #>         watcher$capture_plot_and_output() #>         watcher$print_value(ev$value, ev$visible, envir) #>     } #>     TRUE #> }, handlers) #>  #> [[38]] #> eval(call) #>  #> [[39]] #> eval(call) #>  #> [[40]] #> withCallingHandlers(code, message = function (cnd)  #> { #>     watcher$capture_plot_and_output() #>     if (on_message$capture) { #>         watcher$push(cnd) #>     } #>     if (on_message$silence) { #>         invokeRestart(\"muffleMessage\") #>     } #> }, warning = function (cnd)  #> { #>     if (getOption(\"warn\") >= 2 || getOption(\"warn\") < 0) { #>         return() #>     } #>     watcher$capture_plot_and_output() #>     if (on_warning$capture) { #>         cnd <- sanitize_call(cnd) #>         watcher$push(cnd) #>     } #>     if (on_warning$silence) { #>         invokeRestart(\"muffleWarning\") #>     } #> }, error = function (cnd)  #> { #>     watcher$capture_plot_and_output() #>     cnd <- sanitize_call(cnd) #>     watcher$push(cnd) #>     switch(on_error, continue = invokeRestart(\"eval_continue\"),  #>         stop = invokeRestart(\"eval_stop\"), error = NULL) #> }) #>  #> [[41]] #> withVisible(eval(expr, envir)) #>  #> [[42]] #> eval(expr, envir) #>  #> [[43]] #> eval(expr, envir) #>  #> [[44]] #> future({ #>     foo(\"a\") #> }) #>  #> [[45]] #> Future(expr, substitute = FALSE, envir = envir, lazy = TRUE,  #>     seed = seed, globals = globals, packages = packages, stdout = stdout,  #>     conditions = conditions, earlySignal = earlySignal, label = label,  #>     gc = gc, onReference = onReference, ...) #>  #> [[46]] #> eval(expr, envir = globalenv()) #>  #> [[47]] #> eval(expr, envir = globalenv()) #>  #> [[48]] #> local({ #>     { #>         foo(\"a\") #>     } #> }) #>  #> [[49]] #> eval.parent(substitute(eval(quote(expr), envir))) #>  #> [[50]] #> eval(expr, p) #>  #> [[51]] #> eval(expr, p) #>  #> [[52]] #> eval(quote({ #>     { #>         foo(\"a\") #>     } #> }), new.env()) #>  #> [[53]] #> eval(quote({ #>     { #>         foo(\"a\") #>     } #> }), new.env()) #>  #> [[54]] #> foo(\"a\") #>  #> [[55]] #> my_log(...) #>  #> [[56]] #> log(x) #>"},{"path":"https://future.futureverse.org/reference/cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a cluster future whose value will be resolved asynchronously in a parallel process — cluster","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process — cluster","text":"cluster future future uses cluster evaluation, means value computed resolved parallel another process.","code":""},{"path":"https://future.futureverse.org/reference/cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process — cluster","text":"","code":"cluster(   ...,   persistent = FALSE,   workers = availableWorkers(),   gc = FALSE,   earlySignal = FALSE,   envir = parent.frame() )"},{"path":"https://future.futureverse.org/reference/cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process — cluster","text":"persistent FALSE, evaluation environment cleared objects prior evaluation future. workers cluster object, character vector host names, positive numeric scalar, function. character vector numeric scalar, cluster object created using makeClusterPSOCK(workers). function, called without arguments future created value used configure workers. function return types. gc TRUE, garbage collector run (process evaluated future) value future collected. Exactly values collected may depend various factors number free workers whether earlySignal TRUE (frequently) FALSE (less frequently). types futures ignore argument. earlySignal Specified whether conditions signaled soon possible . envir environment global objects identified. ... Additional named elements passed Future().","code":""},{"path":"https://future.futureverse.org/reference/cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process — cluster","text":"ClusterFuture.","code":""},{"path":"https://future.futureverse.org/reference/cluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process — cluster","text":"function meant called directly.  Instead, typical usages :","code":"# Evaluate futures via a single background R process on the local machine plan(cluster, workers = 1)  # Evaluate futures via two background R processes on the local machine plan(cluster, workers = 2)  # Evaluate futures via a single R process on another machine on on the # local area network (LAN) plan(cluster, workers = \"raspberry-pi\")  # Evaluate futures via a single R process running on a remote machine plan(cluster, workers = \"pi.example.org\")  # Evaluate futures via four R processes, one running on the local machine, # two running on LAN machine 'n1' and one on a remote machine plan(cluster, workers = c(\"localhost\", \"n1\", \"n1\", \"pi.example.org\"))"},{"path":"https://future.futureverse.org/reference/cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process — cluster","text":"","code":"# \\donttest{  ## Use cluster futures cl <- parallel::makeCluster(2, timeout = 60) plan(cluster, workers = cl)  ## A global variable a <- 0  ## Create future (explicitly) f <- future({   b <- 3   c <- 2   a * b * c })  ## A cluster future is evaluated in a separate process. ## Regardless, changing the value of a global variable will ## not affect the result of the future. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)  ## CLEANUP parallel::stopCluster(cl)  # }"},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":null,"dir":"Reference","previous_headings":"","what":"Export globals to the sticky-globals environment of the cluster nodes — clusterExportSticky","title":"Export globals to the sticky-globals environment of the cluster nodes — clusterExportSticky","text":"Export globals sticky-globals environment cluster nodes","code":""},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export globals to the sticky-globals environment of the cluster nodes — clusterExportSticky","text":"","code":"clusterExportSticky(cl, globals)"},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export globals to the sticky-globals environment of the cluster nodes — clusterExportSticky","text":"cl (cluster) cluster object returned parallel::makeCluster(). globals (list) named list sticky globals exported.","code":""},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export globals to the sticky-globals environment of the cluster nodes — clusterExportSticky","text":"(invisible; cluster) cluster object.","code":""},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export globals to the sticky-globals environment of the cluster nodes — clusterExportSticky","text":"requires future package installed cluster nodes.","code":""},{"path":"https://future.futureverse.org/reference/find_references.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the first or all references of an R object — find_references","title":"Get the first or all references of an R object — find_references","text":"Get first references R object Assert references among identified globals","code":""},{"path":"https://future.futureverse.org/reference/find_references.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the first or all references of an R object — find_references","text":"","code":"find_references(x, first_only = FALSE)  assert_no_references(   x,   action = c(\"error\", \"warning\", \"message\", \"string\"),   source = c(\"globals\", \"value\") )"},{"path":"https://future.futureverse.org/reference/find_references.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the first or all references of an R object — find_references","text":"x R object checked. first_only TRUE, first reference returned, otherwise references. action Type action take reference found. source source x globals value future?","code":""},{"path":"https://future.futureverse.org/reference/find_references.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the first or all references of an R object — find_references","text":"find_references() returns list zero references identified. reference detected, informative error, warning, message, character string produced, otherwise NULL returned invisibly.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a future — future","title":"Create a future — future","text":"Creates future evaluates R expression future calls R function set arguments. , , futures evaluated can configured using plan() evaluated parallel , instance, current machine, remote machine, via job queue compute cluster. Importantly, R code using futures remains regardless settings need modify code switching , say, sequential parallel processing.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a future — future","text":"","code":"future(   expr,   envir = parent.frame(),   substitute = TRUE,   lazy = FALSE,   seed = FALSE,   globals = TRUE,   packages = NULL,   stdout = TRUE,   conditions = \"condition\",   label = NULL,   gc = FALSE,   earlySignal = FALSE,   ... )  futureCall(   FUN,   args = list(),   envir = parent.frame(),   lazy = FALSE,   seed = FALSE,   globals = TRUE,   packages = NULL,   stdout = TRUE,   conditions = \"condition\",   earlySignal = FALSE,   label = NULL,   gc = FALSE,   ... )  minifuture(   expr,   substitute = TRUE,   globals = NULL,   packages = NULL,   stdout = NA,   conditions = NULL,   seed = NULL,   ...,   envir = parent.frame() )"},{"path":"https://future.futureverse.org/reference/future.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a future — future","text":"expr R expression. envir environment global objects identified. substitute TRUE, argument expr substitute():ed, otherwise . lazy FALSE (default), future resolved eagerly (starting immediately), otherwise . seed (optional) TRUE, random seed, , state random number generator (RNG) set statistically sound random numbers produced (also parallelization). FALSE (default), assumed future expression neither need use random numbers generation. use fixed random seed, specify L'Ecuyer-CMRG seed (seven integer) regular RNG seed (single integer).  latter, L'Ecuyer-CMRG seed automatically created based given seed. Furthermore, FALSE, future monitored make sure use random numbers.  depending value option future.rng.onMisuse, check ignored, informative warning, error produced. seed NULL, effect seed = FALSE without RNG check performed. globals (optional) logical, character vector, named list control globals handled. details, see section 'Globals used future expressions' help future(). packages (optional) character vector specifying packages attached R environment evaluating future. stdout TRUE (default), standard output captured, re-outputted value() called. FALSE, output silenced (sinking null device outputted). Using stdout = structure(TRUE, drop = TRUE) causes captured standard output dropped future object soon relayed. can help decrease overall memory consumed captured output across futures. Using stdout = NA fully avoids intercepting standard output; behavior unhandled standard output depends future backend. conditions character string conditions classes captured relayed.  default relay conditions, including messages warnings.  drop conditions, use conditions = character(0). Errors always relayed. Attribute exclude can used ignore specific classes, e.g. conditions = structure(\"condition\", exclude = \"message\") capture condition classes except inherits message class. Using conditions = structure(..., drop = TRUE) causes captured conditions dropped future object soon relayed, e.g. value(f). can help decrease overall memory consumed captured conditions across futures. Using conditions = NULL (recommended) avoids intercepting conditions, except errors; behavior unhandled conditions depends future backend environment R runs. label character string label attached future. gc TRUE, garbage collector run (process evaluated future) value future collected. Exactly values collected may depend various factors number free workers whether earlySignal TRUE (frequently) FALSE (less frequently). types futures ignore argument. earlySignal Specified whether conditions signaled soon possible . FUN function evaluated. args list arguments passed function FUN. ... Additional arguments passed Future().","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a future — future","text":"future() returns Future evaluates expression expr. futureCall() returns Future calls function FUN arguments args. minifuture(expr) creates future minimal overhead, disabling user-friendly behaviors, e.g. automatic identification global variables packages needed, relaying output.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a future — future","text":"state future either unresolved resolved. value future can retrieved using v <- value(f). Querying value non-resolved future block call future resolved. possible check whether future resolved without blocking using resolved(f). futureCall() function works analogously .call(), calls function set arguments.  difference .call() returns value call whereas futureCall() returns future.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"eager-or-lazy-evaluation","dir":"Reference","previous_headings":"","what":"Eager or lazy evaluation","title":"Create a future — future","text":"default, future resolved using eager evaluation (lazy = FALSE).  means expression starts evaluated soon future created. alternative, future can resolved using lazy evaluation (lazy = TRUE).  means expression evaluated value future requested. Note means expression may evaluated - guaranteed evaluated value requested.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"globals-used-by-future-expressions","dir":"Reference","previous_headings":"","what":"Globals used by future expressions","title":"Create a future — future","text":"Global objects (short globals) objects (e.g. variables functions) needed order future expression evaluated local objects defined future expression. example, variable global future assignment f whereas b local variable. order future resolved successfully (correctly), globals need gathered future created available whenever wherever future resolved. default behavior (globals = TRUE), globals automatically identified gathered. precisely, globals identified via code inspection future expression expr values retrieved environment envir starting point (basically via get(global, envir = envir, inherits = TRUE)). cases, automatic collection globals sufficient less tedious error prone manually specified. However, full control, also possible explicitly specify exactly globals providing names character vector. example, use Yet another alternative explicitly specify also values using named list Specifying globals explicitly avoids overhead added automatically identifying globals gathering values. Furthermore, know future expression make use global variables, can disable automatic search globals using Future expressions often make use functions one packages. long functions part set globals, future package make sure packages attached future resolved.  need globals frozen exported, future package export , reduces amount transferred objects. example, variable x median() globals, x exported whereas median(), part stats package, exported.  Instead made sure stats package search path future expression evaluated. Effectively, becomes manually specify , one can either effectively . Although rarely needed, combination automatic identification manual specification globals supported via attributes add (add false negatives) ignore (ignore false positives) value TRUE.  example, globals = structure(TRUE, ignore = \"b\", add = \"\") globals automatically identified except b used addition global .","code":"a <- 42   f <- future({ b <- 2; a * b }) a <- 42   f <- future({ b <- 2; a * b }, globals = \"a\") a <- 42   f <- future({ b <- 2; a * b }, globals = list(a = a)) f <- future({ b <- 2; a * b }, globals = list(a = 42)) f <- future({ a <- 42; b <- 2; a * b }, globals = FALSE) x <- rnorm(1000)   f <- future({ median(x) }) x <- rnorm(1000)   f <- future({     library(stats)     median(x)   }) x <- rnorm(1000)   f <- future({     median(x)   }, globals = list(x = x, median = stats::median) x <- rnorm(1000)   f <- future({     library(stats)     median(x)   }, globals = list(x = x))"},{"path":[]},{"path":"https://future.futureverse.org/reference/future.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a future — future","text":"future logo designed Dan LaBar tweaked Henrik Bengtsson.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a future — future","text":"","code":"## Evaluate futures in parallel plan(multisession)  ## Data x <- rnorm(100) y <- 2 * x + 0.2 + rnorm(100) w <- 1 + x ^ 2   ## EXAMPLE: Regular assignments (evaluated sequentially) fitA <- lm(y ~ x, weights = w)      ## with offset fitB <- lm(y ~ x - 1, weights = w)  ## without offset fitC <- {   w <- 1 + abs(x)  ## Different weights   lm(y ~ x, weights = w) } print(fitA) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.2778       2.0244   #>  print(fitB) #>  #> Call: #> lm(formula = y ~ x - 1, weights = w) #>  #> Coefficients: #>     x   #> 2.028   #>  print(fitC) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.2938       1.9952   #>    ## EXAMPLE: Future assignments (evaluated in parallel) fitA %<-% lm(y ~ x, weights = w)      ## with offset fitB %<-% lm(y ~ x - 1, weights = w)  ## without offset fitC %<-% {   w <- 1 + abs(x)   lm(y ~ x, weights = w) } print(fitA) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.2938       1.9952   #>  print(fitB) #>  #> Call: #> lm(formula = y ~ x - 1, weights = w) #>  #> Coefficients: #>     x   #> 2.005   #>  print(fitC) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.2938       1.9952   #>    ## EXAMPLE: Explicitly create futures (evaluated in parallel) ## and retrieve their values fA <- future( lm(y ~ x, weights = w) ) fB <- future( lm(y ~ x - 1, weights = w) ) fC <- future({   w <- 1 + abs(x)   lm(y ~ x, weights = w) }) fitA <- value(fA) fitB <- value(fB) fitC <- value(fC) print(fitA) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.2938       1.9952   #>  print(fitB) #>  #> Call: #> lm(formula = y ~ x - 1, weights = w) #>  #> Coefficients: #>     x   #> 2.005   #>  print(fitC) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.2938       1.9952   #>   ## EXAMPLE: futureCall() and do.call() x <- 1:100 y0 <- do.call(sum, args = list(x)) print(y0) #> [1] 5050  f1 <- futureCall(sum, args = list(x)) y1 <- value(f1) print(y1) #> [1] 5050"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a future assignment — futureAssign","title":"Create a future assignment — futureAssign","text":"x %<-% value (also known \"future assignment\") futureAssign(\"x\", value) create Future evaluates expression (value) binds variable x (promise). expression evaluated parallel background. Later , x first queried, value future automatically retrieved regular variable x materialized regular value.","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a future assignment — futureAssign","text":"","code":"futureAssign(   x,   value,   envir = parent.frame(),   substitute = TRUE,   lazy = FALSE,   seed = FALSE,   globals = TRUE,   packages = NULL,   stdout = TRUE,   conditions = \"condition\",   earlySignal = FALSE,   label = NULL,   gc = FALSE,   ...,   assign.env = envir )  x %<-% value  fassignment %globals% globals fassignment %packages% packages  fassignment %seed% seed  fassignment %stdout% capture  fassignment %conditions% capture  fassignment %lazy% lazy  fassignment %label% label  fassignment %plan% strategy  fassignment %tweak% tweaks"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a future assignment — futureAssign","text":"x name future variable, hold value future expression (promise). value R expression. envir environment global objects identified. substitute TRUE, argument expr substitute():ed, otherwise . lazy FALSE (default), future resolved eagerly (starting immediately), otherwise . seed (optional) TRUE, random seed, , state random number generator (RNG) set statistically sound random numbers produced (also parallelization). FALSE (default), assumed future expression neither need use random numbers generation. use fixed random seed, specify L'Ecuyer-CMRG seed (seven integer) regular RNG seed (single integer).  latter, L'Ecuyer-CMRG seed automatically created based given seed. Furthermore, FALSE, future monitored make sure use random numbers.  depending value option future.rng.onMisuse, check ignored, informative warning, error produced. seed NULL, effect seed = FALSE without RNG check performed. globals (optional) logical, character vector, named list control globals handled. details, see section 'Globals used future expressions' help future(). packages (optional) character vector specifying packages attached R environment evaluating future. stdout TRUE (default), standard output captured, re-outputted value() called. FALSE, output silenced (sinking null device outputted). Using stdout = structure(TRUE, drop = TRUE) causes captured standard output dropped future object soon relayed. can help decrease overall memory consumed captured output across futures. Using stdout = NA fully avoids intercepting standard output; behavior unhandled standard output depends future backend. conditions character string conditions classes captured relayed.  default relay conditions, including messages warnings.  drop conditions, use conditions = character(0). Errors always relayed. Attribute exclude can used ignore specific classes, e.g. conditions = structure(\"condition\", exclude = \"message\") capture condition classes except inherits message class. Using conditions = structure(..., drop = TRUE) causes captured conditions dropped future object soon relayed, e.g. value(f). can help decrease overall memory consumed captured conditions across futures. Using conditions = NULL (recommended) avoids intercepting conditions, except errors; behavior unhandled conditions depends future backend environment R runs. earlySignal Specified whether conditions signaled soon possible . label character string label attached future. gc TRUE, garbage collector run (process evaluated future) value future collected. Exactly values collected may depend various factors number free workers whether earlySignal TRUE (frequently) FALSE (less frequently). types futures ignore argument. assign.env environment variable assigned. fassignment future assignment, e.g. x %<-% { expr }. capture TRUE, standard output captured, otherwise . strategy mechanism future resolved. See plan() details. tweaks named list (vector) arguments changed relative current strategy. ... Additional arguments passed Future().","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a future assignment — futureAssign","text":"futureAssign() x %<-% expr returns Future invisibly, e.g. f <- futureAssign(\"x\", expr) f <- (x %<-% expr).","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a future assignment — futureAssign","text":"future created via future assignment, x %<-% value futureAssign(\"x\", value), value bound promise, queried internally call value()  future resolved regular variable bound value. example, future assignment x %<-% value, first time variable x queried call blocks , , future yet resolved. soon resolved, succeeding queries, querying x immediately give value. future assignment construct x %<-% value formal assignment per se, binary infix operator objects x expression value. However, using non-standard evaluation, constructs can emulate assignment operator similar x <- value. Due R's precedence rules operators, future expressions often need explicitly bracketed, e.g. x %<-% { + b }.","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"adjust-future-arguments-of-a-future-assignment","dir":"Reference","previous_headings":"","what":"Adjust future arguments of a future assignment","title":"Create a future assignment — futureAssign","text":"future() futureAssign() take serveral arguments can used explicitly specify global variables packages future use. can also used override default behaviors future, e.g. whether output relayed . using future assignment, arguments can specified via corresponding assignment expression.  example, x %<-% { rnorm(10) } %seed% TRUE corresponds futureAssign(\"x\", { rnorm(10) }, seed = TRUE). several examples. explicitly specify variables functions future assignment use, use %globals%. explicitly specify packages need attacheed evaluate success, use %packages%. example,   median() function part 'stats' package. declare generate random numbers, use %seed%, e.g.   disable relaying standard output (e.g. print(), cat(), str()), keeping relaying conditions (e.g. message()   disable relaying conditions, use %conditions%, e.g.     create future without launching processed value really needed, use %lazy%, e.g.","code":"> x <- rnorm(1000) > y %<-% { median(x) } %globals% list(x = x) %packages% \"stats\" > y [1] -0.03956372 > x %<-% { rnorm(3) } %seed% TRUE > x [1] -0.2590562 -1.2262495  0.8858702 > x %<-% { cat(\"Hello\\n\"); message(\"Hi there\"); 42 } %stdout% FALSE > y <- 13 > z <- x + y Hi there > z [1] 55 > x %<-% { cat(\"Hello\\n\"); message(\"Hi there\"); 42 } %conditions% character(0) > y <- 13 > z <- x + y Hello > z [1] 55 > x %<-% { print(1:10); message(\"Hello\"); 42 } %stdout% FALSE > y <- 13 > z <- x + y Hello > z [1] 55 > x %<-% { Sys.sleep(5); 42 } %lazy% TRUE > y <- sum(1:10) > system.time(z <- x + y)   user  system elapsed   0.004   0.000   5.008 > z [1] 97"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"error-handling","dir":"Reference","previous_headings":"","what":"Error handling","title":"Create a future assignment — futureAssign","text":"future assignments promises, errors produced future expression signaled value future requested. example, create future assignment produce error, affected error \"touch\" future-assignment variable. example,","code":"> x %<-% { stop(\"boom\") } > y <- sum(1:10) > z <- x + y Error in eval(quote({ : boom"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"use-alternative-future-backend-for-future-assignment","dir":"Reference","previous_headings":"","what":"Use alternative future backend for future assignment","title":"Create a future assignment — futureAssign","text":"Futures evaluated future backend user specified plan(). regular futures, can temporarily use another future backend wrapping code [withPlan()], temporarily inside function using [localPlan()]. achieve specific future assignment, use %plan%, e.g.   x resolved background via multisession backend, whereas y resolved sequentially main R session.","code":"> plan(multisession) > x %<-% { 42 } > y %<-% { 13 } %plan% sequential > z <- x + y > z [1] 55"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"getting-the-future-object-of-a-future-assignment","dir":"Reference","previous_headings":"","what":"Getting the future object of a future assignment","title":"Create a future assignment — futureAssign","text":"underlying Future future variable x can retrieved without blocking using f <- futureOf(x), e.g.   Technically, future variable (promise) assigned time environment assign.env name future .future_<name>.","code":"> x %<-% { stop(\"boom\") } > f_x <- futureOf(x) > resolved(f_x) [1] TRUE > x Error in eval(quote({ : boom > value(f_x) Error in eval(quote({ : boom"},{"path":"https://future.futureverse.org/reference/futureOf.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the future of a future variable — futureOf","title":"Get the future of a future variable — futureOf","text":"Get future future variable created directly indirectly via future().","code":""},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the future of a future variable — futureOf","text":"","code":"futureOf(   var = NULL,   envir = parent.frame(),   mustExist = TRUE,   default = NA,   drop = FALSE )"},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the future of a future variable — futureOf","text":"var variable.  NULL, futures environment returned. envir environment search . mustExist TRUE variable exists, informative error thrown, otherwise NA returned. default default value future found. drop TRUE var NULL, returned list contains futures, otherwise also default values.","code":""},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the future of a future variable — futureOf","text":"Future (default). var NULL, named list Future:s returned.","code":""},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the future of a future variable — futureOf","text":"","code":"a %<-% { 1 }  f <- futureOf(a) print(f) #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     1 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’  b %<-% { 2 }  f <- futureOf(b) print(f) #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     2 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’  ## All futures fs <- futureOf() print(fs) #> $a #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     1 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’ #>  #> $b #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     2 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’ #>  #> $f #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     2 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’ #>    ## Futures part of environment env <- new.env() env$c %<-% { 3 }  f <- futureOf(env$c) print(f) #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     3 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’  f2 <- futureOf(c, envir = env) print(f2) #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     3 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’  f3 <- futureOf(\"c\", envir = env) print(f3) #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     3 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’  fs <- futureOf(envir = env) print(fs) #> $c #> SequentialFuture: #> Label: NULL #> Expression: #> { #>     3 #> } #> Lazy evaluation: FALSE #> Asynchronous evaluation: TRUE #> Local evaluation: TRUE #> Environment: 0x64e6dc9cc8f0 #> Capture standard output: TRUE #> Capture condition classes: ‘condition’ (excluding ‘<none>’) #> Immediate condition classes: ‘immediateCondition’ #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Resolved: TRUE #> Value: 39 bytes of class ‘numeric’ #> Early signaling: FALSE #> Owner process: 997ff7e05bc7bad4d8b3ef4303d69423 #> Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’ #>"},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Get future-specific session information and validate current backend — futureSessionInfo","title":"Get future-specific session information and validate current backend — futureSessionInfo","text":"Get future-specific session information validate current backend","code":""},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get future-specific session information and validate current backend — futureSessionInfo","text":"","code":"futureSessionInfo(test = TRUE, anonymize = TRUE)"},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get future-specific session information and validate current backend — futureSessionInfo","text":"test TRUE, one futures created query workers validate information. anonymize TRUE, user names host names anonymized.","code":""},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get future-specific session information and validate current backend — futureSessionInfo","text":"Nothing.","code":""},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get future-specific session information and validate current backend — futureSessionInfo","text":"","code":"plan(multisession, workers = 2) futureSessionInfo() #> *** Package versions #> future 1.34.0.9356, parallelly 1.43.0.9000, parallel 4.4.3, globals 0.16.3.9004, listenv 0.9.1.9001 #>  #> *** Allocations #> availableCores(): #>            system /proc/self/status             nproc  #>                 8                 8                 8  #> availableWorkers(): #> $nproc #> [1] \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" #> [7] \"localhost\" \"localhost\" #>  #> $system #> [1] \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" #> [7] \"localhost\" \"localhost\" #>  #> *** Settings #> - future.plan=<not set> #> - future.fork.multithreading.enable=<not set> #> - future.globals.maxSize=<not set> #> - future.globals.onReference=<not set> #> - future.resolve.recursive=<not set> #> - future.rng.onMisuse=<not set> #> - future.wait.timeout=<not set> #> - future.wait.interval=<not set> #> - future.wait.alpha=<not set> #> - future.startup.script=FALSE #>  #> *** Backends #> Number of workers: 2 #> List of future strategies: #> 1. multisession: #>    - args: function (..., workers = 2, envir = parent.frame()) #>    - tweaked: TRUE #>    - call: plan(multisession, workers = 2) #>  #> *** Basic tests #> Main R session details: #>       pid     r sysname          release #> 1 1440981 4.4.3   Linux 6.8.0-52-generic #>                                                            version nodename #> 1 #53~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jan 15 19:18:46 UTC 2  host001 #>   machine   login    user effective_user #> 1  x86_64 user001 user001        user001 #> Worker R session details: #>   worker     pid     r sysname          release #> 1      1 1441872 4.4.3   Linux 6.8.0-52-generic #> 2      2 1441871 4.4.3   Linux 6.8.0-52-generic #>                                                            version nodename #> 1 #53~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jan 15 19:18:46 UTC 2  host001 #> 2 #53~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jan 15 19:18:46 UTC 2  host001 #>   machine   login    user effective_user #> 1  x86_64 user001 user001        user001 #> 2  x86_64 user001 user001        user001 #> Number of unique worker PIDs: 2 (as expected) plan(sequential)"},{"path":"https://future.futureverse.org/reference/futures.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all futures in a container — futures","title":"Get all futures in a container — futures","text":"Gets futures environment, list, list environment returns object class (dimensions). Non-future elements returned .","code":""},{"path":"https://future.futureverse.org/reference/futures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all futures in a container — futures","text":"","code":"futures(x, ...)"},{"path":"https://future.futureverse.org/reference/futures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all futures in a container — futures","text":"x environment, list, list environment. ... used.","code":""},{"path":"https://future.futureverse.org/reference/futures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all futures in a container — futures","text":"object type x names /dimensions, set.","code":""},{"path":"https://future.futureverse.org/reference/futures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get all futures in a container — futures","text":"function useful retrieve futures created via future assignments (%<-%) therefore stored promises. function turns promises standard Future objects.","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":null,"dir":"Reference","previous_headings":"","what":"Inject code for the next type of future to use for nested futures — getExpression","title":"Inject code for the next type of future to use for nested futures — getExpression","text":"Inject code next type future use nested futures","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inject code for the next type of future to use for nested futures — getExpression","text":"","code":"getExpression(future, ...)"},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inject code for the next type of future to use for nested futures — getExpression","text":"future Current future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inject code for the next type of future to use for nested futures — getExpression","text":"future expression code injected set type future use nested futures, iff .","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inject code for the next type of future to use for nested futures — getExpression","text":"next future strategy specified, default use sequential futures.  conservative approach protects spawning recursive futures mistake, especially multicore multisession ones. default also set options(mc.cores = 1L) (*) parallel R processes spawned functions parallel::mclapply() friends. Currently possible specify type nested futures used, meaning default always used. See Issue #37 plans adding support custom nested future types. (*) Ideally set mc.cores = 0 unfortunately cause mclapply() friends generate error saying \"'mc.cores' must >= 1\".  Ideally functions fall back using non-multicore alternative case, e.g. mclapply(...) => lapply(...). See https://github.com/HenrikBengtsson/Wishlist--R/issues/7 discussion .","code":""},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieves global variables of an expression and their associated packages — getGlobalsAndPackages","title":"Retrieves global variables of an expression and their associated packages — getGlobalsAndPackages","text":"Retrieves global variables expression associated packages","code":""},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieves global variables of an expression and their associated packages — getGlobalsAndPackages","text":"","code":"getGlobalsAndPackages(   expr,   envir = parent.frame(),   tweak = tweakExpression,   globals = TRUE,   locals = getOption(\"future.globals.globalsOf.locals\", TRUE),   resolve = getOption(\"future.globals.resolve\"),   persistent = FALSE,   maxSize = getOption(\"future.globals.maxSize\", 500 * 1024^2),   onReference = getOption(\"future.globals.onReference\", \"ignore\"),   ... )"},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieves global variables of an expression and their associated packages — getGlobalsAndPackages","text":"expr R expression whose globals found. envir environment globals searched. tweak (optional) function takes expression returned modified one. globals (optional) logical, character vector, named list, Globals object.  TRUE, globals identified code inspection based expr tweak searching environment envir.  FALSE, globals used.  character vector, globals identified lookup based names globals searching environment envir.  named list Globals object, globals used . locals globals part \"local\" environment function included ? resolve TRUE, future global variables (part one) resolved replaced \"constant\" future. persistent TRUE, non-existing globals (= identified expression found memory) always silently ignored assumed existing evaluation environment.  FALSE, non-existing globals default ignore, may also trigger informative error option future.globals.onMissing \"error\" (used troubleshooting). maxSize maximum allowed total size (bytes) globals—purpose preventing large exports / transfers happening mistake.  total size global objects greater limit, informative error message produced. maxSize = +Inf, assertion skipped. (Default: 500 MiB). ... used.","code":""},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieves global variables of an expression and their associated packages — getGlobalsAndPackages","text":"named list elements expr (tweaked expression), globals (named list class FutureGlobals) packages (character string).","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/interrupt.html","id":null,"dir":"Reference","previous_headings":"","what":"Interrupts a running future — interrupt","title":"Interrupts a running future — interrupt","text":"Attempts interrupt running future. backend support interrupting futures, nothing done.","code":""},{"path":"https://future.futureverse.org/reference/interrupt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interrupts a running future — interrupt","text":"","code":"interrupt(x, ...)"},{"path":"https://future.futureverse.org/reference/interrupt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interrupts a running future — interrupt","text":"x Future. ... arguments used S3 methods.","code":""},{"path":"https://future.futureverse.org/reference/interrupt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interrupts a running future — interrupt","text":"interrupt() returns Future flagged \"interrupted\", backend supports interrupting futures.","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":null,"dir":"Reference","previous_headings":"","what":"Mandelbrot convergence counts — mandelbrot","title":"Mandelbrot convergence counts — mandelbrot","text":"Mandelbrot convergence counts","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mandelbrot convergence counts — mandelbrot","text":"","code":"mandelbrot(...)  # S3 method for class 'matrix' mandelbrot(Z, maxIter = 200L, tau = 2, ...)  # S3 method for class 'numeric' mandelbrot(   xmid = -0.75,   ymid = 0,   side = 3,   resolution = 400L,   maxIter = 200L,   tau = 2,   ... )"},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mandelbrot convergence counts — mandelbrot","text":"Z complex matrix convergence counts calculated. maxIter Maximum number iterations per bin. tau threshold; radius calling divergence (Mod(z) > tau). xmid, ymid, side, resolution Alternative specification complex plane Z, mean(Re(Z)) == xmid, mean(Im(Z)) == ymid, diff(range(Re(Z))) == side, diff(range(Im(Z))) == side, dim(Z) == c(resolution, resolution).","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mandelbrot convergence counts — mandelbrot","text":"Returns integer matrix (class Mandelbrot) non-negative counts.","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mandelbrot convergence counts — mandelbrot","text":"internal Mandelbrot algorithm inspired adopted similar GPL code Martin Maechler available ftp://stat.ethz.ch/U/maechler/R/ 2005-02-18 (sic!).","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mandelbrot convergence counts — mandelbrot","text":"","code":"counts <- mandelbrot(xmid = -0.75, ymid = 0, side = 3) str(counts) #>  'Mandelbrot' int [1:400, 1:400] 1 1 1 1 1 1 1 1 1 1 ... #>  - attr(*, \"params\")=List of 3 #>   ..$ Z      : cplx [1:400, 1:400] -2.25-1.5i -2.25-1.49i -2.25-1.48i ... #>   ..$ maxIter: int 200 #>   ..$ tau    : num 2 if (FALSE) { # \\dontrun{ plot(counts) } # }  if (FALSE) { # \\dontrun{ demo(\"mandelbrot\", package = \"future\", ask = FALSE) } # }"},{"path":"https://future.futureverse.org/reference/multicore.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","text":"multicore future future uses multicore evaluation, means value computed resolved parallel another process.","code":""},{"path":"https://future.futureverse.org/reference/multicore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","text":"","code":"multicore(   ...,   workers = availableCores(constraints = \"multicore\"),   gc = FALSE,   earlySignal = FALSE,   envir = parent.frame() )"},{"path":"https://future.futureverse.org/reference/multicore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","text":"workers number parallel processes use. function, called without arguments future created value used configure workers. gc TRUE, garbage collector run (process evaluated future) value future collected. Exactly values collected may depend various factors number free workers whether earlySignal TRUE (frequently) FALSE (less frequently). types futures ignore argument. earlySignal Specified whether conditions signaled soon possible . envir environment global objects identified. ... Additional named elements Future().","code":""},{"path":"https://future.futureverse.org/reference/multicore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","text":"Future. workers == 1, processing using done current/main R session therefore fall back using sequential future. override fallback, use workers = (1). also case whenever multicore processing supported, e.g. Windows.","code":""},{"path":"https://future.futureverse.org/reference/multicore.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","text":"function meant called directly.  Instead, typical usages :","code":"# Evaluate futures in parallel on the local machine via as many forked # processes as available to the current R process plan(multicore)  # Evaluate futures in parallel on the local machine via two forked processes plan(multicore, workers = 2)"},{"path":"https://future.futureverse.org/reference/multicore.html","id":"support-for-forked-multicore-processing","dir":"Reference","previous_headings":"","what":"Support for forked (\"multicore\") processing","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","text":"operating systems support process forking thereby multicore futures.  instance, forking supported Microsoft Windows. Moreover, process forking may break R environments RStudio. , future package disables process forking also cases.  See parallelly::supportsMulticore() details. Trying create multicore futures non-supported systems forking disabled result multicore futures falling back becoming sequential futures.  used RStudio, informative warning:","code":"> plan(multicore) Warning message: In supportsMulticoreAndRStudio(...) :   [ONE-TIME WARNING] Forked processing ('multicore') is not supported when running R from RStudio because it is considered unstable. For more details, how to control forked processing or not, and how to silence this warning in future R sessions, see ?parallelly::supportsMulticore"},{"path":[]},{"path":"https://future.futureverse.org/reference/multicore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process — multicore","text":"","code":"## Use multicore futures plan(multicore)  ## A global variable a <- 0  ## Create future (explicitly) f <- future({   b <- 3   c <- 2   a * b * c })  ## A multicore future is evaluated in a separate forked ## process.  Changing the value of a global variable ## will not affect the result of the future. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)"},{"path":"https://future.futureverse.org/reference/multisession.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a multisession future whose value will be resolved asynchronously in a parallel R session — multisession","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session — multisession","text":"multisession future future uses multisession evaluation, means value computed resolved parallel another R session.","code":""},{"path":"https://future.futureverse.org/reference/multisession.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session — multisession","text":"","code":"multisession(   ...,   workers = availableCores(),   lazy = FALSE,   rscript_libs = .libPaths(),   gc = FALSE,   earlySignal = FALSE,   envir = parent.frame() )"},{"path":"https://future.futureverse.org/reference/multisession.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session — multisession","text":"workers number parallel processes use. function, called without arguments future created value used configure workers. lazy FALSE (default), future resolved eagerly (starting immediately), otherwise . rscript_libs character vector R package library folders workers use.  default .libPaths() multisession workers inherits library path main R session. avoid , use plan(multisession, ..., rscript_libs = NULL). Important: Note library path set workers created, .e. plan(multisession) called.  changes .libPaths() main R session workers created effect. passed -parallelly::makeClusterPSOCK(). gc TRUE, garbage collector run (process evaluated future) value future collected. Exactly values collected may depend various factors number free workers whether earlySignal TRUE (frequently) FALSE (less frequently). types futures ignore argument. earlySignal Specified whether conditions signaled soon possible . envir environment global objects identified. ... Additional arguments passed Future().","code":""},{"path":"https://future.futureverse.org/reference/multisession.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session — multisession","text":"MultisessionFuture. workers == 1, processing done current/main R session therefore fall back using lazy future.  override fallback, use workers = (1).","code":""},{"path":"https://future.futureverse.org/reference/multisession.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session — multisession","text":"function meant called directly.  Instead, typical usages :   background R sessions (\"workers\") created using makeClusterPSOCK(). total number R sessions available including current/main R process, see parallelly::availableCores(). multisession future special type cluster future.","code":"# Evaluate futures in parallel on the local machine via as many background # processes as available to the current R process plan(multisession)  # Evaluate futures in parallel on the local machine via two background # processes plan(multisession, workers = 2)"},{"path":[]},{"path":"https://future.futureverse.org/reference/multisession.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session — multisession","text":"","code":"# \\donttest{  ## Use multisession futures plan(multisession)  ## A global variable a <- 0  ## Create future (explicitly) f <- future({   b <- 3   c <- 2   a * b * c })  ## A multisession future is evaluated in a separate R session. ## Changing the value of a global variable will not affect ## the result of the future. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)  ## Explicitly close multisession workers by switching plan plan(sequential) # }"},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the number of workers available — nbrOfWorkers","title":"Get the number of workers available — nbrOfWorkers","text":"Get number workers available","code":""},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the number of workers available — nbrOfWorkers","text":"","code":"nbrOfWorkers(evaluator = NULL)  nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)"},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the number of workers available — nbrOfWorkers","text":"evaluator future evaluator function. NULL (default), current evaluator returned plan() used. background TRUE, workers can process future background considered.  FALSE, also workers running main R process considered, e.g. using 'sequential' backend. ... used; reserved future use.","code":""},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the number of workers available — nbrOfWorkers","text":"nbrOfWorkers() returns positive number \\({1, 2, 3, ...}\\), future backends may also +Inf. nbrOfFreeWorkers() returns non-negative number \\({0, 1, 2, 3, ...}\\) less equal nbrOfWorkers().","code":""},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the number of workers available — nbrOfWorkers","text":"","code":"plan(multisession) nbrOfWorkers()  ## == availableCores() #> [1] 8  plan(sequential) nbrOfWorkers()  ## == 1 #> [1] 1"},{"path":"https://future.futureverse.org/reference/nullcon.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a connection to the system null device — nullcon","title":"Creates a connection to the system null device — nullcon","text":"Creates connection system null device","code":""},{"path":"https://future.futureverse.org/reference/nullcon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a connection to the system null device — nullcon","text":"","code":"nullcon()"},{"path":"https://future.futureverse.org/reference/nullcon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a connection to the system null device — nullcon","text":"Returns open, binary base::connection().","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":null,"dir":"Reference","previous_headings":"","what":"Plan how to resolve a future — plan","title":"Plan how to resolve a future — plan","text":"function allows user plan future, specifically, specifies future():s resolved, e.g. sequentially parallel.","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plan how to resolve a future — plan","text":"","code":"plan(   strategy = NULL,   ...,   substitute = TRUE,   .skip = FALSE,   .call = TRUE,   .cleanup = NA,   .init = TRUE )  tweak(strategy, ..., penvir = parent.frame())  withPlan(   strategy = NULL,   expr,   envir = parent.frame(),   .cleanup = NA,   substitute = TRUE,   ... )  localPlan(   strategy = NULL,   .cleanup = NA,   envir = parent.frame(),   substitute = TRUE,   ... )"},{"path":"https://future.futureverse.org/reference/plan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plan how to resolve a future — plan","text":"strategy existing future function name one. substitute TRUE, strategy expression substitute():d, otherwise . .skip (internal) TRUE, attempts set strategy currently use, skipped. .call (internal) Used recording call function. .cleanup (internal) Used stop implicitly started clusters. .init (internal) Used initiate workers. penvir environment used searching future function name. expr R expression evaluated. envir environment future plan set expression evaluated. ... Named arguments replace defaults existing arguments.","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plan how to resolve a future — plan","text":"plan() returns previous plan invisibly new strategy chosen, otherwise returns current one visibly. future function. withPlan() returns value expression evaluated invisibly. localPlan() returns current future plan applying temporary one.","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plan how to resolve a future — plan","text":"default strategy sequential, default can configured option future.plan , set, system environment variable R_FUTURE_PLAN. reset strategy back default, use plan(\"default\").","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"built-in-evaluation-strategies","dir":"Reference","previous_headings":"","what":"Built-in evaluation strategies","title":"Plan how to resolve a future — plan","text":"future package provides following built-backends: sequential: Resolves futures sequentially current R process, e.g. plan(sequential). multisession: Resolves futures asynchronously (parallel) separate R sessions running background machine, e.g. plan(multisession) plan(multisession, workers = 2). multicore: Resolves futures asynchronously (parallel) separate forked R processes running background machine, e.g. plan(multicore) plan(multicore, workers = 2). backend supported Windows. cluster: Resolves futures asynchronously (parallel) separate R sessions running typically one machines, e.g. plan(cluster), plan(cluster, workers = 2), plan(cluster, workers = c(\"n1\", \"n1\", \"n2\", \"server.remote.org\")). package provide additional evaluation strategies. example, future.callr package implements alternative multisession backend top callr package, e.g. plan(future.callr::callr, workers = 2). Another example future.batchtools package, implements, top batchtools package, e.g. plan(future.batchtools::batchtools_slurm). types futures resolved via job schedulers, typically available high-performance compute (HPC) clusters, e.g. LSF, Slurm, TORQUE/PBS, Sun Grid Engine, OpenLava. \"close\" background workers (e.g. multisession), change plan something different; plan(sequential) recommended .","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"for-package-developers","dir":"Reference","previous_headings":"","what":"For package developers","title":"Plan how to resolve a future — plan","text":"Please refrain modifying future strategy inside packages / functions, .e. call plan() code. Instead, leave control backend use end user. idea part core philosophy future framework—developer can never know future backends user access . Moreover, making assumptions backends available, code also work automatically new backends developed wrote code. think necessary modify future strategy within function, make sure undo changes exiting function. can archived using localPlan(), e.g. important end-user might already set future strategy elsewhere purposes likely known calling function break setup. Remember, package functions might used greater context multiple packages functions involved might also rely future framework, important avoid stepping others' toes.","code":"my_fcn <- function(x) {     localPlan(multisession)     y <- analyze(x)     summarize(y)   }"},{"path":"https://future.futureverse.org/reference/plan.html","id":"using-plan-in-scripts-and-vignettes","dir":"Reference","previous_headings":"","what":"Using plan() in scripts and vignettes","title":"Plan how to resolve a future — plan","text":"writing scripts vignettes use futures, try place call plan() far (.e. early ) code possible. help users quickly identify future plan set allow modify computational resources. Even better leave user set plan() prior source():ing script running vignette. .future.R exists current directory / user's home directory, sourced future package loaded. , .future.R file provides convenient place users set plan(). behavior can controlled via R option—see future options details.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/plan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plan how to resolve a future — plan","text":"","code":"a <- b <- c <- NA_real_  # An sequential future plan(sequential) f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA   # A sequential future with lazy evaluation plan(sequential) f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }, lazy = TRUE) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA   # A multicore future (specified as a string) plan(\"multicore\") f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA  ## Multisession futures gives an error on R CMD check on ## Windows (but not Linux or macOS) for unknown reasons. ## The same code works in package tests. # \\donttest{  # A multisession future (specified via a string variable) plan(\"future::multisession\") f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA  # }   ## Explicitly specifying number of workers ## (default is parallelly::availableCores()) plan(multicore, workers = 2) message(\"Number of parallel workers: \", nbrOfWorkers()) #> Number of parallel workers: 2   ## Explicitly close multisession workers by switching plan plan(sequential)"},{"path":"https://future.futureverse.org/reference/private_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets the length of an object without dispatching — .length","title":"Gets the length of an object without dispatching — .length","text":"Gets length object without dispatching","code":""},{"path":"https://future.futureverse.org/reference/private_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets the length of an object without dispatching — .length","text":"","code":".length(x)"},{"path":"https://future.futureverse.org/reference/private_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets the length of an object without dispatching — .length","text":"x R object.","code":""},{"path":"https://future.futureverse.org/reference/private_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets the length of an object without dispatching — .length","text":"non-negative integer.","code":""},{"path":"https://future.futureverse.org/reference/private_length.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gets the length of an object without dispatching — .length","text":"function returns length(unclass(x)), tries avoid calling unclass(x) unless necessary.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/re-exports.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions Moved to 'parallelly' — re-exports","title":"Functions Moved to 'parallelly' — re-exports","text":"following function used part future since migrated parallelly.  migration started future 1.20.0 (November 2020).  moved also useful outside future framework.","code":""},{"path":"https://future.futureverse.org/reference/re-exports.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions Moved to 'parallelly' — re-exports","text":"using future package, please switch use ones parallelly package. Thank ! parallelly::.cluster() parallelly::autoStopCluster()   (longer re-exported) parallelly::availableCores() parallelly::availableWorkers() parallelly::makeClusterMPI()    (longer re-exported) parallelly::makeClusterPSOCK() parallelly::makeNodePSOCK()     (longer re-exported) parallelly::supportsMulticore() backward-compatible reasons, functions remain available exact copies also package (re-exports), e.g.   can still accessed :   Note goal remove package.","code":"cl <- parallelly::makeClusterPSOCK(2) cl <- future::makeClusterPSOCK(2)"},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Writes and Reads 'immediateCondition' RDS Files — readImmediateConditions","title":"Writes and Reads 'immediateCondition' RDS Files — readImmediateConditions","text":"Writes Reads 'immediateCondition' RDS Files","code":""},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Writes and Reads 'immediateCondition' RDS Files — readImmediateConditions","text":"","code":"readImmediateConditions(   path = immediateConditionsPath(rootPath = rootPath),   rootPath = tempdir(),   pattern = \"[.]rds$\",   include = getOption(\"future.relay.immediate\", \"immediateCondition\"),   signal = FALSE,   remove = TRUE )  saveImmediateCondition(   cond,   path = immediateConditionsPath(rootPath = rootPath),   rootPath = tempdir() )"},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Writes and Reads 'immediateCondition' RDS Files — readImmediateConditions","text":"path (character string) folder RDS files . pattern (character string) regular expression selecting RDS files read. include (character vector) class classes objects kept. signal (logical) TRUE, condition read signaled. remove (logical) TRUE, RDS files used removed exit. cond condition class immediateCondition.","code":""},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Writes and Reads 'immediateCondition' RDS Files — readImmediateConditions","text":"readImmediateConditions() returns base::list immediateCondition objects. saveImmediateCondition() returns, invisibly, pathname RDS written.","code":""},{"path":"https://future.futureverse.org/reference/requestCore.html","id":null,"dir":"Reference","previous_headings":"","what":"Request a core for multicore processing — requestCore","title":"Request a core for multicore processing — requestCore","text":"cores available, current process blocks core available.","code":""},{"path":"https://future.futureverse.org/reference/requestCore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request a core for multicore processing — requestCore","text":"","code":"requestCore(await, workers = availableCores(), timeout, delta, alpha)"},{"path":"https://future.futureverse.org/reference/requestCore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request a core for multicore processing — requestCore","text":"await function used try \"collect\" finished multicore subprocesses. workers Total number workers available. timeout Maximum waiting time (seconds) allowed timeout error generated. delta base interval (seconds) wait try. alpha multiplicative factor used increase wait interval try.","code":""},{"path":"https://future.futureverse.org/reference/requestCore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Request a core for multicore processing — requestCore","text":"Invisible TRUE. cores available extensive waiting, timeout error thrown.","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":null,"dir":"Reference","previous_headings":"","what":"Reset a finished, failed, or interrupted future to a lazy future — reset","title":"Reset a finished, failed, or interrupted future to a lazy future — reset","text":"future successfully completed, interrupted, failed due error, can relaunched resetting .","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reset a finished, failed, or interrupted future to a lazy future — reset","text":"","code":"reset(x, ...)"},{"path":"https://future.futureverse.org/reference/reset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reset a finished, failed, or interrupted future to a lazy future — reset","text":"x Future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reset a finished, failed, or interrupted future to a lazy future — reset","text":"reset() returns lazy, vanilla Future can relaunched. Resetting running future results FutureError.","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reset a finished, failed, or interrupted future to a lazy future — reset","text":"lazy, vanilla Future can reused another R session. instance, :   can read evaluate future another R session using:","code":"library(future) a <- 2 f <- future(42 * a, lazy = TRUE) saveRDS(f, \"myfuture.rds\") library(future) f <- readRDS(\"myfuture.rds\") v <- value(f) print(v) #> [1] 84"},{"path":"https://future.futureverse.org/reference/reset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reset a finished, failed, or interrupted future to a lazy future — reset","text":"","code":"## Like mean(), but fails 90% of the time shaky_mean <- function(x) {   if (as.double(Sys.time()) %% 1 < 0.90) stop(\"boom\")   mean(x) }  x <- rnorm(100)  ## Calculate the mean of 'x' with a risk of failing randomly f <- future({ shaky_mean(x) })  ## Relaunch until success repeat({   v <- tryCatch(value(f), error = identity)   if (!inherits(v, \"error\")) break   message(\"Resetting failed future, and retry in 0.1 seconds\")   f <- reset(f)   Sys.sleep(0.1) }) #> Resetting failed future, and retry in 0.1 seconds #> Resetting failed future, and retry in 0.1 seconds #> Resetting failed future, and retry in 0.1 seconds #> Resetting failed future, and retry in 0.1 seconds #> Resetting failed future, and retry in 0.1 seconds cat(\"mean:\", v, \"\\n\") #> mean: -0.0300474"},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":null,"dir":"Reference","previous_headings":"","what":"Free up active background workers — resetWorkers","title":"Free up active background workers — resetWorkers","text":"Free active background workers","code":""},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Free up active background workers — resetWorkers","text":"","code":"resetWorkers(x, ...)"},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Free up active background workers — resetWorkers","text":"x FutureStrategy. ... used.","code":""},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Free up active background workers — resetWorkers","text":"function resolve active futures currently evaluated background workers.","code":""},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Free up active background workers — resetWorkers","text":"","code":"resetWorkers(plan())"},{"path":"https://future.futureverse.org/reference/resolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve one or more futures synchronously — resolve","title":"Resolve one or more futures synchronously — resolve","text":"function provides efficient mechanism waiting multiple futures container (e.g. list environment) resolved meanwhile retrieving values already resolved futures.","code":""},{"path":"https://future.futureverse.org/reference/resolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve one or more futures synchronously — resolve","text":"","code":"resolve(   x,   idxs = NULL,   recursive = 0,   result = FALSE,   stdout = FALSE,   signal = FALSE,   force = FALSE,   sleep = getOption(\"future.wait.interval\", 0.01),   ... )"},{"path":"https://future.futureverse.org/reference/resolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve one or more futures synchronously — resolve","text":"x Future resolved, list, environment, list environment futures resolved. idxs (optional) integer logical index specifying subset elements check. recursive non-negative number specifying deep recursion done.  TRUE, infinite recursion used.  FALSE zero, recursion performed. result (internal) TRUE, results retrieved, otherwise . Note collects results parallel worker, can help lower overall latency multiple concurrent futures. return collected results. stdout (internal) TRUE, captured standard output relayed, otherwise . signal (internal) TRUE, captured conditions relayed, otherwise . force (internal) TRUE, captured standard output captured conditions already relayed relayed , otherwise . sleep Number seconds wait checking futures resolved since last time. ... used.","code":""},{"path":"https://future.futureverse.org/reference/resolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve one or more futures synchronously — resolve","text":"Returns x (regardless subsetting ). signal TRUE one futures produces error, error produced.","code":""},{"path":"https://future.futureverse.org/reference/resolve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Resolve one or more futures synchronously — resolve","text":"function resolves synchronously, .e. blocks x containing futures resolved.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/resolved.html","id":null,"dir":"Reference","previous_headings":"","what":"Check whether a future is resolved or not — resolved","title":"Check whether a future is resolved or not — resolved","text":"Check whether future resolved ","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check whether a future is resolved or not — resolved","text":"","code":"resolved(x, ...)"},{"path":"https://future.futureverse.org/reference/resolved.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check whether a future is resolved or not — resolved","text":"x Future, list, environment (also includes list environment). ... used.","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check whether a future is resolved or not — resolved","text":"logical length dimensions x. element TRUE unless corresponding element non-resolved future case FALSE.","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check whether a future is resolved or not — resolved","text":"method needs implemented class implement Future API.  implementation return either TRUE FALSE must never throw error (except FutureError:s indicate significant, often unrecoverable infrastructure problems). also possible use method polling future resolved (without wait infinitely long), e.g. (!resolved(future)) Sys.sleep(5).","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the results of a resolved future — result.Future","title":"Get the results of a resolved future — result.Future","text":"Get results resolved future","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the results of a resolved future — result.Future","text":"","code":"# S3 method for class 'Future' result(future, ...)"},{"path":"https://future.futureverse.org/reference/result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the results of a resolved future — result.Future","text":"future Future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the results of a resolved future — result.Future","text":"FutureResult object.","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the results of a resolved future — result.Future","text":"function part backend Future API. function part frontend Future API.","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a future — run.Future","title":"Run a future — run.Future","text":"Run future","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a future — run.Future","text":"","code":"# S3 method for class 'Future' run(future, ...)"},{"path":"https://future.futureverse.org/reference/run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a future — run.Future","text":"future Future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a future — run.Future","text":"Future object.","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a future — run.Future","text":"function can called per future. calls result informative error. future run value queried, run point.","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":null,"dir":"Reference","previous_headings":"","what":"Robustly Saves an Object to RDS File Atomically — save_rds","title":"Robustly Saves an Object to RDS File Atomically — save_rds","text":"Robustly Saves Object RDS File Atomically","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robustly Saves an Object to RDS File Atomically — save_rds","text":"","code":"save_rds(object, pathname, ...)"},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robustly Saves an Object to RDS File Atomically — save_rds","text":"object R object save. pathname RDS file written. ... (optional) Additional arguments passed base::saveRDS().","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robustly Saves an Object to RDS File Atomically — save_rds","text":"pathname RDS written.","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Robustly Saves an Object to RDS File Atomically — save_rds","text":"Uses base::saveRDS internally writes object atomically first writing temporary file renamed.","code":""},{"path":"https://future.futureverse.org/reference/sequential.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a sequential future whose value will be in the current R session — sequential","title":"Create a sequential future whose value will be in the current R session — sequential","text":"sequential future future evaluated sequentially current R session similarly R expressions evaluated R. difference R globals validated default just types futures package.","code":""},{"path":"https://future.futureverse.org/reference/sequential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a sequential future whose value will be in the current R session — sequential","text":"","code":"sequential(..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())"},{"path":"https://future.futureverse.org/reference/sequential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a sequential future whose value will be in the current R session — sequential","text":"gc TRUE, garbage collector run (process evaluated future) value future collected. Exactly values collected may depend various factors number free workers whether earlySignal TRUE (frequently) FALSE (less frequently). types futures ignore argument. earlySignal Specified whether conditions signaled soon possible . envir environment global objects identified. ... Additional named elements Future().","code":""},{"path":"https://future.futureverse.org/reference/sequential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a sequential future whose value will be in the current R session — sequential","text":"Future.","code":""},{"path":"https://future.futureverse.org/reference/sequential.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a sequential future whose value will be in the current R session — sequential","text":"function meant called directly.  Instead, typical usages :","code":"# Evaluate futures sequentially in the current R process plan(sequential)"},{"path":"https://future.futureverse.org/reference/sequential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a sequential future whose value will be in the current R session — sequential","text":"","code":"## Use sequential futures plan(sequential)  ## A global variable a <- 0  ## Create a sequential future f <- future({   b <- 3   c <- 2   a * b * c })  ## Since 'a' is a global variable in future 'f' which ## is eagerly resolved (default), this global has already ## been resolved / incorporated, and any changes to 'a' ## at this point will _not_ affect the value of 'f'. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)"},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":null,"dir":"Reference","previous_headings":"","what":"Outputs details on the current R session — sessionDetails","title":"Outputs details on the current R session — sessionDetails","text":"Outputs details current R session","code":""},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outputs details on the current R session — sessionDetails","text":"","code":"sessionDetails(env = FALSE)"},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outputs details on the current R session — sessionDetails","text":"env TRUE, Sys.getenv() information returned.","code":""},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outputs details on the current R session — sessionDetails","text":"Invisibly list details.","code":""},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Signals Captured Conditions — signalConditions","title":"Signals Captured Conditions — signalConditions","text":"Captured conditions meet include exclude requirements signaled order captured.","code":""},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Signals Captured Conditions — signalConditions","text":"","code":"signalConditions(   future,   include = \"condition\",   exclude = NULL,   resignal = TRUE,   ... )"},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Signals Captured Conditions — signalConditions","text":"future resolved Future. include character string condition classes signal. exclude character string condition classes signal. resignal TRUE, already signaled conditions signaled , otherwise . ... used.","code":""},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Signals Captured Conditions — signalConditions","text":"Returns Future conditioned signaled flagged signaled.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":null,"dir":"Reference","previous_headings":"","what":"Place a sticky-globals environment immediately after the global environment — sticky_globals","title":"Place a sticky-globals environment immediately after the global environment — sticky_globals","text":"Place sticky-globals environment immediately global environment","code":""},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Place a sticky-globals environment immediately after the global environment — sticky_globals","text":"","code":"sticky_globals(erase = FALSE, name = \"future:sticky_globals\", pos = 2L)"},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Place a sticky-globals environment immediately after the global environment — sticky_globals","text":"erase (logical) TRUE, environment erased, otherwise . name (character) name environment base::search path. pos (integer) position search path environment positioned.  pos == 0L, environment detached, exists.","code":""},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Place a sticky-globals environment immediately after the global environment — sticky_globals","text":"(invisible; environment) environment.","code":""},{"path":"https://future.futureverse.org/reference/usedCores.html","id":null,"dir":"Reference","previous_headings":"","what":"Get number of cores currently used — usedCores","title":"Get number of cores currently used — usedCores","text":"Get number children (count current process) used current R session.  number children total number subprocesses launched process still running whose values yet collected.","code":""},{"path":"https://future.futureverse.org/reference/usedCores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get number of cores currently used — usedCores","text":"","code":"usedCores()"},{"path":"https://future.futureverse.org/reference/usedCores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get number of cores currently used — usedCores","text":"non-negative integer.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":null,"dir":"Reference","previous_headings":"","what":"The value of a future or the values of all elements in a container — value","title":"The value of a future or the values of all elements in a container — value","text":"Gets value future values elements (including futures) container list, environment, list environment. one futures unresolved, function blocks queried futures resolved.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The value of a future or the values of all elements in a container — value","text":"","code":"value(...)  # S3 method for class 'Future' value(future, stdout = TRUE, signal = TRUE, drop = FALSE, ...)  # S3 method for class 'list' value(   x,   idxs = NULL,   recursive = 0,   reduce = NULL,   stdout = TRUE,   signal = TRUE,   interrupt = TRUE,   inorder = TRUE,   drop = FALSE,   force = TRUE,   sleep = getOption(\"future.wait.interval\", 0.01),   ... )  # S3 method for class 'listenv' value(   x,   idxs = NULL,   recursive = 0,   reduce = NULL,   stdout = TRUE,   signal = TRUE,   interrupt = TRUE,   inorder = TRUE,   drop = FALSE,   force = TRUE,   sleep = getOption(\"future.wait.interval\", 0.01),   ... )  # S3 method for class 'environment' value(x, ...)"},{"path":"https://future.futureverse.org/reference/value.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The value of a future or the values of all elements in a container — value","text":"future, x Future, environment, list, list environment. stdout TRUE, standard output captured resolving futures relayed, otherwise . signal TRUE, conditions captured resolving futures relayed, otherwise . drop TRUE, resolved futures minimized size invalidated soon values collected output conditions relayed. Combining drop = TRUE inorder = FALSE reduces memory use sooner, especially avoiding risk holding future values end. idxs (optional) integer logical index specifying subset elements check. recursive non-negative number specifying deep recursion done.  TRUE, infinite recursion used.  FALSE zero, recursion performed. reduce optional function reducing values. Optional attribute init can used set initial value reduction. specified, first value used initial value. Reduction values done soon possible, always order x, unless inorder FALSE. interrupt TRUE signal TRUE, non-resolved futures interrupted soon error detected one futures, signaling error. inorder TRUE, standard output conditions relayed, value reduction, done order futures occur x, always soon possible. achieved buffering details can released. setting inorder = FALSE, buffering takes place everything relayed reduced soon new future resolved. Regardlessly, values always returned order x. force (internal) TRUE, captured standard output captured conditions already relayed relayed , otherwise . sleep Number seconds wait checking futures resolved since last time. ... arguments used S3 methods.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The value of a future or the values of all elements in a container — value","text":"value() Future object returns value future, can type R object. value() list, environment, list environment returns object number elements class. Names dimension attributes preserved, available. future elements replaced corresponding value() values. elements, existing object kept -. signal TRUE one futures produces error, error relayed. remaining, non-resolved futures x interrupted, prior signalling error.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The value of a future or the values of all elements in a container — value","text":"","code":"## ------------------------------------------------------ ## A single future ## ------------------------------------------------------ x <- sample(100, size = 50) f <- future(mean(x)) v <- value(f) message(\"The average of 50 random numbers in [1,100] is: \", v) #> The average of 50 random numbers in [1,100] is: 50    ## ------------------------------------------------------ ## Ten futures ## ------------------------------------------------------ xs <- replicate(10, { list(sample(100, size = 50)) }) fs <- lapply(xs, function(x) { future(mean(x)) })  ## The 10 values as a list (because 'fs' is a list) vs <- value(fs) message(\"The ten averages are:\") #> The ten averages are: str(vs) #> List of 10 #>  $ : num 48.8 #>  $ : num 50.7 #>  $ : num 48.6 #>  $ : num 54.3 #>  $ : num 49.1 #>  $ : num 46.5 #>  $ : num 48.4 #>  $ : num 49.8 #>  $ : num 47.1 #>  $ : num 50.2  ## The 10 values as a vector (by manually unlisting) vs <- value(fs) vs <- unlist(vs) message(\"The ten averages are: \", paste(vs, collapse = \", \")) #> The ten averages are: 48.84, 50.68, 48.56, 54.3, 49.1, 46.52, 48.42, 49.76, 47.12, 50.24  ## The values as a vector (by reducing) vs <- value(fs, reduce = `c`) message(\"The ten averages are: \", paste(vs, collapse = \", \")) #> The ten averages are: 48.84, 50.68, 48.56, 54.3, 49.1, 46.52, 48.42, 49.76, 47.12, 50.24  ## Calculate the sum of the averages (by reducing) total <- value(fs, reduce = `sum`) message(\"The sum of the ten averages is: \", total) #> The sum of the ten averages is: 493.54"},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":null,"dir":"Reference","previous_headings":"","what":"Options used for futures — zzz-future.options","title":"Options used for futures — zzz-future.options","text":"R options environment variables used future package packages enhancing .WARNING: Note names default values options may change future versions package.  Please use care notice.","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"packages-must-not-change-future-options","dir":"Reference","previous_headings":"","what":"Packages must not change future options","title":"Options used for futures — zzz-future.options","text":"Just like R options, package developer must change future.* options.  end-user set . find tweak one options, make sure undo changes immediately afterward.  example, want bump future.globals.maxSize limit creating future, use something like following inside function:","code":"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB on.exit(options(oopts)) f <- future({ expr })  ## Launch a future with large objects"},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"settings-moved-to-the-parallelly-package","dir":"Reference","previous_headings":"","what":"Settings moved to the 'parallelly' package","title":"Options used for futures — zzz-future.options","text":"Several functions moved parallelly package: parallelly::availableCores() parallelly::availableWorkers() parallelly::makeClusterMPI() parallelly::makeClusterPSOCK() parallelly::makeNodePSOCK() parallelly::supportsMulticore() options environment variables controlling adjusted accordingly different prefixes. example, option future.fork.enable renamed parallelly.fork.enable corresponding environment variable R_FUTURE_FORK_ENABLE renamed R_PARALLELLY_FORK_ENABLE. backward compatibility reasons, parallelly package support versions long foreseeable time. See parallelly::parallelly.options page settings.","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-controlling-futures","dir":"Reference","previous_headings":"","what":"Options for controlling futures","title":"Options used for futures — zzz-future.options","text":"future.plan: (character string future function) Default future strategy plan used unless otherwise specified via plan(). also future plan set calling plan(\"default\").  specified, option may set future package loaded command-line option --parallel=ncores (short -p ncores) specified; ncores > 1, option future.plan set multisession otherwise sequential (addition option mc.cores set ncores, ncores >= 1). (Default: sequential) future.globals.maxSize: (numeric) Maximum allowed total size (bytes) global variables identified. used protect exporting large objects parallel workers mistake. Transfering large objects network, internet, can slow therefore introduce large bottleneck increases overall processing time. can also result large egress ingress costs, may exist systems. set +Inf, check large globals skipped. (Default: 500 * 1024 ^ 2 = 500 MiB) future.globals.onReference: (beta feature - may change) (character string) Controls whether identified globals scanned called references (e.g. external pointers connections) .  unlikely another R process (\"worker\") can use global uses internal reference master R process—call objects non-exportable globals. option \"error\", informative error message produced non-exportable global detected. \"warning\", warning produced, processing continue; likely future resolved run-time error unless processed master R process (e.g. plan(sequential) plan(multicore)). \"ignore\", scan performed. (Default: \"ignore\" may change) future.resolve.recursive: (integer) integer specifying maximum recursive depth futures resolved. negative, nothing resolved.  0, future resolved.  1, future elements futures resolved, . +Inf, infinite search depth used. (Default: 0) future.rng.onMisuse: (beta feature - may change) (character string) random numbers used futures, parallel (L'Ecuyer-CMRG) RNG used order get statistical sound RNGs. defaults future framework assume random number generation (RNG) taken place future expression L'Ecuyer-CMRG RNGs come unnecessary overhead needed.  protect mistakes, future framework attempts detect random numbers used despite L'Ecuyer-CMRG RNGs place.  detected, future.rng.onMisuse = \"error\", informative error message produced.  \"warning\", warning message produced.  \"ignore\", check performed. (Default: \"warning\") future.connections.onMisuse: (beta feature - may change) (character string) future must close connections opens must close connections open. misuse detected option set \"error\", value() produce error details. set \"warning\", warning produced. \"ignore\", check performed. (Default: \"warning\") future.globalenv.onMisuse: (beta feature - may change) (character string) Assigning variables global environment purpose using variable later time makes sense futures, next future may evaluated different R process.  protect mistakes, future framework attempts detect variables added global environment.  detected, future.globalenv.onMisuse = \"error\", informative error message produced.  \"warning\", warning message produced.  \"ignore\", check performed. (Default: \"ignore\") future.onFutureCondition.keepFuture: (logical) TRUE, FutureCondition keeps copy Future object triggered condition. FALSE, dropped. (Default: TRUE) future.wait.timeout: (numeric) Maximum waiting time (seconds) future resolve free worker become available timeout error generated. (Default: 30 * 24 * 60 * 60 (= 30 days)) future.wait.interval: (numeric) Initial interval (seconds) polls. controls polling frequency finding available worker workers currently busy. also controls polling frequency resolve(). (Default: 0.01 = 1 ms) future.wait.alpha: (numeric) Positive scale factor used increase interval poll. (Default: 1.01)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-debugging-futures","dir":"Reference","previous_headings":"","what":"Options for debugging futures","title":"Options used for futures — zzz-future.options","text":"future.debug: (logical) TRUE, extensive debug messages generated. (Default: FALSE)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-controlling-package-startup","dir":"Reference","previous_headings":"","what":"Options for controlling package startup","title":"Options used for futures — zzz-future.options","text":"future.startup.script: (character vector logical) Specifies zero future startup scripts sourced future package attached. first existing script sourced. none specified files exist, nothing sourced—neither warning error. option specified, environment variable R_FUTURE_STARTUP_SCRIPT considered, multiple scripts may separated either colon (:) semicolon (;). neither set, either set TRUE, default look .future.R script current directory user's home directory.  disable future startup scripts, set option environment variable FALSE.  Importantly, option always set FALSE future package loaded part future expression evaluated, e.g. background process. order words, sourced main R process future processes. (Default: TRUE main R process FALSE future processes / future evaluation) future.cmdargs: (character vector) Overrides commandArgs() future package loaded.","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-configuring-low-level-system-behaviors","dir":"Reference","previous_headings":"","what":"Options for configuring low-level system behaviors","title":"Options used for futures — zzz-future.options","text":"future.fork.multithreading.enable (beta feature - may change): (logical) Enable disable multi-threading using forked parallel processing.  FALSE, different multi-thread library settings overridden run single-thread mode. Specifically, multi-threading disabled OpenMP (requires RhpcBLASctl package) RcppParallel. TRUE, set (default), multi-threading allowed.  Parallelization via multi-threaded processing (done native code packages external libraries) time using forked (aka \"multicore\") parallel processing known unstable.  Note true using plan(multicore) also using, instance, mclapply() parallel package. (Default: set) future.output.windows.reencode: (logical) Enable disable re-encoding UTF-8 symbols incorrectly encoded captured.  R (< 4.2.0) older versions MS Windows, R capture UTF-8 symbols -captured standard output.  examples, UTF-8 check mark symbol (\"\\u2713\") relayed \"<U+2713>\" (string eight ASCII characters).  Setting option TRUE cause value() attempt recover intended UTF-8 symbols <U+nnnn> string components, , , string captured future resolved MS Windows. (Default: TRUE) See also parallelly::parallelly.options.","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-demos","dir":"Reference","previous_headings":"","what":"Options for demos","title":"Options used for futures — zzz-future.options","text":"future.demo.mandelbrot.region: (integer) Either named list mandelbrot() arguments integer {1, 2, 3} specifying predefined Mandelbrot region. (Default: 1L) future.demo.mandelbrot.nrow: (integer) Number rows columns tiles. (Default: 3L)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"deprecated-or-for-internal-prototyping","dir":"Reference","previous_headings":"","what":"Deprecated or for internal prototyping","title":"Options used for futures — zzz-future.options","text":"following options exists troubleshooting purposes must used production.  used, risk results non-reproducible processed elsewhere.  lower risk used mistake, marked deprecated produce warnings set. future.globals.onMissing: (character string) Action take non-existing global variables (\"globals\" \"unknowns\") identified future created.  \"error\", error generated immediately.  \"ignore\", action taken attempt evaluate future expression made.  latter useful risk false-positive globals identified, e.g. future expression contains non-standard evaluation (NSE).  (Default: \"ignore\") future.globals.method: (character string) Method used identify globals. details, see globalsOf(). (Default: \"ordered\") future.globals.resolve: (logical) TRUE, globals Future objects (typically created explicit futures) resolved values (using value()) collected.  searching unresolved futures among globals (including content) can expensive, default instead leave run-time checks assert proper ownership resolving futures collecting values. (Default: FALSE)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"environment-variables-that-set-r-options","dir":"Reference","previous_headings":"","what":"Environment variables that set R options","title":"Options used for futures — zzz-future.options","text":"R future.* options can set corresponding environment variable R_FUTURE_* future package loaded. means environment variables must set future package loaded order effect. example, R_FUTURE_RNG_ONMISUSE=\"ignore\", option future.rng.onMisuse set \"ignore\" (character string). Similarly, R_FUTURE_GLOBALS_MAXSIZE=\"50000000\", option future.globals.maxSize set 50000000 (numeric).","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options used for futures — zzz-future.options","text":"","code":"# Allow at most 5 MB globals per futures options(future.globals.maxSize = 5e6)  # Be strict; catch all RNG mistakes options(future.rng.onMisuse = \"error\")"},{"path":"https://future.futureverse.org/news/index.html","id":"version-development-version","dir":"Changelog","previous_headings":"","what":"Version (development version)","title":"Version (development version)","text":"first rollout three major updates, now possible due multi-year effort internal re-designs, work package maintainers, release, repeat. release comes large redesign future backends implemented internally. One goal lower threshold implementing exciting, new features, old hold long. features available already release, come near-future releases. Another goal make straightforward implement new backend. update fully backward compatible previous versions. Developers end-users can expect business usual. Like releases, version validated thoroughly via reverse-dependency checks, future.tests checks, .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-development-version","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version (development version)","text":"Add localPlan() withPlan() functions evaluating expression, including futures, using temporary future plan. Add interrupt(), interrupts future, parallel backend supports , otherwise silently ignored. can also used container (.e. lists, listenv:s environment) futures. Add reset(), resets future completed, failed, interrupted. future reset back lazy, vanilla future can relaunched. value() containers gained argument reduce, specifies function reducing values, e.g. values(fs, reduce =    `+`). Optional attribute init controls initial value. Note attributes must set primitive functions. workaround, use reduce = structure(\"+\", init = 42). value() containers gained argument inorder, can used control whether standard output conditions relayed order x, soon future x resolved. also controls order values reduced. value() gained argument drop turn resolved futures minimal, invalid light-weight futures values returned. reduces memory use. particularly useful using reduce combination inorder = FALSE. instance, list futures fs, know need query futures values , memory efficient performant use v <-    value(fs, reduce = `+`, inorder = FALSE, drop = TRUE). value() containers interrupts non-resolved futures error detected one futures. Add minifuture(), like future(), different default arguments resulting less overhead added burden specify globals packages, conditions standard output relayed, ignoring random number generation. Printing plan() output details future backend, e.g. number workers, number free workers, backend settings, summary resolved non-resolved, active futures. Interrupted futures now handled produce informative error. Timeout errors triggered setTimeLimit() now relayed. Failures launch future now detected, handled, relayed error details failed. future must close connections opens, must never close connections open. Now value() produces warning misuse detected. may upgrade error future releases. default behavior can controlled via R option. Reverse dependency checks spotted one CRAN package, 426, problem. parallel backends now prevent nested parallelization, unless explicitly allowed, e.g. settings recognized parallelly::availableCores() set future plan(). Previously, implemented backend, now ’s handled automatically future framework. Add new FutureBackend API writing future backends. maximum total size objects send worker can now configured per backend, e.g. plan(multisession,    maxSizeOfObjects = 10e6) produce error total size globals exceeds 10 MB. Backends sequential multicore longer limit maximum size globals, .e. now default maxSizeOfObjects    = +Inf. Backends cluster multisession also default maxSizeOfObjects = +Inf, unless R option future.globals.maxSize (sic!) set.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-development-version","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version (development version)","text":"Now ‘interrupt’ conditions captured evaluation future, results evaluation terminated FutureInterruptError. backends manage catch interrupts, leading parallel R workers terminate, resulting regular FutureError. Previously, interrupts result un-determistic behavior errors depending future backend. Timeout errors triggered setTimeLimit() likely render future corresponding worker invalid. Identified fixed one reason cluster multisession futures result errors “Unexpected result (class ‘NULL’ != ‘FutureResult’) retrieved MultisessionFuture future … suggests communication ‘RichSOCKnode’ #1 host ‘localhost’ (R development (unstable) (2025-03-23 r88038), platform x86_64-pc-linux-gnu) sync.” Switching plan active futures likely result active futures becoming corrupt, resulting unpredictable errors querying future , instance, value(), also resolved(), never produce error. Now futures become predictable, interrupted futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-development-version","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version (development version)","text":"Updated future topology vignette information CPU-overuse protection error may occur using nested future plan avoid .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"cleanup-development-version","dir":"Changelog","previous_headings":"","what":"Cleanup","title":"Version (development version)","text":"Starting future 1.20.0 (2020-10-30), several low-level functions creating working PSOCK MPI clusters moved parallelly package. backward-compatibility reasons, functions kept future re-exports, e.g. future::makeClusterPSOCK() still works, whereas parallelly::makeClusterPSOCK() preferred use. long-term goal clean re-exports. Starting release, future package longer re-exports autoStopCluster(), makeClusterMPI(), makeNodePSOCK().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1340","dir":"Changelog","previous_headings":"","what":"Version 1.34.0","title":"Version 1.34.0","text":"CRAN release: 2024-07-29","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-34-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.34.0","text":"Added support backend maintainers specify “cleanup” hook functions future strategies, called switching future plan. hook functions specified via optional cleanup attribute, cf. attr(cluster, \"cleanup\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-34-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.34.0","text":"Size calculation globals now done using much faster parallelly::serializedSize().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-34-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.34.0","text":"resolved() ClusterFuture:s produce Error:    'inherits(future, \"Future\")' TRUE instead intended, informative error message connection parallel worker broken.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1332","dir":"Changelog","previous_headings":"","what":"Version 1.33.2","title":"Version 1.33.2","text":"CRAN release: 2024-03-26","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-33-2","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.33.2","text":"Decreased overhead launching futures occurred future strategies used complex workers argument. example, plan(cluster, workers = cl), cl cluster object, come extra overhead, workers object unnecessarily transferred cluster nodes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-33-2","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.33.2","text":"Now plan(multisession, workers = (n)), cluster, preserves “AsIs” class attribute workers argument propagated parallelly::makeClusterWorkers().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-33-2","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.33.2","text":"Clarify packages must change future.* options.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1331","dir":"Changelog","previous_headings":"","what":"Version 1.33.1","title":"Version 1.33.1","text":"CRAN release: 2023-12-22","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-33-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.33.1","text":"getExpression() ‘cluster’ future circumstances call local() global search path rather base::local() intended. example, package exports local() function attached, called instead, often leading hard--troubleshoot error.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1330","dir":"Changelog","previous_headings":"","what":"Version 1.33.0","title":"Version 1.33.0","text":"CRAN release: 2023-07-01","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-33-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.33.0","text":"‘cluster’ future fails communicate parallel worker, post-mortem analysis figure , including inspecting whether worker process still alive . previous versions, worked workers running current machine. Starting version, also attempts check remote versions.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-33-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.33.0","text":"‘multicore’ future failed, parallel process crashed, corresponding parallel-worker slot never released. Now removed can confirm forked worker process longer alive.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-33-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.33.0","text":"‘multiprocess’ strategy now fully removed. Please use ‘multisession’ (recommended) ‘multicore’ instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1320","dir":"Changelog","previous_headings":"","what":"Version 1.32.0","title":"Version 1.32.0","text":"CRAN release: 2023-03-07","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-32-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.32.0","text":"Add prototype internal event-logging framework purpose profiling futures backends. Add option future.globalenv.onMisuse optionally asserting future expression result variables added global environment. Add option future.onFutureCondition.keepFuture controlling whether FutureCondition objects keep copy Future object . default keep copy, future carries large global objects, FutureCondition also large, can result memory issues slow downs.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-32-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.32.0","text":"Fix future.tests check occurred MS Windows.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-32-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.32.0","text":"‘multiprocess’ strategy, deprecated since future 1.20.0 [2020-10-30] now defunct. Please use ‘multisession’ (recommended) ‘multicore’ instead. Add optional assertion internal Future state field.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1310","dir":"Changelog","previous_headings":"","what":"Version 1.31.0","title":"Version 1.31.0","text":"CRAN release: 2023-02-01","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-31-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.31.0","text":"Remove function remote(). Note plan(remote, ...) deprecated since future 1.24.0 [2022-02-19] defunct since future 1.30.0 (2022-12-15).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-31-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.31.0","text":"Add example ‘Common Issues Solutions’ vignette magrittr pipes can result error used future assignment operator fix .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-31-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.31.0","text":"Error messages contain deparsed version future expression become large cases expression comprise expanded, large objects. Now first 100 lines expression deparsed.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-31-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.31.0","text":"Deprecated plan(multiprocess, ...) now equals plan(sequential), still producing one warning time future created. Argument local defunct removed. Previously local = FALSE defunct. Remove defunct argument value resolve() methods. Remove defunct functions transparent() TransparentFuture().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1300","dir":"Changelog","previous_headings":"","what":"Version 1.30.0","title":"Version 1.30.0","text":"CRAN release: 2022-12-15","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-30-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.30.0","text":"futureOf() used listenv::map(), deprecated listenv (>= 0.9.0) favor listenv::mapping(). Starting R (>= 4.2.0), internal function myInternalIP() longer detected attempted system call failed, resulting obscure error instead falling back alternatives. errors produced system2() longer inherits class simpleError.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-30-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.30.0","text":"Strategy ‘remote’ deprecated future 1.24.0 now defunct. Use plan(cluster, ..., persistent = TRUE) instead. Note persistent = TRUE eventually also become deprecated defunct, alternative solution available.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1290","dir":"Changelog","previous_headings":"","what":"Version 1.29.0","title":"Version 1.29.0","text":"CRAN release: 2022-11-06","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-29-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.29.0","text":"Add section ‘Making sure stop parallel workers’ ‘Best Practices Package Developers’, explains R CMD check may produce “checking detritus temp directory … NOTE” avoid .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-29-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.29.0","text":"evaluation sequential future reset warnings collected R prior creating future. happened plan(sequential) getOption(\"warn\") == 0. bug introduced future 1.26.0 [2022-05-27].","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-29-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.29.0","text":"Using deprecated plan(multiprocess) now trigger deprecation warning time multiprocess future created. means lot warnings produced. Note multiprocess deprecated since future 1.20.0 [2020-10-30]. Please use multisession (recommended) multicore instead. Removing values(), defunct since future 1.23.0. Use value() instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1280","dir":"Changelog","previous_headings":"","what":"Version 1.28.0","title":"Version 1.28.0","text":"CRAN release: 2022-09-02","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-28-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.28.0","text":"Mention source(..., local = TRUE) preferred source() used inside futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-28-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.28.0","text":".call(plan, args = list(multisession, workers = 2)) ignore workers argument, arguments.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-28-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.28.0","text":"Previously deprecated use local = FALSE futures now defunct. R option temporarily allow plan(transparent) although declared defunct now removed; plan(transparent), together functions transparent() TransparentFuture() now formally defunct. Using argument persistent multisession futures now defunct. Previously persistent = TRUE defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-28-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.28.0","text":"Use CSS style align image right instead non-HTML5 attribute align=\"right\". Avoid nested <em> tags HTML-generated help pages.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1270","dir":"Changelog","previous_headings":"","what":"Version 1.27.0","title":"Version 1.27.0","text":"CRAN release: 2022-07-22","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-27-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.27.0","text":"fallback sequential processing done ‘multicore’ ‘multisession’ workers = 1 can now overridden specifying workers = (1).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-27-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.27.0","text":"warnings errors showed wrong call. print() FutureResult report captured conditions class list, instead condition classes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1261","dir":"Changelog","previous_headings":"","what":"Version 1.26.1","title":"Version 1.26.1","text":"CRAN release: 2022-05-27","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-26-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.26.1","text":"TESTS: R CMD check ---cran R-devel MS Windows trigger NOTE “Check: detritus temp directory” “Found following files/directories: ‘Rscript1349cb8aeeba0’ …”. two package tests explicitly created PSOCK cluster without stopping . third test launched multisession future without resolving , prevented PSOCK worker terminate. detected R 4.2.0. problem macOS Linux, background workers automatically terminated main R session terminates.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-26-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.26.0","text":"R options environment variables now reset workers future resolved packages required future loaded attached. Previously, reset loaded attached. addition, pre-existing R options environment variables reset. new ones added removed now, know added R options environment variables might added loading package essential package work. changed evaluating future expression, current working directory now reset future resolved.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-26-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.26.0","text":"futureSessionInfo() gained argument anonymize. TRUE (default), host user names anonymized. futureSessionInfo() now also report main R session details.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-26-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.26.0","text":"bug fix future 1.22.0 addressed issue object future(fcn(), globals = list(= 42, fcn =    function() )) found redesigned robust way. Use packages data.table ff cluster multisession futures broke future 1.25.0. data.table, saw “Error setalloccol(ans) : verbose must TRUE FALSE”. ff, saw “Error splitted$path[nopath] <- getOption(”fftempdir”) : replacement length zero”. See ‘Significant Changes’ fixed. deprecation warning using local = FALSE silenced sequential futures since future 1.25.0. futureCall() ignored arguments stdout, conditions, earlySignal, label, gc.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-26-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.26.0","text":"Strategy ‘transparent’ deprecated future 1.24.0 now defunct. Use plan(sequential, split = TRUE) instead. Strategy ‘multiprocess’ deprecated future 1.20.0, ‘remote’ deprecated future 1.24.0. Since , attempts use plan() produce deprecation warning, limited one per R session. Starting release, warning now produced whenever using plan() deprecated future strategies.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1250","dir":"Changelog","previous_headings":"","what":"Version 1.25.0","title":"Version 1.25.0","text":"CRAN release: 2022-04-24","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-25-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.25.0","text":"R options environment variables now reset workers future resolved changes future expression effect following futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-25-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.25.0","text":"Now f <- future(..., stdout = structure(TRUE, drop = TRUE)) cause captured standard output dropped future object soon relayed , instance, value(f). Similarly, conditions = structure(\"conditions\", drop =    TRUE) drop captured non-error conditions soon relayed. can help decrease amount memory used, especially many active futures. Now resolve() respects option future.wait.interval. Previously, hardcoded poll results every 0.1 seconds.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-25-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.25.0","text":"Now, value() attempt recover UTF-8 symbols captured standard output future evaluated MS Windows support capturing UTF-8 symbols. Support UTF-8 capturing also MS Windows added R 4.2.0, typically requires --date MS Windows 10 MS Windows Server 2022.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-25-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.25.0","text":"default value option future.wait.interval decreased 0.2 seconds 0.01 seconds. controls polling frequency finding available worker workers currently busy. Starting release, option also controls polling frequency resolve().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-25-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.25.0","text":"bug introduced future 1.24.0 [2022-02-19] caused future plan tweaking break, e.g. plan(multicore, workers = 2) plan(sequential, split = TRUE) introduced breaking side effects futures evaluated.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1240","dir":"Changelog","previous_headings":"","what":"Version 1.24.0","title":"Version 1.24.0","text":"CRAN release: 2022-02-19","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-24-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.24.0","text":"Now future(..., seed = TRUE) forwards RNG state calling R session. Previously, leave intact.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-24-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.24.0","text":"Now plan() tweak() preserve calls arguments, e.g. plan(multisession, workers = 2, rscript_startup =    quote(options(socketOptions=\"-delay\"))), tweak(..., abc =    quote(x == y)).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-24-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.24.0","text":"nbrOfFreeWorkers() produce “Error: ‘.character(name)’ TRUE” plan(multisession, workers = 1). Internal calls FutureRegistry(action = \"collect-first\") FutureRegistry(action = \"collect-last\") signal errors early polling resolved().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-24-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.24.0","text":"Strategy ‘remote’ deprecated favor ‘cluster’. plan() function give informative deprecation warning ‘remote’ used. now, warning given per R session. Strategy ‘transparent’ deprecated favor ‘sequential’ argument split = TRUE set. plan() function give informative deprecation warning ‘transparent’ used. now, warning given per R session.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1230","dir":"Changelog","previous_headings":"","what":"Version 1.23.0","title":"Version 1.23.0","text":"CRAN release: 2021-10-31","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-23-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.23.0","text":"plan() now produces one-time warning ‘transparent’ strategy set. warning reminds user ‘transparent’ used troubleshooting purposes never used production. days plan(sequential, split = TRUE) together debug() probably better approach troubleshooting. long-term plan deprecate ‘transparent’ strategy. Support persistent = TRUE multisession futures defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-23-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.23.0","text":"UTF-8 symbols outputted MS Windows relayed escaped symbols, e.g. UTF-8 check mark symbol (\\u2713) relayed <U+2713> (8 characters). reason limitation R MS Windows. Now, value() attempts recover MS Windows output UTF-8 relaying . option disabling new feature.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-23-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.23.0","text":"TESTS: Using robust emulation crashed forked parallel workers understanding quit() must used forked R processes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-23-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.23.0","text":"Now future(..., seed) set random seed late possible just future expression evaluated. Previously done package dependencies attached, lead non-reproduce random numbers case package dependency update RNG seed attached.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-23-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.23.0","text":"values(), deprecated since future 1.20.0, now defunct. Use value() instead. Support persistent = TRUE multisession futures defunct. still needed, temporary workaround use cluster futures. However, likely support persistent eventually deprecated future backends. Argument value resolve(), deprecated since future 1.15.0, defunct favor argument result.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1221","dir":"Changelog","previous_headings":"","what":"Version 1.22.1","title":"Version 1.22.1","text":"CRAN release: 2021-08-25","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-22-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.22.1","text":"Disable package test emulates crashing forked parallel workers using parallel::makeCluster(..., type = \"FORK\"). test disabled macOS, appears main R session becomes unstable FORK node terminated.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-22-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.22.0","text":"lazy future remains generic future launched, means assigned future backend class launched. Argument seed futureAssign() futureCall() now defaults FALSE just like future(). R_FUTURE_* environment variables now read future package loaded, set corresponding future.* option. Previously, environment variables queried different functions fallback option set. parsing package loaded, decrease overhead functions, clarifies options can changed runtime whereas environment variables set startup.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-22-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.22.0","text":"overhead initiating futures significantly reduced. example, roundtrip time value(future(NULL)) twice fast ‘sequential’, ‘cluster’, ‘multisession’ futures. ‘multicore’ futures roundtrip speedup 20%. speedup comes pre-compiling R expression used resolve future expression R expression templates can quickly compiled future. speeds creation expression ~10 times, compared re-compiling time. default timeout resolved() decreased 0.20 0.01 seconds cluster/multisession multicore futures, means spend less time waiting results available.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-22-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.22.0","text":"Analogously globals may scanned “non-exportable” objects option future.globals.onReference set \"error\" \"warning\", value() now check similar problems resolved value object. example f <-    future(xml2::read_xml(\"<body><\/body>\")), result invalid xml_document object run parallel, objects transferred R processes. addition specify condition classes captured relayed, now possible also specify condition classes ignored. example, conditions = structure(\"condition\", exclude    = \"message\") captures conditions message conditions. Now cluster futures use homogeneous = NULL default instead homogeneous = TRUE. new default result parallelly package trying infer whether TRUE FALSE used based workers argument. Now post-mortem analysis report multicore cluster futures case results retrieved include information globals sizes, non-exportable. similar, detailed report also produced cluster future fails set launch parallel worker. option future.fork.multithreading.enable FALSE, RcppParallel, addition OpenMP, forced run single threaded whenever running forked process (=‘multicore’ futures). done setting environment variable RCPP_PARALLEL_NUM_THREADS 1. Add futureSessionInfo() get quick overview future framework, current setup, run simple tests . Now plan(multicore) warns immediately multicore processing, , forked processing, supported, e.g. running RStudio Console.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-22-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.22.0","text":"plan(multiprocess, workers = n) warn ‘multiprocess’ deprecated argument workers specified. getGlobalsAndPackages() throw false error “mean create future within function? Invalid future expression tries use global ... variables exist: ” ... solely part formula used S4 generic functions. enabled, option future.globals.onReference falsely alert ‘Detected non-exportable reference (externalptr) one globals (<unknown>) used future expression’ globals, e.g. using future.apply furrr map-reduce functions using ‘multisession’ backend. future(fcn(), globals = list(= 42, fcn = function() )) fail “Error fcn() : object ‘’ found” using sequential multicore futures. affected also map-reduce calls future.apply::future_lapply(1, function(x) ,    future.globals = list(= 42)). Resolving ‘sequential’ future without globals result internal several ...future.* objects written calling environment, might global environment. Environment variable R_FUTURE_PLAN propagate nested futures, forcing onto also nested future plans. Now unset nested futures, resulting sequential future strategy unless another explicitly set plan(). Transparent futures longer warn local = FALSE deprecated. Although local = FALSE deprecated, still used internally ‘transparent’ futures longer. Please use ‘transparent’ futures production code never package. remote() produce error “object ‘homogeneous’ found”. nbrOfFreeWorkers() ‘cluster’ futures assumed current plan set cluster .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1210","dir":"Changelog","previous_headings":"","what":"Version 1.21.0","title":"Version 1.21.0","text":"CRAN release: 2020-12-10","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-21-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.21.0","text":"order handle conditionally higher call chain, warnings errors produced using random number generator (RNG) future without declaring intention use one now class RngFutureWarning RngFutureError, respectively. classes inherits RngFutureCondition. Now run-time errors resolving future take precedence RngFutureError:s. , future({ rnorm(1); log(\"\") }, seed =    FALSE) signal error ‘log(“”)’ instead RNG error option future.rng.onMisuse set \"error\".","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-21-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.21.0","text":"Add nbrOfFreeWorkers() query many workers free take futures immediately. third-party future backends implemented , backends might produce error saying yet supported.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-21-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.21.0","text":"future(..., seed = TRUE) ‘sequential’ futures set RNG kind parent process. Now behaves regardless future backend. Signaling immediateCondition:s ‘multicore’ result Error save_rds(obj, file) : save_rds() failed rename    temporary save file    '/tmp/RtmpxNyIyK/progression21f3f31eadc.rds.tmp' (NA bytes; last    modified NA) '/tmp/RtmpxNyIyK/progression21f3f31eadc.rds' (NA    bytes; last modified NA). assertion end internal save_rds() function incorrectly assumed target file exist. However, file might already processed removed future main R session. value() run-time error RNG mistake signal RNG warning instead run-time error -internal-use-argument signal set FALSE. Due mistake introduced future 1.20.0, package end assigning .packageVersion object global environment loaded.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1201","dir":"Changelog","previous_headings":"","what":"Version 1.20.1","title":"Version 1.20.1","text":"CRAN release: 2020-11-03","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-20-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.20.1","text":"future::plan(\"multisession\") produce ‘Error (debug) mdebug(“covr::package_coverage() workaround …”) : argument interpretable logical’ covr package loaded.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-20-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.20.0","text":"Strategy ‘multiprocess’ deprecated favor either ‘multisession’ ‘multicore’, depending operating system R setup. plan() function give informative deprecation warning ‘multiprocess’ used. warning given per R session. Launching R Rscript command-line option --parallel=n, n > 1, now use ‘multisession’ future strategy. Previously, use ‘multiprocess’, now deprecated. Support local = FALSE deprecated. time , remains supported ‘transparent’ futures ‘cluster’ futures use persistent = TRUE. However, note persistent =    TRUE also deprecated point future. deprecations required order standardize Future API across various types parallel backends. Now multisession workers inherit package library path main R session created, , calling plan(multisession). avoid , use plan(multisession,    rscript_libs = NULL), argument passed makeClusterPSOCK(). update, ‘sequential’, ‘multisession’, ‘multicore’ futures see exact library path. Several functions managing parallel-style processing moved new parallelly package. Specifically, functions availableCores(), availableWorkers(), supportsMulticore(), .cluster(), autoStopCluster(), makeClusterMPI(), makeClusterPSOCK(), makeNodePSOCK() moved. None specific futures per se likely useful elsewhere . Also, separate, standalone package speed process releasing updates functions. code base future package shrunk 10-15% migration. backward compatibility, migrated functions remain package re-exports.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-20-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.20.0","text":"Setting future strategy argument split = TRUE cause standard output non-error conditions split (“tee:d”) worker’s end, still relaying back main R session . can useful debugging browse() debug(), e.g. plan(sequential, split = TRUE). Without , debug output displayed. Now multicore futures relay immediateCondition:s near-live fashion. now possible pass arguments makeClusterPSOCK() accepts call plan(cluster, ...) plan(multisession,    ...). instance, set working directory cluster workers temporary folder, pass argument rscript_startup =    \"setwd(tempdir())\". Another example rscript_libs = c(libs,    \"*\") prepend library path worker paths libs. plan() tweak() check even arguments must set either . Specifically, attempts adjust following arguments future() result error: conditions, envir, globals, packages, stdout, substitute addition already validated lazy seed. tweak() now returns wrapper function calls original future strategy function modified defaults. Previously, make copy original function modified argument defaults. new approach make possible introduce new future arguments can modified tweak() plan() without update every future backend package, e.g. new split = TRUE argument.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-20-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.20.0","text":"Add ‘Best Practices Package Developers’ vignette. Add ‘Future Framework Validated’ vignette.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-20-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.20.0","text":"Harmonizing Future constructor functions also use substitute =    TRUE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-20-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.20.0","text":"Since last version, future 1.19.1, future(..., conditions =    character(0L)) longer avoid intercepting conditions intended; instead, muffles conditions. now , use conditions = NULL. Relaying immediateCondition:s near-live multisession cluster underlying PSOCK cluster used useXDR=FALSE communication. print() Future also print attributes environment. error message produced nbrOfWorkers() incomplete. Renamed environment variable R_FUTURE_MAKENODEPSOCK_tries used makeClusterPSOCK() R_FUTURE_MAKENODEPSOCK_TRIES. Mandelbrot demo produce random numbers without declaring .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-20-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.20.0","text":"Strategy ‘multiprocess’ deprecated favor either ‘multisession’ ‘multicore’, depending operating system R setup. values() deprecated. Use value() instead. backward compatible code legacy, defunct, internal Future element value now removed. Using relying error.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1191","dir":"Changelog","previous_headings":"","what":"Version 1.19.1","title":"Version 1.19.1","text":"CRAN release: 2020-09-22","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-19-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.19.1","text":"passing ... globals, rather via arguments, higher-level map-reduce APIs future.apply furrr, arguments ... produce error “unused argument”.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-19-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.19.0","text":"Futures detect random number generation (RNG) used resolve . future uses RNG without parallel RNG requested, informative warning produced. request parallel RNG, specify argument seed, e.g. f <- future(rnorm(3),    seed = TRUE) y %<-% { rnorm(3) } %seed% TRUE. Higher-level map-reduce APIs provide similarly named “seed” arguments achieve . , escalate warning errors, set option future.rng.onMisuse \"error\". silence , set \"ignore\". Now, non-captured conditions muffled, possible. instance, future(warning(\"boom\"), conditions = c(\"message\")) truly muffle warning regardless backend used. needed fix bug.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-19-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.19.0","text":"makeClusterPSOCK() now retry create cluster node tries (default: 3) times giving . argument port species one port (e.g. port = \"random\") also attempt find valid random port tries times giving . pre-validation random port supported R (>= 4.0.0) skipped otherwise. makeClusterPSOCK() skips shell quoting elements rscript inherits AsIs. makeClusterPSOCK(), actually makeNodePSOCK(), gained argument quiet, can used silence output produced manual = TRUE. multithreading disabled multicore futures fail acknowledge setting current system, informative FutureWarning produced futures. Now availableCores() better supports Slurm. Specifically, environment variable SLURM_CPUS_PER_TASK set, requires option --slurm-cpus-per-task=n specified SLURM_JOB_NUM_NODES=1, falls back using SLURM_CPUS_ON_NODE, e.g. using --ntasks=n. Now availableCores() availableWorkers() supports LSF/OpenLava. Specifically, acknowledge environment variable LSB_DJOB_NUMPROC LSB_HOSTS, respectively.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-19-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.19.0","text":"Now plan(multisession), plan(cluster, workers = <number>), makeClusterPSOCK() use internally, sets localhost workers twice fast compared versions since future 1.12.0, brings back par bare-bone parallel::makeCluster(..., setup_strategy = \"sequential\") setup. slowdown introduced future 1.12.0 (2019-03-07) protection leaving stray R processes behind failed worker startup implemented. protection now makes use memoization speedup.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-19-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.19.0","text":"Sequential multicore backends, multisession, produce errors “‘…’ used incorrect context” cases ... part argument globals evaluation environment. Contrary future backends, conditions produced resolving sequential future using future(..., conditions =    character()) signaled, although reasonable expectation silenced. Now, non-captured conditions muffled, possible. Option future.rng.onMisuse passed nested futures. Disabling multithreading forked processes setting R option future.fork.multithreading.enable environment variable R_FUTURE_FORK_MULTITHREADING_ENABLE FALSE cause multicore futures always return value 1L. bug introduced future 1.17.0 (2020-04-17). getGlobalsAndPackages() always return globals element class FutureGlobals. getGlobalsAndPackages(..., globals) recalculate total_size even already calculated known zero. getGlobalsAndPackages(Formula::Formula(~ x)) produce “condition length > 1” warnings (become errors future R versions).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1180","dir":"Changelog","previous_headings":"","what":"Version 1.18.0","title":"Version 1.18.0","text":"CRAN release: 2020-07-09","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-18-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.18.0","text":"Support persistent = TRUE multisession futures deprecated.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-18-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.18.0","text":"print() RichSOCKcluster gives information name host also version R platform node (“worker”), e.g. “Socket cluster 3 nodes 2 nodes host ‘localhost’ (R version 4.0.0 (2020-04-24), platform x86_64-w64-mingw32), 1 node host ‘n3’ (R version 3.6.3 (2020-02-29), platform x86_64-pc-linux-gnu)”. Error messages cluster future failures now informative “Unexpected result (class ‘NULL’ != ‘FutureResult’)”. example, future package installed worker, error message clearly says . Even, unexpected result error PSOCK cluster future, error produced give extra information node failed, e.g. “Unexpected result (class ‘NULL’ != ‘FutureResult’) retrieved ClusterFuture future (label = ‘’, expression = ‘…’): suggests communication ClusterFuture worker (‘RichSOCKnode’ #1 host ‘n3’ (R version 3.6.3 (2020-02-29), platform x86_64-pc-linux-gnu)) sync.” now possible set environment variables workers launched makeClusterPSOCK() specify \"<name>=<value>\" part rscript vector argument, e.g. rscript = c(\"ABC=123\", \"DEF='hello world'\", \"Rscript\"). works elements rscript match regular expression [[:alpha:]_][[:alnum:]_]*=.* longer shell quoted. makeClusterPSOCK() now returns cluster addition inheriting SOCKcluster also inherit RichSOCKcluster.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-18-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.18.0","text":"Made makeClusterPSOCK() makeNodePSOCK() agile name change parallel:::.slaveRSOCK() parallel:::.workRSOCK() R (>= 4.1.0). makeClusterPSOCK(..., rscript) try locate rscript[1] argument homogeneous FALSE (inferred FALSE). makeClusterPSOCK(..., rscript_envs) result syntax error starting workers due non-ASCII quotation marks option useFancyQuotes set FALSE. plan(list(...)) produce ‘Error UseMethod(“tweak”) : applicable method ’tweak’ applied object class “list”’ non-function object named ‘list’ search path. plan(x$abc) x <- list(abc = sequential) produce ‘Error UseMethod(“tweak”) : applicable method ’tweak’ applied object class “c(‘FutureStrategyList’, ‘list’)”’. TESTS: R_FUTURE_FORK_ENABLE=false R CMD check ... produce ‘Error: connections left open: …’ checking ‘multiprocess’ example.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-18-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.18.0","text":"Support persistent = TRUE multisession futures deprecated. still needed, temporary workaround use cluster futures. However, likely support persistent eventually deprecated future backends. Options future.globals.method, future.globals.onMissing, future.globals.resolve deprecated produce warnings set. may used troubleshooting purposes may affect futures evaluated, means reproducibility guaranteed elsewhere.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1170","dir":"Changelog","previous_headings":"","what":"Version 1.17.0","title":"Version 1.17.0","text":"CRAN release: 2020-04-18","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-17-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.17.0","text":"Renamed values() value() clean simplify API.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-17-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.17.0","text":"makeClusterPSOCK() gained argument rscript_envs setting environment variables workers startup, e.g. rscript_envs =    c(FOO = \"3.14\", \"BAR\"). Now result future holds session details case error occurred evaluating future.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-17-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.17.0","text":"CRAN servers _R_CHECK_LIMIT_CORES_ set. better emulate CRAN submission checks, future package , loaded, set environment variable ‘TRUE’ unset R    CMD check running. Note future::availableCores() respects _R_CHECK_LIMIT_CORES_ returns 2L (two cores) detected.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-17-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.17.0","text":"globals named version has_future overwritten “garbage” values internally. Disabling multi-threading using ‘multicore’ futures work platforms.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-17-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.17.0","text":"values() S3 methods renamed value() since closely related original purpose value(). values() methods continue work soon formally deprecated later made defunct finally removed. Please replace values() value() calls.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1160","dir":"Changelog","previous_headings":"","what":"Version 1.16.0","title":"Version 1.16.0","text":"CRAN release: 2020-01-16","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-16-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.16.0","text":"Now oplan <- plan(new_strategy) returns list nested strategies previously set, instead just strategy top stack. makes easier temporarily use another plan. old behavior, use oplan <- plan(new_strategy)[[1]].","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-16-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.16.0","text":"Now value() detects future(..., seed = FALSE) call generated random numbers, might give unreliable results non-parallel safe, non-statistically sound random number generation (RNG) used. option future.rng.onMisuse \"warning\", warning produced. \"error\", error produced. \"ignore\" (default), mistake silently ignored. Using seed = NULL like seed = FALSE without performing RNG validation. convenience, argument seed future() may now also ordinary single integer random seed. , L’Ecuyer-CMRG RNG seed created seed. seed = TRUE, L’Ecuyer-CMRG RNG seed based current RNG state used. Use seed = FALSE known future use RNG. ClusterFuture:s now relay immediateCondition:s back main process momentarily signaled future resolved.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-16-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.16.0","text":"Add support automatically disable multi-threading using ‘multicore’ futures. now, default allow multi-threaded processing might change future. disable multi-threaded, set option future.fork.multithreading.enable environment variable R_FUTURE_FORK_MULTITHREADING_ENABLE FALSE. requires RhpcBLASctl package installed. Parallelization via multi-threaded processing (done native code packages externally library) time using forked (aka “multicore”) parallel processing unstable cases. Note true using plan(multicore) also using, instance, parallel::mclapply(). beta names options might change later.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-16-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.16.0","text":"Evaluation futures fail global environment contained functions names small set base R functions, e.g. raw(), list(), options(). future(alist(=)) produce “Error objectSize_list(x, depth = depth - 1L) : argument”x_kk” missing, default”","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-16-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.16.0","text":"Future FutureResult objects internal version 1.7 older deprecated since 1.14.0 (July 2019) now defunct. Defunct hidden argument progress resolve(), hidden arguments/fields condition calls FutureResult now gone.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1151","dir":"Changelog","previous_headings":"","what":"Version 1.15.1","title":"Version 1.15.1","text":"CRAN release: 2019-11-25","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-15-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.15.1","text":"default range ports makeClusterPSOCK() draws random port (argument port specified) can now controlled environment variable R_FUTURE_RANDOM_PORTS. default range still 11000:11999 parallel package.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-15-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.15.1","text":"change introduced resolved() future 1.15.0 cause lazy futures block workers occupied.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1150","dir":"Changelog","previous_headings":"","what":"Version 1.15.0","title":"Version 1.15.0","text":"CRAN release: 2019-11-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-15-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.15.0","text":"resolved() now launch lazy futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-15-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.15.0","text":"Now “visibility” future values recorded reflected value(). Now option future.globals.onReference defaults environment variable R_FUTURE_GLOBALS_ONREFERENCE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-15-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.15.0","text":"Added ‘Troubleshooting’ section ?makeClusterPSOCK instructions troubleshoot setup local remote clusters fail.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-15-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.15.0","text":"values() resignal immediateCondition:s despite signaled per future. makeClusterPSOCK() produce warnings like “open file ‘/tmp/alice/Rtmpi69yYF/future.parent=2622.a3e32bc6af7.pid’: file”, e.g. launching R workers running Docker containers. Package set update RNG state R (.Random.seed) loaded, affect RNG reproducibility. Package set .Random.seed NULL, instead removing , turn produce warning “‘.Random.seed’ integer vector type ‘NULL’, ignored” next random number generated. Now future assignment list environments produce informative error messages attempting assign one element. makeClusterMPI() work MPI clusters comm 1.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-15-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.15.0","text":"Argument value resolve() deprecated. Use result instead. Use internal argument evaluator future() now defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1140","dir":"Changelog","previous_headings":"","what":"Version 1.14.0","title":"Version 1.14.0","text":"CRAN release: 2019-07-02","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-14-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.14.0","text":"types conditions now captured relayed. Previously, conditions class message warning relayed. one futures collection produces error, values() signal error soon detected. means calling values() guarantees resolve futures, guarantee result futures gathered back master R session error relayed.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-14-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.14.0","text":"values() now relays stdout signal soon possible long standard output conditions relayed original order. captured condition can “muffled”, muffled. helps prevent conditions handled twice condition handlers futures evaluated main R session, e.g. plan(sequential). Messages warnings already muffled past. Forked processing considered unstable running R certain environments, RStudio environment. , ‘multicore’ futures disabled cases since future 1.13.0. change caught several RStudio users surprise. Starting future 1.14.0, informative one-time-per-session warning produced attempts use ‘multicore’ made non-supported environments RStudio. warning also produced using ‘multiprocess’, fall back using ‘multisession’ futures. warning can disabled setting R option future.supportsMulticore.unstable, environment variable FUTURE_SUPPORTSMULTICORE_UNSTABLE \"quiet\". Now option future.startup.script falls back environment variable R_FUTURE_STARTUP_SCRIPT. Conditions inheriting immediateCondition signaled soon possible. Contrary types conditions, signaled per future, despite collected.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-14-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.14.0","text":"Early signaling take place resolved() ClusterFuture MulticoreFuture. early signaling enabled, functions resolved() resolve() relay captured conditions multiple times. , instance, result messages warnings outputted . Now value() resignal conditions. validation connections failed detect connection serialized (= NIL external pointer) macOS systems.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-14-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.14.0","text":"Argument progress resolve() now defunct (deprecated since future 1.12.0). Option future.progress ignored. make room progress-update mechanisms works. Usage internal argument evaluator future() now deprecated. Removed defunct argument output FutureError(). FutureResult fields/arguments condition calls now defunct. Use conditions instead. Future FutureResult objects internal version 1.7 older deprecated eventually become defunct. Future backends implement Future classes update implement result() method instead value() method Future classes. future backends available CRAN Bioconductor already updated accordingly.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1130","dir":"Changelog","previous_headings":"","what":"Version 1.13.0","title":"Version 1.13.0","text":"CRAN release: 2019-05-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-13-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.13.0","text":"Forked processing now disabled default running R via RStudio disabled, ‘multicore’ futures fall back ‘sequential’ futures. update follows RStudio recommendation using forked parallel processing within RStudio likely break RStudio R session. See help(\"supportsMulticore\") details, e.g. re-enable process forking. Note parallelization via ‘multisession’ unaffected still work . Also, forked processing disabled, otherwise supported, using plan(\"multiprocess\") fall back using ‘multisession’ futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-13-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.13.0","text":"Forked processing can disabled setting R option future.fork.enable FALSE (environment variable R_FUTURE_FORK_ENABLE=false). disabled, ‘multicore’ futures fall back ‘sequential’ futures even operating system supports process forking. set TRUE, ‘multicore’ fall back ‘sequential’. NA, set (default), set best-practices rules decide whether forking enabled . See help(\"supportsMulticore\") details. Now availableCores() also recognizes PBS environment variable NCPUS, PBSPro scheduler set PBS_NUM_PPN. , option future.availableCores.custom set function, availableCores() call function interpret value number cores. Analogously, option future.availableWorkers.custom can used specify hostnames set workers availableWorkers() sees. new options provide mechanism anyone customize availableCores() availableWorkers() case (yet) recognize, say, environment variables specific user’s compute environment HPC scheduler. makeClusterPSOCK() gained support argument rscript_startup evaluating one R expressions background R worker prior worker event loop launching. provides convenient approach use, say, rscript_args =    c(\"-e\", sQuote(code)). makeClusterPSOCK() gained support argument rscript_libs control R package library search path workers. example, prepend folder ~/R-libs workers, use rscript_libs = c(\"~/R-libs\", \"*\"), \"*\" resolved current .libPaths() workers. Debug messages now prepended timestamp.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-13-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.13.0","text":"Add vignette ‘Non-Exportable Objects’ (extracted another vignette).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-13-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.13.0","text":"makeClusterPSOCK() shell quote Rscript executable running pre-tests checking whether localhost Rscript processes can killed PIDs .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-13-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.13.0","text":"Argument value resolve() renamed result better reflect values collected argument used. Argument value still works backward compatibility, eventually formally deprecated defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1120","dir":"Changelog","previous_headings":"","what":"Version 1.12.0","title":"Version 1.12.0","text":"CRAN release: 2019-03-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-12-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.12.0","text":"makeClusterPSOCK() fails create one many nodes, attempt stop nodes successfully created. lowers risk leaving R worker processes behind. Future results now hold timestamps evaluation future started finished.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-12-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.12.0","text":"Functions longer produce “partial match ‘condition’ ‘conditions’” warnings options(warnPartialMatchDollar =    TRUE). future infix operators (%conditions%, %globals%, %label%, %lazy%, %packages%, %seed%, %stdout%) intended future assignments used wrong context, incorrectly applied next future created. Now ’re discarded. makeClusterPSOCK() future (>= 1.11.1) produced warnings argument rscript length(rscript) > 1. Validation L’Ecuyer-CMRG RNG seeds failed recent R devel. options(OutDec = \",\"), default value several argument resolve NA_real_ rather numeric value resulting errors “.finite(alpha) TRUE”.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-12-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.12.0","text":"Argument progress resolve() now deprecated. Argument output FutureError() now defunct. FutureError longer inherits simpleError.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-11111","dir":"Changelog","previous_headings":"","what":"Version 1.11.1.1","title":"Version 1.11.1.1","text":"CRAN release: 2019-01-26","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-11-1-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.1.1","text":"makeClusterPSOCK() fails connect worker, produces error detailed information happened. rare cases, another error produced generating information workers PID .","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-11-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.11.1","text":"defaults several arguments makeClusterPSOCK() makeNodePSOCK() can now controlled via environment variables addition R options supported past. advantage using environment variables inherited child processes, also nested ones. printing future plans now less verbose workers argument complex object PSOCK cluster object. Previously, output include verbose output attributes, etc.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-11-1","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.11.1","text":"TESTS: future package loaded, checks whether R    CMD check running . , future-specific environment variables adjusted tests play nice testing environment. instance, sets socket connection timeout PSOCK cluster workers 120 seconds (instead default 30 days!). lower risk zombie worker processes cluttering test machine (e.g. CRAN servers) case worker process left behind despite main R processes terminated. Note adjustments applied automatically checks package depends , imports, future package.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-11-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.1","text":"Whenever makeClusterPSOCK() fail connect worker, instance due port clash, leave R worker process running - also main R process terminated. worker running machine, makeClusterPSOCK() now attempt kill stray R processes. Note parallel::makePSOCKcluster() still problem.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1110","dir":"Changelog","previous_headings":"","what":"Version 1.11.0","title":"Version 1.11.0","text":"CRAN release: 2019-01-21","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-11-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.11.0","text":"Message warning conditions now captured relayed default.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-11-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.11.0","text":"future call stack (“traceback”) now recorded evaluation future produces error. Use backtrace() future retrieve . Now futureCall() defaults args = list() making easier call functions take arguments, e.g. futureCall(function() 42). plan() gained argument .skip = FALSE. TRUE, setting future strategy already set skipped, e.g. calling plan(multisession) consecutively effect calling just . makeClusterPSOCK() produces informative error messages whenever setup R workers fails. Also, verbose messages now prefixed [local output] help distinguish output produced current R session produced background workers. now possible specify type SSH clients makeClusterPSOCK() automatically searches order, e.g. rshcmd = c(\"<rstudio-ssh>\", \"<putty-plink>\"). Now makeClusterPSOCK() preserves global RNG state (.Random.seed) also draws random port number. makeClusterPSOCK() gained argument rshlogfile. Cluster futures provide informative error messages communication worker node sync.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-11-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.0","text":"Argument stdout forced TRUE using single-core multicore single-core multisession futures. evaluated local environment, futureCall(..., globals =    \"\") set value global NULL, regardless exists true value . makeClusterPSOCK(..., rscript = \"my_r\") cases fail find intended my_r executable. ROBUSTNESS: cluster future, including multisession one, retrieve results wrong workers new set cluster workers set future created/launched results retrieved. happen connections R indexed solely integers recycled old connections closed new ones created. Now cluster futures assert connections workers valid, , informative error message produced. Calling result() non-resolved UniprocessFuture signal evaluation errors.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-11-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.11.0","text":"Removed defunct future::future_lapply(). Please use one future.apply package instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1100","dir":"Changelog","previous_headings":"","what":"Version 1.10.0","title":"Version 1.10.0","text":"CRAN release: 2018-10-17","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-10-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.10.0","text":"Add support manually specifying globals addition automatically identified via argument globals %globals%. Two examples globals = structure(TRUE, add =    list(= 42L, b = 3.14)) globals = structure(TRUE, add =    c(\"\", \"b\")). Analogously, attribute ignore can used exclude automatically identified globals. error reported failing retrieve results future evaluated localhost cluster/multisession worker forked/multicore worker now informative. Specifically, mentions whether worker process still alive . Add makeClusterMPI(n) creating MPI-based clusters similar kind parallel::makeCluster(n, type = \"MPI\") also attempts workaround issues parallel::stopCluster() causes R stall. makeClusterPSOCK() makeClusterMPI() gained argument autoStop controlling whether cluster automatically stopped garbage collected . BETA: Now resolved() ClusterFuture non-blocking also clusters type MPIcluster created parallel::makeCluster(..., type = \"MPI\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-10-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.10.0","text":"Windows, plan(multiprocess) initiate workers. Instead workers set first future created.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-190","dir":"Changelog","previous_headings":"","what":"Version 1.9.0","title":"Version 1.9.0","text":"CRAN release: 2018-07-23","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-9-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.9.0","text":"Standard output now captured re-outputted value() called. new behavior can controlled argument stdout future() specifying %stdout% operator future assignment used.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-9-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.9.0","text":"R option width passed standard output captured consistently across workers consistently master process. Now future.* options passed also acknowledged using nested futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-9-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.9.0","text":"Add vignette ‘Outputting Text’. CLEANUP: core parts API now listed help index. done clarify Future API. Help non-core parts still via cross references indexed API well via help().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-9-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.9.0","text":"using forced, nested ‘multicore’ parallel processing, , plan(list(tweak(multicore, workers = 2), tweak(multicore, workers    = 2))), child process attempt resolve futures owned parent process resulting error (‘bad error message’). using plan(multicore), forked worker terminate unexpectedly, corrupt master R session attempts using forked workers fail. forked worker terminated way user pressed Ctrl-C (worker receives SIGINT signal). makeClusterPSOCK() produced warning environment variable R_PARALLEL_PORT set random (e.g. CRAN). Printing plan() produce error deparsed call used set plan() longer 60 characters.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-9-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.9.0","text":"future::future_lapply() defunct (gives error called). Please use one future.apply package instead. Argument output FutureError() formally deprecated. Removed FutureEvaluationCondition classes related methods.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-181","dir":"Changelog","previous_headings":"","what":"Version 1.8.1","title":"Version 1.8.1","text":"CRAN release: 2018-05-03","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-8-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.8.1","text":"getGlobalsAndPackages() gained argument maxSize. makeClusterPSOCK() now produces informative warning environment variable R_PARALLEL_PORT specifies non-numeric port. Now plan() gives informative error message case fails, e.g. internal future validation fails . Added UnexpectedFutureResultError used backends signaling standard way unexpected result retrieved worker.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-8-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.8.1","text":"communication asynchronous future background R process failed, querying future state/results end infinite waiting loop. Now failed communication error recorded re-signaled querying attempts. Internal, seldom used myExternalIP() failed recognize IPv4 answers lookup servers. turn produce another error. R (>= 3.5.0), multicore futures produce multiple warnings originating querying whether background processes completed . warnings now suppressed.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-180","dir":"Changelog","previous_headings":"","what":"Version 1.8.0","title":"Version 1.8.0","text":"CRAN release: 2018-04-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-8-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.8.0","text":"Errors produces evaluating futures now (re-)signaled master R process -original content class attributes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-8-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.8.0","text":"errors related orchestration futures class FutureError make easier distinguish future evaluation errors. Add support richer set results returned resolved futures. Previously value future expression, captured error resignaled, expected. Now FutureResult object may returned instead. Although supported release, update opens reporting additional information evaluation futures, e.g. captured output, timing memory benchmarks, etc. can take place, existing future backend packages updated accordingly. backtrace() returns last call produced error. unfortunately possible capture call stack led error evaluating future expression.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-8-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.8.0","text":"value() MulticoreFuture produce error (forked) background R workers terminate future expression resolved. limitation inherited parallel package. Now informative FutureError message produced. value() MulticoreFuture signal errors unless inherited simpleError - now ’s enough inherits error. value() ClusterFuture longer produces FutureEvaluationError, FutureError, connection R worker changed (happens something drastic closeAllConnections() called.) futureCall(..., globals = FALSE) produce “Error: second argument must list”, explicit arguments exported. also happen specifying globals name named list. Nested futures conservative requiring global variables exist, even false positives.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-8-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.8.0","text":"future::future_lapply() formally deprecated. Please use one future.apply package instead. Recently introduced FutureEvaluationCondition classes deprecated, longer serve purpose since future evaluation conditions now signaled -.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-170","dir":"Changelog","previous_headings":"","what":"Version 1.7.0","title":"Version 1.7.0","text":"CRAN release: 2018-02-11","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-7-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.7.0","text":"future_lapply() moved future.apply package available CRAN.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-7-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.7.0","text":"Argument workers future strategies may now also function, called without argument future strategy set used . instance, plan(multiprocess, workers =    halfCores) halfCores <- function() { max(1,    round(availableCores()/ 2)) } use half number available cores. useful using nested future strategies remote machines. Windows, makeClusterPSOCK(), therefore plan(multisession) plan(multiprocess), use SSH client distributed RStudio fallback neither ssh plink available system PATH. Now plan() makes sure nbrOfWorkers() work new strategy. help catch mistakes plan(cluster,    workers = cl) cl basic R list rather cluster list early . Added %packages% explicitly control packages attached future resolved, e.g. y %<-% { YT[2] } %packages%    \"data.table\". Note, needed cases automatic identification global package dependencies sufficient. Added condition classes FutureCondition, FutureMessage, FutureWarning, FutureError representing conditions occur future setup, launched, queried, retrieved. represent conditions occur evaluating future expression. conditions, new classes FutureEvaluationCondition, FutureEvaulationMessage, FutureEvaluationWarning, FutureEvaluationError exists.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.7.0","text":"Vignette ‘Common Issues Solutions’ now documents case future framework fails identify variable global conditionally, e.g. (runif(1) <    1/2) x <- 0; y <- 2 * x.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-7-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.7.0","text":"Added mechanism detecting globals may exportable external R process (“worker”). Typically, globals carry connections external pointers (externalptr) can exported, exceptions. setting options future.globals.onReference \"warning\", warning produced informing user potential problems. \"error\", error produced. might false positive, default \"ignore\", cause scans skipped. non-exportable globals tests skipped, run-time error may produced future expression evaluated.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-7-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.7.0","text":"total size global variables overestimated, dramatically defined global environment large objects . sometimes result false error saying total size larger allowed limit. assignment x <- x + 1 left-hand side (LHS) x global failed identify x global right-hand side (RHS) x override local variable. Updates globals package fixed problem. makeClusterPSOCK(..., renice = 19) launch PSOCK worker via nice +19 resulting error “nice: ‘+19’: file directory”. bug inherited parallel::makePSOCKcluster(). Now using nice --adjustment=19 instead. Protection passing future objects futures work future strategy ‘multicore’.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-7-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.7.0","text":"future_lapply() moved new future.apply package available CRAN. future::future_lapply() function soon deprecated, defunct, eventually removed future package. Please update code make use future.apply::future_lapply() instead. Dropped defunct ‘eager’ ‘lazy’ futures; use ‘sequential’ instead. Dropped defunct arguments cluster maxCores; use workers instead. previous version future package FutureError class used represent orchestration errors (now FutureError) evaluation errors (now FutureEvaluationError). usage class FutureError latter type errors deprecated updated FutureEvaluationError.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-162","dir":"Changelog","previous_headings":"","what":"Version 1.6.2","title":"Version 1.6.2","text":"CRAN release: 2017-10-16","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-6-2","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.6.2","text":"Now plan() accepts also strings \"future::cluster\". Now backtrace(x[[ER]]) works also non-environment x:s, e.g. lists.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-6-2","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.6.2","text":"measuring size globals scanning content, certain types classes inferred lengths objects incorrect causing internal subset --range issues. print() Future output one global per line instead concatenating information commas.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-161","dir":"Changelog","previous_headings":"","what":"Version 1.6.1","title":"Version 1.6.1","text":"CRAN release: 2017-09-09","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-6-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.6.1","text":"Now exporting getGlobalsAndPackages().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-6-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.6.1","text":"future_lapply() give “Error objectSize.env(x, depth = depth - 1L): object ‘nnn’ found” instance ‘nnn’ part unresolved expression argument value.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-6-1","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.6.1","text":"FIX: package assertion tests made precise assumptions object sizes, fails introduction ALTREP R-devel causes R’s SEXP header size change.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-160","dir":"Changelog","previous_headings":"","what":"Version 1.6.0","title":"Version 1.6.0","text":"CRAN release: 2017-08-13","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-6-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.6.0","text":"Now tweak(), hence plan(), generates informative error message non-future function specified mistake, e.g. calling plan(cluster) survival package attached future equivalent calling plan(survival::cluster) plan(future::cluster) intended.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-6-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.6.0","text":"nbrOfWorkers() gave error plan(remote). Fixed making ‘remote’ future inherit cluster ().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-6-0","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.6.0","text":"TESTS: longer testing forced termination forked cluster workers running Solaris. termination done launching future called quit(), appeared corrupted main R session running Solaris.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-6-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.6.0","text":"Formally defunct ‘eager’ ‘lazy’ futures; use ‘sequential’ instead. Dropped previously defunct %<=% %=>% operators.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-150","dir":"Changelog","previous_headings":"","what":"Version 1.5.0","title":"Version 1.5.0","text":"CRAN release: 2017-05-26","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-5-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.5.0","text":"Multicore multisession futures longer reserve one core main R process, done lower risk producing higher CPU load number cores available R session.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-5-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.5.0","text":"makeClusterPSOCK() now defaults use Windows PuTTY software’s SSH client plink -ssh, ssh found. Argument homogeneous makeNodePSOCK(), helper function makeClusterPSOCK(), default FALSE also hostname fully qualified domain name (FQDN), , “contains periods”. instance, c('node1', 'node2.server.org') use homogeneous = TRUE first worker homogeneous = FALSE second. makeClusterPSOCK() now asserts cluster node functioning retrieving recording node’s session information including process ID corresponding R process. Nested futures sets option mc.cores prevent spawning recursive parallel processes mistake. ‘mc.cores’ controls additional processes, previously set zero. However, since functions mclapply() support , now set one instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-5-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.5.0","text":"Help makeClusterPSOCK() gained detailed descriptions arguments defaults .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-5-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.5.0","text":"Formally deprecated eager futures; use sequential instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-5-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.5.0","text":"future_lapply() multicore / multisession futures, use suboptimal workload balancing split data one chunk many. longer problem argument workers now defined type futures (see note top). future_lapply(), well lazy multicore lazy sequential futures, respect option future.globals.resolve, hardcoded always resolve globals (future.globals.resolve =    TRUE). globals larger allowed size (option future.globals.maxSize) detected informative error message generated. Previous version introduced bug causing error produce another error. Lazy sequential futures produce error resolved required packages detached. print() display globals gathered lazy sequential futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-5-0","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.5.0","text":"Added package tests globals part formulas part globals, e.g. purrr::map(x, ~ rnorm(.)), requires globals (>= 0.10.0). Now package tests parallel::makeCluster() test type = \"PSOCK\" clusters also \"FORK\" (supported). TESTS: Cleaned test scripts overall processing time tests roughly halved, preserving test coverage.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-140","dir":"Changelog","previous_headings":"","what":"Version 1.4.0","title":"Version 1.4.0","text":"CRAN release: 2017-03-13","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-4-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.4.0","text":"default future_lapply() now generate RNG seeds (future.seed = FALSE). proper random number generation needed, use future.seed = TRUE. details, see help page.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-4-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.4.0","text":"future() future_lapply() gained argument packages explicitly specifying packages attached futures evaluated. Note default throughout future package globals required packages automatically identified gathered, cases specified manually. default values arguments connectTimeout timeout makeNodePSOCK() can now controlled via global options.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"random-number-generation-1-4-0","dir":"Changelog","previous_headings":"","what":"Random Number Generation","title":"Version 1.4.0","text":"Now future_lapply() guarantees RNG state calling R process returning updated compared exact way regardless future.seed (except FALSE), future.scheduling future strategy used. done order guarantee R script calling future_lapply() multiple times numerically reproducible given initial seed. now possible specify pre-generated sequence .Random.seed seeds used FUN(x[[]], ...) call future_lapply(x, FUN, ...).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-4-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.4.0","text":"future_lapply() scans global variables non-resolved futures (resolve ) calculate total size . Previously, chunk (future) redo .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-4-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.4.0","text":"Now future_lapply(X, FUN, ...) identifies global objects among X, FUN ... recursively new globals found. Previously, first level globals scanned. mostly thanks bug fix globals 0.9.0. future used global object x class overrides length() produce error length(x) reports elements can subsetted. nbrOfWorkers() gave error plan(cluster, workers = cl) cl cluster object created parallel::makeCluster(), etc. prevented instance future_lapply() work setups. plan(cluster, workers = cl) cl <- makeCluster(..., type =    MPI\") give instant error due invalid internal assertion.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-4-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.4.0","text":"Previously deprecated arguments maxCores cluster now defunct. Previously deprecated assignment operators %<=% %=>% now defunct. availableCores(method = \"mc.cores\") now defunct favor \"mc.cores+1\".","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-130","dir":"Changelog","previous_headings":"","what":"Version 1.3.0","title":"Version 1.3.0","text":"CRAN release: 2017-02-19","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-3-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.3.0","text":"applicable, workers now initiated calling plan(), e.g. plan(cluster) set workers cluster nodes. Previously, happened first future created.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.3.0","text":"Renamed ‘eager’ futures ‘sequential’, e.g. plan(sequential). ‘eager’ futures deprecated upcoming release. Added support controlling whether future resolved eagerly lazily creating future, e.g. future(..., lazy =    TRUE), futureAssign(..., lazy = TRUE), x %<-% { ... }    %lazy% TRUE. future(), futureAssign() futureCall() gained argument seed, specifies L’Ecuyer-CMRG random seed used future. seed future assignment can specified via %seed%. futureAssign() now passes additional arguments future(). Added future_lapply() supports load balancing (“chunking”) perfect reproducibility (regardless type load balancing futures resolved) via initial random seed. Added availableWorkers(). default returns localhost workers according availableCores(). addition, detects common HPC allocations given environment variables set HPC scheduler. default plan(cluster) now workers =    availableWorkers(). Now plan() stops clusters implicitly created. instance, multisession cluster created plan(multisession) stopped plan(eager) called. makeClusterPSOCK() treats workers refer local machine local canonical hostname “localhost”. avoids launch workers SSH, may supported systems / compute cluster. Option future.debug = TRUE also reports total size globals identified cluster futures also size individual global variables exported. Option future.wait.timeout (replaces future.wait.times) specifies maximum waiting time free workers (e.g. core compute node) generating timeout error. Option future.availableCores.fallback, defaults environment variable R_FUTURE_AVAILABLECORES_FALLBACK can now used specify default number cores / workers returned availableCores() availableWorkers() settings available. instance, R_FUTURE_AVAILABLECORES_FALLBACK=1 set system wide HPC environment, R processes uses availableCores() detect many cores can used run single-core processes. Without fallback setting, without core-specifying settings, default use cores machine, play well multi-user systems.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-1-3-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 1.3.0","text":"Globals part locally defined functions now also identified thanks globals (>= 0.8.0) updates.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-3-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.3.0","text":"Lazy futures plan(lazy) now deprecated. Instead, use plan(eager) f <- future(..., lazy = TRUE) x %<-% {    ... } %lazy% TRUE. reason behind cases code uses futures works eager evaluation (lazy =    FALSE; default), vice verse. removing “lazy” future strategy, user can longer override lazy = TRUE / FALSE developer using.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-3-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.3.0","text":"Creation cluster futures (including multisession ones) time already 40 seconds workers busy. New default timeout 30 days (option future.wait.timeout). nbrOfWorkers() gave error plan(cluster, workers) workers character vector cluster object parallel package. , future_lapply() gave error setups. availableCores(methods = \"_R_CHECK_LIMIT_CORES_\") give error running R CMD check.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-120","dir":"Changelog","previous_headings":"","what":"Version 1.2.0","title":"Version 1.2.0","text":"CRAN release: 2016-11-12","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.2.0","text":"Added makeClusterPSOCK() - version parallel::makePSOCKcluster() allows flexible control PSOCK cluster workers set launched communicated running external machines. Added generic .cluster() coercing objects cluster objects used plan(cluster, workers = .cluster(x)). Also added c() implementation cluster objects multiple cluster objects can combined single one. Added sessionDetails() gathering details current R session. plan() plan(\"list\") now prints user-friendly output. Unix, internal myInternalIP() tries alternatives finding local IP number.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-2-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.2.0","text":"%<=% deprecated. Use %<-% instead. %=>%.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-2-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.2.0","text":"values() lists list environments futures one futures resolved NULL give error. value() ClusterFuture give cryptic error message “Error stop(ex) : bad error message” cluster worker crashed / terminated. Now instead give error message like “Failed retrieve value ClusterFuture cluster node #1 ‘localhost’. reason reported ”error reading connection”. Argument user remote() ignored (since 1.1.0).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-111","dir":"Changelog","previous_headings":"","what":"Version 1.1.1","title":"Version 1.1.1","text":"CRAN release: 2016-10-11","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-1-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.1.1","text":"special case ‘remote’ futures use workers =    \"localhost\" () use exact R executable main / calling R session (cases uses whatever Rscript found PATH). already indeed implemented 1.0.1, added support reverse SSH tunnels 1.1.0 default behavior lost.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-110","dir":"Changelog","previous_headings":"","what":"Version 1.1.0","title":"Version 1.1.0","text":"CRAN release: 2016-10-10","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.1.0","text":"REMOTE CLUSTERS: now simple use cluster() remote() connect remote clusters / machines. long can connect via SSH machines, works also future. new code completely avoids incoming firewall incoming port forwarding issues previously needed. done using reverse SSH tunneling. also need worry internal external IP numbers. Added optional argument label futures, e.g. f <-    future(42, label = \"answer\") v %<-% { 42 } %label% \"answer\". Added argument user cluster() remote(). Now Future classes supports run() launching future value() calls run() future launched. MEMORY: Now plan(cluster, gc = TRUE) causes background R session garbage collected immediately value collected. Since multisession remote futures special cases cluster futures, true well. ROBUSTNESS: Now default future strategy explicitly set strategies set, e.g. used nested futures. Previously, mc.cores set single core used, now also plan(\"default\") set. WORKAROUND: resolved() cluster futures block Linux future resolved. due bug R. workaround use round timeout (seconds) integer, seems always work / respected.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-1-1-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 1.1.0","text":"Global variables part subassignments future expressions recognized exported (iff found), e.g. x$<- value, x[[\"\"]]    <- value, x[1,2,3] <- value. Global variables part formulae future expressions recognized exported (iff found), e.g. y ~ x | z. alternative default automatic identification globals, now also possible explicitly specify either names (character vector) names values (named list), e.g. f <- future({ 2*}, globals = c(\"\")) f <- future({ 2*}, globals = list(= 42)). future assignments one can use %globals% operator, e.g. y %<-% {    2*} %globals% c(\"\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-1-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.1.0","text":"Added vignette command-line options methods controlling default type futures use.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-101","dir":"Changelog","previous_headings":"","what":"Version 1.0.1","title":"Version 1.0.1","text":"CRAN release: 2016-07-04","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-0-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.0.1","text":"ROBUSTNESS: special case ‘remote’ futures use workers = \"localhost\" now use exact R executable main / calling R session (cases uses whatever Rscript found PATH). FutureError now extends simpleError longer error class captured errors.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-0-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.0.1","text":"Adding section vignette globals formulas describing currently automatically detected explicitly export .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.0.1","text":"Since future 0.13.0, global pkg overwritten name last package attached future. Futures generated R.oo::Exception errors, triggered another internal error.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"CRAN release: 2016-06-24","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.0.0","text":"Add support remote(..., myip = \"<external>\"), now queries set external lookup services case one fails. Add mandelbrot() function used demo API convenience. ROBUSTNESS: .future.R script, sourced future package attached, gives error, error ignored warning. TROUBLESHOOTING: future requires attachment packages, namespace loaded separately attaching package. done order see actual error message case problem loading namespace. require()/library() error message otherwise suppressed replaced generic one.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-1-0-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 1.0.0","text":"Falsely identified global variables longer generate error future created. Instead, leave R evaluation individual futures throw error global variable truly missing. done order automatically handle future expressions use non-standard evaluation (NSE), e.g. subset(df, x < 3) x falsely identified global variable. Dropped support system environment variable R_FUTURE_GLOBALS_MAXSIZE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-0-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.0.0","text":"DEMO: Now Mandelbrot demo tiles single Mandelbrot region one future per tile. better illustrates parallelism. Documented R options used future package.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-0-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.0.0","text":"Custom futures based constructor function defined outside package gave error. plan(\"default\") assumed future.plan option string; gave error function. Various future options passed futures. startup .future.R script longer sourced future package attached future expression.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0150","dir":"Changelog","previous_headings":"","what":"Version 0.15.0","title":"Version 0.15.0","text":"CRAN release: 2016-06-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-15-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.15.0","text":"Added remote futures, cluster futures convenient default arguments simple remote access R, e.g. plan(remote, workers = \"login.-server.org\"). Now .future.R (found current directory otherwise user’s home directory) sourced future package attach (loaded). helps separating scripts configuration futures. Added support plan(cluster, workers = c(\"n1\", \"n2\", \"n2\",    \"n4\")), workers (also ClusterFuture()) set host names passed parallel::makeCluster(workers). can also number localhost workers. Added command line option --parallel=<p>, long -p <p>. Now command line option -p <p> also set default future strategy multiprocessing (p >= 2 eager otherwise), unless another strategy already specified via option future.plan system environment variable R_FUTURE_PLAN. Now availableCores() also acknowledges environment variable NSLOTS set Sun/Oracle Grid Engine (SGE). MEMORY: Added argument gc = FALSE futures. TRUE, garbage collector run end process evaluated future (just returning value). may help lowering overall memory footprint running multiple parallel R processes. user can enable specifying plan(multiprocess, gc = TRUE). developer can control using future(expr, gc = TRUE) v %<-% { expr } %tweak% list(gc    = TRUE).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-0-15-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 0.15.0","text":"Significantly decreased overhead creating future, particularly multicore futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-15-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.15.0","text":"Future give error plan(list(\"eager\")), whereas work plan(\"eager\") plan(list(eager)).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0140","dir":"Changelog","previous_headings":"","what":"Version 0.14.0","title":"Version 0.14.0","text":"CRAN release: 2016-05-17","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-14-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.14.0","text":"Added nbrOfWorkers(). Added informative print() method Future class. values() passes arguments ... value() future. Added FutureError class.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-0-14-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 0.14.0","text":"Renamed arguments maxCores cluster workers. using old argument names deprecation warning generated, still work made defunct future release.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-14-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.14.0","text":"resolve() lists environments work properly set futures resolved order, happen asynchronous futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0130","dir":"Changelog","previous_headings":"","what":"Version 0.13.0","title":"Version 0.13.0","text":"CRAN release: 2016-04-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-13-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.13.0","text":"Add support plan() specifying different future strategies different levels nested futures. Add backtrace() listing trace expressions evaluated (calls made) condition caught. Add transparent futures, eager futures early signaling conditioned enabled whose expression evaluated calling environment. makes evaluation futures similar possible R evaluates expressions, turn simplifies troubleshooting errors, etc. Add support early signaling conditions. default () signal conditions value queried. addition, may signals soon possible, e.g. checking whether future resolved . Signaling conditions calling value() now controlled argument signal (previously onError). Now UniprocessFuture:s captures call stack errors occurring resolving futures. ClusterFuture() gained argument persistent = FALSE. persistent = TRUE, objects cluster R session created evaluation previous future available succeeding futures evaluated session. Moreover, globals still identified exported “missing” globals give error - instead assumed globals available environment future evaluated. OVERHEAD: Utility functions exported ClusterFuture now much smaller; previously export package environment.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-13-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.13.0","text":"f <- multicore(NA, maxCores = 2) end endless waiting loop free core availableCores() returned one. ClusterFuture() ignore local = TRUE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0120","dir":"Changelog","previous_headings":"","what":"Version 0.12.0","title":"Version 0.12.0","text":"CRAN release: 2016-02-24","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-12-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.12.0","text":"Added multiprocess futures, multicore futures supported, otherwise multisession futures. makes possible use plan(multiprocess) everywhere regardless operating system. Future strategy functions gained class attributes possible test type future currently used, e.g. inherits(plan(), \"multicore\"). ROBUSTNESS: R process created future can resolve . non-resolved future queried another R process, informative error generated explaining possible. ROBUSTNESS: Now value() multicore futures detects underlying forked R process terminated completing generates informative error messages.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-0-12-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 0.12.0","text":"Adjusted parameters schema used wait next available cluster node nodes polled frequently.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-12-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.12.0","text":"resolve() gained argument recursive. Added option future.globals.resolve controlling whether global variables resolved futures . TRUE, globals searched recursively futures found “global” futures resolved. FALSE, global futures located, later trying resolved parent future, informative error message generated clarifying R process created future can resolve . default currently FALSE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-12-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.12.0","text":"FIX: Exports objects available packages already attached future still exported. FIX: Now availableCores() returns 3L (=2L+1L) instead 2L _R_CHECK_LIMIT_CORES_ set.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0110","dir":"Changelog","previous_headings":"","what":"Version 0.11.0","title":"Version 0.11.0","text":"CRAN release: 2016-01-20","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-11-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.11.0","text":"Add multisession futures, analogously multicore ones, use multiple cores local machine difference evaluated separate R session running background rather separate forked R processes. multisession future special type cluster futures require explicit setup cluster nodes. Add support cluster futures, can make use cluster nodes created parallel::makeCluster(). Add futureCall(), futures .call() otherwise. Standardized options named, .e. future.<option>. used future options previously, make sure check follow format.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-11-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.11.0","text":"futures now validates globals default (globals = TRUE).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0100","dir":"Changelog","previous_headings":"","what":"Version 0.10.0","title":"Version 0.10.0","text":"CRAN release: 2015-12-31","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-10-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.10.0","text":"Now %<=% can also assign multi-dimensional list environments. Add futures(), values() resolved(). Add resolve() resolve futures lists environments. Now availableCores() also acknowledges number CPUs allotted Slurm. CLEANUP: Now internal future variable created %<=% removed future variable resolved.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-10-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.10.0","text":"futureOf(envir = x) work properly x list environment.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-090","dir":"Changelog","previous_headings":"","what":"Version 0.9.0","title":"Version 0.9.0","text":"CRAN release: 2015-12-12","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.9.0","text":"ROBUSTNESS: Now values environment variables trimmed parsed. ROBUSTNESS: Add reproducibility test random number generation using Pierre L’Ecuyer’s RNG stream regardless futures evaluated, e.g. eager, lazy multicore.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-9-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.9.0","text":"Now globals (“unknown” variables) identified using new findGlobals(..., method = \"ordered\") globals (> 0.5.0) global variable preceding local variable name properly identified exported/frozen.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-9-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.9.0","text":"Updated vignette common issues case global variable identified hidden element assignment future expression.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.9.0","text":"Errors occurring multicore futures prevent multicore futures created.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-082","dir":"Changelog","previous_headings":"","what":"Version 0.8.2","title":"Version 0.8.2","text":"CRAN release: 2015-10-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-8-2","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.8.2","text":"Globals copies package objects exported future environments. future package attached future::future() imported, %<=% used internally another package. Similarly, also attached multicore futures used.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-081","dir":"Changelog","previous_headings":"","what":"Version 0.8.1","title":"Version 0.8.1","text":"CRAN release: 2015-10-05","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-8-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.8.1","text":"Added vignette ‘Futures R: Common issues solutions’.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-8-1","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.8.1","text":"eager() multicore() gained argument globals, globals = TRUE validate global variables identified can located already future created. provides means providing tests global variables eager multicore futures lazy futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-8-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.8.1","text":"lazy(sum(x, ...), globals = TRUE) now properly passes ... function future setup. called within function called within function without ... arguments, informative error message thrown.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-080","dir":"Changelog","previous_headings":"","what":"Version 0.8.0","title":"Version 0.8.0","text":"CRAN release: 2015-09-07","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.8.0","text":"plan(\"default\") resets default strategy, synchronous eager evaluation unless option future_plan environment variable R_FUTURE_PLAN set. availableCores(\"mc.cores\") returns getOption(\"mc.cores\") + 1L, option mc.cores specifies “allowed number additional R processes” used addition main R process.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.8.0","text":"plan(future::lazy) similar gave errors.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-070","dir":"Changelog","previous_headings":"","what":"Version 0.7.0","title":"Version 0.7.0","text":"CRAN release: 2015-07-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.7.0","text":"multicore() gained argument maxCores, makes possible use instance plan(multicore, maxCores = 4L). Add availableMulticore() [(-house) async package].","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.7.0","text":"colorful demo(\"mandelbrot\", package = \"future\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.7.0","text":"ROBUSTNESS: multicore() blocks one CPU cores available, iff currently occupied multicore futures. old <- plan(new) now returns old plan/strategy (newly set one).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-060","dir":"Changelog","previous_headings":"","what":"Version 0.6.0","title":"Version 0.6.0","text":"CRAN release: 2015-06-19","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.6.0","text":"Add multicore futures, futures resolved asynchronously separate process. supported Unix-like systems, Windows.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-5-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.5.1","text":"Eager lazy futures now records result internally expression evaluated , even error values requested multiple times. Eager futures always created regardless error . Future objects environments record expression, call environment optional variables.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-5-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.5.0","text":"lazy() “freezes” global variables time future created. way result lazy future likely ‘eager’ future. also globals likely handled asynchronous futures.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-4-2","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.4.2","text":"plan() records call.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-4-2","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.4.2","text":"Added demo(\"mandelbrot\", package = \"future\"), can re-used future packages.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-4-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.4.1","text":"Added plan(). Added eager future - useful troubleshooting.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-040","dir":"Changelog","previous_headings":"","what":"Version 0.4.0","title":"Version 0.4.0","text":"Distilled Future API (-house) async package.","code":""}]
