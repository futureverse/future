[{"path":[]},{"path":"https://future.futureverse.org/CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing othersâ€™ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported project lead. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://future.futureverse.org/CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozillaâ€™s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://future.futureverse.org/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to the â€˜futureâ€™ package","title":"Contributing to the â€˜futureâ€™ package","text":"Git repository uses Git Flow branching model (git flow extension useful ). develop branch contains latest contributions code appear next release, master branch contains code latest release, exactly currently CRAN. Contributing package easy. Just send pull request. send PR, make sure develop destination branch future repository. PR pass R CMD check ---cran, also checked GitHub Actions PR submitted. abide Code Conduct Contributor Covenant.","code":""},{"path":[]},{"path":"https://future.futureverse.org/README_ja.html","id":"ã‚¤ãƒ³ãƒˆãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³","dir":"","previous_headings":"","what":"ã‚¤ãƒ³ãƒˆãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€R ã®å¼ (expression) ã‚’éåŒæœŸçš„ã«å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ã‚·ãƒ³ãƒ—ãƒ«ãªæ–¹æ³•ã‚’æä¾›ã™ã‚‹ã€‚ ã¾ãŸã€éåŒæœŸå‡¦ç†ã«ä½¿ã‚ã‚Œã‚‹æ§˜ã€…ãªãƒªã‚½ãƒ¼ã‚¹ã‚’ä¸€è²«ã—ãŸæ–¹æ³•ã§å–ã‚Šæ‰±ã†ã“ã¨ãŒã§ãã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ (future) ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨èªã§ã‚ã‚Šã€ã€Œæœªæ¥ã®ã‚ã‚‹æ™‚ç‚¹ã§åˆ©ç”¨å¯èƒ½ã«ãªã‚‹äºˆå®šã®å€¤ (value)ã€ã‚’è¡¨ã™æŠ½è±¡çš„ãªæ¦‚å¿µã§ã‚ã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯çŠ¶æ…‹ã‚’ã‚‚ã¡ã€è§£æ±ºæ¸ˆã¿ã‹æœªè§£æ±ºã‹ã®ã©ã¡ã‚‰ã‹ã®çŠ¶æ…‹ã‚’ã¨ã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºæ¸ˆã¿çŠ¶æ…‹ã®å ´åˆã€ãã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å€¤ã¯ã™ãã«åˆ©ç”¨ã§ãã‚‹ã€‚ ä¸€æ–¹ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒæœªè§£æ±ºçŠ¶æ…‹ã®å ´åˆã€ãã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å€¤ã‚’åˆ©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çŠ¶æ…‹ãŒè§£æ±ºæ¸ˆã¿ã«ãªã‚‹ã¾ã§ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€‚ ãŸã ã—ã€ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãšã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹æ–¹æ³•ã‚‚ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã€‚ ã„ã¤ã©ã®ã‚ˆã†ã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºã•ã‚Œã‚‹ã‹ã¯ã€å¼ã®è©•ä¾¡ã«ä½¿ã‚ã‚Œã‚‹æˆ¦ç•¥ (strategy) ã«ã‚ˆã£ã¦ç•°ãªã‚‹ã€‚ ä¾‹ãˆã°ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’è§£æ±ºã™ã‚‹æˆ¦ç•¥ã®1ã¤ã«é€æ¬¡æˆ¦ç•¥ãŒã‚ã‚‹ã€‚ ã“ã®æˆ¦ç•¥ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ç¾è¡Œã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§è§£æ±ºã—ã‚ˆã†ã¨ã™ã‚‹ã€‚ ã¾ãŸã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’éåŒæœŸçš„ã«è§£æ±ºã™ã‚‹æˆ¦ç•¥ã¨ã—ã¦ã€1å°ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ä¸Šã§å¼ã®ä¸¦åˆ—è©•ä¾¡ã‚’è¡Œã†æˆ¦ç•¥ã‚„ã€è¨ˆç®—ã‚¯ãƒ©ã‚¹ã‚¿ä¸Šã§ä¸€æ–‰ã«å¼ã‚’è©•ä¾¡ã™ã‚‹æˆ¦ç•¥ãªã©ãŒã‚ã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã‹ä¾‹ã‚’ç¤ºãã†ã€‚ ã¾ãšã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½¿ã‚ãšã«å¼ã‚’è©•ä¾¡ã™ã‚‹æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã¿ã‚ˆã†ã€‚ ä¸Šã®ã‚³ãƒ¼ãƒ‰ã¯å¼ã®å€¤ã‚’å¤‰æ•° v ã«ä»£å…¥ã—ã€æ¬¡ã« v ã®å€¤ã‚’è¡¨ç¤ºã—ã¦ã„ã‚‹ã€‚ ã“ã®ã¨ãã€v ã®å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹éš›ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚è¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã‚ˆã†ã€‚ ä¸Šã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½¿ã£ãŸå¼ã«æ›¸ãæ›ãˆã‚ˆã†ã€‚ 2ã¤ã®ã‚³ãƒ¼ãƒ‰é•ã„ã¯ v ã«å¯¾ã™ã‚‹ä»£å…¥è¨˜å·ã«ã‚ã‚‹ã€‚ æœ€åˆã®ã‚³ãƒ¼ãƒ‰ã§ <- ãŒä½¿ã‚ã‚Œã¦ã„ãŸã¨ã“ã‚ãŒã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å ´åˆã¯ %<-% ã«å¤‰ã‚ã£ã¦ã„ã‚‹ã€‚ ã‚‚ã†1ã¤ã®é•ã„ã¯ã€Hello World! ãŒãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºã•ã‚ŒãŸã‚ã¨ã€ã™ãªã‚ã¡å€¤ãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã«è¡¨ç¤ºã•ã‚Œã‚‹ï¼ˆãƒ“ãƒãƒƒãƒˆ â€˜Outputting Textâ€™ ã‚’å‚ç…§ï¼‰ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ä½•ãŒä¾¿åˆ©ãªã®ã ã‚ã†ã‹ï¼Ÿ å¼ã‚’ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«ã—ã¦ãŠãã¨ã€å¼ã®è©•ä¾¡ã‚’éåŒæœŸå®Ÿè¡Œã—ãŸã„ã¨ãã«ã€æ¬¡ã®ã‚ˆã†ã«ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ éåŒæœŸåŒ–ã•ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ã€å®Ÿè¡Œæ™‚ã«ç¾è¡Œã®ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã€‚ ã¤ã¾ã‚Šã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã§ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºã•ã‚Œã¦ã„ã‚‹é–“ã«ã€ç¾è¡Œã®ãƒ—ãƒ­ã‚»ã‚¹ã§å¼•ãç¶šãå‡¦ç†ã‚’å®Ÿè¡Œã§ãã‚‹ã€‚ ã“ã®ã‚ˆã†ã«ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ã€R ã«ãŠã‘ã‚‹ä¸¦åˆ—åˆ†æ•£å‡¦ç†ã®ãŸã‚ã®ã‚·ãƒ³ãƒ—ãƒ«ã§å¼·åŠ›ãªå®Ÿè¡Œæ–¹æ³•ã‚’æä¾›ã™ã‚‹ã®ã§ã‚ã‚‹ã€‚ ä»¥é™ã§ã¯ future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒæä¾›ã™ã‚‹æ©Ÿèƒ½ã®è©³ç´°ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ã„ãã€‚ ãã®å‰ã«ã€ã¨ã‚Šã‚ãˆãšè©¦ã—ã¦ã¿ãŸã„ã¨ã„ã†äººã¯ã€å…ˆã«çµ‚ã‚ã‚Šã®æ–¹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€Œãƒ‡ãƒ¢ã€ã‚’èª­ã‚“ã§ã€ãƒãƒ³ãƒ‡ãƒ«ãƒ–ãƒ­é›†åˆã‚’æ§˜ã€…ãªæˆ¦ç•¥ã§æç”»ã—ã¦ã¿ã‚‹ã¨è‰¯ã„ã ã‚ã†ã€‚","code":"> v <- { +   cat(\"Hello world!\\n\") +   3.14 + } Hello world! > v [1] 3.14 > library(future) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14 > library(future) > plan(multisession) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14"},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆ","dir":"","previous_headings":"","what":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆ","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã¨ã—ã¦ã€æ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã¨éæ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã®2ç¨®é¡ãŒã‚ã‚‹ã€‚ ä¸Šè¨˜ã®ä¾‹ã§ã¯ã€v %<-% { å¼ } ã¨ã„ã†éæ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã§ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã—ãŸã€‚ ä¸€æ–¹ã€æ˜ç¤ºçš„ã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã¨ã—ã¦ f <- future({ å¼ }) ã¨ v <- value(f) ã¨ã„ã†2ã¤ã®é–¢æ•°ã‚’ä½¿ã†ã‚¹ã‚¿ã‚¤ãƒ«ãŒã‚ã‚‹ã€‚ ä¸Šè¨˜ã®ä¾‹ã‚’æ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã«æ›¸ãæ›ãˆã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã€‚ ã©ã¡ã‚‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ä½œæˆã—ã¦ã‚‚ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å‹•ä½œã¯åŒã˜ã§ã‚ã‚‹(*)ã€‚ éæ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä½¿ã†ã¨é€šå¸¸ã® R ã‚³ãƒ¼ãƒ‰ã«è¿‘ã„æ›¸ãæ–¹ã«ãªã‚‹ã€‚ ã“ã®å ´åˆã€åŸå‰‡çš„ã«ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆã¯ <- ã§ä»£å…¥ã—ã¦ã„ãŸã¨ã“ã‚ã‚’ %<-% ã«ç½®ãæ›ãˆã‚‹ã ã‘ã§ã‚ã‚‹ã€‚ ã—ã‹ã—ã€ã“ã®ã‚·ãƒ³ãƒ—ãƒ«ã•ã®æ¬ ç‚¹ã¨ã—ã¦ã€ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€éš›ã«ã€ã‚³ãƒ¼ãƒ‰å†…ã§éåŒæœŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ°—ã¥ã‹ãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚ æ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ãªã‚‰ã°ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒæ˜ç¢ºã«ãªã‚Šã€ã“ã†ã—ãŸè¦‹é€ƒã—ã®ãƒªã‚¹ã‚¯ã¯è»½æ¸›ã•ã‚Œã‚‹ãŸã‚ã€ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€äººã«å„ªã—ã„ã€‚ (*) å°‘ã—å¤‰æ›´ã—ãªã„ã¨ %<-% ãŒä½¿ãˆãªã„å ´åˆãŒã‚ã‚‹ã€‚ ã“ã®è©±é¡Œã«ã¯ã€ä¸‹ã®æ–¹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€Œéæ˜ç¤ºçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®åˆ¶ç´„ã€ã§è§¦ã‚Œã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã™ã‚‹æ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ­£å¼ã«è¿°ã¹ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã€‚ f <- future({ å¼ }) â€“ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆ v <- value(f) â€“ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‹ã‚‰å€¤ã‚’å–å¾—ã™ã‚‹ (æœªè§£æ±ºã®å ´åˆã¯è§£æ±ºã•ã‚Œã‚‹ã¾ã§ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹) ã¾ãŸã€éæ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã€‚ v %<-% { å¼ } â€“ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã—ã€ãã®å€¤ã®ãƒ—ãƒ­ãƒŸã‚¹ã‚’ä½œæˆã™ã‚‹ ä»¥é™ã§ã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’ç°¡æ½”ã«ã™ã‚‹ãŸã‚ã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆã«ã¯éæ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä½¿ã†ã€‚ ãŸã ã—ã€è­°è«–ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ã“ã¨ãŒæ˜ç¤ºçš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã§ä½œæˆã•ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«å¯¾ã—ã¦ã‚‚åŒæ§˜ã«æˆã‚Šç«‹ã¤ã€‚","code":"> library(future) > f <- future({ +   cat(\"Hello world!\\n\") +   3.14 + }) > v <- value(f) Hello world! > v [1] 3.14"},{"path":"https://future.futureverse.org/README_ja.html","id":"æˆ¦ç•¥ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹","dir":"","previous_headings":"","what":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§åˆ©ç”¨ã§ãã‚‹æˆ¦ç•¥ã‚’æ¬¡ã®è¡¨ã«ç¤ºã™ã€‚ future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€è‡ªåˆ†ã§å®Ÿè£…ã—ãŸæˆ¦ç•¥ã‚’è¿½åŠ ã§ãã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã€‚ ä¾‹ãˆã°ã€future.callr ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€callr ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’åˆ©ç”¨ã—ã¦ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã® R ãƒ—ãƒ­ã‚»ã‚¹ã§ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’è©•ä¾¡ã™ã‚‹ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’æä¾›ã™ã‚‹ã€‚ ã“ã‚Œã¯ multisession æˆ¦ç•¥ã¨ä¼¼ã¦ã„ã‚‹ãŒã€ã„ãã¤ã‹ã®åˆ©ç‚¹ãŒã‚ã‚‹ã€‚ ã¾ãŸã€future.batchtools ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€batchtools ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ã™ã¹ã¦ã®ã‚¯ãƒ©ã‚¹ã‚¿é–¢æ•°ã«å¯¾ã™ã‚‹ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’æä¾›ã™ã‚‹ã€‚ å…·ä½“çš„ã«ã¯ã€Slurmã€TORQUE/PBSã€Oracle/Sun Grid Engine (SGE)ã€Load Sharing Facility (LSF) ãªã©ã®ã‚¸ãƒ§ãƒ–ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã‚’ä½¿ç”¨ã—ã¦ R ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã‚ã‚‹ã€‚ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å¼ã¯ãã®å ´ã§åŒæœŸçš„ã«ï¼ˆç¾è¡Œã®Rã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ï¼‰è©•ä¾¡ã•ã‚Œã‚‹ã€‚ ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æˆ¦ç•¥ã¯é€æ¬¡ (sequential) æˆ¦ç•¥ã¨å‘¼ã°ã‚Œã‚‹ã€‚ ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§åˆ©ç”¨ã§ãã‚‹ãã‚Œãã‚Œã®æˆ¦ç•¥ã«ã¤ã„ã¦èª¬æ˜ã—ã€å…±é€šç‚¹ã¨ç›¸é•ç‚¹ã«ã¤ã„ã¦è¿°ã¹ã‚‹ã€‚","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«å…±é€šã®ãµã‚‹ã¾ã„","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹","what":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«å…±é€šã®ãµã‚‹ã¾ã„","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ãã‚Œãã‚Œã®æˆ¦ç•¥ã®èª¬æ˜ã«é€²ã‚€å‰ã«ã€future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒæä¾›ã™ã‚‹ API (Future API) ã®è¨­è¨ˆã«ã¤ã„ã¦ç†è§£ã—ã‚ˆã†ã€‚ Future API ã¯ãƒ¦ãƒ¼ã‚¶ãŒã©ã®æˆ¦ç•¥ã‚’ä½¿ã£ã¦ã‚‚åŒã˜ãµã‚‹ã¾ã„ã‚’ã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã€‚ ãªãœãªã‚‰ã€ãƒ¦ãƒ¼ã‚¶ãŒå®Ÿéš›ã«ã©ã‚“ãªè¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ã†ã‹ã«ã¤ã„ã¦ã‚ã‚‰ã‹ã˜ã‚çŸ¥ã‚‹ã“ã¨ãŒã§ããªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚ ã“ã‚Œã«ã‚ˆã‚Šã€Future API ã¯ã€ãƒ¦ãƒ¼ã‚¶ãŒä½¿ç”¨ã™ã‚‹æˆ¦ç•¥ã«ã¤ã„ã¦ã€åŒæœŸã‹éåŒæœŸã‹ãªã©ã®ã„ã‹ãªã‚‹ä»®å®šã‚‚ãŠã‹ãšã«åˆ©ç”¨ã§ãã‚‹ã€‚ Future API ã¯ã€ãã®å‹•ä½œãŒæˆ¦ç•¥ã«ä¾å­˜ã—ãªã„ã‚ˆã†ã«ã€ã‚ã‚‰ã‚†ã‚‹é•ã„ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å¼ãŒç¾è¡Œã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§è©•ä¾¡ã•ã‚Œã‚ˆã†ãŒã€ãƒªãƒ¢ãƒ¼ãƒˆã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§è©•ä¾¡ã•ã‚Œã‚ˆã†ãŒé–¢ä¿‚ãªãã€ã©ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£æˆ¦ç•¥ã«å¯¾ã—ã¦ã‚‚ä¸€è²«ã—ãŸ API ã¨ãµã‚‹ã¾ã„ã‚’æŒã¤ã€‚ ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½¿ã£ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã™ã‚‹ã¨ãã€ãƒ¦ãƒ¼ã‚¶ã¯ã©ã®æˆ¦ç•¥ã‚’ä½¿ã†ã‹ã‚’æ°—ã«ã—ãªãã¦ã™ã‚€ã€‚ ã¾ãŸã€ã“ã®è¨­è¨ˆã®ã‚‚ã†1ã¤ã®åˆ©ç‚¹ã¯ã€ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã—ã‚„ã™ã„ã“ã¨ã«ã‚ã‚‹ã€‚ éåŒæœŸå‡¦ç†ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æ›¸ãéš›ã«ã€æœ€åˆã¯ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„é€æ¬¡æˆ¦ç•¥ã‚’ä½¿ç”¨ã—ã¦æ›¸ãã€å®Ÿéš›ã®å‡¦ç†ã®ã¨ãã«ç°¡å˜ã«éåŒæœŸå‡¦ç†ã¸åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ ãã®ãŸã‚ã«ã€ã™ã¹ã¦ã®æˆ¦ç•¥ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å¼ã®è©•ä¾¡çµæœã¨å‰¯ä½œç”¨ãŒå¯èƒ½ãªé™ã‚ŠåŒã˜ã«ãªã‚‹ã‚ˆã†ã«ä½œã‚‰ã‚Œã¦ã„ã‚‹ã€‚ å…·ä½“çš„ã«ã¯ã€ã™ã¹ã¦ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£æˆ¦ç•¥ã¯ä»¥ä¸‹ã‚’æº€ãŸã™ã€‚ å¼ã®è©•ä¾¡ã¯ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒï¼ˆã™ãªã‚ã¡ local({ å¼ })ï¼‰ã§è¡Œã‚ã‚Œã‚‹ã€‚ã—ãŸãŒã£ã¦ã€ä»£å…¥æ–‡ã¯å‘¼ã³å‡ºã—ç’°å¢ƒã«å½±éŸ¿ã‚’ä¸ãˆãªã„ã€‚ ã“ã‚Œã¯è©•ä¾¡ãŒå¤–éƒ¨ã® R ãƒ—ãƒ­ã‚»ã‚¹ã§è¡Œã‚ã‚Œã‚‹ã¨ãã¯ã‚‚ã¡ã‚ã‚“ã€ç¾è¡Œã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§è¡Œã‚ã‚Œã‚‹ã¨ãã«ã‚‚é©ç”¨ã•ã‚Œã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆæ™‚ã«ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒå›ºå®šã•ã‚Œã‚‹ã€‚ éåŒæœŸè©•ä¾¡ã®å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ R ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ã€‚ é…å»¶è©•ä¾¡ (lazy = TRUE) ã‚’ä¼´ã†é€æ¬¡æˆ¦ç•¥ã«ãŠã„ã¦ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯ãƒ•ãƒªãƒ¼ã‚ºï¼ˆãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã«ã‚¯ãƒ­ãƒ¼ãƒ³ï¼‰ã•ã‚Œã‚‹ã€‚ ã¾ãŸã€èª¤ã£ã¦å¤§ãã™ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’é˜²ããŸã‚ã«ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®åˆè¨ˆã‚µã‚¤ã‚ºã«ã—ãã„å€¤ã‚’è¨­å®šã§ãã‚‹ã€‚ã“ã®ã—ãã„å€¤ã‚’è¶…ãˆã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ï¼ˆhelp(\"future.options\") ã‚’å‚ç…§ï¼‰ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å¼ã®è©•ä¾¡ã¯ä¸€åº¦ã ã‘å®Ÿè¡Œã•ã‚Œã‚‹ã€‚ å€¤ãŒå®šã¾ã£ãŸï¼ˆè§£æ±ºæ¸ˆã¿çŠ¶æ…‹ã«ãªã£ãŸï¼‰ã‚ã¨ã§ã€åŒã˜ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ã‚‚ã†ä¸€åº¦è©•ä¾¡ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚ ä»£å…¥ãŒãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§å®Ÿè¡Œã•ã‚Œã‚‹ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ç’°å¢ƒã«å½±éŸ¿ã—ãªã„ï¼‰ã“ã¨ã¯ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã®å®Ÿè¡Œçµæœã‹ã‚‰ã‚ã‹ã‚‹ã€‚ ä»¥ä¸Šã§ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«å…±é€šã™ã‚‹ãµã‚‹ã¾ã„ãŒã‚ã‹ã£ãŸã€‚ ä»¥é™ã§ã¯ãã‚Œãã‚Œã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£æˆ¦ç•¥ã«ã¤ã„ã¦è¦‹ã¦ã„ãã€‚","code":"> plan(sequential) > a <- 1 > x %<-% { +     a <- 2 +     2 * a + } > x [1] 4 > a [1] 1"},{"path":"https://future.futureverse.org/README_ja.html","id":"åŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹","what":"åŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"åŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã—ãŸ R ãƒ—ãƒ­ã‚»ã‚¹ã§ä¸€ã¤ã²ã¨ã¤è§£æ±ºã•ã‚Œã‚‹ã€‚ åŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºã•ã‚Œã¦ã„ã‚‹é–“ã€ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€‚","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"é€æ¬¡çš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£-sequential-future","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹ > åŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","what":"é€æ¬¡çš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ (Sequential Future)","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"é€æ¬¡çš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§ã‚ã‚‹ã€‚ Future API ã®å…±é€šã®ãµã‚‹ã¾ã„ã‚’æº€ãŸã—ãªãŒã‚‰ã€é€šå¸¸ã® R è©•ä¾¡ã¨åŒã˜ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã€‚ é€æ¬¡çš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ãµã‚‹ã¾ã„ã‚’æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã«ç¤ºã™ã€‚ é€æ¬¡çš„ãªè©•ä¾¡ãŒãã®å ´ã§è¡Œã‚ã‚Œã‚‹ãŸã‚ã€3ã¤ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ä½œæˆã¨åŒæ™‚ã«å³åº§ã«è§£æ±ºã•ã‚Œã‚‹ã€‚ å‘¼ã³å‡ºã—ç’°å¢ƒã® pidï¼ˆã“ã‚Œã¯ç¾è¡Œãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ—ãƒ­ã‚»ã‚¹ ID ãŒä»£å…¥ã•ã‚Œã¦ã„ã‚‹ï¼‰ã¯ä¸Šæ›¸ãã‚‚å‰Šé™¤ã‚‚ã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã‚ˆã†ã€‚ ã“ã‚Œã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§è©•ä¾¡ã•ã‚Œã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚ åŒæœŸçš„ãªï¼ˆå˜ä¸€ã®ï¼‰ãƒ—ãƒ­ã‚»ã‚¹ãŒè©•ä¾¡ã«ä½¿ã‚ã‚Œã‚‹ã®ã§ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ b ã¯ãƒ¡ã‚¤ãƒ³ã® R ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã£ã¦ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ï¼‰è§£æ±ºã•ã‚Œã‚‹ ã€‚ ã“ã‚ŒãŒ b ã®å€¤ã¨ pid ãŒä¸€è‡´ã™ã‚‹ç†ç”±ã§ã‚ã‚‹ã€‚","code":"> plan(sequential) > pid <- Sys.getpid() > pid [1] 1427324 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1427324 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1427324"},{"path":"https://future.futureverse.org/README_ja.html","id":"éåŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹","what":"éåŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"éåŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®èª¬æ˜ã«ç§»ã‚ã†ã€‚ éåŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å‡¦ç†ã•ã‚Œã‚‹ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§ã‚ã‚‹ã€‚ è¨­è¨ˆä¸Šã€ã“ã‚Œã‚‰ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã§ã‚ã‚‹ã€‚ ã™ãªã‚ã¡ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã—ãŸã¨ãã€å‘¼ã³å‡ºã—å´ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ä»–ã®ã‚¿ã‚¹ã‚¯ï¼ˆã•ã‚‰ã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œã‚‹ãªã©ï¼‰ã«åˆ©ç”¨ã§ãã‚‹ã€‚ å‘¼ã³å‡ºã—å´ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã®ã¯ã€æœªè§£æ±ºã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã‚’è©¦ã¿ãŸå ´åˆã‹ã€ã™ã¹ã¦ã®åˆ©ç”¨å¯èƒ½ãª R ãƒ—ãƒ­ã‚»ã‚¹ãŒä»–ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§ãƒ“ã‚¸ãƒ¼ã«ãªã£ã¦ã„ã‚‹ã¨ãã«ã•ã‚‰ã«éåŒæœŸã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã—ã‚ˆã†ã¨ã—ãŸå ´åˆã«é™ã‚‰ã‚Œã‚‹ã€‚","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ•ãƒ¥ãƒ¼ãƒãƒ£-multisession-future","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹ > éåŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","what":"ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ (Multisession Future)","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ã™ã¹ã¦ã® OS ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‹ã‚‰å§‹ã‚ã‚ˆã†ã€‚ ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯å‘¼ã³å‡ºã—å´ã® R ãƒ—ãƒ­ã‚»ã‚¹ã¨åŒã˜ãƒã‚·ãƒ³ã§ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ãŠã„ã¦ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’è©•ä¾¡ã™ã‚‹ã€‚ ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³è©•ä¾¡ã®ä¾‹ã‚’ç¤ºãã†ã€‚ ã“ã®çµæœã‚’è¦‹ã‚‹ã¨ã€, c, pid ã®å€¤ã¯é€æ¬¡çš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ã¨ãã¨åŒã˜ã§ã‚ã‚Šã€b ã ã‘ãŒç•°ãªã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚ ãã®ç†ç”±ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ b ã¯ç¾è¡Œã¨ã¯åˆ¥ã® R ãƒ—ãƒ­ã‚»ã‚¹ã§è©•ä¾¡ã•ã‚Œã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ ID ã‚’è¿”ã™ã‹ã‚‰ã§ã‚ã‚‹ã€‚ ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³æˆ¦ç•¥ã‚’ä½¿ã†ã¨ã€ç¾è¡Œã¨ã¯åˆ¥ã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§èµ·å‹•ã•ã‚Œã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ä½œæˆã¨åŒæ™‚ã«ãã‚Œã‚‰ã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§è©•ä¾¡ã•ã‚Œã‚‹ã€‚ ã‚‚ã—ã™ã¹ã¦ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒä»–ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§ãƒ“ã‚¸ãƒ¼ãªã‚‰ã°ã€æ–°ã—ãä½œæˆã•ã‚ŒãŸãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€‚ ã„ãã¤ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ãŒèµ·å‹•ã•ã‚Œã‚‹ã‹ã¯ availableCores() ã®å€¤ã«ã‚ˆã£ã¦æ±ºã¾ã‚‹ã€‚ ã“ã®çµæœã‹ã‚‰ã€ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ä»¥å¤–ã« 2ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒåˆ©ç”¨å¯èƒ½ãªã“ã¨ãŒã‚ã‹ã‚‹ã€‚ ã—ãŸãŒã£ã¦ã€ã“ã®è¨­å®šã§ã¯ã€ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ 2ã¤ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚ ã“ã®å€¤ã¯ mc.cores ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§å¤‰æ›´ã§ãã‚‹ã€‚ availableCores() ã¯ã•ã¾ã–ã¾ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚„ã‚·ã‚¹ãƒ†ãƒ ç’°å¢ƒã«ã‚‚å¯¾å¿œã—ã¦ã„ã‚‹ã€‚ ä¾‹ãˆã°ã€è¨ˆç®—ã‚¯ãƒ©ã‚¹ã‚¿ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ï¼ˆä¾‹ãˆã° TORQUE/PBS ã‚„ Slurmï¼‰ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ä¸ãˆã‚‰ã‚ŒãŸã‚¸ãƒ§ãƒ–ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã‚³ã‚¢æ•°ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã®ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã™ã‚‹ã€‚ ãã®å ´åˆã‚‚ availableCores() ã¯ãã®ã‚³ã‚¢æ•°ã‚’èªè­˜ã™ã‚‹ã€‚ ä½•ã‚‚æŒ‡å®šã—ãªã„å ´åˆã€ãƒã‚·ãƒ³ä¸Šã®åˆ©ç”¨å¯èƒ½ãªã™ã¹ã¦ã®ã‚³ã‚¢ãŒä½¿ã‚ã‚Œã‚‹ã€‚ ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã¯ parallel::detectCores() ã§ç¢ºèªã§ãã‚‹ã€‚ è©³ç´°ã«ã¤ã„ã¦ã¯ help(\"availableCores\", package = \"parallelly\") ã‚’å‚ç…§ã—ã¦ã»ã—ã„ã€‚","code":"> plan(multisession) > pid <- Sys.getpid() > pid [1] 1427324 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1427382 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1427324 > availableCores() mc.cores         2"},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒãƒ«ãƒã‚³ã‚¢ãƒ•ãƒ¥ãƒ¼ãƒãƒ£-multicore-future","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹ > éåŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","what":"ãƒãƒ«ãƒã‚³ã‚¢ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ (Multicore Future)","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"R ãŒãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ•ã‚©ãƒ¼ã‚¯ (forking) ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ OSï¼ˆåŸºæœ¬çš„ã«ã¯ Windows ä»¥å¤–ï¼‰ã§ã¯ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹ä»£ã‚ã‚Šã«ã€æ—¢å­˜ã® R ãƒ—ãƒ­ã‚»ã‚¹ã‚’ãƒ•ã‚©ãƒ¼ã‚¯ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ ãƒ•ã‚©ãƒ¼ã‚¯ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€æ¬¡ã®ã‚ˆã†ã«ã—ã¦ãƒãƒ«ãƒã‚³ã‚¢ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¨åŒã˜ã‚ˆã†ã«ã€ä¸¦åˆ—ã«å®Ÿè¡Œã§ãã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®æœ€å¤§å€¤ã¯ availableCores() ã«ã‚ˆã£ã¦æ±ºã¾ã‚‹ã€‚ ã©ã¡ã‚‰ã®å ´åˆã‚‚è©•ä¾¡ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒã‚·ãƒ³ä¸Šã§è¡Œã‚ã‚Œã‚‹ã€‚ ãƒ•ã‚©ãƒ¼ã‚¯ã•ã‚ŒãŸ R ãƒ—ãƒ­ã‚»ã‚¹ã§ã®å®Ÿè¡Œã¯ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ã®å®Ÿè¡Œã‚ˆã‚Šé€Ÿããªã‚‹ã€‚ ãã®ç†ç”±ã®1ã¤ã¯ã€ãƒ•ã‚©ãƒ¼ã‚¯ã§ã¯ãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«å¤§ããªã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«ã‚ˆã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãŒç„¡ããªã‚‹ã“ã¨ã«ã‚ã‚‹ã€‚ ä¸€æ–¹ã€å…±æœ‰ãƒ¡ãƒ¢ãƒªã¯èª­ã¿å–ã‚Šå°‚ç”¨ã§ã‚ã‚‹ã€‚ ã¤ã¾ã‚Šã€ãƒ•ã‚©ãƒ¼ã‚¯ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ï¼ˆãƒ¯ãƒ¼ã‚«ï¼‰ãŒå…±æœ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚³ãƒ”ãƒ¼ã‚’å¼•ãèµ·ã“ã™ã€‚ ã“ã‚Œã¯ã€R ã®ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ãŒã€ãƒ•ã‚©ãƒ¼ã‚¯ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ã®1ã¤ã§å®Ÿè¡Œã•ã‚ŒãŸå ´åˆã«ã‚‚ç”Ÿã˜ã‚‹ã€‚ ã¾ãŸã€ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ•ã‚©ãƒ¼ã‚¯ã¯ R ç’°å¢ƒã«ã‚ˆã£ã¦ã¯ä¸å®‰å®šã§ã‚ã‚‹ã€‚ ä¾‹ãˆã°ã€RStudio ã®ãƒ—ãƒ­ã‚»ã‚¹å†…ã‹ã‚‰ R ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã¨ãã«ãƒ•ã‚©ãƒ¼ã‚¯ã‚’è¡Œã†ã¨ã€ R ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚ ã“ã®ãŸã‚ã€future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¯ã€RStudio ä¸Šã§ãƒãƒ«ãƒã‚³ã‚¢ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½¿ç”¨ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç„¡åŠ¹ã«ã—ã¦ã„ã‚‹ã€‚ è©³ç´°ã¯ help(\"supportsMulticore\") ã‚’å‚ç…§ã—ã¦ã»ã—ã„ã€‚","code":"plan(multicore)"},{"path":"https://future.futureverse.org/README_ja.html","id":"ã‚¯ãƒ©ã‚¹ã‚¿ãƒ•ãƒ¥ãƒ¼ãƒãƒ£-cluster-future","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹ > éåŒæœŸçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£","what":"ã‚¯ãƒ©ã‚¹ã‚¿ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ (Cluster Future)","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ã‚¯ãƒ©ã‚¹ã‚¿ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯ã€ï¼ˆparallel ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªï¼‰ã‚¢ãƒ‰ãƒ›ãƒƒã‚¯ã‚¯ãƒ©ã‚¹ã‚¿ä¸Šã§å¼ã‚’è©•ä¾¡ã™ã‚‹ã€‚ ä¾‹ãˆã°ã€3ã¤ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒãƒ¼ãƒ‰ n1, n2, n3 ãŒã‚ã‚‹ã¨ãã€ãã‚Œã‚‰ã‚’ä½¿ã£ã¦éåŒæœŸå‡¦ç†ã‚’è¡Œã†ã«ã¯æ¬¡ã®ã‚ˆã†ã«ã™ã‚‹ã€‚ parallel::makeCluster() ã§ä½œã‚‰ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿ãªã‚‰ä½•ã§ã‚‚ã‚¯ãƒ©ã‚¹ã‚¿ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§åˆ©ç”¨ã§ãã‚‹ã€‚ ä¾‹ãˆã°ã€ä¸Šè¨˜ã®ã‚¯ãƒ©ã‚¹ã‚¿ã‚’æ˜ç¤ºçš„ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹ã«ã¯æ¬¡ã®ã‚ˆã†ã«æ›¸ãã€‚ ã‚¯ãƒ©ã‚¹ã‚¿ cl ãŒã‚‚ã†ä½¿ã‚ã‚Œãªããªã£ãŸã¨ãã€parallel::stopCluster(cl) ã‚’å®Ÿè¡Œã—ã¦ã‚¯ãƒ©ã‚¹ã‚¿ã‚’ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã™ã‚‹ã®ãŒè‰¯ã„ä½œæ³•ã§ã‚ã‚‹ã€‚ ä¾¿åˆ©ãªã“ã¨ã«ã€future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸã¨ãã«ã€ã‚¯ãƒ©ã‚¹ã‚¿ã‚’è‡ªå‹•ã§ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã—ã¦ãã‚Œã‚‹ã€‚ ã‚¯ãƒ©ã‚¹ã‚¿ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚„ç®¡ç†ã«ã¤ã„ã¦ã¯ help(\"makeCluster\", package = \"parallel\") ã‚’å‚ç…§ã—ã¦ã»ã—ã„ã€‚ plan(cluster, workers = hosts)ï¼ˆhosts ã«ã¯æ–‡å­—åˆ—ãŒå…¥ã‚‹ï¼‰ã§éæ˜ç¤ºçš„ã«ä½œã‚‰ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿ã‚‚ã€ãƒ¡ã‚¤ãƒ³ã® R ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã™ã‚‹ã¨ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã•ã‚Œã‚‹ã€‚ ã¾ãŸã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£æˆ¦ç•¥ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãï¼ˆä¾‹ãˆã° plan(sequential) ãŒå‘¼ã°ã‚ŒãŸã¨ãï¼‰ã‚‚ã‚¯ãƒ©ã‚¹ã‚¿ã¯ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã•ã‚Œã‚‹ã€‚ SSH ã‚­ãƒ¼ãƒšã‚¢ãªã©ã®è‡ªå‹•èªè¨¼è¨­å®šãŒã‚ã‚‹ãªã‚‰ã€ãƒªãƒ¢ãƒ¼ãƒˆãƒã‚·ãƒ³ã®ã‚¯ãƒ©ã‚¹ã‚¿ãŒåŒã˜æ–¹æ³•ã§ä½¿ç”¨ã§ãã‚‹ã€‚ å„ãƒãƒ¼ãƒ‰ã§è¤‡æ•°ã®ãƒ¯ãƒ¼ã‚«ã‚’å®Ÿè¡Œã—ãŸã„å ´åˆã¯ã€æ¬¡ã®ã‚ˆã†ã«ãƒãƒ¼ãƒ‰åã‚’è¤‡æ•°å›æ›¸ã‘ã°ã‚ˆã„ã€‚ ã“ã®ä¾‹ã§ã¯ã€n1 ã§ã¯3ã¤ã€n2 ã§ã¯1ã¤ã€n3 ã§ã¯5ã¤ã¨ã€åˆè¨ˆ9ã¤ã®ãƒ¯ãƒ¼ã‚«ã«ã‚ˆã‚Šä¸¦åˆ—å®Ÿè¡Œã•ã‚Œã‚‹ã€‚","code":"> plan(cluster, workers = c(\"n1\", \"n2\", \"n3\")) > pid <- Sys.getpid() > pid [1] 1427324 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1427499 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1427324 cl <- parallel::makeCluster(c(\"n1\", \"n2\", \"n3\")) plan(cluster, workers = cl) > plan(cluster, workers = c(rep(\"n1\", times = 3), \"n2\", rep(\"n3\", times = 5)))"},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ãƒã‚¹ãƒˆã¨è©•ä¾¡ãƒˆãƒãƒ­ã‚¸ãƒ¼","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹","what":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ãƒã‚¹ãƒˆã¨è©•ä¾¡ãƒˆãƒãƒ­ã‚¸ãƒ¼","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ã“ã“ã¾ã§ã®èª¬æ˜ã§ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯åŒã˜ç’°å¢ƒã§ä½œæˆã•ã‚Œã¦ã„ãŸã€‚ ã“ã‚Œã¯ã€Œãƒ•ãƒ©ãƒƒãƒˆãƒˆãƒãƒ­ã‚¸ãƒ¼ã€ã¨è¨€ã†ã“ã¨ãŒã§ãã‚‹ã€‚ ã—ã‹ã—ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å†…éƒ¨ã§ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚ ã“ã‚Œã‚’ã€Œãƒã‚¹ãƒˆãƒˆãƒãƒ­ã‚¸ãƒ¼ã€ã¨å‘¼ã¶ã€‚ ä¾‹ãˆã°ã€æ¬¡ã®ä¾‹ã§ã¯ã€2ã¤ã®ã€Œãƒˆãƒƒãƒ—ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ï¼ˆã¨ bï¼‰ãŒã‚ã‚Šã€ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³æˆ¦ç•¥ã‚’ä½¿ã£ã¦è©•ä¾¡ã•ã‚Œã‚‹ã€‚ ãŸã ã—ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ b ã¯å†…éƒ¨ã«åˆ¥ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã€‚ ãƒ—ãƒ­ã‚»ã‚¹IDã‚’è¦‹ã‚‹ã¨ã€3ã¤ã®ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚ ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ (pid 1427324)ã€ã«ä½¿ã‚ã‚Œã‚‹ãƒ—ãƒ­ã‚»ã‚¹ (pid 1427606)ã€b ã«ä½¿ã‚ã‚Œã‚‹ãƒ—ãƒ­ã‚»ã‚¹ (pid 1427607) ã§ã‚ã‚‹ã€‚ ã—ã‹ã—ã€b ã«ãƒã‚¹ãƒˆã•ã‚Œã¦ã„ã‚‹2ã¤ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ b1 ã¨ b2 ã¯ b ã¨åŒã˜ãƒ—ãƒ­ã‚»ã‚¹ã§è©•ä¾¡ã•ã‚Œã¦ã„ã‚‹ã€‚ ã“ã‚Œã¯ã€ç‰¹ã«æŒ‡å®šã—ãªã„é™ã‚Šã€ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯é€æ¬¡æˆ¦ç•¥ã‚’ä½¿ã£ã¦è©•ä¾¡ã•ã‚Œã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚ ã“ã‚Œã«ã¯ã„ãã¤ã‹ã®ç†ç”±ãŒã‚ã‚‹ãŒã€ä¸»ãªç†ç”±ã¯ã€å†å¸°å‘¼ã³å‡ºã—ãªã©ã«ã‚ˆã£ã¦ã€èª¤ã£ã¦å¤šãã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ãŒç™ºç”Ÿã™ã‚‹ã®ã‚’é˜²ããŸã‚ã§ã‚ã‚‹ã€‚ plan() ã«æˆ¦ç•¥ã®ãƒªã‚¹ãƒˆã‚’æ¸¡ã™ã“ã¨ã§ã€è©•ä¾¡ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ ä¾‹ãˆã°ã€ä¸Šè¨˜ã¨åŒã˜è©•ä¾¡ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹ã«ã¯æ¬¡ã®ã‚ˆã†ã«ã™ã‚‹ã€‚ ã—ã‹ã—ã€æ¬¡ã«ç¤ºã™ã‚ˆã†ã«ã€è¤‡æ•°ãƒ¬ãƒ™ãƒ«ã®ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³è©•ä¾¡ã‚’è©¦ã—ã¦ã‚‚ã€ä¸Šè¨˜ã¨åŒã˜å‹•ä½œã«ãªã‚‹ã€‚ ã“ã®ç†ç”±ã¯ã€ã“ã“ã§ã‚‚ã€èª¤ã£ã¦å¤šãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒèµ·å‹•ã™ã‚‹ã®ã‚’é˜²ããŸã‚ã§ã‚ã‚‹ã€‚ å†…éƒ¨çš„ã«ã¯ã€parallel::mclapply() ã®ã‚ˆã†ãªé–¢æ•°ãŒé€æ¬¡å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã« mc.core = 1 ãŒè¨­å®šã•ã‚Œã‚‹ã€‚ ã“ã‚Œã¯ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³è©•ä¾¡ã¨ãƒãƒ«ãƒã‚³ã‚¢è©•ä¾¡ã®ä¸¡æ–¹ã§èµ·ã“ã‚‹ã€‚ æ¬¡ã«ã€ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã‚’é€æ¬¡è©•ä¾¡ã«ã—ã¦ã€ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³è©•ä¾¡ã—ã¦ã¿ã‚ˆã†ã€‚ ã¨ b ã¯å‘¼ã³å‡ºã—ãƒ—ãƒ­ã‚»ã‚¹ (pid 1427324) ã§è§£æ±ºã•ã‚Œã€ãƒã‚¹ãƒˆã•ã‚ŒãŸ2ã¤ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ï¼ˆb1 ã¨ b2ï¼‰ã¯ãã‚Œãã‚Œåˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ (pid 1427855 ã¨ 1427854) ã§è§£æ±ºã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚ å„ãƒ¬ãƒ™ãƒ«ã§åˆ©ç”¨å¯èƒ½ãªã‚³ã‚¢ã®æ•°ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹ï¼ˆå¼·åˆ¶ã™ã‚‹ï¼‰ã¨ã€ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³è©•ä¾¡æˆ¦ç•¥ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ ãã®ãŸã‚ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’ â€œtweakâ€ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ ã¾ãšã€ã¨ b ã¯å‘¼ã³å‡ºã—ãƒ—ãƒ­ã‚»ã‚¹ (pid 1427324) ã¨ã¯ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ï¼ˆpid 1427973 ã¨ 1427972ï¼‰ã§è§£æ±ºã•ã‚Œã‚‹ã€‚ æ¬¡ã«ã€2ã¤ã®ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ï¼ˆb1 ã¨ b2ï¼‰ã‚‚ã¾ãŸç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ï¼ˆpid 1428098 ã¨ 1428099ï¼‰ã§è§£æ±ºã•ã‚Œã‚‹ã€‚ ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å„ãƒ¬ãƒ™ãƒ«ã§ç•°ãªã‚‹è©•ä¾¡æˆ¦ç•¥ã‚’ä½¿ã†æ–¹æ³•ã«ã¤ã„ã¦ã®è©³ç´°ã¯ã€ãƒ“ãƒãƒƒãƒˆ â€˜Futures R: Future Topologiesâ€™ ã‚’å‚ç…§ã—ã¦ã»ã—ã„ã€‚","code":"> plan(multisession) > pid <- Sys.getpid() > a %<-% { +     cat(\"Future 'a' ...\\n\") +     Sys.getpid() + } > b %<-% { +     cat(\"Future 'b' ...\\n\") +     b1 %<-% { +         cat(\"Future 'b1' ...\\n\") +         Sys.getpid() +     } +     b2 %<-% { +         cat(\"Future 'b2' ...\\n\") +         Sys.getpid() +     } +     c(b.pid = Sys.getpid(), b1.pid = b1, b2.pid = b2) + } > pid [1] 1427324 > a Future 'a' ... [1] 1427606 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427607 1427607 1427607 plan(list(multisession, sequential)) > plan(list(multisession, multisession)) [...] > pid [1] 1427324 > a Future 'a' ... [1] 1427721 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427722 1427722 1427722 > plan(list(sequential, multisession)) [...] > pid [1] 1427324 > a Future 'a' ... [1] 1427324 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427324 1427855 1427854 > plan(list(tweak(multisession, workers = 2), tweak(multisession,  +     workers = 2))) [...] > pid [1] 1427324 > a Future 'a' ... [1] 1427973 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid 1427972 1428098 1428099"},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãšã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹","dir":"","previous_headings":"æˆ¦ç•¥ï¼šãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®è§£æ±ºæ–¹æ³•ã‚’æ±ºã‚ã‚‹","what":"ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãšã«ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºæ¸ˆã¿ã‹æœªè§£æ±ºã‹ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãšã«ç¢ºèªã™ã‚‹æ–¹æ³•ãŒã‚ã‚‹ã€‚ ã“ã‚Œã«ã¯ resolved(f) é–¢æ•°ã‚’ä½¿ã†ã€‚ ã“ã®é–¢æ•°ã«ã¯å…¥åŠ›ã¨ã—ã¦æ˜ç¤ºçš„ãªãƒ•ãƒ¥ãƒ¼ãƒãƒ£ f ã‚’ä¸ãˆã‚‹ã€‚ ã‚‚ã—éæ˜ç¤ºçš„ãªãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã€f <- futureOf() ã®ã‚ˆã†ã«ã—ã¦éæ˜ç¤ºçš„ãªãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’æ˜ç¤ºçš„ãªãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ ä¾‹ã‚’æ¬¡ã«ç¤ºã™ã€‚","code":"> plan(multisession) > a %<-% { +     cat(\"Future 'a' ...\") +     Sys.sleep(2) +     cat(\"done\\n\") +     Sys.getpid() + } > cat(\"Waiting for 'a' to be resolved ...\\n\") Waiting for 'a' to be resolved ... > f <- futureOf(a) > count <- 1 > while (!resolved(f)) { +     cat(count, \"\\n\") +     Sys.sleep(0.2) +     count <- count + 1 + } 1  2  3  4  5  > cat(\"Waiting for 'a' to be resolved ... DONE\\n\") Waiting for 'a' to be resolved ... DONE > a Future 'a' ...done [1] 1428185"},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«ãŠã‘ã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†","dir":"","previous_headings":"","what":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«ãŠã‘ã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒæœŸå¾…é€šã‚Šã«å‹•ã‹ãªã„å ´åˆãŒã‚ã‚‹ã€‚ ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’è©•ä¾¡ã—ã¦ã„ã‚‹ã¨ãã«ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸå ´åˆã€ãã®ã‚¨ãƒ©ãƒ¼ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å€¤ãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã«å‘¼ã³å‡ºã—ç’°å¢ƒã¸ä¼æ’­ã•ã‚Œã‚‹ã€‚ ä¾‹ãˆã°ã€é…å»¶è©•ä¾¡ã‚’ä½¿ã£ãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸå ´åˆã€æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã€‚ ã“ã®ã‚¨ãƒ©ãƒ¼ã¯å€¤ã‚’è¦æ±‚ã™ã‚‹ãŸã³ã«èµ·ã“ã‚‹ã€‚ ã™ãªã‚ã¡ã€ã‚‚ã†ä¸€åº¦å€¤ã‚’å–å¾—ã—ã‚ˆã†ã¨ã™ã‚‹ã¨åŒã˜ã‚¨ãƒ©ãƒ¼ï¼ˆã¨å‡ºåŠ›ï¼‰ã«ãªã‚‹ã€‚ ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã—ãŸã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®æœ€å¾Œã®å‘¼ã³å‡ºã—ã‚’è¦‹ã‚‹ã«ã¯ã€backtrace() é–¢æ•°(*)ã‚’ä½¿ã†ã€‚ (*) ä¸€èˆ¬çš„ã«ä½¿ç”¨ã•ã‚Œã‚‹ traceback() ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å ´åˆã«ã¯é–¢é€£æƒ…å ±ã‚’æä¾›ã—ãªã„ã€‚ ã•ã‚‰ã«ã€æ®‹å¿µãªãŒã‚‰ã€ã‚¨ãƒ©ãƒ¼ã®åŸå› ã¨ãªã£ãŸå‘¼ã³å‡ºã—ã®ãƒªã‚¹ãƒˆã‚’è¦‹ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚ ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã—ãŸå‘¼ã³å‡ºã—ã ã‘ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ˆã“ã‚Œã¯å†…éƒ¨ã§ä½¿ã‚ã‚Œã‚‹ tryCatch() ã®åˆ¶ç´„ã§ã‚ã‚‹ï¼‰ã€‚","code":"> plan(sequential) > b <- \"hello\" > a %<-% { +     cat(\"Future 'a' ...\\n\") +     log(b) + } %lazy% TRUE > cat(\"Everything is still ok although we have created a future that will fail.\\n\") Everything is still ok although we have created a future that will fail. > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function In addition: Warning message: restarting interrupted promise evaluation > backtrace(a) [[1]] log(a)"},{"path":"https://future.futureverse.org/README_ja.html","id":"ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ","dir":"","previous_headings":"","what":"ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"R ã®å¼ã‚’éåŒæœŸçš„ã«ï¼ˆä¸¦åˆ—ã«ï¼‰è©•ä¾¡ã™ã‚‹ã¨ãã€ã¾ãŸã¯é…å»¶è©•ä¾¡ã§é€æ¬¡è©•ä¾¡ã™ã‚‹ã¨ãã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆã€Œãƒ•ãƒªãƒ¼ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã‚‚è¨€ã†ï¼‰ã‚’ç‰¹å®šã—ã¦æ¸¡ã™å¿…è¦ãŒã‚ã‚‹ã€‚ é…å»¶è©•ä¾¡ã§ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆæ™‚ã¨è©•ä¾¡æ™‚ã§å¤‰æ›´ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®ä½œæˆæ™‚ã¨ã¾ã£ãŸãåŒã˜çŠ¶æ…‹ã§æ¸¡ã™å¿…è¦ãŒã‚ã‚‹ã€‚ éåŒæœŸè©•ä¾¡ã§ã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’è©•ä¾¡ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€ãã‚Œã‚‰ã‚’ç‰¹å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¯ã“ã‚Œã‚’ã§ãã‚‹é™ã‚Šè‡ªå‹•åŒ–ã—ã¦ã„ã‚‹ã€‚ ãã®ãŸã‚ã«é™çš„ã‚³ãƒ¼ãƒ‰è§£æã«ã‚ˆã£ã¦ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ç‰¹å®šã™ã‚‹ globals ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒä½¿ã‚ã‚Œã‚‹ã€‚ ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒç‰¹å®šã•ã‚Œã‚‹ã¨ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚Œã€è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã§åˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã€‚ ã¾ãŸã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å†…ã§ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚‰ã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œãªã„ã€‚ ã‹ã‚ã‚Šã«ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè©•ä¾¡ã•ã‚Œã‚‹ã¨ãã«å¯¾å¿œã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒç¢ºå®Ÿã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ ã“ã‚Œã¯ãƒ¡ã‚¤ãƒ³ R ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è¨­å®šã‚’ã‚ˆã‚Šã‚ˆãåæ˜ ã™ã‚‹ã ã‘ã§ãªãã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã®å¿…è¦æ€§ã‚‚æœ€å°é™ã«æŠ‘ãˆã‚‹ã€‚ ã“ã‚Œã«ã‚ˆã‚Šã€ç‰¹ã«ãƒªãƒ¢ãƒ¼ãƒˆã®è¨ˆç®—ãƒãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ãƒ¡ãƒ¢ãƒªã ã‘ã§ãªãæ™‚é–“ã¨å¸¯åŸŸå¹…ã‚‚ç¯€ç´„ã§ãã‚‹ã€‚ æœ€å¾Œã«ã€é™çš„ã‚³ãƒ¼ãƒ‰è§£æã ã‘ã§ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ç‰¹å®šã™ã‚‹ã®ã¯é›£ã—ã„ã¨ã„ã†ã“ã¨ã‚’è¿°ã¹ã¦ãŠã“ã†ã€‚ ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®è‡ªå‹•è­˜åˆ¥ã«å¤±æ•—ã™ã‚‹ã‚±ãƒ¼ã‚¹ãŒå¸¸ã«å­˜åœ¨ã™ã‚‹ã€‚ ãã®ãŸã‚ã€é–“é•ã£ã¦ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆ¤å®šã—ã¦ã—ã¾ã†å ´åˆï¼ˆã“ã‚Œã¯ç‰¹ã«å•é¡Œã«ãªã‚‰ãªã„ï¼‰ã¨ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’è¦‹é€ƒã—ã¦ã—ã¾ã†å ´åˆï¼ˆã“ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‹é–“é•ã£ãŸçµæœã«ãªã‚‹ï¼‰ãŒã‚ã‚‹ã€‚ ãƒ“ãƒãƒƒãƒˆ â€˜Futures R: Common Issues Solutionsâ€™ ã§ã¯ã€ãã®ã‚ˆã†ãªã‚±ãƒ¼ã‚¹ã®ä¸€èˆ¬çš„ãªä¾‹ã‚„ã€é¿ã‘ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°ã„ã„ã‹ã€ã¾ãŸã€ã©ã®ã‚ˆã†ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒç‰¹å®šã•ã‚Œã‚‹ã‹ã‚„é–“é•ã£ã¦ç‰¹å®šã—ãŸã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ç„¡è¦–ã™ã‚‹æ–¹æ³•ã‚’èª¬æ˜ã—ã¦ã„ã‚‹ã€‚ ãã‚Œã§ã‚‚ååˆ†ã§ãªã„å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®åå‰ã‚’æŒ‡å®šã™ã‚‹ï¼ˆä¾‹ï¼šglobals = c(\"\", \"slow_sum\")ï¼‰ã‹ã€åå‰ã¨å€¤ã®ãƒšã‚¢ã§æŒ‡å®šã™ã‚‹ï¼ˆä¾‹ï¼šglobals = list(= 42, slow_sum = my_sum)ï¼‰ã“ã¨ãŒã§ãã‚‹ã€‚","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"éæ˜ç¤ºçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®åˆ¶ç´„","dir":"","previous_headings":"","what":"éæ˜ç¤ºçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®åˆ¶ç´„","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"éæ˜ç¤ºçš„ãªãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã«ã¯1ã¤ã®åˆ¶ç´„ãŒã‚ã‚‹ã€‚ æ˜ç¤ºçš„ãªãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã¯å˜ãªã‚‹ R ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã§ã€ã©ã“ã§ã‚‚ä½•ã«ã§ã‚‚ä»£å…¥å¯èƒ½ã§ã‚ã‚‹ã€‚ ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«ã€ãƒ«ãƒ¼ãƒ—ã®ä¸­ã§ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ãƒªã‚¹ãƒˆã®è¦ç´ ã¨ã—ã¦ä»£å…¥ã§ãã‚‹ã€‚ ã“ã‚Œã¯éæ˜ç¤ºçš„ãªãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§ã¯ã§ããªã„ã€‚ ãªãœãªã‚‰ã€%<-% æ¼”ç®—å­ã¯é€šå¸¸ã® <- ä»£å…¥æ¼”ç®—å­ã¨ã¯é•ã†å‹•ä½œã‚’ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚ %<-% æ¼”ç®—å­ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å€¤ã‚’ç’°å¢ƒï¼ˆå‘¼ã³å‡ºã—ç’°å¢ƒãªã©ï¼‰ã«ä»£å…¥ã™ã‚‹ã€‚ ã“ã‚Œã¯ assign(name, value, envir) ã¨åŒã˜å‹•ä½œã§ã‚ã‚‹ã€‚ ã—ãŸãŒã£ã¦ã€ä¸Šè¨˜ã¨åŒæ§˜ã®ã“ã¨ã‚’éæ˜ç¤ºçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã§è¡Œã„ãŸã„å ´åˆã¯ã€æ¬¡ã®ã‚ˆã†ã«åå‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã£ã¦ç’°å¢ƒã«ä»£å…¥ã™ã‚‹ã€‚ ã“ã“ã§ã€.list(v) ã¯ç’°å¢ƒ v ã®ã™ã¹ã¦ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€‚ ãã®å¾Œã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã®å€¤ã¯é€šå¸¸ã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã•ã‚Œã‚‹ã€‚ ã‚‚ã—æ•°å€¤ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã„ãŸã„å ´åˆã¯ã€listenv ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ãƒªã‚¹ãƒˆç’°å¢ƒã‚’ä½¿ãˆã°ã‚ˆã„ã€‚ ãƒªã‚¹ãƒˆç’°å¢ƒã¯ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä»˜ããƒªã‚¹ãƒˆã¨åŒã˜ã‚ˆã†ã«ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä»˜ã‘ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ç’°å¢ƒã§ã‚ã‚‹ã€‚ ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã§ãƒªã‚¹ãƒˆã‚’ãƒªã‚¹ãƒˆç’°å¢ƒã«ç½®ãæ›ãˆã‚‹ã¨ã€æ•°å€¤ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã£ã¦éæ˜ç¤ºçš„ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä»£å…¥ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚ ã“ã“ã§ã‚‚ã€.list(v) ã¯ã™ã¹ã¦ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒè§£æ±ºã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€‚","code":"> plan(multisession) > f <- list() > for (ii in 1:3) { +     f[[ii]] <- future({ +         Sys.getpid() +     }) + } > v <- lapply(f, FUN = value) > str(v) List of 3  $ : int 1428291  $ : int 1428290  $ : int 1428291 > plan(multisession) > v <- new.env() > for (name in c(\"a\", \"b\", \"c\")) { +     v[[name]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ a: int 1428405  $ b: int 1428406  $ c: int 1428405 > library(listenv) > plan(multisession) > v <- listenv() > for (ii in 1:3) { +     v[[ii]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ : int 1428523  $ : int 1428522  $ : int 1428523"},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒ‡ãƒ¢","dir":"","previous_headings":"","what":"ãƒ‡ãƒ¢","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"æ§˜ã€…ãªæˆ¦ç•¥ã«ãŠã„ã¦ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãŒã©ã®ã‚ˆã†ã«è©•ä¾¡ã•ã‚Œã‚‹ã‹ã®å®Ÿä¾‹ã‚’è¦‹ã‚‹ã«ã¯ã€ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å«ã¾ã‚Œã‚‹ãƒãƒ³ãƒ‡ãƒ«ãƒ–ãƒ­ (Mandelbrot) ãƒ‡ãƒ¢ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã‚ˆã„ã€‚ ã¾ãšã€é€æ¬¡è©•ä¾¡ã§å®Ÿè¡Œã—ã¦ã¿ã‚ˆã†ã€‚ ã“ã‚Œã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½¿ç”¨ã—ãªã„å ´åˆã®å‹•ä½œã¨ã»ã¨ã‚“ã©åŒã˜ã§ã‚ã‚‹ã€‚ æ¬¡ã«ã€ãƒãƒ«ãƒã‚»ãƒƒã‚·ãƒ§ãƒ³è©•ä¾¡ã‚’è©¦ã—ã¦ã¿ã‚ˆã†ã€‚ ã“ã‚Œã¯ç•°ãªã‚‹ãƒãƒ³ãƒ‡ãƒ«ãƒ–ãƒ­å¹³é¢ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œã•ã‚Œã‚‹ R ãƒ—ãƒ­ã‚»ã‚¹ã§ä¸¦åˆ—ã«è¨ˆç®—ã™ã‚‹ã€‚ æœ€å¾Œã«ã€è¤‡æ•°ã®è¨ˆç®—æ©Ÿã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹å ´åˆã€ã‚¯ãƒ©ã‚¹ã‚¿ã®ãƒ¯ãƒ¼ã‚«ã‚’æŒ‡å®šã—ã¦å®Ÿè¡Œã§ãã‚‹ã€‚","code":"library(future) plan(sequential) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(multisession) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(cluster, workers = c(\"n2\", \"n5\", \"n6\", \"n6\", \"n9\")) demo(\"mandelbrot\", package = \"future\", ask = FALSE)"},{"path":"https://future.futureverse.org/README_ja.html","id":"è²¢çŒ®ã™ã‚‹ã«ã¯","dir":"","previous_headings":"","what":"è²¢çŒ®ã™ã‚‹ã«ã¯","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ç›®çš„ã¯ã€R ã§ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ã‚’ä½¿ã†ãŸã‚ã®æ¨™æº–çš„ã§çµ±ä¸€ã•ã‚ŒãŸ API ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚ ç¾çŠ¶ã¯ã“ã®ç›®çš„ã‚’é”æˆã™ã‚‹ãŸã‚ã®åˆæœŸæ®µéšã«ã™ããªã„ã€‚ future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’æ”¹å–„ã™ã‚‹ã‚¢ã‚¤ãƒ‡ã‚¢ã‚„æ„è¦‹ã‚’æŒã£ã¦ã„ã‚‹äººãŒã„ãŸã‚‰ãœã²æ•™ãˆã¦ã»ã—ã„ã€‚ é–‹ç™ºè€…ã«é€£çµ¡ã‚’ã¨ã‚‹ã«ã¯ GitHub ãƒªãƒã‚¸ãƒˆãƒªçµŒç”±ãŒå¥½ã¾ã—ã„ãŒã€ã©ã®ã‚ˆã†ãªæ‰‹æ®µã§ã‚ã£ã¦ã‚‚æ­“è¿ã™ã‚‹ã€‚","code":""},{"path":"https://future.futureverse.org/README_ja.html","id":"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«","dir":"","previous_headings":"","what":"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"future ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ CRAN ã§åˆ©ç”¨å¯èƒ½ã§ã‚ã‚Šã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ãã‚‹ã€‚","code":"install.packages(\"future\")"},{"path":"https://future.futureverse.org/README_ja.html","id":"ãƒ—ãƒ¬ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«","dir":"","previous_headings":"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«","what":"ãƒ—ãƒ¬ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ãƒ—ãƒ¬ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ GitHub ã® develop ãƒ–ãƒ©ãƒ³ãƒã«ã‚ã‚Šã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã«ã¯æ¬¡ã®ã‚ˆã†ã«ã™ã‚‹ã€‚ ã“ã‚Œã¯ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨ãªã‚‹ã€‚","code":"remotes::install_github(\"futureverse/future\", ref=\"develop\")"},{"path":"https://future.futureverse.org/README_ja.html","id":"è²¢çŒ®","dir":"","previous_headings":"","what":"è²¢çŒ®","title":"future: Rã«ãŠã‘ã‚‹çµ±ä¸€çš„ãªä¸¦åˆ—åˆ†æ•£å‡¦ç† ","text":"ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«è²¢çŒ®ã™ã‚‹ã«ã¯ã€CONTRIBUTING.md ã‚’å‚ç…§ã—ã¦ã»ã—ã„ã€‚","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A Future for R: A Comprehensive Overview","text":"purpose future package provide simple uniform way evaluating R expressions asynchronously using various resources available user. programming, future abstraction value may available point future. state future can either unresolved resolved. soon resolved, value available instantaneously. value queried future still unresolved, current process blocked future resolved. possible check whether future resolved without blocking. Exactly futures resolved depends future backend set evaluate . instance, future can resolved using sequential backend, means resolved current R session. backends may used resolving futures asynchronously, instance, parallel current machine compute cluster. example illustrating basics futures work. First, consider following code snippet uses plain R code: works assigning value expression variable v print value v. Moreover, expression v evaluated also print message. code snippet modified use futures instead: difference v constructed; plain R use <- whereas futures use %<-%. difference output relayed future resolved () value queried (see Vignette â€˜Outputting Textâ€™). futures useful? can choose evaluate future expression separate R process asynchronously simply switching settings : asynchronous futures, current/main R process block, means available processing futures resolved separate processes running background. words, futures provide simple yet powerful construct parallel / distributed processing R. Now, bothered read nitty-gritty details futures, just want try , skip end play Mandelbrot demo using parallel non-parallel evaluation.","code":"> v <- { +   cat(\"Hello world!\\n\") +   3.14 + } Hello world! > v [1] 3.14 > library(future) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14 > library(future) > plan(multisession) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"implicit-or-explicit-futures","dir":"Articles","previous_headings":"","what":"Implicit or Explicit Futures","title":"A Future for R: A Comprehensive Overview","text":"Futures can created either implicitly explicitly. introductory example used implicit futures created via v %<-% { expr } construct. alternative explicit futures using f <- future({ expr }) v <- value(f) constructs. , example alternatively written : Either style future construct works equally(*) well. implicit style similar regular R code written. principle, replace <- %<-% turn assignment future assignment. hand, simplicity can also deceiving, particularly asynchronous futures used. contrast, explicit style makes much clearer futures used, lowers risk mistakes better communicates design others reading code. (*) cases %<-% used without (small) modifications. return Section â€˜Constraints using Implicit Futuresâ€™ near end document. summarize, explicit futures, use: f <- future({ expr }) - creates future v <- value(f) - gets value future (blocks yet resolved) implicit futures, use: v %<-% { expr } - creates future promise value keep simple, use implicit style rest document, everything discussed also apply explicit futures.","code":"> library(future) > f <- future({ +   cat(\"Hello world!\\n\") +   3.14 + }) > v <- value(f) Hello world! > v [1] 3.14"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"controlling-how-futures-are-resolved","dir":"Articles","previous_headings":"","what":"Controlling How Futures are Resolved","title":"A Future for R: A Comprehensive Overview","text":"future package comes built-future backends leverage parallel package part R . addition backends, others exist package extensions, e.g.Â future.callr, future.mirai, future.batchtools. overview common backends end-user can chose . ğŸ“¶: futures relay progress updates real-time, e.g.Â progressr â™»ï¸: futures interruptible restartable; * disabled default (next): next release; (soon): near-future release default, future expressions evaluated synchronously current R session via â€œsequentialâ€ backend. section, go backend discuss common differ.","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"consistent-behavior-across-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Consistent Behavior Across Futures","title":"A Future for R: A Comprehensive Overview","text":"going different future backends, probably helpful clarify objectives Future API (defined future package). programming futures, matter future backend used executing code. really know computational resources user access , choice parallel backend hands user developer. words, code make assumptions futures resolved. One designs Future API encapsulate differences types futures appear work . despite expressions may evaluated locally current R session across world remote R sessions. Another obvious advantage consistent API behavior among different types futures helps prototyping. Typically one use sequential evaluation building script , later, script fully developed, one may turn asynchronous processing. , defaults different backends results side effects evaluating future expression similar possible. specifically, following true futures: evaluation done local environment (.e.Â local({ expr })) assignments affect calling environment. natural evaluating external R process, also enforced evaluating current R session. future constructed, global variables identified. asynchronous evaluation, globals exported R process/session evaluating future expression. sequential futures lazy evaluation (lazy = TRUE), globals â€œfrozenâ€ (cloned local environment future). Also, order protect exporting large objects mistake, built-assertion total size globals less given threshold (controllable via option, cf.Â help(\"future.options\")). threshold exceeded, informative error thrown. Future expressions evaluated . soon value (error) collected available succeeding requests. example illustrating assignments done local environment: Now ready explore different future backends.","code":"> plan(sequential) > a <- 1 > x %<-% { +     a <- 2 +     2 * a + } > x [1] 4 > a [1] 1"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"synchronous-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Synchronous Futures","title":"A Future for R: A Comprehensive Overview","text":"Synchronous futures resolved one another commonly R process creates . synchronous future resolved blocks main process resolved.","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"sequential-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Synchronous Futures","what":"Sequential Futures","title":"A Future for R: A Comprehensive Overview","text":"Sequential futures default unless otherwise specified. designed behave similar possible regular R evaluation still fulfilling Future API behaviors. example illustrating properties: Since eager sequential evaluation taking place, three futures resolved instantaneously moment created. Note also pid calling environment, assigned process ID current process, neither overwritten removed. futures evaluated local environment. Since synchronous (uni-)processing used, future b resolved main R process (still local environment), value b pid .","code":"> plan(sequential) > pid <- Sys.getpid() > pid [1] 1287562 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1287562 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1287562"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"asynchronous-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Asynchronous Futures","title":"A Future for R: A Comprehensive Overview","text":"Next, turn asynchronous futures, futures resolved background. design, futures non-blocking, , created calling process available tasks including creating additional futures. calling process tries access value future yet resolved, trying create another asynchronous future available R processes busy serving futures, blocks.","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"multisession-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multisession Futures","title":"A Future for R: A Comprehensive Overview","text":"start multisession futures supported operating systems. multisession future evaluated background R session running machine calling R process. example multisession evaluation: first thing observe values , c pid previously. However, notice b different . future b evaluated different R process therefore returns different process ID. multisession evaluation used, package launches set R sessions background serve multisession futures evaluating expressions created. background sessions busy serving futures, creation next multisession future blocked background session becomes available . total number background processes launched decided value availableCores(), e.g. particular result tells us mc.cores option set allowed use total two (2) processes including main process. words, settings, two (2) background processes serving multisession futures. availableCores() also agile different options system environment variables. instance, compute cluster schedulers used (e.g.Â TORQUE/PBS Slurm), set specific environment variable specifying number cores allotted given job; availableCores() acknowledges well. nothing else specified, available cores machine utilized, cf.Â parallel::detectCores(). details, please see help(\"availableCores\", package = \"parallelly\").","code":"> plan(multisession, workers = 2) > pid <- Sys.getpid() > pid [1] 1287562 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1287626 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1287562 > availableCores() mc.cores         2"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"multicore-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multicore Futures","title":"A Future for R: A Comprehensive Overview","text":"operating systems R supports forking processes, basically operating system except Windows, alternative spawning R sessions background fork existing R process. use multicore futures, supported, specify: Just like multisession futures, maximum number parallel processes running decided availableCores(), since cases evaluation done local machine. Forking R process can faster working separate R session running background. One reason overhead exporting large globals background session can greater forking, therefore shared memory, used. hand, shared memory read , meaning modifications shared objects one forked processes (â€œworkersâ€) cause copy operating system. can also happen R garbage collector runs one forked processes. hand, process forking also considered unstable R environments. instance, running R within RStudio process forking may resulting crashed R sessions. , future package disables multicore futures default running RStudio. See help(\"supportsMulticore\") details.","code":"plan(multicore)"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"cluster-futures","dir":"Articles","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Cluster Futures","title":"A Future for R: A Comprehensive Overview","text":"Cluster futures evaluate expressions ad-hoc cluster (implemented parallel package). instance, assume access three nodes n1, n2 n3, can use asynchronous evaluation : types clusters parallel::makeCluster() creates can used cluster futures. instance, cluster can explicitly set : Also, considered good style shut cluster cl longer needed, , calling parallel::stopCluster(cl). However, shut main process terminated. information set manage clusters, see help(\"makeCluster\", package = \"parallel\"). Clusters created implicitly using plan(cluster, workers = hosts) hosts character vector also shut main R session terminates, future backend changed, e.g.Â calling plan(sequential). Note automatic authentication setup (e.g.Â SSH key pairs), nothing preventing us using approach using cluster remote machines. want run multiple workers node, replicate node name many times number workers run node. example, run three workers n1, one n2, five n3, total nine parallel workers.","code":"> plan(cluster, workers = c(\"n1\", \"n2\", \"n3\")) > pid <- Sys.getpid() > pid [1] 1287562 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1287729 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1287562 cl <- parallel::makeCluster(c(\"n1\", \"n2\", \"n3\")) plan(cluster, workers = cl) > plan(cluster, workers = c(rep(\"n1\", times = 3), \"n2\", rep(\"n3\", times = 5)))"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"nested-futures-and-evaluation-topologies","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Nested Futures and Evaluation Topologies","title":"A Future for R: A Comprehensive Overview","text":"far discussed can referred â€œflat topologyâ€ futures, , futures created assigned environment. However, nothing stopping us using â€œnested topologyâ€ futures, one set futures may, turn, create another set futures internally . instance, example two â€œtopâ€ futures (b) uses multisession evaluation second future (b) turn uses two internal futures: inspection process IDs, see total three different processes involved resolving futures. main R process (pid 1287562), two processes used (pid 1287860) b (pid 1287859). However, two futures (b1 b2) nested b evaluated R process b. nested futures use sequential evaluation unless otherwise specified. reasons , main reason protects us spawning large number background processes mistake, e.g.Â via recursive calls. specify different type evaluation topology, first level futures resolved multisession evaluation second level sequential evaluation, can provide sequence nested backend specifying list plan(). clarify, first, sequence backends used can explicitly specified : actually get behavior try multiple levels multisession evaluations; second multisession backend default single, sequential processing. reason , also , protect us launching processes machine can support. case multisession multicore evaluation. Continuing, start sequential backend use multisession backend nested futures, get: clearly show b resolved calling process (pid 1287562) whereas two nested futures (b1 b2) resolved two separate R processes (pids 1288080 1288081). said , indeed possible use nested multisession backend forced sequential processing explicitly specifying (read forcing) number workers available level. order need â€œtweakâ€ default settings, can done follows: First, see b resolved different processes (pids 1288184 1288185) calling process (pid 1287562). Second, two nested futures (b1 b2) resolved yet two R processes (pids 1288314 1288315). details working nested futures different future backends level, see Vignette â€˜Future R: Future Topologiesâ€™.","code":"> plan(multisession, workers = 2) > pid <- Sys.getpid() > a %<-% { +     cat(\"Future 'a' ...\\n\") +     Sys.getpid() + } > b %<-% { +     cat(\"Future 'b' ...\\n\") +     b1 %<-% { +         cat(\"Future 'b1' ...\\n\") +         Sys.getpid() +     } +     b2 %<-% { +         cat(\"Future 'b2' ...\\n\") +         Sys.getpid() +     } +     c(b.pid = Sys.getpid(), b1.pid = b1, b2.pid = b2) + } > pid [1] 1287562 > a Future 'a' ... [1] 1287860 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1287859 1287859 1287859 plan(list(multisession, sequential)) > plan(list(multisession, multisession)) [...] > pid [1] 1287562 > a Future 'a' ... [1] 1287962 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1287963 1287963 1287963 > plan(list(sequential, multisession)) [...] > pid [1] 1287562 > a Future 'a' ... [1] 1287562 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1287562 1288080 1288081 > plan(list(tweak(multisession, workers = 2), tweak(multisession,  +     workers = 2))) [...] > pid [1] 1287562 > a Future 'a' ... [1] 1288184 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1288185 1288314 1288315"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"checking-a-future-without-blocking","dir":"Articles","previous_headings":"Controlling How Futures are Resolved","what":"Checking A Future without Blocking","title":"A Future for R: A Comprehensive Overview","text":"possible check whether future resolved without blocking. can done using resolved(f) function, takes explicit future f input. work implicit futures (examples ), can use f <- futureOf() function retrieve explicit future implicit one. example,","code":"> plan(multisession, workers = 2) > a %<-% { +     cat(\"Future 'a' ...\") +     Sys.sleep(2) +     cat(\"done\\n\") +     Sys.getpid() + } > cat(\"Waiting for 'a' to be resolved ...\\n\") Waiting for 'a' to be resolved ... > f <- futureOf(a) > count <- 1 > while (!resolved(f)) { +     cat(count, \"\\n\") +     Sys.sleep(0.2) +     count <- count + 1 + } 1  2  3  4  5  6  7  8  9  10  11  > cat(\"Waiting for 'a' to be resolved ... DONE\\n\") Waiting for 'a' to be resolved ... DONE > a Future 'a' ...done [1] 1288421"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"failed-futures","dir":"Articles","previous_headings":"","what":"Failed Futures","title":"A Future for R: A Comprehensive Overview","text":"Sometimes future expected. error occurs evaluating future, error propagated thrown error calling environment future value requested. example, use lazy evaluation future generates error, might see something like error thrown time value requested, , try get value generate error (output): see last call call stack gave error, can use backtrace() function(*) future, .e. (*) commonly used traceback() provide relevant information context futures. Furthermore, unfortunately possible see list calls (evaluated expressions) led error; call gave error (due limitation tryCatch() used internally).","code":"> plan(sequential) > b <- \"hello\" > a %<-% { +     cat(\"Future 'a' ...\\n\") +     log(b) + } %lazy% TRUE > cat(\"Everything is still ok although we have created a future that will fail.\\n\") Everything is still ok although we have created a future that will fail. > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function In addition: Warning message: restarting interrupted promise evaluation > backtrace(a) [[1]] log(a)"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"globals","dir":"Articles","previous_headings":"","what":"Globals","title":"A Future for R: A Comprehensive Overview","text":"Whenever R expression evaluated asynchronously (parallel) sequentially via lazy evaluation, global (aka â€œfreeâ€) objects identified passed evaluator. need passed exactly time future created, , lazy evaluation, globals may otherwise change created resolved. asynchronous processing, reason globals need identified can exported process evaluates future. future package tries automate tasks far possible. help globals package, uses static-code inspection identify global variables. global variable identified, captured made available evaluating process. Moreover, global defined package, global exported. Instead, made sure corresponding package attached future evaluated. better reflects setup main R session, also minimizes need exporting globals, saves memory also time bandwidth, especially using remote compute nodes. Finally, clarified identifying globals static code inspection alone challenging problem. always corner cases automatic identification globals fails either false globals identified (less concern) true globals missing (result run-time error possibly wrong results). Vignette â€˜Future R: Common Issues Solutionsâ€™ provides examples common cases explains avoid well help package identify globals ignore falsely identified globals. suffice, always possible manually specify global variables names (e.g.Â globals = c(\"\", \"slow_sum\")) name-value pairs (e.g.Â globals = list(= 42, slow_sum = my_sum)).","code":""},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"constraints-when-using-implicit-futures","dir":"Articles","previous_headings":"","what":"Constraints when using Implicit Futures","title":"A Future for R: A Comprehensive Overview","text":"one limitation implicit futures exist explicit ones. explicit future just like object R can assigned anywhere/anything. instance, can create several loop assign list, e.g. possible using implicit futures. %<-% assignment operator used cases regular <- assignment operator can used. can used assign future values environments (including calling environment) much like assign(name, value, envir) works. However, can assign implicit futures environments using named indices, e.g. .list(v) blocks futures environment v resolved. values collected returned regular list. numeric indices required, list environments can used. List environments, implemented listenv package, regular environments customized subsetting operators making possible index much like lists can indexed. using list environments otherwise use lists, can also assign implicit futures list-like objects using numeric indices. example, previously, .list(v) blocks futures resolved.","code":"> plan(multisession, workers = 2) > f <- list() > for (ii in 1:3) { +     f[[ii]] <- future({ +         Sys.getpid() +     }) + } > v <- lapply(f, FUN = value) > str(v) List of 3  $ : int 1288542  $ : int 1288543  $ : int 1288543 > plan(multisession, workers = 2) > v <- new.env() > for (name in c(\"a\", \"b\", \"c\")) { +     v[[name]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ a: int 1288542  $ b: int 1288543  $ c: int 1288542 > library(listenv) > plan(multisession, workers = 2) > v <- listenv() > for (ii in 1:3) { +     v[[ii]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ : int 1288542  $ : int 1288543  $ : int 1288542"},{"path":"https://future.futureverse.org/articles/future-1-overview.html","id":"demos","dir":"Articles","previous_headings":"","what":"Demos","title":"A Future for R: A Comprehensive Overview","text":"see live illustration different types futures evaluated, run Mandelbrot demo package. First, try sequential evaluation, resembles script run futures used. , try multisession evaluation, calculates different Mandelbrot planes using parallel R processes running background. Try, Finally, access multiple machines can try set cluster workers use , e.g.","code":"library(future) plan(sequential) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(multisession) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(cluster, workers = c(\"n2\", \"n5\", \"n6\", \"n6\", \"n9\")) demo(\"mandelbrot\", package = \"future\", ask = FALSE)"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"future-frontends","dir":"Articles","previous_headings":"","what":"Future frontends","title":"A Future for R: Text and Message Output","text":"relaying output handled core future framework, automatically works using packages future.apply, furrr, foreach doFuture. examples â€œjust worksâ€:","code":"> library(future.apply) > plan(future.callr::callr)  > y <- future_lapply(1:3, FUN = function(x) {     cat(\"x =\", x, \"\\n\")     message(\"x : \", x)     sqrt(x)   }) x = 1  x = 2  x = 3  x : 1  ## <= 1st message x : 2  ## <= 2nd message x : 3  ## <= 3rd message  > str(y) List of 3  $ : num 1  $ : num 1.41  $ : num 1.73 > library(furrr) > plan(future.callr::callr)  > y <- future_map(1:3, function(x) {     cat(\"x =\", x, \"\\n\")     message(\"x : \", x)     sqrt(x)   }) x = 1  x = 2  x = 3  x : 1  ## <= 1st message x : 2  ## <= 2nd message x : 3  ## <= 3rd message  > str(y) List of 3  $ : num 1  $ : num 1.41  $ : num 1.73 > library(doFuture) > plan(future.callr::callr)  > y <- foreach(x = 1:3) %dofuture% {     cat(\"x =\", x, \"\\n\")     message(\"x : \", x)     sqrt(x)   } x = 1  x = 2  x = 3 x : 1  ## <= 1st message x : 2  ## <= 2nd message x : 3  ## <= 3rd message  > str(y) List of 3  $ : num 1  $ : num 1.41  $ : num 1.73"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"capturing-output","dir":"Articles","previous_headings":"","what":"Capturing output","title":"A Future for R: Text and Message Output","text":"capture output produced futures, use capture.output() capturing output elsewhere R. example,","code":"> library(future) > fa <- future({ cat(\"Hello world!\\n\"); print(1:3); 42L }) > stdout <- capture.output(a <- value(fa)) > stdout [1] \"Hello world!\" \"[1] 1 2 3\" > a [1] 42"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"suppressing-messages","dir":"Articles","previous_headings":"","what":"Suppressing messages","title":"A Future for R: Text and Message Output","text":"","code":"> library(future) > plan(multisession) > fa <- future({ message(\"Hello\"); print(1:3); message(\"world!\"); cat(\"ping\\n\"); 42L }) > suppressMessages(a <- value(fa)) [1] 1 2 3 ping > a [1] 42"},{"path":"https://future.futureverse.org/articles/future-2-output.html","id":"known-limitations","dir":"Articles","previous_headings":"","what":"Known limitations","title":"A Future for R: Text and Message Output","text":"standard output relayed. possible relay output send standard error (stderr), e.g.Â output sent cat(..., file = stderr()) lost. due limitation R, preventing us capturing stderr reliable way, particularly across backends. However, note captured messages message() outputted stderr (expected) resignaled/relayed.","code":""},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"example-high-throughput-sequencing","dir":"Articles","previous_headings":"","what":"Example: High-Throughput Sequencing","title":"A Future for R: Future Topologies","text":"Consider high-throughput sequencing (HT-Seq) project 50 human DNA samples one FASTQ file per sample containing raw sequence reads come sequencing machine. data, wish align FASTQ reference genome generate 24 individual BAM files per sample - one per chromosome. layout analysis look like R using futures. default use synchronous futures, without specifications, process sample chromosome sequentially. Next, consider can done following two computer setups: single machine 8 cores compute cluster 3 machines 16 cores","code":"library(future) library(listenv) htseq_align <- function(fq, chr) { chr }  fqs <- dir(pattern = \"[.]fastq$\")  bams <- listenv() for (ss in seq_along(fqs)) {   fq <- fqs[ss]   bams[[ss]] %<-% {     bams_ss <- listenv()     for (cc in 1:24) {       bams_ss[[cc]] %<-% htseq_align(fq, chr = cc)     }     as.list(bams_ss)   } } bams <- as.list(bams)"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"one-multi-core-machine","dir":"Articles","previous_headings":"Example: High-Throughput Sequencing","what":"One multi-core machine","title":"A Future for R: Future Topologies","text":"single machine 8 cores, choose process multiple samples time processing chromosomes sequentially. words, like evaluate outer layer futures using multisession futures inner ones sequential futures. can specified : internals processing multisession future queries availableCores() infer many cores can used simultaneously, need explicitly specify 8 cores available. Comment: Since synchronous default future, skip trailing sequential futures setup, e.g.Â plan(list(multisession)) just plan(multisession). However, hurt explicit. instead like process sample sequentially chromosomes parallel, can use:","code":"plan(list(multisession, sequential)) plan(list(sequential, multisession))"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"built-in-protection-against-recursive-parallelism","dir":"Articles","previous_headings":"Example: High-Throughput Sequencing > One multi-core machine","what":"Built-in protection against recursive parallelism","title":"A Future for R: Future Topologies","text":"processed either outer inner set future parallel. want process layers parallel? â€™s tempting use: Although give error, find inner layer futures processed sequentially just use plan(list(multisession, sequential)). behavior due built-protection nested parallelism. layers run parallel, using 8 cores available machine, running 8 * 8 = 64 parallel processes - sure overload computer. happens internally outer layer, availableCores() equals eight (8), whereas inner layer equals one (1). Now, imagine process outer layer , say, two parallel futures, inner layer four parallel futures. case, end running eight cores (= 2 * 4). can achieved forcing fixed number workers layer: Note -(.) specification inner layer, .e.Â workers = (4). just specify workers = 4, future framework detect potential user mistake. default prevents nested parallelization allots single CPU core inner layer, .e.Â availableCores() return one . However, user requests four CPU cores, result unintended 400% CPU overuse. future framework detects discrepancy, large, produce error. example, eight core machine, get following error produced inner layer: Futureverse built-protection, need explicitly override declaring nested workers using -(.) function. basically tells parallel framework â€œtrust us, know â€. minimize risk mistakes , please make sure settings respect availableCores() gives. make sure stay within limits current machine, â€™s best use something like: However, using nested parallelization single machine, make sure actually efficient using parallelization one layers.","code":"plan(list(multisession, multisession)) plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = I(4)))) > plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) > a %<-% { b %<-% 1 ; b } > a Error in checkNumberOfLocalWorkers(workers) :    Attempting to set up 4 localhost parallel workers with only 1 CPU cores available for this R process (per 'mc.cores'), which could result in a 400% load. The hard limit is set to 300%. Overusing the CPUs has negative impact on the current R process, but also on all other processes of yours and others running on the same machine. See help(\"parallelly.maxWorkers.localhost\", package = \"parallelly\") for further explanations and how to override the hard limit that triggered this error plan(list(   tweak(multisession, workers = availableCores() %/% 4),   tweak(multisession, workers = I(4)) ))"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"an-ad-hoc-compute-cluster","dir":"Articles","previous_headings":"Example: High-Throughput Sequencing","what":"An ad-hoc compute cluster","title":"A Future for R: Future Topologies","text":"compute cluster 3 machines 16 cores, can run 48 alignment processes parallel. natural setup one machine process one sample parallel. specify : Comment: Multisession futures agile environment, , query machine running find many parallel processes can run time. One possible downside setup might utilize available cores time. alignment shorter chromosomes finish sooner longer ones, means might end sample alignment processes running machine leaving remaining cores idle/unused. alternative set use following setup: cause 24 (= 3*8) samples processed parallel processing two chromosomes time.","code":"nodes <- c(\"n1\", \"n2\", \"n3\") plan(list(tweak(cluster, workers = nodes), multisession)) nodes <- rep(c(\"n1\", \"n2\", \"n3\"), each = 8) plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = I(2)) ))"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"example-a-remote-compute-cluster","dir":"Articles","previous_headings":"","what":"Example: A Remote Compute Cluster","title":"A Future for R: Future Topologies","text":"Imagine access remote compute cluster, login node remote.server.org, cluster three nodes n1, n2, n3. Also, let us assume already set cluster can log via public key authentication via SSH, .e.Â ssh remote.server.org authentication done automatically. setup, can use nested futures local R session evaluate R expression remote compute cluster three nodes. proof concept illustrating different nested futures evaluated different machines. Try x %<-% { ... } future , say, plan(list(sequential, multisession)) see output .","code":"library(future) library(listenv)  ## Set up access to remote login node (must have Rscript) login <- tweak(cluster, workers = \"remote.server.org\", persistent = TRUE) plan(login)  ## Set up cluster nodes on login node nodes %<-% { .keepme <- parallelly::makeClusterPSOCK(c(\"n1\", \"n2\", \"n3\")) } print(nodes) ## socket cluster with 3 nodes on hosts 'n1', 'n2', 'n3'  ## Specify future topology ## login node -> { cluster nodes } -> { multiple cores } plan(list(   login,   tweak(cluster, workers = nodes),   multisession ))   ## (a) This will be evaluated on the cluster login computer x %<-% {   thost <- Sys.info()[[\"nodename\"]]   tpid <- Sys.getpid()   y <- listenv()   for (task in 1:4) {     ## (b) This will be evaluated on a compute node on the cluster     y[[task]] %<-% {       mhost <- Sys.info()[[\"nodename\"]]       mpid <- Sys.getpid()       z <- listenv()       for (jj in 1:2) {         ## (c) These will be evaluated in separate processes on the same compute node         z[[jj]] %<-% data.frame(task = task,                                 top.host = thost, top.pid = tpid,                                 mid.host = mhost, mid.pid = mpid,                                 host = Sys.info()[[\"nodename\"]],                                 pid = Sys.getpid())       }       Reduce(rbind, z)     }   }   Reduce(rbind, y) }  print(x) ##   task top.host top.pid mid.host mid.pid host    pid ## 1    1    login  391547       n1  391878   n1 393943 ## 2    1    login  391547       n1  391878   n1 393951 ## 3    2    login  391547       n2  392204   n2 393971 ## 4    2    login  391547       n2  392204   n2 393978 ## 5    3    login  391547       n3  392527   n3 394040 ## 6    3    login  391547       n3  392527   n3 394048 ## 7    4    login  391547       n1  391878   n1 393959 ## 8    4    login  391547       n1  391878   n1 393966"},{"path":"https://future.futureverse.org/articles/future-3-topologies.html","id":"example-adjust-the-number-of-workers-for-each-cluster-node","dir":"Articles","previous_headings":"","what":"Example: Adjust the Number of Workers for Each Cluster Node","title":"A Future for R: Future Topologies","text":"using number workers used nodes (n1, n2, n3) given value availableCores() nodes. turn, availableCores() typically defaults number cores nodes. Now, imagine want use 50% cores. can done tweaking multisession plan passing function workers; , node use 50% cores available. instance, n1 n2 eight cores, n3 32 cores, nodes use four, four, 16 cores, respectively. Another example : case, node n1 always use two cores, n2 three cores, n3 respect availableCores() returns.","code":"nodes <- c(\"n1\", \"n2\", \"n3\") plan(list(tweak(cluster, workers = nodes), multisession)) halfCores <- function() { max(1, round(0.5 * availableCores())) plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = I(halfCores)) )) customWorkers <- function() {   switch(Sys.info()[[\"nodename\"]],     \"n1\" = 2L,     \"n2\" = 3L,     ## default:     availableCores()   ) } plan(list(   tweak(cluster, workers = nodes),   tweak(multisession, workers = I(customWorkers)) ))"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"missing-globals-false-negatives","dir":"Articles","previous_headings":"Issues with globals and packages","what":"Missing globals (false negatives)","title":"A Future for R: Common Issues with Solutions","text":"global variable used future expression conditionally overrides global variable local one, future framework fails identify global variable therefore fails export , resulting run-time error. example, although works: following work: recommended avoid constructs ambiguous whether variable global local. force variable x always global, insert beginning future expression, e.g. Comment: goal future version package detect globals also expression local-global state variable known run time.","code":"plan(multisession)  reset <- TRUE x <- 1 y %<-% { if (reset) x <- 0; x + 1 } y ## [1] 1 reset <- FALSE x <- 1 y %<-% { if (reset) x <- 0; x + 1 } y ## Error: object 'x' not found reset <- FALSE x <- 1 y %<-% { x; if (reset) x <- 0; x + 1 } y ## [1] 2"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"do-call---function-not-found","dir":"Articles","previous_headings":"Issues with globals and packages > Missing globals (false negatives)","what":"do.call() - function not found","title":"A Future for R: Common Issues with Solutions","text":"calling function using .call() make sure specify function object name. help identify function global object future expression. instance, use instead file_ext() properly located exported. Although may notice difference evaluating futures R session, may become problem use character string instead function object futures evaluated external R sessions, cluster. may also become problem futures evaluated lazy evaluation intended function redefined future resolved. example,","code":"do.call(file_ext, list(\"foo.txt\")) do.call(\"file_ext\", list(\"foo.txt\")) > library(future) > library(listenv) > library(tools) > plan(sequential) > pathnames <- c(\"foo.txt\", \"bar.png\", \"yoo.md\") > res <- listenv() > for (ii in seq_along(pathnames)) { +   res[[ii]] %<-% do.call(\"file_ext\", list(pathnames[ii])) %lazy% TRUE + } > file_ext <- function(...) \"haha!\" > unlist(res) [1] \"haha!\" \"haha!\" \"haha!\""},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"get---object-not-found","dir":"Articles","previous_headings":"Issues with globals and packages > Missing globals (false negatives)","what":"get() - object not found","title":"A Future for R: Common Issues with Solutions","text":"base R function get() can used get value object name. example, get(\"pi\", envir = baseenv()) get value object pi â€˜baseâ€™ environment, .e.Â corresponds base::pi. objects named pi exists search path, used get(\"pi\") pi, respectively. unusual see code snippets : attempt call my_sum() via future, get error (future resolved external R process); static code inspection done future expression my_sum(\"\") reveal object global object. expression alone, three objects: function my_sum(), primitive function (, string \"\", none object . future framework also scan three objects globals, example means scans also my_sum(). recursive search globals identify three additional globals, namely, primitive function {, function sum(), function get(), , , none sources identify global object. order identified, future framework need built-understanding get(var) works, daunting task, especially needs know acts different data types var various choices arguments envir enclos. fact, can often inferred run time, , possible identify objects needed without actually running code. short, possible automatically identify global variables specified via character string. workaround tell future framework additional globals needed. can done via argument globals using: injecting variable beginning future expression, e.g. Note , independently future framework, often bad idea use get(), related functions mget() assign(), R code. Searching archives R forums, R-help R-devel mailing lists, reveal numerous suggestions using . good rule thumb : find using get() code, take step back, reconsider implementation. likely better solution available. example, consider , slightly complex, example: Instead using â€œfree roamingâ€ objects , b, c, â€™s better put values list (data frame length); turn allow us perform calculations without use get();","code":"> a <- 1:3 > b <- 4:6 > c <- 3:5 > my_sum <- function(var) { sum(get(var)) } > y <- my_sum(\"a\") > y [1] 6 > library(future) > plan(multisession) > f <- future(my_sum(\"a\")) > y <- value(f) Error in get(var) : object 'a' not found > f <- future(my_sum(\"a\"), globals = structure(TRUE, add = \"a\")) > y <- value(f) > y [1] 6 > f <- future({ a; my_sum(\"a\") }) > y <- value(f) > y [1] 6 > a <- 1:3 > b <- 4:7 > c <- 3:5 > my_sum <- function(var) { sum(get(var)) } > y <- sapply(c(\"a\", \"b\", \"c\"), FUN = my_sum) > y  a  b  c  6 22 12 > data <- list(a = 1:3, b = 4:7, c = 3:5) > my_sum <- function(x) { sum(x) } > y <- sapply(data, FUN = my_sum) > y  a  b  c  6 22 12"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"glueglue---object-not-found","dir":"Articles","previous_headings":"Issues with globals and packages > Missing globals (false negatives)","what":"glue::glue() - object not found","title":"A Future for R: Common Issues with Solutions","text":"future framework fail identify globals declared via character strings. section gives example get() used explains feasible automatically identify string-embedded globals code. Another example, using glue() glue package generate strings dynamically, e.g. Attempt perform via future resolved another R session produce â€œobject foundâ€ error; explained previous section, workaround specify additional global variables , can done : alternative solution guide future framework adding missing globals â€œdummyâ€ variables, e.g.","code":"> library(glue) > a <- 42 > s <- glue(\"The value of a is {a}.\") > s The value of a is 42. > library(glue) > library(future) > plan(multisession) > a <- 42 > s %<-% glue(\"The value of a is {a}.\") > s Error in eval(parse(text = text, keep.source = FALSE), envir) :    object 'a' not found > s %<-% glue(\"The value of a is {a}.\") %globals% structure(TRUE, add = \"a\") > s The value of a is 42. > s %<-% { a; glue(\"The value of a is {a}.\") } > s The value of a is 42."},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"missing-packages-false-negatives","dir":"Articles","previous_headings":"Issues with globals and packages","what":"Missing packages (false negatives)","title":"A Future for R: Common Issues with Solutions","text":"Occasionally, static-code inspection future expression fails identify packages needed evaluated expression. may occur expression uses S3 generic functions part one package whereas required S3 method another package. example, future generic function [ used data.table object DT, requires S3 method [.data.table data.table package. However, future globals packages fail identify data.table required package, results evaluation error: error occurs , contrary master R process, R worker evaluated future expression data.table loaded. Instead evaluation falls back [.data.frame method, want. future framework manages identify data.table required package (goal), can guide future package specifying additional packages needed: equivalently Note, use library() loadNamespace() resolve problems. always better use packages approach.","code":"> library(future) > plan(multisession)  > library(data.table) > DT <- data.table(a = LETTERS[1:3], b = 1:3) > y %<-% DT[, sum(b)] > y Error: object 'b' not found > y %<-% DT[, sum(b)] %packages% \"data.table\" > y [1] 6 > f <- future(DT[, sum(b)], packages = \"data.table\") > value(f) [1] 6"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"used-in-an-incorrect-context","dir":"Articles","previous_headings":"","what":"â€˜â€¦â€™ used in an incorrect context","title":"A Future for R: Common Issues with Solutions","text":"R, ... construct used refer zero arguments. example, can use : makes sure trim na.rm arguments passed mean() function. can also use pass arguments map-reduce calls anonymous functions : Note digits = 3 passed anonymous function via ... argument, passed round(), effectively calling round(X[[1]], digits = 3), round(X[[2]], digits = 3), . take one step , might see things like: case, two levels ... arguments; one my_fcn() one anonymous function. Note ... arguments my_fcn() passed anonymous function specifying ... final argument lapply(). ideal proper way pass .... However, uncommon see ... used global variable anonymous functions. example, might find: also work, ... becomes global variable environment anonymous function. Although know relying global variables bad idea, one often slips . attempt future framework, parallel frameworks, might work. example, using: might result error : Even get error, always good idea make sure ... passed argument way used, e.g.","code":"my_mean <- function(x, ...) mean(x, ...)  y <- my_mean(1:10, trim = 0.1, na.rm = FALSE) X <- rnorm(10) y <- lapply(X, FUN = function(x, ...) {   round(x, ...) }, digits = 3) my_fcn <- function(X, ...) {  ## outer '...'   y <- lapply(X, FUN = function(x, ...) { ## inner '...'     round(x, ...) ## inner '...'   }, ...) ## outer '...'   y }  X <- rnorm(10) y <- my_fcn(X, digits = 3) my_fcn <- function(X, ...) {  ## outer '...'   y <- lapply(X, FUN = function(x) {     round(x, ...) ## outer '...' as global variables   })   y } my_fcn <- function(X, ...) {   y <- future_lapply(X, FUN = function(x) {     round(x, ...)   })   y } Error: '...' used in an incorrect context my_fcn <- function(X, ...) {   y <- future.apply::future_lapply(X, FUN = function(x, ...) {     round(x, ...)   }, ...)   y }"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"non-exportable-objects","dir":"Articles","previous_headings":"","what":"Non-exportable objects","title":"A Future for R: Common Issues with Solutions","text":"Certain types objects tied given R session passed along another R process (â€œworkerâ€). example non-exportable object XML objects xml2 package. attempt use parallel processing, may get error future evaluated (just invalid results depending used), e.g. future framework can help detect sending future worker; additional details non-exportable objects examples R packages use objects may cause problems parallel processing, see Vignette â€˜Non-Exportable Objectsâ€™.","code":"> library(future) > plan(multisession) > library(xml2) > xml <- read_xml(\"<body><\/body>\") > f <- future(xml_children(xml)) > value(f) Error: external pointer is not valid > options(future.globals.onReference = \"error\") > f <- future(xml_children(xml)) Error in FALSE :    Detected a non-exportable reference ('externalptr') in one of the globals ('xml' of class 'xml_document') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"trying-to-pass-an-unresolved-future-to-another-future","dir":"Articles","previous_headings":"","what":"Trying to pass an unresolved future to another future","title":"A Future for R: Common Issues with Solutions","text":"possible future resolve another one unless created future trying resolve . instance, following gives error: main R process creates two futures, second future tries retrieve value first one. invalid request second future channel communicate first future; process created future can communicate (*). Note unresolved futures queried way. Thus, solution problem make sure futures resolved passed futures, e.g. works value already collected stored inside future f1 future f2 created. Since value already stored internally, value(f1) readily available everywhere. course, instead using value(f1) second future, readable cleaner simply use v1. typically problem future assignments used. example: reason approach works box second future assignment v1 identified global variable, retrieved. point, v1 promise (â€œdelayed assignmentâ€ R), retrieved global variable value resolved v1 becomes regular variable. However, cases future assignments can passed via global variables without resolved. can happen future assignment done element environment (including list environments). instance, previously, can avoided making sure x$resolved first, can done various ways, e.g.Â dummy <- x$, resolve(x$) force(x$). Footnote: (*) Although sequential futures passed futures part R process resolved share evaluation process, definition Future API invalid regardless future type. conservative approach taken order make future expressions behave consistently regardless type future used.","code":"> library(future) > plan(multisession) > f1 <- future({ Sys.getpid() }) > f2 <- future({ value(f1) }) > v1 <- value(f1) [1] 7464 > v2 <- value(f2) Error: Invalid usage of futures: A future whose value has not yet been collected  can only be queried by the R process (cdd013cb-e045-f4a5-3977-9f064c31f188; pid  1276 on MyMachine) that created it, not by any other R processes (5579f789-e7b6  -bace-c50d-6c7a23ddb5a3; pid 2352 on MyMachine): {; Sys.getpid(); } > f1 <- future({ Sys.getpid() }) > v1 <- value(f1) > v1 [1] 7464 > f2 <- future({ value(f1) }) > v2 <- value(f2) > v2 [1] 7464 > v1 %<-% { Sys.getpid() }) > v2 %<-% { v1 } > v1 [1] 2352 > v2 [1] 2352 > library(listenv) > x <- listenv() > x$a %<-% { Sys.getpid() } > x$b %<-% { x$a } > x$a [1] 2352 > x$b Error: Invalid usage of futures: A future whose value has not yet been collected  can only be queried by the R process (cdd013cb-e045-f4a5-3977-9f064c31f188; pid  1276 on localhost) that created it, not by any other R processes (2ce86ccd-5854  -7a05-1373-e1b20022e4d8; pid 7464 on localhost): {; Sys.getpid(); }"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"capturing-errors-outputting-their-messages-and-returning-a-default-value","dir":"Articles","previous_headings":"Miscellaneous","what":"Capturing errors, outputting their messages, and returning a default value","title":"A Future for R: Common Issues with Solutions","text":"Sometimes function call produce error particular input. cases, might want return default value, say, missing value, instead signaling error. can done using: , res takes value unstable_calc(x), unless produces error, case takes value NA_real_. addition , produce warning whenever get error replace missing value. can : turn error warning message. want just output message without producing warning, can use message(conditionMessage(e)). Importantly, must use just warning(e) message(e), although appears work first glance. , end re-signaling error without interruption. important distinction reveal used within futures. example warning(conditionMessage(e)) work expected, use warning(e) future framework produce error, warning.","code":"res <- tryCatch({   unstable_calc(x) }, error = function(e) {   NA_real_ }) res <- tryCatch({   unstable_calc(x) }, error = function(e) {   warning(conditionMessage(e))   NA_real_ })"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"using-source-in-a-future","dir":"Articles","previous_headings":"Miscellaneous","what":"Using source() in a future","title":"A Future for R: Common Issues with Solutions","text":"Avoid using source() inside futures. always better source external R scripts top main R script, e.g. However, find source script inside future, inside function, make sure specify argument local = TRUE, e.g. source() defaults local = FALSE, side effects. using local = FALSE, functions variables defined R script assigned global environment - calling environment might expect. may make little difference calling source() R prompt, another script. However, called inside function, inside local(), inside future, might result unexpected behavior. similar using assign(\"\", 42, envir = globalenv()), known bad practice. safe side, almost always better call source() local = TRUE.","code":"library(future) source(\"./my-script.R\")  f <- future({   ... }) f <- future({   source(\"./my-script.R\", local = TRUE)   ... })"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"clashes-with-other-packages","dir":"Articles","previous_headings":"Miscellaneous","what":"Clashes with other packages","title":"A Future for R: Common Issues with Solutions","text":"Sometimes packages functions operators name future package, packages attached future package, objects mask ones future package. instance, igraph package also defines %<-% operator clashes one future used prompt script (problem inside package explicitly import objects known order). might get: get error %<-% igraph future assignment operator wanted. can confirmed : avoid problem, attach two packages opposite order future comes last thereby overrides igraph, .e. alternative detach future package re-attach , achieve thing: Yet another alternative explicitly override object importing global environment, e.g. case, matter order packages attached always use copy future::`%<-%`.","code":"> library(future) > library(igraph)  Attaching package: 'igraph'  The following objects are masked from 'package:future':      %<-%, %->%  The following objects are masked from 'package:stats':      decompose, spectrum  The following object is masked from 'package:base':      union  > y %<-% { 42 } Error in get(\".igraph.from\", parent.frame()) :    object '.igraph.from' not found > environment(`%<-%`) <environment: namespace:igraph> > library(igraph) > library(future)  Attaching package: 'future'  The following objects are masked from 'package:igraph':  %<-%, %->%  > y %<-% { 42 } > y [1] 42 > detach(\"package:future\") > library(future) > `%<-%` <- future::`%<-%` > y %<-% { 42 } > y [1] 42"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"syntax-error-non-numeric-argument-to-binary-operator","dir":"Articles","previous_headings":"Miscellaneous","what":"Syntax error: â€œnon-numeric argument to binary operatorâ€","title":"A Future for R: Common Issues with Solutions","text":"future assignment operator %<-% binary infix operator, means higher precedence binary operators also higher unary operators R. instance, explains get following error: effectively happening higher priority %<-%, first create future x %<-% 2 try multiply future (value) value runif(1) - makes sense. order properly assign future variable, need put future expression within curly brackets; Parentheses also . details precedence operators R, see Section â€˜Infix prefix operatorsâ€™ â€˜R Language Definitionâ€™ document.","code":"> x %<-% 2 * runif(1) Error in x %<-% 2 * runif(1) : non-numeric argument to binary operator > x %<-% { 2 * runif(1) } > x [1] 1.030209"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"error-invalid-type-environment-of-argument-with-magrittr","dir":"Articles","previous_headings":"Miscellaneous","what":"Error: invalid â€˜typeâ€™ (environment) of argument with magrittr","title":"A Future for R: Common Issues with Solutions","text":"Another example future assignment operator %<-% requires curly brackets using magrittr infix operator %>%, e.g. reason error x %<-% 1:100 passed sum() %>%. fix , use:","code":"> library(magrittr) > x %<-% 1:100 %>% sum Error in sum(.) : invalid 'type' (environment) of argument > x %<-% { 1:100 %>% sum } > x [1] 5050"},{"path":"https://future.futureverse.org/articles/future-4-issues.html","id":"r-cmd-check-notes","dir":"Articles","previous_headings":"Miscellaneous","what":"R CMD check NOTEs","title":"A Future for R: Common Issues with Solutions","text":"code inspection run R CMD check recognize future assignment operator %<-% assignment operator, surprising %<-% technically infix operator. means instance use following code package: R CMD check produce NOTE saying: order avoid , can add dummy assignment missing global top function, .e.","code":"foo <- function() {   b <- 3.14   a %<-% { b + 1 }   a } * checking R code for possible problems ... NOTE foo: no visible binding for global variable 'a' Undefined global functions or variables:   a foo <- function() {   a <- NULL ## To please R CMD check   b <- 3.14   a %<-% { b + 1 }   a }"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"a-first-example---file-connections","dir":"Articles","previous_headings":"","what":"A first example - file connections","title":"A Future for R: Non-Exportable Objects","text":"example non-exportable object connection, e.g.Â file connection. instance, create file connection, work used another R process. try, result â€œunknownâ€, e.g. words, output \"world!\" written R worker completely lost. culprit connection uses called external pointer: bound main R process makes sense worker. Ideally, R process worker detect produce informative error message, seen , always occur.","code":"con <- file(\"output.log\", open = \"wb\") cat(\"hello \", file = con) flush(con) readLines(\"output.log\", warn = FALSE) ## [1] \"hello \" library(future) plan(multisession) f <- future({ cat(\"world!\", file = con); flush(con) }) value(f) ## NULL close(con) readLines(\"output.log\", warn = FALSE) ## [1] \"hello \" str(con) ## Classes 'file', 'connection'  atomic [1:1] 3 ##   ..- attr(*, \"conn_id\")=<externalptr>"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"protect-against-non-exportable-objects","dir":"Articles","previous_headings":"","what":"Protect against non-exportable objects","title":"A Future for R: Non-Exportable Objects","text":"help avoid exporting non-exportable objects mistake, typically happens global variable non-exportable, future framework provides mechanism automatically detecting objects. enable , : Comment: future.globals.onReference option set \"ignore\" default due extra overhead \"error\" introduces, can significant large nested objects. Furthermore, subclasses external pointers can exported without causing problems.","code":"options(future.globals.onReference = \"error\") f <- future({ cat(\"world!\", file = con); flush(con) }) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('con' of class 'file') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"packages-with-non-exportable-objects","dir":"Articles","previous_headings":"","what":"Packages with non-exportable objects","title":"A Future for R: Non-Exportable Objects","text":"table sections provide examples non-exportable R objects may run trying parallelize code, simply trying reload objects saved previous R session. identify cases, please consider reporting can documented possibly even fixed. illustrated sections â€˜Packages rely external pointersâ€™ â€˜Packages types non-external objectsâ€™ . Importantly, objects external pointer can indeed exported. example, discussed sections â€˜False positives - packages exportable external pointersâ€™ end vignette.","code":""},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-parallel","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages with connections","what":"Package: parallel","title":"A Future for R: Non-Exportable Objects","text":"turn options(future.globals.onReference = \"error\"), catch already create future:","code":"library(future) plan(multisession, workers = 2)  cl <- parallel::makeCluster(2L) y <- parSapply(cl, X = 2:3, FUN = sqrt) y ## [1] 1.414214 1.732051  y %<-% parSapply(cl, X = 2:3, FUN = sqrt) y ## Error in summary.connection(connection) : invalid connection y %<-% parSapply(cl, X = 2:3, FUN = sqrt) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('cl' of class 'SOCKcluster') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"packages-that-rely-on-external-pointers","dir":"Articles","previous_headings":"Packages with non-exportable objects","what":"Packages that rely on external pointers","title":"A Future for R: Non-Exportable Objects","text":"object carries external pointer, likely can used R session created. exported used parallel process, likely cause error . shown , examples, setting option future.globals.onReference \"error\" make future scan external pointers launching future parallel worker, throw error one detected. However, objects external pointers can exported, e.g.Â data.table objects data.table package one example. words, existence external pointer just suggestion object non-exportable - sufficient condition. examples packages produce non-exportable objects external pointers.","code":""},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-arrow","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: arrow","title":"A Future for R: Non-Exportable Objects","text":"arrow package provides efficient -memory storage arrays tables. However, objects transferred -parallel worker. error takes place parallel worker. set options(future.globals.onReference = \"error\") future detect problem sends object parallel worker. said, arrow package provides low-level functions write_to_raw() read_ipc_stream() can used marshal unmarshal arrow objects. example,","code":"library(arrow)  library(future) plan(multisession)  data <- as_arrow_table(iris) f <- future(dim(data)) v <- value(f) #> Error: Invalid <Table>, external pointer to null library(arrow)  library(future) plan(multisession)  data <- as_arrow_table(iris) .data <- write_to_raw(data)      ## marshal f <- future({   data <- read_ipc_stream(.data) ## unmarshal   dim(data) }) v <- value(f) print(v) #> [1] 150   5"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-bigmemory","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: bigmemory","title":"A Future for R: Non-Exportable Objects","text":"bigmemory package provides mechanisms working large matrices can updated -place, helps save memory. example, Note x updated -place. achieved big.matrix objects hold external pointer matrix data stored; try use x parallel worker, parallel worker crashes due bug bigmemory, e.g. can protect setting: gives:","code":"library(bigmemory)  g <- function(x) {   x[1,1] <- 42L   x }  x <- big.matrix(nrow = 3, ncol = 2, type = \"integer\") print(x[1,1]) #> [1] NA  void <- g(x) print(x[1,1]) #> [1] 42 str(x) #> Formal class 'big.matrix' [package \"bigmemory\"] with 1 slot #>   ..@ address:<externalptr> library(bigmemory)  library(future) plan(multisession, workers = 2)  x <- big.matrix(nrow = 3, ncol = 2, type = \"integer\") f <- future(dim(x), packages = \"bigmemory\") value(f) #> Error in unserialize(node$con) :  #>   MultisessionFuture (<none>) failed to receive message results from #> cluster RichSOCKnode #1 (PID 1746676 on localhost 'localhost'). The #> reason reported was 'error reading from connection'. Post-mortem #> diagnostic: No process exists with this PID, i.e. the localhost worker #> is no longer alive. Detected a non-exportable reference #> ('externalptr') in one of the globals ('x' of class 'big.matrix') used #> in the future expression. The total size of the 1 globals exported is #> 696 bytes. There is one global: 'x' (696 bytes of class 'S4') options(future.globals.onReference = \"error\") f <- future(dim(x), packages = \"bigmemory\") #> Error: Detected a non-exportable reference ('externalptr') in one #> of the globals ('x' of class 'big.matrix') used in the future #> expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-cpp11","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: cpp11","title":"A Future for R: Non-Exportable Objects","text":"Another example cpp11, allows us easily create R functions implemented C++, e.g. : However, function exported another R process:","code":"cpp11::cpp_source(code = ' #include \"cpp11/doubles.hpp\" using namespace cpp11;  [[cpp11::register]] int my_length(doubles x) {     return x.size(); } ') x <- rnorm(10) my_length(x) ## [1] 10 library(future) plan(multisession) x <- rnorm(10) n %<-% my_length(x) n #> Error in .Call(\"_code_1748ff617940b9_my_length\", x, PACKAGE = \"code_1748ff617940b9\") : #>   \"_code_1748ff617940b9_my_length\" not available for .Call() for package \"code_1748ff617940b9\""},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-dbi","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: DBI","title":"A Future for R: Non-Exportable Objects","text":"DBI provides unified database interface communication R various database engines. Analogously regular connections R, DBIConnection objects can safely exported another R process, e.g.","code":"library(future) options(future.globals.onReference = \"error\") plan(multisession) library(DBI) con <- dbConnect(RSQLite::SQLite(), \":memory:\") dummy %<-% print(con) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('con' of class 'SQLiteConnection') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-inline","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: inline","title":"A Future for R: Non-Exportable Objects","text":"Another example inline, allows us easily create R functions implemented C C++, e.g. However, attempt call sum_1_to_n() future, get error: :","code":"library(inline) code <- \"   int i;   for (i = 0; i < *n; i++) x[0] = x[0] + (i+1); \" sum_1_to_n <- cfunction(signature(n=\"integer\", x=\"numeric\"), code, language = \"C\", convention = \".C\") y <- sum_1_to_n(10, 0)$x print(y) ## 55 library(future) plan(cluster, workers = 1L) f <- future(sum_1_to_n(10, 0)) v <- value(f) ## Error in .Primitive(\".C\")(<pointer: (nil)>, n = as.integer(n), x = as.double(x)) : ##   NULL value passed as symbol address options(future.globals.onReference = \"error\") f <- future(sum_1_to_n(10, 0)) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'DLLHandle') in one of the globals ('sum_1_to_n' of class 'CFunc') ## used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-keras","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: keras","title":"A Future for R: Non-Exportable Objects","text":"keras package provides R interface Keras, â€œhigh-level neural networks API developed focus enabling fast experimentationâ€. R implementation accesses Keras Python API via reticulate. However, Keras model instances R make use R connections external pointers, prevents exported external R processes. example, attempt use Keras model multisession worker, worker produce run-time error: error message helpful. , turn options(future.globals.onReference = \"error\"), get clues; Functions serialize_model() unserialize_model() keras package can used workaround marshal unmarshal non-exportable keras objects, e.g.","code":"library(keras)  library(future) plan(multisession)  ## Adopted from the 'keras' vignettes inputs <- layer_input(shape = shape(32)) outputs <- layer_dense(inputs, units = 1L) model <- keras_model(inputs, outputs) model <- compile(model, optimizer = \"adam\", loss = \"mean_squared_error\")  test_input <- array(runif(128 * 32), dim = c(128, 32)) test_target <- array(runif(128), dim = c(128, 1)) fit(model, test_input, test_target)  f <- future({   stats::predict(model, test_input) }, seed = TRUE) pred <- value(f) ## Error in do.call(object$predict, args) : ##   'what' must be a function or character string Error: Detected a non-exportable reference ('externalptr') in one of the globals ('model' of class 'keras.engine.functional.Functional') used in the future expression .model <- serialize_model(model)      ## marshal f <- future({   model <- unserialize_model(.model)  ## unmarshal   stats::predict(model, test_input) }, seed = TRUE) rm(.model) ## not needed anymore  pred <- value(f) str(pred) ## num [1:128, 1] 0.6937 -0.048 0.2996 -0.0818 1.0673 ..."},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-magick","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: magick","title":"A Future for R: Non-Exportable Objects","text":"magick package provides R-level API ImageMagick work images. working API, images represented internally external pointers class â€˜magick_imageâ€™ exported another R process, e.g. set: â€™ll see caught even attempting run parallel;","code":"library(future) plan(multisession) library(magick) frink <- magick::image_read(\"https://jeroen.github.io/images/frink.png\") f <- future(image_fill(frink, \"orange\", \"+100+200\", 20)) v <- value(f) ## Error: Image pointer is dead. You cannot save or cache image objects ## between R sessions. options(future.globals.onReference = \"error\") > f <- future(image_fill(frink, \"orange\", \"+100+200\", 20)) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'magick-image') in one of the globals ('frink' of class 'magick-image') ## used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-polars","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: polars","title":"A Future for R: Non-Exportable Objects","text":"polars package provides objects performant processing tabular data. However, objects tied R process created . attempt use parallel worker, end crashing parallel worker: external pointer RPolarsDataFrame object erased transferred another process, polars (>= 0.15.0) detects gives informative error message .","code":"library(future) plan(multisession)  library(polars) data <- as_polars_df(data.frame(x = 1:3)) f <- future(dim(data), packages = \"polars\") v <- value(f) #> Error: Execution halted with the following contexts #>    0: In R: in `$.RPolarsDataFrame` #>    0: During function call [workRSOCK()] #>    1: This Polars object is not valid. Execute `rm(<object>)` to remove #>       the object or restart the R session."},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-raster","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: raster","title":"A Future for R: Non-Exportable Objects","text":"raster package provides methods working spatial data, held â€˜RasterLayerâ€™ objects. objects use external pointer. example, Note RasterLayer object s carries external pointer. dig deeper, find attr(s@file, \"con\") file connection opened writing. s passed external worker. contrast, RasterLayer object r problem fine pass worker.","code":"library(future) plan(multisession) options(future.globals.onReference = \"error\")  library(raster) r <- raster(system.file(\"external/test.grd\", package = \"raster\")) tf <- tempfile(fileext = \".grd\") s <- writeStart(r, filename = tf,  overwrite = TRUE)  f <- future({   print(dim(r))   print(dim(s)) }) Error: Detected a non-exportable reference ('externalptr') in one of the globals ('s' of class 'RasterLayer') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-rcpp","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: Rcpp","title":"A Future for R: Non-Exportable Objects","text":"Similarly cpp11, Rcpp can used create R functions implemented C++, e.g. : However, since function uses external pointer internally, pass another R process: can detect protect using:","code":"Rcpp::sourceCpp(code = ' #include <Rcpp.h> using namespace Rcpp;  // [[Rcpp::export]] int my_length(NumericVector x) {     return x.size(); } ') x <- 1:10 my_length(x) ## [1] 10 library(future) plan(multisession) x <- rnorm(10) n %<-% my_length(x) n ## Error in .Call(<pointer: (nil)>, x) : NULL value passed as symbol address options(future.globals.onReference = \"error\") n %<-% my_length(x) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'NativeSymbol') in one of the globals ('my_length' of class 'function') ## used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-reticulate","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: reticulate","title":"A Future for R: Non-Exportable Objects","text":"reticulate package provides methods creating calling Python code within R. one attempts use Python-binding objects package, get errors like: telling future package validate globals , get: Another reticulate example try use Python function create : , , :","code":"library(future) plan(multisession) library(reticulate) os <- import(\"os\") pwd %<-% os$getcwd() pwd ## Error in eval(quote(os$getcwd()), new.env()) : ##   attempt to apply non-function options(future.globals.onReference = \"error\") pwd %<-% os$getcwd() ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('os' of class 'python.builtin.module') used in the future expression cat(\"def twice(x):\\n    return 2*x\\n\", file = \"twice.py\") source_python(\"twice.py\") twice(1.2) ## [1] 2.4 y %<-% twice(1.2) y ## Error in unserialize(node$con) : ##   Failed to retrieve the value of MultisessionFuture from cluster node #1 ##   (on 'localhost').  The reason reported was 'error reading from connection' options(future.globals.onReference = \"error\") y %<-% twice(1.2) ## Error: Detected a non-exportable reference ('externalptr') in one of the globals ## ('twice' of class 'python.builtin.function') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-rjava","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: rJava","title":"A Future for R: Non-Exportable Objects","text":"example shows rJava objects exported external R processes. Although error produced, see value d1 Java NULL Object. , can catch using:","code":"library(future) plan(multisession) library(rJava) .jinit() ## Initialize Java VM on master  Double <- J(\"java.lang.Double\") d0 <- new(Double, \"3.14\") d0 ## [1] \"Java-Object{3.14}\"  f <- future({   .jinit() ## Initialize Java VM on worker   new(Double, \"3.14\") }) d1 <- value(f) d1 ## [1] \"Java-Object<null>\" options(future.globals.onReference = \"error\") f <- future({   .jinit() ## Initialize Java VM on worker   new(Double, \"3.14\") }) ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('Double' of class 'jclassName') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-shortread","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: ShortRead","title":"A Future for R: Non-Exportable Objects","text":"ShortRead package Bioconductor implements efficient methods sampling, iterating, reading FASTQ files. helper objects used saved file exported parallel worker, comprise connections non-exportable objects. example illustrates attempt use â€˜FastqStreamerâ€™ object created main R session fails used parallel worker: catch earlier, get informative error message, ;","code":"library(future) plan(multisession)  # Adopted from example(\"FastqStreamer\", package = \"ShortRead\") library(ShortRead) sp <- SolexaPath(system.file(\"extdata\", package = \"ShortRead\")) fl <- file.path(analysisPath(sp), \"s_1_sequence.txt\") fs <- FastqStreamer(fl, 50)  reads %<-% yield(fs) reads ## Error in status(update = TRUE) : invalid FastqStreamer options(future.globals.onReference = \"error\")  reads %<-% yield(fs) ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('fs' of class 'FastqStreamer') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-sparklyr","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: sparklyr","title":"A Future for R: Non-Exportable Objects","text":"catch soon possible,","code":"library(future) plan(multisession) library(sparklyr) sc <- spark_connect(master = \"local\")  file <- system.file(\"misc\", \"exDIF.csv\", package = \"utils\") data <- spark_read_csv(sc, \"exDIF\", file) d %<-% dim(data) d ## Error in unserialize(node$con) : ##   Failed to retrieve the value of MultisessionFuture (<none>) from cluster ## SOCKnode #1 (PID 29864 on localhost 'localhost'). The reason reported was ## 'unknown input format'. Post-mortem diagnostic: A process with this PID ## exists, which suggests that the localhost worker is still alive. options(future.globals.onReference = \"error\") d %<-% dim(data) ## Error: Detected a non-exportable reference ('externalptr') in one of ## the globals ('data' of class 'tbl_spark') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-terra","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: terra","title":"A Future for R: Non-Exportable Objects","text":"catch soon possible, Functions wrap() unwrap() terra package can used workaround marshal unmarshal non-exportable terra objects, e.g. details, see help(\"wrap\", package = \"terra\").","code":"library(future) plan(multisession) library(terra)  file <- system.file(\"ex/lux.shp\", package = \"terra\") v <- vect(file) dv %<-% dim(v) dv Error in x@ptr$nrow() : external pointer is not valid  file <- system.file(\"ex/elev.tif\", package = \"terra\") r <- rast(file) dr %<-% dim(r) dr ## Error in .External(list(name = \"CppMethod__invoke_notvoid\", address = <pointer: (nil)>,  : ##  NULL value passed as symbol address options(future.globals.onReference = \"error\")  dv %<-% dim(v) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'RegisteredNativeSymbol') in one of the globals ('v' of class ## 'SpatVector') used in the future expression  dr %<-% dim(data) ## Error: Detected a non-exportable reference ('externalptr' of class ## 'RegisteredNativeSymbol') in one of the globals ('r' of class ## 'SpatRaster') used in the future expression library(future) plan(multisession) library(terra)  file <- system.file(\"ex/lux.shp\", package = \"terra\") v <- vect(file) .v <- wrap(v)      ## marshal dv %<-% {   v <- unwrap(.v)  ## unmarshal   dim(v) } rm(.v) ## not needed anymore dv [1] 12  6 file <- system.file(\"ex/elev.tif\", package = \"terra\") r <- rast(file) .r <- wrap(r)      ## marshal dr %<-% {   r <- unwrap(.r)  ## unmarshal   dim(r) } rm(.r) ## not needed anymore dr [1] 90 95  1"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-udpipe","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: udpipe","title":"A Future for R: Non-Exportable Objects","text":"catch soon possible, Now, indeed possible parallelize udpipe calls. details , see â€˜UDPipe Natural Language Processing - Parallelâ€™ vignette comes udpipe package.","code":"library(future) plan(multisession) library(udpipe) udmodel <- udpipe_download_model(language = \"dutch\") udmodel <- udpipe_load_model(file = udmodel$file_model) x %<-% udpipe_annotate(udmodel, x = \"Ik ging op reis en ik nam mee.\") x ## Error in udp_tokenise_tag_parse(object$model, x, doc_id, tokenizer, tagger,  : ##   external pointer is not valid options(future.globals.onReference = \"error\") x %<-% udpipe_annotate(udmodel, x = \"Ik ging op reis en ik nam mee.\") ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('udmodel' of class 'udpipe_model') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-xgboost","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: xgboost","title":"A Future for R: Non-Exportable Objects","text":"xgboost package provides fast gradient-boosting methods. data structures use external pointers. example, works just fine attempt pass â€˜xgb.DMatrixâ€™ object train external worker, silently get incorrect value: unfortunate, can least detect : train external pointer, .e.Â mode(train) == \"externalptr\".","code":"library(future) plan(multisession)  library(xgboost) data(agaricus.train, package = \"xgboost\") train <- xgb.DMatrix(agaricus.train$data, label = agaricus.train$label) class(train) ## [1] \"xgb.DMatrix\"  d <- dim(train) d ## [1] 6513  126 f <- future(dim(train)) d <- value(f) d ## NULL options(future.globals.onReference = \"error\") f <- future(dim(dtrain)) ## Error: Detected a non-exportable reference ('externalptr' of class 'xgb.DMatrix') ## in one of the globals ('dtrain' of class 'xgb.DMatrix') used in the future expression"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-xml","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: XML","title":"A Future for R: Non-Exportable Objects","text":"Another example XML objects XML package, may produce evaluation error, even cause R abort used another R process, e.g. example, end exporting XMLInternalElementNode object another R process, longer valid. try use calling xmlGetAttr() , XML causes R crash abort. illustrate â€™s going parallel workers, save object file using saveRDS(, \".rds\"), try use another R session, following happens: harsh way telling us export types objects produced XML. Ideally, XML detect give informative error message crash R like . workaround marshal problematic objects exporting parallel R process, unmarshal working . example, alternative, generic workaround, always create doc element, XMLInternalDocument object, parallel workers, .e.","code":"library(future) plan(multisession) library(XML) doc <- xmlParse(system.file(\"exampleData\", \"tagnames.xml\", package = \"XML\")) a <- getNodeSet(doc, \"/doc//a[@status]\")[[1]] f <- future(xmlGetAttr(a, \"status\")) value(f) ## Error in unserialize(node$con) : ##   MultisessionFuture (<none>) failed to receive results from cluster ## RichSOCKnode #1 (PID 31541 on localhost 'localhost'). The reason ## reported was 'error reading from connection'. Post-mortem diagnostic: ## No process exists with this PID, i.e. the localhost worker is no ## longer alive. Detected a non-exportable reference ('externalptr' of ## class 'XMLInternalElementNode') in one of the globals ('a' of class ## 'XMLInternalElementNode') used in the future expression. The total ## size of the 1 globals exported is 520 bytes. There is one global: 'a' ## (520 bytes of class 'externalptr') $ R --quiet --vanilla > a <- readRDS(\"a.rds\") > XML::xmlGetAttr(a, \"status\")   *** caught segfault *** address 0x40, cause 'memory not mapped'  Traceback:  1: xmlAttrs.XMLInternalNode(node, addNamespace)  2: xmlAttrs(node, addNamespace)  3: XML::xmlGetAttr(a, \"status\")  Possible actions: 1: abort (with core dump, if enabled) 2: normal R exit 3: exit R without saving workspace 4: exit R saving workspace Selection: library(future) plan(multisession) library(XML) doc <- xmlParse(system.file(\"exampleData\", \"tagnames.xml\", package = \"XML\")) a <- getNodeSet(doc, \"/doc//a[@status]\")[[1]]  ## Marshall the non-exportable XMLInternalElementNode object .a <- xmlSerializeHook(a)      ## marshal  f <- future({   a <- xmlDeserializeHook(.a)  ## unmarshal   xmlGetAttr(a, \"status\") }) value(f) ## [1] \"xyz\" library(future) plan(multisession) library(XML)  f <- future({   doc <- xmlParse(system.file(\"exampleData\", \"tagnames.xml\", package = \"XML\"))   a <- getNodeSet(doc, \"/doc//a[@status]\")[[1]]   xmlGetAttr(a, \"status\") }) value(f) ## [1] \"xyz\""},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-xml2","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages that rely on external pointers","what":"Package: xml2","title":"A Future for R: Non-Exportable Objects","text":"Yet another example XML objects xml2 package, may produce evaluation errors (just invalid results depending used), e.g. future framework can help detect sending future worker; One workaround dealing non-exportable objects look ways encode object can exported, decoded receiving end. xml2, can use xml2::xml_serialize() xml2::xml_unserialize() . can rewrite example can pass xml2 object back forth main R session R workers:","code":"library(future) plan(multisession) library(xml2) doc <- read_xml(\"<body><\/body>\") f <- future(xml_children(doc)) value(f) ## Error: external pointer is not valid options(future.globals.onReference = \"error\") f <- future(xml_children(xml)) ## Error: Detected a non-exportable reference ('externalptr') in one of the ## globals ('xml' of class 'xml_document') used in the future expression ## Encode the 'xml_document' object 'doc' as a 'raw' object .doc <- xml_serialize(doc, connection = NULL)  ## marshal  f <- future({   ## In the future, reconstruct the 'xml_document' object   ## from the 'raw' object   doc <- xml_unserialize(.doc)                 ## unmarshal    ## Continue as usual   children <- xml_children(doc)    ## Send back a 'raw' representation of the 'xml_nodeset'   ## object 'children'   xml_serialize(children, connection = NULL) })  ## Reconstruct the 'xml_nodeset' object in the main R session children <- xml_unserialize(value(f))"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-ncdf4","dir":"Articles","previous_headings":"Packages with non-exportable objects > Packages with other types of non-external objects","what":"Package: ncdf4","title":"A Future for R: Non-Exportable Objects","text":"Package ncdf4 provides R API work data live netCDF files. example, can create simple netCDF file holds variable â€˜xâ€™: can now use netCDF file next time start R, e.g. However, fail attempt use file, object class â€˜ncdf4â€™, parallel worker, get error: ncdf4 objects make use internal references unique R session created. However, formal external pointer:s, meaning future framework detect . , using options(future.globals.onReference = \"error\") help . workaround open netCDF worker, e.g.","code":"library(ncdf4) x <- ncvar_def(\"x\", units = \"count\", dim = list()) file <- nc_create(\"example.nc\", x) ncvar_put(file, x, 42) nc_close(file) library(ncdf4) file <- nc_open(\"example.nc\") y <- ncvar_get(file) y ## [1] 42 library(future) plan(multisession) library(ncdf4) file <- nc_open(\"example.nc\") f <- future(ncvar_get(file)) y <- value(f) ## Error in R_nc4_inq_varndims: NetCDF: Not a valid ID ## Error in ncvar_ndims(ncid, varid) : error returned from C call library(future) plan(multisession) library(ncdf4) f <- future({   file <- nc_open(\"example.nc\")   value <- ncvar_get(file)   nc_close(file)   value }) y <- value(f) y ## [1] 42"},{"path":[]},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-data-table","dir":"Articles","previous_headings":"Packages with non-exportable objects > False positives - packages with exportable external pointers","what":"Package data.table","title":"A Future for R: Non-Exportable Objects","text":"data.table package creates objects comprising external pointers. Contrary non-exportable examples, objects can saved file used another R session, exported parallel worker. data.table capable restoring objects valid state. Consider following example: try last step future strict checking references enabled, get error: false positive. relax checks, indeed work:","code":"library(data.table) DT <- data.table(a = 1:3, b = letters[1:3])  ## Extract second row row <- DT[2] print(row) #>    a b #> 1: 2 b library(future) plan(multisession) options(future.globals.onReference = \"error\")  row %<-% DT[2] Error: Detected a non-exportable reference ('externalptr') in one of the globals ('DT' of class 'data.table') used in the future expression options(future.globals.onReference = NULL)  row <- DT[2] print(row) #>    a b #> 1: 2 b"},{"path":"https://future.futureverse.org/articles/future-4-non-exportable-objects.html","id":"package-rstan","dir":"Articles","previous_headings":"Packages with non-exportable objects > False positives - packages with exportable external pointers","what":"Package rstan","title":"A Future for R: Non-Exportable Objects","text":"rstan package creates objects comprising external pointers. Contrary non-exportable examples, objects can saved file used another R session, exported parallel worker. rstan capable restoring objects valid state. Consider following example example(\"rstan\", package = \"rstan\"): try last step future strict checking references enabled, get error: However, false positive. fit object, class â€˜stanfitâ€™, can indeed exported used external R process, e.g.","code":"library(rstan)  code <- \" data {   int<lower=0> N;   real y[N]; }  parameters {   real mu; }  model {   target += normal_lpdf(mu | 0, 10);   target += normal_lpdf(y  | mu, 1); } \"  y <- rnorm(20) data <- list(N = 20, y = y) fit <- stan(model_code = code, model_name = \"example\",             data = data, iter = 2012L, chains = 3L,             sample_file = file.path(tempdir(), \"norm.csv\"))  e <- extract(fit, permuted = FALSE) library(future) plan(multisession) options(future.globals.onReference = \"error\")  e %<-% extract(fit, permuted = FALSE) Error: Detected a non-exportable reference ('externalptr' of class 'DLLHandle') in one of the globals ('fit' of class 'stanfit') used in the future expression options(future.globals.onReference = NULL)  e %<-% extract(fit, permuted = FALSE) str(e) #>  num [1:1006, 1:3, 1:2] -0.3028 -0.4017 -0.3379 -0.2358 0.0443 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ iterations: NULL #>   ..$ chains    : chr [1:3] \"chain:1\" \"chain:2\" \"chain:3\" #>   ..$ parameters: chr [1:2] \"mu\" \"lp__\""},{"path":"https://future.futureverse.org/articles/future-5-startup.html","id":"r-options","dir":"Articles","previous_headings":"","what":"R options","title":"A Future for R: Controlling Default Future Strategy","text":"default future backend can controlled via R option future.plan. instance, add ~/.Rprofile startup script, future package resolve futures parallel (asynchronously using available cores), .e. Option future.plan ignored command-line option --parallel (-p) specified.","code":"options(future.plan = \"multisession\") $ Rscript -e \"class(future::plan())\" [1] \"multisession\" \"future\"       \"function\""},{"path":"https://future.futureverse.org/articles/future-5-startup.html","id":"environment-variables","dir":"Articles","previous_headings":"","what":"Environment variables","title":"A Future for R: Controlling Default Future Strategy","text":"alternative using options() setting option future.plan specify system environment variable R_FUTURE_PLAN. set, future package set future.plan accordingly loaded. example, Environment variable R_FUTURE_PLAN ignored either option future.plan command-line option --parallel (-p) specified.","code":"$ export R_FUTURE_PLAN=multisession $ Rscript -e \"class(future::plan())\" [1] \"multisession\" \"future\"       \"function\""},{"path":"https://future.futureverse.org/articles/future-5-startup.html","id":"command-line-options","dir":"Articles","previous_headings":"","what":"Command-line options","title":"A Future for R: Controlling Default Future Strategy","text":"loaded, future package checks command-line option --parallel=ncores (short -p ncores) sets future backend (via option future.plan) number available cores (via option mc.cores) accordingly. provides convenient mechanism specifying parallel future processing command line. example, start R future package interpret wish resolve futures parallel using 2 cores. specifically, get can use command-line option also Rscript, provides convenient mechanism launching future-enhanced R scripts run parallel, e.g. , course, require script uses futures future package. --parallel=1 specified, equivalently -p 1, futures resolved using single process. Specifying command-line options override startup settings.","code":"$ R --quiet --args --parallel=2 > availableCores() mc.cores        2 > class(future::plan()) [1] \"FutureStrategy\" \"tweaked\"        \"multisession\"   \"future\"         \"function\" $ Rscript analysis.R --parallel=4"},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"future-api-backend-specification","dir":"Articles","previous_headings":"","what":"Future API Backend Specification","title":"A Future for R: Future API Backend Specification","text":"Version 0.1.9-9000 WARNING: Starting future 1.40.0 (2025-04-10), migrating new way write future backends. work progress, subject change next release cycles.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"introduction","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Introduction","title":"A Future for R: Future API Backend Specification","text":"document written serve reference developers developing future backend future framework implemented future package R available CRAN. Future Application Programming Interface (API) three fundamental functions core: f <- future(expr) - create future R expression (non-blocking may blocking) r <- resolved(f) - check whether future resolved (non-blocking) v <- value(f) - retrieve value future (blocking) three functions alone, possible evaluate one R expressions synchronously asynchronously. expressions resolved depends â€œfuture backendâ€ use. example, one backend may evaluated expressions sequentially (synchronously) another may evaluated parallel (asynchronously). Regardless backend, value future expression always . fundamental future ecosystem future backends conform Future API specification. Conformance serves guarantor correctness behavior developer use futures software well end-user software. future backend meets requirements can used software use futures internally. example, three functions serve building blocks several higher-level map-reduce APIs. One example future.apply package CRAN provides future_lapply(), futurized version lapply() available base package. function can used perform lapply-like processing parallel using parallel backend. implementation future.apply package 100% invariant parallel backend used. possible future backends conform set rules. Rules documented . supplement specification herein â€˜Test Suite Future API Backendsâ€™, consists set tests can used validate future backend meets minimal requirements Future API. tests run command-line, R prompt, part package tests backend package. test suite documented implemented future.tests package available CRAN.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"feedback","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Feedback","title":"A Future for R: Future API Backend Specification","text":"find something document missing, unclear, faulty, please report feedback using official issue tracker future package https://github.com/futureverse/future. feedback specific test suite, please use official issue tracker future.tests package https://github.com/futureverse/future.tests.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"overview-of-the-future-api","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Overview of the Future API","title":"A Future for R: Future API Backend Specification","text":"Future API three fundamental functions core: f <- future(expr) - create future R expression (non-blocking may blocking) r <- resolved(f) - check whether future resolved (non-blocking) v <- value(f) - retrieve value future (blocking) implementation future backend involves several steps. simplicity, lets say call future backend â€˜myparallelâ€™. broad summary, future backend needs implement following components: myparallel function inherits class future. function must never called - used -op placeholder setting future backend via plan(). MyParallelFutureBackend function returns object class MyParallelFutureBackend inheriting FutureBackend. function set attribute factory myparallel function. launchFuture() method MyParallelFutureBackend class taking arguments backend future. method responsible starting concurrent evaluation Future object returning instance class MyParallelFuture inheriting Future class. method often non-blocking parallel backends, may blocking compute resources exhausted. typically blocking sequential backends. S3 method resolved() MyParallelFuture , non-blocking fashion, returns TRUE future resolved FALSE . S3 method result() MyParallelFuture returns FutureResult object (defined future package) future resolved otherwise fails resolve. future yet resolved, method block future resolved. place, selection using backend future plan, done plan(myparallel) option specifying certain arguments passed myparallel(). plan set, call f <- future(expr) launch evaluation future via launchFuture() method current set future backend return future now inheriting MyParallelFuture. calling resolved(f) query whether future expression resolved , underlying S3 method class check parallel worker whether expression resolved . calling value(f), S3 method Future class calls result(f), return FutureResult object future. future yet resolved, call block . errors occurred resolving future expression, value(f) return value expression, recorded backend FutureResult object. evaluation error, value(f) resignal (â€œrelayedâ€) error. captured conditions standard output also relayed point.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"requirements-for-the-backend-future-api","dir":"Articles","previous_headings":"Future API Backend Specification","what":"Requirements for the backend Future API","title":"A Future for R: Future API Backend Specification","text":"section describes detail requirements four components . requirements given continuation â€˜myparallelâ€™ example. otherwise specified, functions mentioned future package.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"constructor-function-creating-a-future","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"Constructor function creating a Future","title":"A Future for R: Future API Backend Specification","text":"place-holder function myparallel() used plan() must inherit class future inherits(myparallel, \"future\") true. must also attribute factory set corresponding FutureBackend function, .e.Â MyParallelFutureBackend.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"launchfuture-method-of-the-futurebackend-class","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"launchFuture() method of the FutureBackend class","title":"A Future for R: Future API Backend Specification","text":"S3 method launchFuture() MyParallelFutureBackend takes FutureBackend object first argument Future object second required. accept additional arguments via ..., currently used. launchFuture() method invisibly return Future object desired class, e.g.Â MyParallelFuture. launchFuture() method responsible evaluating Future object. evaluation future expression respect global variables FutureGlobals object returned globals() Future object first argument. evaluation also respect package names returned packages() Future object first argument. backend provides parallel processing, launchFuture() return future soon possible without waiting resolved. workers occupied, launchFuture() responsible waiting worker becomes available launch future worker immediately return future. launchFuture() method may produce error class FutureError case fails launch future worker worker terminated unexpectedly. launchFuture() method must update RNG state.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"resolved-method-for-the-future-class","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"resolved() method for the Future class","title":"A Future for R: Future API Backend Specification","text":"S3 method resolved() MyParallelFuture takes Future object first argument return either TRUE FALSE required. accept additional arguments via ..., currently used. method may called zero times. method return FALSE long future unresolved. may also return FALSE fails establish state future within reasonable time period (â€œtimeoutâ€). return TRUE soon can established future resolved. returned TRUE , succeeding calls return TRUE. resolved() called future yet launched, launch future calling run(). occasion resolved() may block. cases, return promptly. resolved() method may produce FutureError error created FutureError() case communication worker broken worker terminated unexpectedly. resolved() method must update RNG state.","code":""},{"path":"https://future.futureverse.org/articles/future-6-future-api-backend-specification.html","id":"result-method-for-the-future-class","dir":"Articles","previous_headings":"Future API Backend Specification > Requirements for the backend Future API","what":"result() method for the Future class","title":"A Future for R: Future API Backend Specification","text":"S3 method result() MyParallelFuture takes Future object first argument returns FutureResult object required. accept additional arguments via ..., currently used. method may called zero times. result() called future yet launched, launch future calling run(). result() called future yet resolved, block future resolved. value result() value evaluating getExpression() expression run() launched. result() method may produce FutureError error created FutureError() case communication worker broken worker terminated unexpectedly. result() method must update RNG state.","code":""},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"the-future-smell-test","dir":"Articles","previous_headings":"","what":"The future smell test","title":"A Future for R: Best Practices for Package Developers","text":"far common popular future backend parallelize local machine, e.g.Â plan(multisession). often good enough situations note end-users access multiple machines might want run code using speed beyond single machine can . , avoid far possible making assumptions code run local machine. good â€œsmell testâ€ ask : - future code work ends running side world? Regardless performance, answer â€œYesâ€, already embraced core philosophy future framework. answer â€œMaybeâ€ â€œâ€, see can rewrite . instance, future code made assumption access local file system, : can rewrite code load content file set future, : Similarly, avoid future code write local file system parent R session might access file system. keeping future smell test mind writing future code, increase chances code can parallelized ways just local computer. Properly written future code work regardless future backend end-user picks, e.g. Remember, developers never know compute resources end-user access right now access six month. knows, code might even end running 2,000 cores located Moon twenty years now.","code":"f <- future({   data <- read_tsv(file)   analyze(data) }) data <- read_tsv(file) f <- future({   analyze(data) }) plan(sequential) plan(multisession) plan(cluster, workers = rep(c(\"n1.remote.org\", \"n2.remote.org\", \"n3.remote.org\"), each = 32))"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"avoid-changing-the-future-backend","dir":"Articles","previous_headings":"","what":"Avoid changing the future backend","title":"A Future for R: Best Practices for Package Developers","text":"reasons like ones mentioned , refrain setting plan() function. better leave end-user decide want parallelize. One reason can never know context code run. example, might use futures parallelize function call package package code calls package internally. set plan(multisession) internally without undoing, might mess plan() already set breaking parallelization. still think necessary set plan(), make sure undo function exits, also errors. can done using (plan(...), local = TRUE), e.g. need setting future backend within function often comes developers wanting add argument function allows end-user specify whether want run function parallel sequentially. often result code like: way user can use: depending needs. However, another package developer decides call function function, now expose parallel argument users function, e.g. Exposing passing â€œparallelâ€ argument along can become quite cumbersome. Instead, neater use: let user control whether want parallelize via plan(), e.g.Â plan(multisession) plan(sequential).","code":"my_fcn <- function(x) {   with(plan(multisession), local = TRUE)   y <- analyze(x)   summarize(y) } my_fcn <- function(x, parallel = FALSE) {   if (parallel) {     with(plan(multisession), local = TRUE)     y <- future_lapply(x, FUN = analyze) ## from future.apply package   } else {     y <- lapply(x, FUN = analyze)   }   summarize(y) } y <- my_fcn(x, parallel = FALSE) y <- my_fcn(x, parallel = TRUE) their_fcn <- function(x, parallel = FALSE) {   x2 <- preprocess(x)   y <- my_fcn(x2, parallel = parallel)   z <- another_fcn(y)   z } my_fcn <- function(x) {   y <- future_lapply(x, FUN = analyze) ## from future.apply package   summarize(y) }"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"avoid-changing-the-future-options","dir":"Articles","previous_headings":"","what":"Avoid changing the future options","title":"A Future for R: Best Practices for Package Developers","text":"Just like R options, must change R future.* options. end-user set . find tweak one options, make sure undo changes immediately afterward. example, want bump future.globals.maxSize limit creating future, use something like following inside function:","code":"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB on.exit(options(oopts)) f <- future({ expr })  ## Launch a future with large objects"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"writing-examples","dir":"Articles","previous_headings":"","what":"Writing examples","title":"A Future for R: Best Practices for Package Developers","text":"example sets future backend beginning, make sure reset future backend plan(sequential) end example. reason switching plan, previous one cleaned . particularly important multisession cluster futures plan(sequential) shut underlying PSOCK clusters. instance, example: forget shut PSOCK cluster, R CMD check ---cran, R CMD check environment variable _R_CHECK_CONNECTIONS_LEFT_OPEN_=true set, produce error reason like display reset future backend help documentation, still want run, wrap statement Rd \\dontshow{} statement.","code":"## Run the analysis in parallel on the local computer future::plan(\"multisession\")  y <- analyze(\"path/to/file.csv\")  ## Shut down parallel workers future::plan(\"sequential\") $ R CMD check --as-cran mypkg_1.0.tar.gz ... * checking examples ... ERROR Running examples in 'analyze-Ex.R' failed ... > cleanEx() Error: connections left open:       <-localhost:37400 (sockconn)       <-localhost:37400 (sockconn) Execution halted"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"writing-vignettes","dir":"Articles","previous_headings":"","what":"Writing vignettes","title":"A Future for R: Best Practices for Package Developers","text":"Importantly, use multisession backend vignette, must manually specify number workers, .e. reason manually limit number workers vignettes, automatically limited us package examples package tests, R CMD check ---cran set environment variable _R_CHECK_LIMIT_CORES_ re-building vignettes, resulting default workers = availableCores() use whatever number cores operating system given R process. Donâ€™t forget stop parallel workers calling end vignette.","code":"plan(multisession, workers = 2) plan(sequential)"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"testing-a-package-that-relies-on-futures","dir":"Articles","previous_headings":"","what":"Testing a package that relies on futures","title":"A Future for R: Best Practices for Package Developers","text":"want make sure code works running sequentially well running parallel, often good enough package tests run code : code works setup, can sure global variables properly identified exported workers required packages loaded workers. Always make sure shut parallel â€˜multisessionâ€™ workers end package test calling: tests written way, can set environment variable R_FUTURE_PLAN=multisession call R CMD check. make default future backend become â€˜multisessionâ€™ instead â€˜sequentialâ€™. example,","code":"plan(multisession) plan(sequential) $ export R_FUTURE_PLAN=multisession $ R CMD check --as-cran mypkg_1.0.tar.gz"},{"path":"https://future.futureverse.org/articles/future-7-for-package-developers.html","id":"making-sure-to-stop-parallel-workers","dir":"Articles","previous_headings":"","what":"Making sure to stop parallel workers","title":"A Future for R: Best Practices for Package Developers","text":"creating cluster object, instance via plan(multisession), package help example, package vignette, package test, must _remember stop cluster end examples(*), vignettes, unit tests_. required order leave behind stray parallel cluster workers main R session terminates. Linux macOS, operating system often takes care terminating worker processes forget, MS Windows processes keep running background time , takes 30 days (sic!). R CMD check ---cran indirectly detect stray worker processes MS Windows running R (>= 4.3.0). detected, result placeholder Rscript<hexcode> files left behind temporary directory. check NOTE look (R (>= 4.3.0)) : Rscript<hexcode> files background R worker processes, almost always parallel cluster:s forgot stop end. stop â€˜multisessionâ€™ workers, call: end examples(*), vignettes, package tests. create cluster manually using make sure stop clusters end using (*) Currently, examples excluded detritus checks. validated R-devel revision 82991 (2022-10-02).","code":"* checking for detritus in the temp directory ... NOTE Found the following files/directories:   'Rscript1058267d0c10' 'Rscriptbd4267d0c10' plan(sequential) cl <- parallelly::makeClusterPSOCK(2) plan(cluster, workers = cl) plan(sequential) parallel::stopCluster(cl)"},{"path":"https://future.futureverse.org/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Henrik Bengtsson. Author, maintainer, copyright holder.","code":""},{"path":"https://future.futureverse.org/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Henrik Bengtsson, Unifying Framework Parallel Distributed Processing R using Futures, R Journal (2021) 13:2, pages 208-227, doi:10.32614/RJ-2021-048","code":"@Article{RJ-2021-048,   author = {Henrik Bengtsson},   title = {A Unifying Framework for Parallel and Distributed Processing in R using Futures},   year = {2021},   journal = {The R Journal},   doi = {10.32614/RJ-2021-048},   url = {https://doi.org/10.32614/RJ-2021-048},   pages = {208--227},   volume = {13},   number = {2}, }"},{"path":[]},{"path":"https://future.futureverse.org/index.html","id":"tldr","dir":"","previous_headings":"","what":"TL;DR","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Futureverse makes easy parallelize existing R code - often minor change code. lowers barriers anyone can safely speed existing R code worry-free manner. cross-platform solution requires additional setups technical skills. Anyone can running within minutes.","code":"library(future) plan(multisession)  ## Evaluate an R expression sequentially y <- slow_fcn(X[1])  ## Evaluate it in parallel in the background f <- future(slow_fcn(X[1])) y <- value(f)  ## future.apply: futurized version of base R apply library(future.apply) y <-        lapply(X, slow_fcn) y <- future_lapply(X, slow_fcn)  ## furrr: futurized version of purrr library(furrr) y <- X |>        map(slow_fcn) y <- X |> future_map(slow_fcn)  ## foreach: futurized version (modern) library(foreach) y <- foreach(x = X) %do%       slow_fcn(x) y <- foreach(x = X) %dofuture% slow_fcn(x)  ## foreach: futurized version (traditional) library(foreach) doFuture::registerDoFuture() y <- foreach(x = X) %do%    slow_fcn(x) y <- foreach(x = X) %dopar% slow_fcn(x)"},{"path":"https://future.futureverse.org/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"purpose future package provide simple uniform way evaluating R expressions asynchronously using various resources available user. programming, future abstraction value may available point future. state future can either unresolved resolved. soon resolved, value available instantaneously. value queried future still unresolved, current process blocked future resolved. possible check whether future resolved without blocking. Exactly futures resolved depends future backend set evaluate . instance, future can resolved using sequential backend, means resolved current R session. backends may used resolving futures asynchronously, instance, parallel current machine compute cluster. example illustrating basics futures work. First, consider following code snippet uses plain R code: works assigning value expression variable v print value v. Moreover, expression v evaluated also print message. code snippet modified use futures instead: difference v constructed; plain R use <- whereas futures use %<-%. difference output relayed future resolved () value queried (see Vignette â€˜Outputting Textâ€™). futures useful? can choose evaluate future expression separate R process asynchronously simply switching settings : asynchronous futures, current/main R process block, means available processing futures resolved separate processes running background. words, futures provide simple yet powerful construct parallel / distributed processing R. Now, bothered read nitty-gritty details futures, just want try , skip end play Mandelbrot demo using parallel non-parallel evaluation.","code":"> v <- { +   cat(\"Hello world!\\n\") +   3.14 + } Hello world! > v [1] 3.14 > library(future) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14 > library(future) > plan(multisession) > v %<-% { +   cat(\"Hello world!\\n\") +   3.14 + } > v Hello world! [1] 3.14"},{"path":"https://future.futureverse.org/index.html","id":"implicit-or-explicit-futures","dir":"","previous_headings":"","what":"Implicit or Explicit Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Futures can created either implicitly explicitly. introductory example used implicit futures created via v %<-% { expr } construct. alternative explicit futures using f <- future({ expr }) v <- value(f) constructs. , example alternatively written : Either style future construct works equally(*) well. implicit style similar regular R code written. principle, replace <- %<-% turn assignment future assignment. hand, simplicity can also deceiving, particularly asynchronous futures used. contrast, explicit style makes much clearer futures used, lowers risk mistakes better communicates design others reading code. (*) cases %<-% used without (small) modifications. return Section â€˜Constraints using Implicit Futuresâ€™ near end document. summarize, explicit futures, use: f <- future({ expr }) - creates future v <- value(f) - gets value future (blocks yet resolved) implicit futures, use: v %<-% { expr } - creates future promise value keep simple, use implicit style rest document, everything discussed also apply explicit futures.","code":"> library(future) > f <- future({ +   cat(\"Hello world!\\n\") +   3.14 + }) > v <- value(f) Hello world! > v [1] 3.14"},{"path":"https://future.futureverse.org/index.html","id":"controlling-how-futures-are-resolved","dir":"","previous_headings":"","what":"Controlling How Futures are Resolved","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"future package comes built-future backends leverage parallel package part R . addition backends, others exist package extensions, e.g.Â future.callr, future.mirai, future.batchtools. overview common backends end-user can chose . ğŸ“¶: futures relay progress updates real-time, e.g.Â progressr â™»ï¸: futures interruptible restartable; * disabled default (next): next release; (soon): near-future release default, future expressions evaluated synchronously current R session via â€œsequentialâ€ backend. section, go backend discuss common differ.","code":""},{"path":"https://future.futureverse.org/index.html","id":"consistent-behavior-across-futures","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Consistent Behavior Across Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"going different future backends, probably helpful clarify objectives Future API (defined future package). programming futures, matter future backend used executing code. really know computational resources user access , choice parallel backend hands user developer. words, code make assumptions futures resolved. One designs Future API encapsulate differences types futures appear work . despite expressions may evaluated locally current R session across world remote R sessions. Another obvious advantage consistent API behavior among different types futures helps prototyping. Typically one use sequential evaluation building script , later, script fully developed, one may turn asynchronous processing. , defaults different backends results side effects evaluating future expression similar possible. specifically, following true futures: evaluation done local environment (.e.Â local({ expr })) assignments affect calling environment. natural evaluating external R process, also enforced evaluating current R session. future constructed, global variables identified. asynchronous evaluation, globals exported R process/session evaluating future expression. sequential futures lazy evaluation (lazy = TRUE), globals â€œfrozenâ€ (cloned local environment future). Also, order protect exporting large objects mistake, built-assertion total size globals less given threshold (controllable via option, cf.Â help(\"future.options\")). threshold exceeded, informative error thrown. Future expressions evaluated . soon value (error) collected available succeeding requests. example illustrating assignments done local environment: Now ready explore different future backends.","code":"> plan(sequential) > a <- 1 > x %<-% { +     a <- 2 +     2 * a + } > x [1] 4 > a [1] 1"},{"path":"https://future.futureverse.org/index.html","id":"synchronous-futures","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Synchronous Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Synchronous futures resolved one another commonly R process creates . synchronous future resolved blocks main process resolved.","code":""},{"path":"https://future.futureverse.org/index.html","id":"sequential-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Synchronous Futures","what":"Sequential Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Sequential futures default unless otherwise specified. designed behave similar possible regular R evaluation still fulfilling Future API behaviors. example illustrating properties: Since eager sequential evaluation taking place, three futures resolved instantaneously moment created. Note also pid calling environment, assigned process ID current process, neither overwritten removed. futures evaluated local environment. Since synchronous (uni-)processing used, future b resolved main R process (still local environment), value b pid .","code":"> plan(sequential) > pid <- Sys.getpid() > pid [1] 1287562 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1287562 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1287562"},{"path":"https://future.futureverse.org/index.html","id":"asynchronous-futures","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Asynchronous Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Next, turn asynchronous futures, futures resolved background. design, futures non-blocking, , created calling process available tasks including creating additional futures. calling process tries access value future yet resolved, trying create another asynchronous future available R processes busy serving futures, blocks.","code":""},{"path":"https://future.futureverse.org/index.html","id":"multisession-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multisession Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"start multisession futures supported operating systems. multisession future evaluated background R session running machine calling R process. example multisession evaluation: first thing observe values , c pid previously. However, notice b different . future b evaluated different R process therefore returns different process ID. multisession evaluation used, package launches set R sessions background serve multisession futures evaluating expressions created. background sessions busy serving futures, creation next multisession future blocked background session becomes available . total number background processes launched decided value availableCores(), e.g. particular result tells us mc.cores option set allowed use total two (2) processes including main process. words, settings, two (2) background processes serving multisession futures. availableCores() also agile different options system environment variables. instance, compute cluster schedulers used (e.g.Â TORQUE/PBS Slurm), set specific environment variable specifying number cores allotted given job; availableCores() acknowledges well. nothing else specified, available cores machine utilized, cf.Â parallel::detectCores(). details, please see help(\"availableCores\", package = \"parallelly\").","code":"> plan(multisession, workers = 2) > pid <- Sys.getpid() > pid [1] 1287562 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1287626 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1287562 > availableCores() mc.cores         2"},{"path":"https://future.futureverse.org/index.html","id":"multicore-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Multicore Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"operating systems R supports forking processes, basically operating system except Windows, alternative spawning R sessions background fork existing R process. use multicore futures, supported, specify: Just like multisession futures, maximum number parallel processes running decided availableCores(), since cases evaluation done local machine. Forking R process can faster working separate R session running background. One reason overhead exporting large globals background session can greater forking, therefore shared memory, used. hand, shared memory read , meaning modifications shared objects one forked processes (â€œworkersâ€) cause copy operating system. can also happen R garbage collector runs one forked processes. hand, process forking also considered unstable R environments. instance, running R within RStudio process forking may resulting crashed R sessions. , future package disables multicore futures default running RStudio. See help(\"supportsMulticore\") details.","code":"plan(multicore)"},{"path":"https://future.futureverse.org/index.html","id":"cluster-futures","dir":"","previous_headings":"Controlling How Futures are Resolved > Asynchronous Futures","what":"Cluster Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Cluster futures evaluate expressions ad-hoc cluster (implemented parallel package). instance, assume access three nodes n1, n2 n3, can use asynchronous evaluation : types clusters parallel::makeCluster() creates can used cluster futures. instance, cluster can explicitly set : Also, considered good style shut cluster cl longer needed, , calling parallel::stopCluster(cl). However, shut main process terminated. information set manage clusters, see help(\"makeCluster\", package = \"parallel\"). Clusters created implicitly using plan(cluster, workers = hosts) hosts character vector also shut main R session terminates, future backend changed, e.g.Â calling plan(sequential). Note automatic authentication setup (e.g.Â SSH key pairs), nothing preventing us using approach using cluster remote machines. want run multiple workers node, replicate node name many times number workers run node. example, run three workers n1, one n2, five n3, total nine parallel workers.","code":"> plan(cluster, workers = c(\"n1\", \"n2\", \"n3\")) > pid <- Sys.getpid() > pid [1] 1287562 > a %<-% { +     pid <- Sys.getpid() +     cat(\"Future 'a' ...\\n\") +     3.14 + } > b %<-% { +     rm(pid) +     cat(\"Future 'b' ...\\n\") +     Sys.getpid() + } > c %<-% { +     cat(\"Future 'c' ...\\n\") +     2 * a + } Future 'a' ... > b Future 'b' ... [1] 1287729 > c Future 'c' ... [1] 6.28 > a [1] 3.14 > pid [1] 1287562 cl <- parallel::makeCluster(c(\"n1\", \"n2\", \"n3\")) plan(cluster, workers = cl) > plan(cluster, workers = c(rep(\"n1\", times = 3), \"n2\", rep(\"n3\", times = 5)))"},{"path":"https://future.futureverse.org/index.html","id":"nested-futures-and-evaluation-topologies","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Nested Futures and Evaluation Topologies","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"far discussed can referred â€œflat topologyâ€ futures, , futures created assigned environment. However, nothing stopping us using â€œnested topologyâ€ futures, one set futures may, turn, create another set futures internally . instance, example two â€œtopâ€ futures (b) uses multisession evaluation second future (b) turn uses two internal futures: inspection process IDs, see total three different processes involved resolving futures. main R process (pid 1287562), two processes used (pid 1287860) b (pid 1287859). However, two futures (b1 b2) nested b evaluated R process b. nested futures use sequential evaluation unless otherwise specified. reasons , main reason protects us spawning large number background processes mistake, e.g.Â via recursive calls. specify different type evaluation topology, first level futures resolved multisession evaluation second level sequential evaluation, can provide sequence nested backend specifying list plan(). clarify, first, sequence backends used can explicitly specified : actually get behavior try multiple levels multisession evaluations; second multisession backend default single, sequential processing. reason , also , protect us launching processes machine can support. case multisession multicore evaluation. Continuing, start sequential backend use multisession backend nested futures, get: clearly show b resolved calling process (pid 1287562) whereas two nested futures (b1 b2) resolved two separate R processes (pids 1288080 1288081). said , indeed possible use nested multisession backend forced sequential processing explicitly specifying (read forcing) number workers available level. order need â€œtweakâ€ default settings, can done follows: First, see b resolved different processes (pids 1288184 1288185) calling process (pid 1287562). Second, two nested futures (b1 b2) resolved yet two R processes (pids 1288314 1288315). details working nested futures different future backends level, see Vignette â€˜Future R: Future Topologiesâ€™.","code":"> plan(multisession, workers = 2) > pid <- Sys.getpid() > a %<-% { +     cat(\"Future 'a' ...\\n\") +     Sys.getpid() + } > b %<-% { +     cat(\"Future 'b' ...\\n\") +     b1 %<-% { +         cat(\"Future 'b1' ...\\n\") +         Sys.getpid() +     } +     b2 %<-% { +         cat(\"Future 'b2' ...\\n\") +         Sys.getpid() +     } +     c(b.pid = Sys.getpid(), b1.pid = b1, b2.pid = b2) + } > pid [1] 1287562 > a Future 'a' ... [1] 1287860 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1287859 1287859 1287859 plan(list(multisession, sequential)) > plan(list(multisession, multisession)) [...] > pid [1] 1287562 > a Future 'a' ... [1] 1287962 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1287963 1287963 1287963 > plan(list(sequential, multisession)) [...] > pid [1] 1287562 > a Future 'a' ... [1] 1287562 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1287562 1288080 1288081 > plan(list(tweak(multisession, workers = 2), tweak(multisession,  +     workers = 2))) [...] > pid [1] 1287562 > a Future 'a' ... [1] 1288184 > b Future 'b' ... Future 'b1' ... Future 'b2' ...   b.pid  b1.pid  b2.pid  1288185 1288314 1288315"},{"path":"https://future.futureverse.org/index.html","id":"checking-a-future-without-blocking","dir":"","previous_headings":"Controlling How Futures are Resolved","what":"Checking A Future without Blocking","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"possible check whether future resolved without blocking. can done using resolved(f) function, takes explicit future f input. work implicit futures (examples ), can use f <- futureOf() function retrieve explicit future implicit one. example,","code":"> plan(multisession, workers = 2) > a %<-% { +     cat(\"Future 'a' ...\") +     Sys.sleep(2) +     cat(\"done\\n\") +     Sys.getpid() + } > cat(\"Waiting for 'a' to be resolved ...\\n\") Waiting for 'a' to be resolved ... > f <- futureOf(a) > count <- 1 > while (!resolved(f)) { +     cat(count, \"\\n\") +     Sys.sleep(0.2) +     count <- count + 1 + } 1  2  3  4  5  6  7  8  9  10  11  > cat(\"Waiting for 'a' to be resolved ... DONE\\n\") Waiting for 'a' to be resolved ... DONE > a Future 'a' ...done [1] 1288421"},{"path":"https://future.futureverse.org/index.html","id":"failed-futures","dir":"","previous_headings":"","what":"Failed Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Sometimes future expected. error occurs evaluating future, error propagated thrown error calling environment future value requested. example, use lazy evaluation future generates error, might see something like error thrown time value requested, , try get value generate error (output): see last call call stack gave error, can use backtrace() function(*) future, .e. (*) commonly used traceback() provide relevant information context futures. Furthermore, unfortunately possible see list calls (evaluated expressions) led error; call gave error (due limitation tryCatch() used internally).","code":"> plan(sequential) > b <- \"hello\" > a %<-% { +     cat(\"Future 'a' ...\\n\") +     log(b) + } %lazy% TRUE > cat(\"Everything is still ok although we have created a future that will fail.\\n\") Everything is still ok although we have created a future that will fail. > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function > a Future 'a' ... Error in log(b) : non-numeric argument to mathematical function In addition: Warning message: restarting interrupted promise evaluation > backtrace(a) [[1]] log(a)"},{"path":"https://future.futureverse.org/index.html","id":"globals","dir":"","previous_headings":"","what":"Globals","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"Whenever R expression evaluated asynchronously (parallel) sequentially via lazy evaluation, global (aka â€œfreeâ€) objects identified passed evaluator. need passed exactly time future created, , lazy evaluation, globals may otherwise change created resolved. asynchronous processing, reason globals need identified can exported process evaluates future. future package tries automate tasks far possible. help globals package, uses static-code inspection identify global variables. global variable identified, captured made available evaluating process. Moreover, global defined package, global exported. Instead, made sure corresponding package attached future evaluated. better reflects setup main R session, also minimizes need exporting globals, saves memory also time bandwidth, especially using remote compute nodes. Finally, clarified identifying globals static code inspection alone challenging problem. always corner cases automatic identification globals fails either false globals identified (less concern) true globals missing (result run-time error possibly wrong results). Vignette â€˜Future R: Common Issues Solutionsâ€™ provides examples common cases explains avoid well help package identify globals ignore falsely identified globals. suffice, always possible manually specify global variables names (e.g.Â globals = c(\"\", \"slow_sum\")) name-value pairs (e.g.Â globals = list(= 42, slow_sum = my_sum)).","code":""},{"path":"https://future.futureverse.org/index.html","id":"constraints-when-using-implicit-futures","dir":"","previous_headings":"","what":"Constraints when using Implicit Futures","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"one limitation implicit futures exist explicit ones. explicit future just like object R can assigned anywhere/anything. instance, can create several loop assign list, e.g. possible using implicit futures. %<-% assignment operator used cases regular <- assignment operator can used. can used assign future values environments (including calling environment) much like assign(name, value, envir) works. However, can assign implicit futures environments using named indices, e.g. .list(v) blocks futures environment v resolved. values collected returned regular list. numeric indices required, list environments can used. List environments, implemented listenv package, regular environments customized subsetting operators making possible index much like lists can indexed. using list environments otherwise use lists, can also assign implicit futures list-like objects using numeric indices. example, previously, .list(v) blocks futures resolved.","code":"> plan(multisession, workers = 2) > f <- list() > for (ii in 1:3) { +     f[[ii]] <- future({ +         Sys.getpid() +     }) + } > v <- lapply(f, FUN = value) > str(v) List of 3  $ : int 1288542  $ : int 1288543  $ : int 1288543 > plan(multisession, workers = 2) > v <- new.env() > for (name in c(\"a\", \"b\", \"c\")) { +     v[[name]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ a: int 1288542  $ b: int 1288543  $ c: int 1288542 > library(listenv) > plan(multisession, workers = 2) > v <- listenv() > for (ii in 1:3) { +     v[[ii]] %<-% { +         Sys.getpid() +     } + } > v <- as.list(v) > str(v) List of 3  $ : int 1288542  $ : int 1288543  $ : int 1288542"},{"path":"https://future.futureverse.org/index.html","id":"demos","dir":"","previous_headings":"","what":"Demos","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"see live illustration different types futures evaluated, run Mandelbrot demo package. First, try sequential evaluation, resembles script run futures used. , try multisession evaluation, calculates different Mandelbrot planes using parallel R processes running background. Try, Finally, access multiple machines can try set cluster workers use , e.g.","code":"library(future) plan(sequential) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(multisession) demo(\"mandelbrot\", package = \"future\", ask = FALSE) plan(cluster, workers = c(\"n2\", \"n5\", \"n6\", \"n6\", \"n9\")) demo(\"mandelbrot\", package = \"future\", ask = FALSE)"},{"path":"https://future.futureverse.org/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"R package future available CRAN can installed R :","code":"install.packages(\"future\")"},{"path":"https://future.futureverse.org/index.html","id":"pre-release-version","dir":"","previous_headings":"Installation","what":"Pre-release version","title":"Unified Parallel and Distributed Processing in R for Everyone","text":"install pre-release version available Git branch develop GitHub, use: install package source.","code":"remotes::install_github(\"futureverse/future\", ref=\"develop\")"},{"path":"https://future.futureverse.org/reference/Future-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A future represents a value that will be available at some point in the future â€” Future-class","title":"A future represents a value that will be available at some point in the future â€” Future-class","text":"future abstraction value may available point future.  future can either unresolved resolved, state can checked resolved().  long unresolved, value available.  soon resolved, value available via value().","code":""},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A future represents a value that will be available at some point in the future â€” Future-class","text":"","code":"Future(   expr = NULL,   envir = parent.frame(),   substitute = TRUE,   stdout = TRUE,   conditions = \"condition\",   globals = list(),   packages = NULL,   seed = FALSE,   lazy = FALSE,   label = NULL,   ... )"},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A future represents a value that will be available at some point in the future â€” Future-class","text":"expr R expression. envir environment global objects identified. substitute TRUE, argument expr substitute():d, otherwise . stdout TRUE (default), standard output captured, re-outputted value() called. FALSE, output silenced (sinking null device outputted). Using stdout = structure(TRUE, drop = TRUE) causes captured standard output dropped future object soon relayed. can help decrease overall memory consumed captured output across futures. Using stdout = NA fully avoids intercepting standard output; behavior unhandled standard output depends future backend. conditions character string condition classes captured relayed.  default relay conditions, including messages warnings.  drop conditions, use conditions = character(0). Errors always relayed. Attribute exclude can used ignore specific classes, e.g. conditions = structure(\"condition\", exclude = \"message\") capture condition classes except inherit message class. Using conditions = structure(..., drop = TRUE) causes captured conditions dropped future object soon relayed, e.g. value(f). can help decrease overall memory consumed captured conditions across futures. Using conditions = NULL (recommended) avoids intercepting conditions, except errors; behavior unhandled conditions depends future backend environment R runs. globals (optional) logical, character vector, named list control globals handled. details, see section 'Globals used future expressions' help future(). packages (optional) character vector specifying packages attached R environment evaluating future. seed (optional) TRUE, random seed, , state random number generator (RNG) set statistically sound random numbers produced (also parallelization). FALSE (default), assumed future expression neither needs uses random number generation. use fixed random seed, specify L'Ecuyer-CMRG seed (seven integers) regular RNG seed (single integer).  latter, L'Ecuyer-CMRG seed automatically created based given seed. Furthermore, FALSE, future monitored make sure use random numbers.  depending value option future.rng.onMisuse, check ignored, informative warning, error produced. seed NULL, effect seed = FALSE without RNG check performed. lazy FALSE (default), future resolved eagerly (starting immediately), otherwise . label character string label attached future. ... Additional named elements future.","code":""},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A future represents a value that will be available at some point in the future â€” Future-class","text":"Future() returns object class Future.","code":""},{"path":"https://future.futureverse.org/reference/Future-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A future represents a value that will be available at some point in the future â€” Future-class","text":"Future object environment.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/FutureBackend-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure a backend that controls how and where futures are evaluated â€” FutureBackend-class","title":"Configure a backend that controls how and where futures are evaluated â€” FutureBackend-class","text":"functionality developers wish implement future backend.  End-users package developers use futureverse, need know functions. looking available future backends choose , please see 'Future R: Available Future Backends' vignette https://www.futureverse.org/backends.html.","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure a backend that controls how and where futures are evaluated â€” FutureBackend-class","text":"","code":"FutureBackend(   ...,   earlySignal = FALSE,   gc = FALSE,   maxSizeOfObjects = getOption(\"future.globals.maxSize\", +Inf),   interrupts = TRUE,   hooks = FALSE )  launchFuture(backend, future, ...)  listFutures(backend, ...)  interruptFuture(backend, future, ...)  validateFutureGlobals(backend, future, ...)  stopWorkers(backend, ...)  MultiprocessFutureBackend(   ...,   wait.timeout = getOption(\"future.wait.timeout\", 24 * 60 * 60),   wait.interval = getOption(\"future.wait.interval\", 0.01),   wait.alpha = getOption(\"future.wait.alpha\", 1.01) )  ClusterFutureBackend(   workers = availableWorkers(constraints = \"connections\"),   gc = TRUE,   earlySignal = FALSE,   interrupts = FALSE,   persistent = FALSE,   ... )  MulticoreFutureBackend(   workers = availableCores(constraints = \"multicore\"),   maxSizeOfObjects = +Inf,   ... )  SequentialFutureBackend(..., maxSizeOfObjects = +Inf)  MultisessionFutureBackend(   workers = availableCores(constraints = \"connections-16\"),   rscript_libs = .libPaths(),   interrupts = TRUE,   gc = FALSE,   earlySignal = FALSE,   ... )"},{"path":"https://future.futureverse.org/reference/FutureBackend-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure a backend that controls how and where futures are evaluated â€” FutureBackend-class","text":"earlySignal Overrides default behavior whether futures resignal (\"relay\") conditions captured soon possible, delayed, instance, value() called future. (Default: FALSE) gc Overrides default behavior whether futures trigger garbage collection via gc() parallel worker value collected worker. can help release memory sooner letting R parallel worker decided needed. Releasing memory sooner can help fit parallel workers machine limited amount total memory. (Default: FALSE) maxSizeOfObjects maximum allowed total size, bytes, objects parallel worker allows. can help protect unexpectedly large data transfers parent process parallel workers - data often transferred network, sometimes also includes internet. instance, sit home set future backend workers running remotely university company, might want use protection avoid transferring giga- terabytes data without noticing. (Default: \\(500 \\cdot 1024^2\\) bytes = 500 MiB, unless overridden FutureBackend subclass, R option future.globals.maxSize (sic!)) interrupts FALSE, attempts interrupt futures take place backend, even backend supports . useful , instance, takes long time interrupt future. backend FutureBackend. future Future started. wait.timeout Number seconds timing . wait.interval Baseline number seconds retries. wait.alpha Scale factor increasing waiting interval attempt. workers ... persistent (deprecated) ... ... (optional) used.","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure a backend that controls how and where futures are evaluated â€” FutureBackend-class","text":"FutureBackend() returns FutureBackend object, inherits environment. Specific future backends defined subclasses implementing FutureBackend API. launchFuture() returns launched Future object. interruptFuture() returns interrupted Future object, supported, unmodified future. stopWorkers() returns TRUE workers shut , otherwise FALSE.","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Configure a backend that controls how and where futures are evaluated â€” FutureBackend-class","text":"ClusterFutureBackend selected plan(cluster, workers = workers). MulticoreFutureBackend backend selected plan(multicore, workers = workers). SequentialFutureBackend selected plan(sequential). MultisessionFutureBackend backend selected plan(multisession, workers = workers).","code":""},{"path":"https://future.futureverse.org/reference/FutureBackend-class.html","id":"the-futurebackend-api","dir":"Reference","previous_headings":"","what":"The FutureBackend API","title":"Configure a backend that controls how and where futures are evaluated â€” FutureBackend-class","text":"FutureBackend class specifies FutureBackend API, backends must implement comply . Specifically,","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":null,"dir":"Reference","previous_headings":"","what":"A condition (message, warning, or error) that occurred while orchestrating a future â€” FutureCondition","title":"A condition (message, warning, or error) that occurred while orchestrating a future â€” FutureCondition","text":"orchestrating (creating, launching, querying, collection) futures, unexpected run-time errors (types conditions) may occur.  conditions coerced corresponding FutureCondition class help distinguish conditions occur due evaluation future.","code":""},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A condition (message, warning, or error) that occurred while orchestrating a future â€” FutureCondition","text":"","code":"FutureCondition(   message,   call = NULL,   by = session_uuid(),   when = NULL,   uuid = future[[\"uuid\"]],   label = future[[\"label\"]],   future = NULL,   drop = FALSE )  FutureMessage(   message,   call = NULL,   ...,   uuid = future[[\"uuid\"]],   future = NULL )  FutureWarning(   message,   call = NULL,   ...,   uuid = future[[\"uuid\"]],   future = NULL )  FutureError(message, call = NULL, ..., uuid = future[[\"uuid\"]], future = NULL)  RngFutureCondition(   message = NULL,   call = NULL,   ...,   uuid = future[[\"uuid\"]],   future = NULL )  RngFutureWarning(...)  RngFutureError(...)  UnexpectedFutureResultError(future, hint = NULL)  GlobalEnvMisuseFutureCondition(   message = NULL,   call = NULL,   ...,   differences = NULL,   uuid = future[[\"uuid\"]],   future = NULL )  GlobalEnvMisuseFutureWarning(...)  GlobalEnvMisuseFutureError(...)  ConnectionMisuseFutureCondition(   message = NULL,   call = NULL,   ...,   differences = NULL,   uuid = future[[\"uuid\"]],   future = NULL )  ConnectionMisuseFutureWarning(...)  ConnectionMisuseFutureError(...)  DeviceMisuseFutureCondition(   message = NULL,   call = NULL,   ...,   differences = NULL,   uuid = future[[\"uuid\"]],   future = NULL )  DeviceMisuseFutureWarning(...)  DeviceMisuseFutureError(...)  DefaultDeviceMisuseFutureCondition(   message = NULL,   call = NULL,   ...,   incidents = NULL,   uuid = future[[\"uuid\"]],   future = NULL )  DefaultDeviceMisuseFutureWarning(...)  DefaultDeviceMisuseFutureError(...)  FutureLaunchError(..., future = NULL)  FutureInterruptError(   message = \"A future was interrupted\",   when = Sys.time(),   future = NULL )  FutureCanceledError(..., future = NULL)  FutureDroppedError(..., future = NULL)  FutureJournalCondition(   message,   journal,   call = NULL,   uuid = future[[\"uuid\"]],   future = NULL )"},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A condition (message, warning, or error) that occurred while orchestrating a future â€” FutureCondition","text":"message message condition. call (optional) call stack led condition. (optional) session UUID object. (optional) POSIXct timestamp condition created. uuid (optional) universally unique identifier future associated FutureCondition. label (optional) future label. future (optional) Future involved. drop TRUE, future argument used populate future metadata, stored condition object created. hint (optional) string suggestion might wrong.","code":""},{"path":"https://future.futureverse.org/reference/FutureCondition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A condition (message, warning, or error) that occurred while orchestrating a future â€” FutureCondition","text":"object class FutureCondition inherits class condition FutureMessage, FutureWarning, FutureError inherits FutureCondition. Moreover, FutureError inherits error, FutureWarning warning, FutureMessage message.","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":null,"dir":"Reference","previous_headings":"","what":"A representation of a set of globals used with futures â€” FutureGlobals","title":"A representation of a set of globals used with futures â€” FutureGlobals","text":"representation set globals used futures","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A representation of a set of globals used with futures â€” FutureGlobals","text":"","code":"FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)"},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A representation of a set of globals used with futures â€” FutureGlobals","text":"object named list. resolved logical indicating whether globals scanned resolved futures . total_size total size globals, known. ... used.","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A representation of a set of globals used with futures â€” FutureGlobals","text":"object class FutureGlobals.","code":""},{"path":"https://future.futureverse.org/reference/FutureGlobals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A representation of a set of globals used with futures â€” FutureGlobals","text":"class extends Globals class adding attributes resolved total_size.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":null,"dir":"Reference","previous_headings":"","what":"Results from resolving a future â€” FutureResult","title":"Results from resolving a future â€” FutureResult","text":"Results resolving future","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results from resolving a future â€” FutureResult","text":"","code":"FutureResult(   value = NULL,   visible = TRUE,   stdout = NULL,   conditions = NULL,   rng = FALSE,   ...,   uuid = NULL,   started = .POSIXct(NA_real_),   finished = Sys.time(),   version = \"1.8\" )  # S3 method for class 'FutureResult' as.character(x, ...)  # S3 method for class 'FutureResult' print(x, ...)"},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Results from resolving a future â€” FutureResult","text":"value value future expression. expression fully resolved (e.g. error) occurred, value NULL. visible TRUE, value visible, otherwise invisible. conditions list zero list elements containing captured condition possibly meta data call stack timestamp. rng TRUE, .Random.seed updated resolving future, otherwise . started, finished POSIXct timestamps evaluation future expression started finished. version version format results. ... (optional) Additional named results returned.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Results from resolving a future â€” FutureResult","text":"object class FutureResult.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Results from resolving a future â€” FutureResult","text":"function part backend Future API. function part frontend Future API.","code":""},{"path":"https://future.futureverse.org/reference/FutureResult.html","id":"note-to-developers","dir":"Reference","previous_headings":"","what":"Note to developers","title":"Results from resolving a future â€” FutureResult","text":"FutureResult structure development may change anytime, e.g. elements may renamed removed.  , please avoid accessing elements directly code.  Feel free reach need code.","code":""},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process â€” MultiprocessFuture-class","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process â€” MultiprocessFuture-class","text":"multiprocess future future whose value resolved asynchronously parallel process","code":""},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process â€” MultiprocessFuture-class","text":"","code":"MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)"},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process â€” MultiprocessFuture-class","text":"expr R expression. substitute TRUE, argument expr substitute():d, otherwise . envir environment global objects identified. ... Additional named elements passed Future().","code":""},{"path":"https://future.futureverse.org/reference/MultiprocessFuture-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process â€” MultiprocessFuture-class","text":"MultiprocessFuture() returns object class MultiprocessFuture.","code":""},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"An uniprocess future is a future whose value will be resolved synchronously in the current process â€” UniprocessFuture-class","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process â€” UniprocessFuture-class","text":"uniprocess future future whose value resolved synchronously current process","code":""},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process â€” UniprocessFuture-class","text":"","code":"UniprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)"},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process â€” UniprocessFuture-class","text":"expr R expression. substitute TRUE, argument expr substitute():d, otherwise . envir environment global objects identified. ... Additional named elements passed Future().","code":""},{"path":"https://future.futureverse.org/reference/UniprocessFuture-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"An uniprocess future is a future whose value will be resolved synchronously in the current process â€” UniprocessFuture-class","text":"UniprocessFuture() returns object class UniprocessFuture.","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Back trace the expressions evaluated when an error was caught â€” backtrace","title":"Back trace the expressions evaluated when an error was caught â€” backtrace","text":"Back trace expressions evaluated error caught","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Back trace the expressions evaluated when an error was caught â€” backtrace","text":"","code":"backtrace(future, envir = parent.frame(), ...)"},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Back trace the expressions evaluated when an error was caught â€” backtrace","text":"future future caught error. envir environment locate future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Back trace the expressions evaluated when an error was caught â€” backtrace","text":"list future's call stack led error.","code":""},{"path":"https://future.futureverse.org/reference/backtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Back trace the expressions evaluated when an error was caught â€” backtrace","text":"","code":"my_log <- function(x) log(x) foo <- function(...) my_log(...)  f <- future({ foo(\"a\") }) res <- tryCatch({   v <- value(f) }, error = function(ex) {   t <- backtrace(f)   print(t) }) #> [[1]] #> base::tryCatch(base::withCallingHandlers({ #>     NULL #>     base::saveRDS(base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/hb/RtmpF6eBvg/callr-fun-3b1bfe2d2706fd\"),  #>         base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>         quote = TRUE), file = \"/tmp/hb/RtmpF6eBvg/callr-res-3b1bfe2db7296d\",  #>         compress = FALSE) #>     base::flush(base::stdout()) #>     base::flush(base::stderr()) #>     NULL #>     base::invisible() #> }, error = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/hb/RtmpF6eBvg/callr-res-3b1bfe2db7296d\",  #>             \".error\")) #>     } #> }, interrupt = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/hb/RtmpF6eBvg/callr-res-3b1bfe2db7296d\",  #>             \".error\")) #>     } #> }, callr_message = function(e) { #>     base::try(base::signalCondition(e)) #> }), error = function(e) { #>     NULL #>     if (FALSE) { #>         base::try(base::stop(e)) #>     } #>     else { #>         base::invisible() #>     } #> }, interrupt = function(e) { #>     NULL #>     if (FALSE) { #>         e #>     } #>     else { #>         base::invisible() #>     } #> }) #>  #> [[2]] #> tryCatchList(expr, classes, parentenv, handlers) #>  #> [[3]] #> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),  #>     names[nh], parentenv, handlers[[nh]]) #>  #> [[4]] #> doTryCatch(return(expr), name, parentenv, handler) #>  #> [[5]] #> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #>  #> [[6]] #> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #>  #> [[7]] #> doTryCatch(return(expr), name, parentenv, handler) #>  #> [[8]] #> base::withCallingHandlers({ #>     NULL #>     base::saveRDS(base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/hb/RtmpF6eBvg/callr-fun-3b1bfe2d2706fd\"),  #>         base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>         quote = TRUE), file = \"/tmp/hb/RtmpF6eBvg/callr-res-3b1bfe2db7296d\",  #>         compress = FALSE) #>     base::flush(base::stdout()) #>     base::flush(base::stderr()) #>     NULL #>     base::invisible() #> }, error = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/hb/RtmpF6eBvg/callr-res-3b1bfe2db7296d\",  #>             \".error\")) #>     } #> }, interrupt = function(e) { #>     { #>         callr_data <- base::as.environment(\"tools:callr\")$`__callr_data__` #>         err <- callr_data$err #>         if (FALSE) { #>             base::assign(\".Traceback\", base::.traceback(4), envir = callr_data) #>             utils::dump.frames(\"__callr_dump__\") #>             base::assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,  #>                 envir = callr_data) #>             base::rm(\"__callr_dump__\", envir = .GlobalEnv) #>         } #>         e <- err$process_call(e) #>         e2 <- err$new_error(\"error in callr subprocess\") #>         class <- base::class #>         class(e2) <- base::c(\"callr_remote_error\", class(e2)) #>         e2 <- err$add_trace_back(e2) #>         cut <- base::which(e2$trace$scope == \"global\")[1] #>         if (!base::is.na(cut)) { #>             e2$trace <- e2$trace[-(1:cut), ] #>         } #>         base::saveRDS(base::list(\"error\", e2, e), file = base::paste0(\"/tmp/hb/RtmpF6eBvg/callr-res-3b1bfe2db7296d\",  #>             \".error\")) #>     } #> }, callr_message = function(e) { #>     base::try(base::signalCondition(e)) #> }) #>  #> [[9]] #> base::saveRDS(base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/hb/RtmpF6eBvg/callr-fun-3b1bfe2d2706fd\"),  #>     base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>     quote = TRUE), file = \"/tmp/hb/RtmpF6eBvg/callr-res-3b1bfe2db7296d\",  #>     compress = FALSE) #>  #> [[10]] #> base::do.call(base::do.call, base::c(base::readRDS(\"/tmp/hb/RtmpF6eBvg/callr-fun-3b1bfe2d2706fd\"),  #>     base::list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,  #>     quote = TRUE) #>  #> [[11]] #> (function (what, args, quote = FALSE, envir = parent.frame())  #> { #>     if (!is.list(args))  #>         stop(\"second argument must be a list\") #>     if (quote)  #>         args <- lapply(args, enquote) #>     .Internal(do.call(what, args, envir)) #> })(base::quote(function (..., cli_colors, hyperlinks)  #> { #>     options(cli.num_colors = cli_colors, cli.hyperlink = hyperlinks,  #>         cli.hyperlink_run = hyperlinks) #>     pkgdown::build_site(...) #> }), base::quote(list(pkg = list(package = \"future\", version = \"1.69.0-9002\",  #>     src_path = \"/tmp/hb/RtmpF6eBvg/future\", meta = list(url = \"https://future.futureverse.org\",  #>         home = list(links = list(list(text = \"Roadmap/Milestones\",  #>             href = \"https://github.com/futureverse/future/milestones\"),  #>             list(text = \"The Futureverse Project\", href = \"https://www.futureverse.org/\"),  #>             list(text = \"Futureverse User Forum\", href = \"https://github.com/futureverse/future/discussions\"))),  #>         navbar = list(structure = list(right = c(\"search\", \"futureverse\",  #>         \"pkgs\", \"cran\", \"github\", \"lightswitch\")), components = list( #>             futureverse = list(icon = \"fas fa-home\", href = \"https://www.futureverse.org/\"),  #>             pkgs = list(text = \"Packages\", menu = list(list(text = \"doFuture (map-reduce)\",  #>                 href = \"https://doFuture.futureverse.org\"), list( #>                 text = \"furrr (map-reduce)\", href = \"https://furrr.futureverse.org\"),  #>                 list(text = \"future\", href = \"https://future.futureverse.org\"),  #>                 list(text = \"future.apply (map-reduce)\", href = \"https://future.apply.futureverse.org\"),  #>                 list(text = \"future.batchtools (backend)\", href = \"https://future.batchtools.futureverse.org\"),  #>                 list(text = \"future.callr (backend)\", href = \"https://future.callr.futureverse.org\"),  #>                 list(text = \"future.mirai (backend)\", href = \"https://future.mirai.futureverse.org\"),  #>                 list(text = \"future.tests\", href = \"https://future.tests.futureverse.org\"),  #>                 list(text = \"futurize (map-reduce)\", href = \"https://futurize.futureverse.org\"),  #>                 list(text = \"globals\", href = \"https://globals.futureverse.org\"),  #>                 list(text = \"listenv\", href = \"https://listenv.futureverse.org\"),  #>                 list(text = \"parallelly\", href = \"https://parallelly.futureverse.org\"),  #>                 list(text = \"progressr\", href = \"https://progressr.futureverse.org\"),  #>                 list(text = \"future.tools (experimental)\", href = \"https://future.tools.futureverse.org\"),  #>                 list(text = \"marshal (experimental)\", href = \"https://marshal.futureverse.org\"))),  #>             cran = list(icon = \"fab fa-r-project\", href = \"https://cloud.r-project.org/package=future\"))),  #>         search = list(exclude = \"README_ja.md\"), template = list( #>             params = list(docsearch = list(api_key = \"aa6e02fc501886fb0f7c91ac4e300456\",  #>                 index_name = \"futureverse\", algoliaOptions = list( #>                   facetFilters = \"project:future\")), ganalytics = \"G-SB3EQSD9FR\"),  #>             bootstrap = 5L, `light-switch` = TRUE)), desc = <environment>,  #>     bs_version = 5L, development = list(destination = \"dev\",  #>         mode = \"default\", version_label = \"muted\", in_dev = FALSE,  #>         prefix = \"\"), prefix = \"\", dst_path = \"/tmp/hb/RtmpF6eBvg/future/docs\",  #>     lang = \"en-US\", install_metadata = FALSE, figures = list( #>         dev = \"ragg::agg_png\", dpi = 96L, dev.args = list(),  #>         fig.ext = \"png\", fig.width = 7.29166666666667, fig.height = NULL,  #>         fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL,  #>         other.parameters = list()), repo = list(url = list(home = \"https://github.com/futureverse/future/\",  #>         source = \"https://github.com/futureverse/future/blob/HEAD/\",  #>         issue = \"https://github.com/futureverse/future/issues/\",  #>         user = \"https://github.com/\")), topics = list(name = c(`Future-class.Rd` = \"Future-class\",  #>     `FutureBackend-class.Rd` = \"FutureBackend-class\", FutureCondition.Rd = \"FutureCondition\",  #>     FutureGlobals.Rd = \"FutureGlobals\", FutureResult.Rd = \"FutureResult\",  #>     `MultiprocessFuture-class.Rd` = \"MultiprocessFuture-class\",  #>     `UniprocessFuture-class.Rd` = \"UniprocessFuture-class\", backtrace.Rd = \"backtrace\",  #>     cancel.Rd = \"cancel\", cluster.Rd = \"cluster\", clusterExportSticky.Rd = \"clusterExportSticky\",  #>     find_references.Rd = \"find_references\", future.Rd = \"future\",  #>     futureAssign.Rd = \"futureAssign\", futureOf.Rd = \"futureOf\",  #>     futureSessionInfo.Rd = \"futureSessionInfo\", futures.Rd = \"futures\",  #>     getExpression.Rd = \"getExpression\", getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>     makeClusterFuture.Rd = \"makeClusterFuture\", mandelbrot.Rd = \"mandelbrot\",  #>     multicore.Rd = \"multicore\", multisession.Rd = \"multisession\",  #>     nbrOfWorkers.Rd = \"nbrOfWorkers\", nullcon.Rd = \"nullcon\",  #>     plan.Rd = \"plan\", private_length.Rd = \".length\", `re-exports.Rd` = \"re-exports\",  #>     readImmediateConditions.Rd = \"readImmediateConditions\", requestCore.Rd = \"requestCore\",  #>     reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\", resolve.Rd = \"resolve\",  #>     resolved.Rd = \"resolved.ClusterFuture\", result.Rd = \"result.Future\",  #>     run.Rd = \"run.Future\", save_rds.Rd = \"save_rds\", sequential.Rd = \"sequential\",  #>     sessionDetails.Rd = \"sessionDetails\", signalConditions.Rd = \"signalConditions\",  #>     sticky_globals.Rd = \"sticky_globals\", usedCores.Rd = \"usedCores\",  #>     value.Rd = \"value\", `zzz-future.options.Rd` = \"zzz-future.options\" #>     ), file_in = c(\"Future-class.Rd\", \"FutureBackend-class.Rd\",  #>     \"FutureCondition.Rd\", \"FutureGlobals.Rd\", \"FutureResult.Rd\",  #>     \"MultiprocessFuture-class.Rd\", \"UniprocessFuture-class.Rd\",  #>     \"backtrace.Rd\", \"cancel.Rd\", \"cluster.Rd\", \"clusterExportSticky.Rd\",  #>     \"find_references.Rd\", \"future.Rd\", \"futureAssign.Rd\", \"futureOf.Rd\",  #>     \"futureSessionInfo.Rd\", \"futures.Rd\", \"getExpression.Rd\",  #>     \"getGlobalsAndPackages.Rd\", \"makeClusterFuture.Rd\", \"mandelbrot.Rd\",  #>     \"multicore.Rd\", \"multisession.Rd\", \"nbrOfWorkers.Rd\", \"nullcon.Rd\",  #>     \"plan.Rd\", \"private_length.Rd\", \"re-exports.Rd\", \"readImmediateConditions.Rd\",  #>     \"requestCore.Rd\", \"reset.Rd\", \"resetWorkers.Rd\", \"resolve.Rd\",  #>     \"resolved.Rd\", \"result.Rd\", \"run.Rd\", \"save_rds.Rd\", \"sequential.Rd\",  #>     \"sessionDetails.Rd\", \"signalConditions.Rd\", \"sticky_globals.Rd\",  #>     \"usedCores.Rd\", \"value.Rd\", \"zzz-future.options.Rd\"), file_out = c(\"Future-class.html\",  #>     \"FutureBackend-class.html\", \"FutureCondition.html\", \"FutureGlobals.html\",  #>     \"FutureResult.html\", \"MultiprocessFuture-class.html\", \"UniprocessFuture-class.html\",  #>     \"backtrace.html\", \"cancel.html\", \"cluster.html\", \"clusterExportSticky.html\",  #>     \"find_references.html\", \"future.html\", \"futureAssign.html\",  #>     \"futureOf.html\", \"futureSessionInfo.html\", \"futures.html\",  #>     \"getExpression.html\", \"getGlobalsAndPackages.html\", \"makeClusterFuture.html\",  #>     \"mandelbrot.html\", \"multicore.html\", \"multisession.html\",  #>     \"nbrOfWorkers.html\", \"nullcon.html\", \"plan.html\", \"private_length.html\",  #>     \"re-exports.html\", \"readImmediateConditions.html\", \"requestCore.html\",  #>     \"reset.html\", \"resetWorkers.html\", \"resolve.html\", \"resolved.html\",  #>     \"result.html\", \"run.html\", \"save_rds.html\", \"sequential.html\",  #>     \"sessionDetails.html\", \"signalConditions.html\", \"sticky_globals.html\",  #>     \"usedCores.html\", \"value.html\", \"zzz-future.options.html\" #>     ), alias = list(`Future-class.Rd` = c(\"Future-class\", \"Future\" #>     ), `FutureBackend-class.Rd` = c(\"FutureBackend-class\", \"FutureBackend\",  #>     \"launchFuture\", \"listFutures\", \"interruptFuture\", \"validateFutureGlobals\",  #>     \"stopWorkers\", \"MultiprocessFutureBackend\", \"ClusterFutureBackend\",  #>     \"MulticoreFutureBackend\", \"SequentialFutureBackend\", \"MultisessionFutureBackend\" #>     ), FutureCondition.Rd = c(\"FutureCondition\", \"FutureMessage\",  #>     \"FutureWarning\", \"FutureError\", \"RngFutureCondition\", \"RngFutureWarning\",  #>     \"RngFutureError\", \"UnexpectedFutureResultError\", \"GlobalEnvMisuseFutureCondition\",  #>     \"GlobalEnvMisuseFutureWarning\", \"GlobalEnvMisuseFutureError\",  #>     \"ConnectionMisuseFutureCondition\", \"ConnectionMisuseFutureWarning\",  #>     \"ConnectionMisuseFutureError\", \"DeviceMisuseFutureCondition\",  #>     \"DeviceMisuseFutureWarning\", \"DeviceMisuseFutureError\", \"DefaultDeviceMisuseFutureCondition\",  #>     \"DefaultDeviceMisuseFutureWarning\", \"DefaultDeviceMisuseFutureError\",  #>     \"FutureLaunchError\", \"FutureInterruptError\", \"FutureCanceledError\",  #>     \"FutureDroppedError\", \"FutureJournalCondition\"), FutureGlobals.Rd = c(\"FutureGlobals\",  #>     \"as.FutureGlobals\", \"as.FutureGlobals.FutureGlobals\", \"as.FutureGlobals.Globals\",  #>     \"as.FutureGlobals.list\", \"[.FutureGlobals\", \"c.FutureGlobals\",  #>     \"unique.FutureGlobals\"), FutureResult.Rd = c(\"FutureResult\",  #>     \"as.character.FutureResult\", \"print.FutureResult\"), `MultiprocessFuture-class.Rd` = c(\"MultiprocessFuture-class\",  #>     \"MultiprocessFuture\"), `UniprocessFuture-class.Rd` = c(\"UniprocessFuture-class\",  #>     \"UniprocessFuture\"), backtrace.Rd = \"backtrace\", cancel.Rd = \"cancel\",  #>         cluster.Rd = \"cluster\", clusterExportSticky.Rd = \"clusterExportSticky\",  #>         find_references.Rd = c(\"find_references\", \"assert_no_references\" #>         ), future.Rd = c(\"future\", \"futureCall\", \"minifuture\" #>         ), futureAssign.Rd = c(\"futureAssign\", \"%<-%\", \"%->%\",  #>         \"%globals%\", \"%packages%\", \"%seed%\", \"%stdout%\", \"%conditions%\",  #>         \"%lazy%\", \"%label%\", \"%plan%\", \"%tweak%\"), futureOf.Rd = \"futureOf\",  #>         futureSessionInfo.Rd = \"futureSessionInfo\", futures.Rd = \"futures\",  #>         getExpression.Rd = c(\"getExpression\", \"getExpression.Future\" #>         ), getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>         makeClusterFuture.Rd = c(\"makeClusterFuture\", \"FUTURE\" #>         ), mandelbrot.Rd = c(\"mandelbrot\", \"as.raster.Mandelbrot\",  #>         \"plot.Mandelbrot\", \"mandelbrot_tiles\", \"mandelbrot.matrix\",  #>         \"mandelbrot.numeric\"), multicore.Rd = c(\"multicore\",  #>         \"MulticoreFuture\"), multisession.Rd = c(\"multisession\",  #>         \"MultisessionFuture\"), nbrOfWorkers.Rd = c(\"nbrOfWorkers\",  #>         \"nbrOfFreeWorkers\"), nullcon.Rd = \"nullcon\", plan.Rd = c(\"plan\",  #>         \"with.FutureStrategyList\", \"tweak\"), private_length.Rd = \".length\",  #>         `re-exports.Rd` = c(\"re-exports\", \"availableCores\", \"availableWorkers\",  #>         \"makeClusterPSOCK\", \"supportsMulticore\"), readImmediateConditions.Rd = c(\"readImmediateConditions\",  #>         \"saveImmediateCondition\"), requestCore.Rd = \"requestCore\",  #>         reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\",  #>         resolve.Rd = \"resolve\", resolved.Rd = c(\"resolved.ClusterFuture\",  #>         \"resolved.MulticoreFuture\", \"resolved\", \"resolved.default\",  #>         \"resolved.list\", \"resolved.environment\", \"resolved.Future\" #>         ), result.Rd = c(\"result.Future\", \"result\"), run.Rd = c(\"run.Future\",  #>         \"run\"), save_rds.Rd = \"save_rds\", sequential.Rd = c(\"sequential\",  #>         \"uniprocess\"), sessionDetails.Rd = \"sessionDetails\",  #>         signalConditions.Rd = \"signalConditions\", sticky_globals.Rd = \"sticky_globals\",  #>         usedCores.Rd = \"usedCores\", value.Rd = c(\"value\", \"value.Future\",  #>         \"value.list\", \"value.listenv\", \"value.environment\"),  #>         `zzz-future.options.Rd` = c(\"zzz-future.options\", \"future.options\",  #>         \"future.startup.script\", \"future.debug\", \"future.demo.mandelbrot.region\",  #>         \"future.demo.mandelbrot.nrow\", \"future.fork.multithreading.enable\",  #>         \"future.globals.maxSize\", \"future.globals.method\", \"future.globals.onMissing\",  #>         \"future.globals.resolve\", \"future.globals.onReference\",  #>         \"future.plan\", \"future.onFutureCondition.keepFuture\",  #>         \"future.resolve.recursive\", \"future.connections.onMisuse\",  #>         \"future.defaultDevice.onMisuse\", \"future.devices.onMisuse\",  #>         \"future.globalenv.onMisuse\", \"future.rng.onMisuse\", \"future.wait.alpha\",  #>         \"future.wait.interval\", \"future.wait.timeout\", \"future.output.windows.reencode\",  #>         \"future.journal\", \"future.globals.objectSize.method\",  #>         \"future.ClusterFuture.clusterEvalQ\", \"R_FUTURE_STARTUP_SCRIPT\",  #>         \"R_FUTURE_DEBUG\", \"R_FUTURE_DEMO_MANDELBROT_REGION\",  #>         \"R_FUTURE_DEMO_MANDELBROT_NROW\", \"R_FUTURE_FORK_MULTITHREADING_ENABLE\",  #>         \"R_FUTURE_GLOBALS_MAXSIZE\", \"R_FUTURE_GLOBALS_METHOD\",  #>         \"R_FUTURE_GLOBALS_ONMISSING\", \"R_FUTURE_GLOBALS_RESOLVE\",  #>         \"R_FUTURE_GLOBALS_ONREFERENCE\", \"R_FUTURE_PLAN\", \"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\",  #>         \"R_FUTURE_RESOLVE_RECURSIVE\", \"R_FUTURE_CONNECTIONS_ONMISUSE\",  #>         \"R_FUTURE_DEVICES_ONMISUSE\", \"R_FUTURE_DEFAULTDEVICE_ONMISUSE\",  #>         \"R_FUTURE_GLOBALENV_ONMISUSE\", \"R_FUTURE_RNG_ONMISUSE\",  #>         \"R_FUTURE_WAIT_ALPHA\", \"R_FUTURE_WAIT_INTERVAL\", \"R_FUTURE_WAIT_TIMEOUT\",  #>         \"R_FUTURE_RESOLVED_TIMEOUT\", \"R_FUTURE_OUTPUT_WINDOWS_REENCODE\",  #>         \"R_FUTURE_JOURNAL\", \"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\",  #>         \"R_FUTURE_CLUSTERFUTURE_CLUSTEREVALQ\", \"future.cmdargs\",  #>         \".future.R\")), funs = list(`Future-class.Rd` = \"Future()\",  #>         `FutureBackend-class.Rd` = c(\"FutureBackend()\", \"launchFuture()\",  #>         \"listFutures()\", \"interruptFuture()\", \"validateFutureGlobals()\",  #>         \"stopWorkers()\", \"MultiprocessFutureBackend()\", \"ClusterFutureBackend()\",  #>         \"MulticoreFutureBackend()\", \"SequentialFutureBackend()\",  #>         \"MultisessionFutureBackend()\"), FutureCondition.Rd = c(\"FutureCondition()\",  #>         \"FutureMessage()\", \"FutureWarning()\", \"FutureError()\",  #>         \"RngFutureCondition()\", \"RngFutureWarning()\", \"RngFutureError()\",  #>         \"UnexpectedFutureResultError()\", \"GlobalEnvMisuseFutureCondition()\",  #>         \"GlobalEnvMisuseFutureWarning()\", \"GlobalEnvMisuseFutureError()\",  #>         \"ConnectionMisuseFutureCondition()\", \"ConnectionMisuseFutureWarning()\",  #>         \"ConnectionMisuseFutureError()\", \"DeviceMisuseFutureCondition()\",  #>         \"DeviceMisuseFutureWarning()\", \"DeviceMisuseFutureError()\",  #>         \"DefaultDeviceMisuseFutureCondition()\", \"DefaultDeviceMisuseFutureWarning()\",  #>         \"DefaultDeviceMisuseFutureError()\", \"FutureLaunchError()\",  #>         \"FutureInterruptError()\", \"FutureCanceledError()\", \"FutureDroppedError()\",  #>         \"FutureJournalCondition()\"), FutureGlobals.Rd = \"FutureGlobals()\",  #>         FutureResult.Rd = c(\"FutureResult()\", \"as.character(<i>&lt;FutureResult&gt;<\/i>)\",  #>         \"print(<i>&lt;FutureResult&gt;<\/i>)\"), `MultiprocessFuture-class.Rd` = \"MultiprocessFuture()\",  #>         `UniprocessFuture-class.Rd` = \"UniprocessFuture()\", backtrace.Rd = \"backtrace()\",  #>         cancel.Rd = \"cancel()\", cluster.Rd = \"cluster()\", clusterExportSticky.Rd = \"clusterExportSticky()\",  #>         find_references.Rd = c(\"find_references()\", \"assert_no_references()\" #>         ), future.Rd = c(\"future()\", \"futureCall()\", \"minifuture()\" #>         ), futureAssign.Rd = c(\"futureAssign()\", \"`%&lt;-%`\",  #>         \"`%globals%`\", \"`%packages%`\", \"`%seed%`\", \"`%stdout%`\",  #>         \"`%conditions%`\", \"`%lazy%`\", \"`%label%`\", \"`%plan%`\",  #>         \"`%tweak%`\"), futureOf.Rd = \"futureOf()\", futureSessionInfo.Rd = \"futureSessionInfo()\",  #>         futures.Rd = \"futures()\", getExpression.Rd = \"getExpression()\",  #>         getGlobalsAndPackages.Rd = \"getGlobalsAndPackages()\",  #>         makeClusterFuture.Rd = \"makeClusterFuture()\", mandelbrot.Rd = \"mandelbrot()\",  #>         multicore.Rd = \"multicore()\", multisession.Rd = \"multisession()\",  #>         nbrOfWorkers.Rd = c(\"nbrOfWorkers()\", \"nbrOfFreeWorkers()\" #>         ), nullcon.Rd = \"nullcon()\", plan.Rd = c(\"plan()\", \"with(<i>&lt;FutureStrategyList&gt;<\/i>)\",  #>         \"tweak()\"), private_length.Rd = \".length()\", `re-exports.Rd` = character(0),  #>         readImmediateConditions.Rd = c(\"readImmediateConditions()\",  #>         \"saveImmediateCondition()\"), requestCore.Rd = \"requestCore()\",  #>         reset.Rd = \"reset()\", resetWorkers.Rd = \"resetWorkers()\",  #>         resolve.Rd = \"resolve()\", resolved.Rd = \"resolved()\",  #>         result.Rd = \"result(<i>&lt;Future&gt;<\/i>)\", run.Rd = \"run(<i>&lt;Future&gt;<\/i>)\",  #>         save_rds.Rd = \"save_rds()\", sequential.Rd = \"sequential()\",  #>         sessionDetails.Rd = \"sessionDetails()\", signalConditions.Rd = \"signalConditions()\",  #>         sticky_globals.Rd = \"sticky_globals()\", usedCores.Rd = \"usedCores()\",  #>         value.Rd = \"value()\", `zzz-future.options.Rd` = character(0)),  #>         title = c(`Future-class.Rd` = \"A future represents a value that will be available at some point in the future\",  #>         `FutureBackend-class.Rd` = \"Configure a backend that controls how and where futures are evaluated\",  #>         FutureCondition.Rd = \"A condition (message, warning, or error) that occurred while orchestrating a future\",  #>         FutureGlobals.Rd = \"A representation of a set of globals used with futures\",  #>         FutureResult.Rd = \"Results from resolving a future\",  #>         `MultiprocessFuture-class.Rd` = \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\",  #>         `UniprocessFuture-class.Rd` = \"An uniprocess future is a future whose value will be resolved synchronously in the current process\",  #>         backtrace.Rd = \"Back trace the expressions evaluated when an error was caught\",  #>         cancel.Rd = \"Cancel a future\", cluster.Rd = \"Create a cluster future whose value will be resolved asynchronously in a parallel process\",  #>         clusterExportSticky.Rd = \"Export globals to the sticky-globals environment of the cluster nodes\",  #>         find_references.Rd = \"Get the first or all references of an <span style=\\\"R\\\">R<\/span> object\",  #>         future.Rd = \"Create a future\", futureAssign.Rd = \"Create a future assignment\",  #>         futureOf.Rd = \"Get the future of a future variable\",  #>         futureSessionInfo.Rd = \"Get future-specific session information and validate current backend\",  #>         futures.Rd = \"Get all futures in a container\", getExpression.Rd = \"Inject code for the next type of future to use for nested futures\",  #>         getGlobalsAndPackages.Rd = \"Retrieves global variables of an expression and their associated packages\",  #>         makeClusterFuture.Rd = \"Create a Future Cluster of Stateless Workers for Parallel Processing\",  #>         mandelbrot.Rd = \"Mandelbrot convergence counts\", multicore.Rd = \"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\",  #>         multisession.Rd = \"Create a multisession future whose value will be resolved asynchronously in a parallel <span style=\\\"R\\\">R<\/span> session\",  #>         nbrOfWorkers.Rd = \"Get the number of workers available\",  #>         nullcon.Rd = \"Creates a connection to the system null device\",  #>         plan.Rd = \"Plan how to resolve a future\", private_length.Rd = \"Gets the length of an object without dispatching\",  #>         `re-exports.Rd` = \"Functions Moved to 'parallelly'\",  #>         readImmediateConditions.Rd = \"Writes and Reads 'immediateCondition' RDS Files\",  #>         requestCore.Rd = \"Request a core for multicore processing\",  #>         reset.Rd = \"Reset a finished, failed, canceled, or interrupted future to a lazy future\",  #>         resetWorkers.Rd = \"Free up active background workers\",  #>         resolve.Rd = \"Resolve one or more futures synchronously\",  #>         resolved.Rd = \"Check whether a future is resolved or not\",  #>         result.Rd = \"Get the results of a resolved future\", run.Rd = \"Run a future\",  #>         save_rds.Rd = \"Robustly Saves an Object to RDS File Atomically\",  #>         sequential.Rd = \"Create a sequential future whose value will be in the current <span style=\\\"R\\\">R<\/span> session\",  #>         sessionDetails.Rd = \"Outputs details on the current <span style=\\\"R\\\">R<\/span> session\",  #>         signalConditions.Rd = \"Signals Captured Conditions\",  #>         sticky_globals.Rd = \"Place a sticky-globals environment immediately after the global environment\",  #>         usedCores.Rd = \"Get number of cores currently used\",  #>         value.Rd = \"The value of a future or the values of all elements in a container\",  #>         `zzz-future.options.Rd` = \"Options used for futures\"),  #>         rd = list(`Future-class.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>             \"\\n\", list(\"Future-class\"), \"\\n\", list(\"Future-class\"),  #>             \"\\n\", list(\"Future\"), \"\\n\", list(\"A future represents a value that will be available at some point in the future\"),  #>             \"\\n\", list(\"\\n\", \"Future(\\n\", \"  expr = NULL,\\n\",  #>                 \"  envir = parent.frame(),\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  stdout = TRUE,\\n\", \"  conditions = \\\"condition\\\",\\n\",  #>                 \"  globals = list(),\\n\", \"  packages = NULL,\\n\",  #>                 \"  seed = FALSE,\\n\", \"  lazy = FALSE,\\n\", \"  label = NULL,\\n\",  #>                 \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                 \"expr\"), list(\"An \", list(), \" \", list(\"expression\"),  #>                 \".\")), \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The \",  #>                 list(\"environment\"), \" from where global objects should be\\n\",  #>                 \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                 list(\"If TRUE, argument \", list(\"expr\"), \" is\\n\",  #>                   list(list(\"substitute\"), \"()\"), \":d, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of condition classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherit from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as they have\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression neither\\n\",  #>                   \"needs nor uses random number generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integers)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements of the future.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"Future()\"), \" returns an object of class \",  #>                 list(\"Future\"), \".\\n\"), \"\\n\", list(\"\\n\", \"A \",  #>                 list(\"future\"), \" is an abstraction for a \",  #>                 list(\"value\"), \" that may be\\n\", \"available at some point in the future.  A future can either be\\n\",  #>                 list(\"unresolved\"), \" or \", list(\"resolved\"),  #>                 \", a state which can be checked\\n\", \"with \",  #>                 list(list(\"resolved()\")), \".  As long as it is \",  #>                 list(\"unresolved\"), \", the\\n\", \"value is not available.  As soon as it is \",  #>                 list(\"resolved\"), \", the value\\n\", \"is available via \",  #>                 list(list(\"value\"), \"()\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A Future object is itself an \", list(\"environment\"),  #>                 \".\\n\"), \"\\n\", list(\"\\n\", \"One function that creates a Future is \",  #>                 list(list(\"future()\")), \".\\n\", \"It returns a Future that evaluates an \",  #>                 list(), \" expression in the future.\\n\", \"An alternative approach is to use the \",  #>                 list(list(\"%<-%\")), \" infix\\n\", \"assignment operator, which creates a future from the\\n\",  #>                 \"right-hand-side (RHS) \", list(), \" expression and assigns its future value\\n\",  #>                 \"to a variable as a \", list(list(\"promise\")),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), `FutureBackend-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-01-FutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-03.MultiprocessFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-11.ClusterFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-11.MulticoreFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-11.SequentialFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-13.MultisessionFutureBackend-class.R\",  #>             \"\\n\", list(\"FutureBackend-class\"), \"\\n\", list(\"FutureBackend-class\"),  #>             \"\\n\", list(\"FutureBackend\"), \"\\n\", list(\"launchFuture\"),  #>             \"\\n\", list(\"listFutures\"), \"\\n\", list(\"interruptFuture\"),  #>             \"\\n\", list(\"validateFutureGlobals\"), \"\\n\", list(\"stopWorkers\"),  #>             \"\\n\", list(\"MultiprocessFutureBackend\"), \"\\n\", list( #>                 \"ClusterFutureBackend\"), \"\\n\", list(\"MulticoreFutureBackend\"),  #>             \"\\n\", list(\"SequentialFutureBackend\"), \"\\n\", list( #>                 \"MultisessionFutureBackend\"), \"\\n\", list(\"Configure a backend that controls how and where futures are evaluated\"),  #>             \"\\n\", list(\"\\n\", \"FutureBackend(\\n\", \"  ...,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  gc = FALSE,\\n\",  #>                 \"  maxSizeOfObjects = getOption(\\\"future.globals.maxSize\\\", +Inf),\\n\",  #>                 \"  interrupts = TRUE,\\n\", \"  hooks = FALSE\\n\",  #>                 \")\\n\", \"\\n\", \"launchFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"listFutures(backend, ...)\\n\", \"\\n\", \"interruptFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"validateFutureGlobals(backend, future, ...)\\n\",  #>                 \"\\n\", \"stopWorkers(backend, ...)\\n\", \"\\n\", \"MultiprocessFutureBackend(\\n\",  #>                 \"  ...,\\n\", \"  wait.timeout = getOption(\\\"future.wait.timeout\\\", 24 * 60 * 60),\\n\",  #>                 \"  wait.interval = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                 \"  wait.alpha = getOption(\\\"future.wait.alpha\\\", 1.01)\\n\",  #>                 \")\\n\", \"\\n\", \"ClusterFutureBackend(\\n\", \"  workers = availableWorkers(constraints = \\\"connections\\\"),\\n\",  #>                 \"  gc = TRUE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  interrupts = FALSE,\\n\", \"  persistent = FALSE,\\n\",  #>                 \"  ...\\n\", \")\\n\", \"\\n\", \"MulticoreFutureBackend(\\n\",  #>                 \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                 \"  maxSizeOfObjects = +Inf,\\n\", \"  ...\\n\", \")\\n\",  #>                 \"\\n\", \"SequentialFutureBackend(..., maxSizeOfObjects = +Inf)\\n\",  #>                 \"\\n\", \"MultisessionFutureBackend(\\n\", \"  workers = availableCores(constraints = \\\"connections-16\\\"),\\n\",  #>                 \"  rscript_libs = .libPaths(),\\n\", \"  interrupts = TRUE,\\n\",  #>                 \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                 \"earlySignal\"), list(\"Overrides the default behavior on whether futures\\n\",  #>                 \"should resignal (\\\"relay\\\") conditions captured as soon as possible, or\\n\",  #>                 \"delayed, for instance, until \", list(list(\"value()\")),  #>                 \" is called on the future.\\n\", \"(Default: \",  #>                 list(\"FALSE\"), \")\")), \"\\n\", \"\\n\", list(list(\"gc\"),  #>                 list(\"Overrides the default behavior of whether futures should trigger\\n\",  #>                   \"garbage collection via \", list(list(\"gc()\")),  #>                   \" on the parallel worker after the value has\\n\",  #>                   \"been collected from the worker.\\n\", \"This can help to release memory sooner than letting R itself on the parallel\\n\",  #>                   \"worker decided when it is needed. Releasing memory sooner can help to fit\\n\",  #>                   \"more parallel workers on a machine with limited amount of total memory.\\n\",  #>                   \"(Default: \", list(\"FALSE\"), \")\")), \"\\n\", \"\\n\",  #>                 list(list(\"maxSizeOfObjects\"), list(\"The maximum allowed total size, in bytes, of all\\n\",  #>                   \"objects to and from the parallel worker allows.\\n\",  #>                   \"This can help to protect against unexpectedly large data transfers between\\n\",  #>                   \"the parent process and the parallel workers - data that is often transferred\\n\",  #>                   \"over the network, which sometimes also includes the internet. For instance,\\n\",  #>                   \"if you sit at home and have set up a future backend with workers running\\n\",  #>                   \"remotely at your university or company, then you might want to use this\\n\",  #>                   \"protection to avoid transferring giga- or terabytes of data without noticing.\\n\",  #>                   \"(Default: \", list(list(\"500 \\\\cdot 1024^2\")),  #>                   \" bytes = 500 MiB, unless overridden by a\\n\",  #>                   \"FutureBackend subclass, or by R option \",  #>                   list(\"future.globals.maxSize\"), \" (sic!))\")),  #>                 \"\\n\", \"\\n\", list(list(\"interrupts\"), list(\"If FALSE, attempts to interrupt futures will not take\\n\",  #>                   \"place on this backend, even if the backend supports it. This is useful\\n\",  #>                   \"when, for instance, it takes a long time to interrupt a future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"backend\"), list(\"a \",  #>                   list(\"FutureBackend\"), \".\")), \"\\n\", \"\\n\", list( #>                   list(\"future\"), list(\"a \", list(\"Future\"),  #>                     \" to be started.\")), \"\\n\", \"\\n\", list(list( #>                   \"wait.timeout\"), list(\"Number of seconds before timing out.\")),  #>                 \"\\n\", \"\\n\", list(list(\"wait.interval\"), list( #>                   \"Baseline number of seconds between retries.\")),  #>                 \"\\n\", \"\\n\", list(list(\"wait.alpha\"), list(\"Scale factor increasing waiting interval after each\\n\",  #>                   \"attempt.\")), \"\\n\", \"\\n\", list(list(\"workers\"),  #>                   list(\"...\")), \"\\n\", \"\\n\", list(list(\"persistent\"),  #>                   list(\"(deprecated) ...\")), \"\\n\", \"\\n\", list( #>                   list(list()), list(\"(optional) not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"FutureBackend()\"),  #>                 \" returns a FutureBackend object, which inherits an\\n\",  #>                 \"environment. Specific future backends are defined by subclasses\\n\",  #>                 \"implementing the FutureBackend API.\\n\", \"\\n\",  #>                 list(\"launchFuture()\"), \" returns the launched \",  #>                 list(\"Future\"), \" object.\\n\", \"\\n\", list(\"interruptFuture()\"),  #>                 \" returns the interrupted \", list(\"Future\"),  #>                 \" object,\\n\", \"if supported, other the unmodified future.\\n\",  #>                 \"\\n\", list(\"stopWorkers()\"), \" returns TRUE if the workers were shut down,\\n\",  #>                 \"otherwise FALSE.\\n\"), \"\\n\", list(\"\\n\", list( #>                 \"This functionality is only for developers who wish to implement their\\n\",  #>                 \"own future backend.  End-users and package developers use futureverse,\\n\",  #>                 \"does not need to know about these functions.\"),  #>                 \"\\n\", \"\\n\", \"If you are looking for available future backends to choose from, please\\n\",  #>                 \"see the 'A Future for R: Available Future Backends' vignette and\\n\",  #>                 list(\"https://www.futureverse.org/backends.html\"),  #>                 \".\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"ClusterFutureBackend\"),  #>                 \" is selected by\\n\", list(\"plan(cluster, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MulticoreFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multicore, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"SequentialFutureBackend\"),  #>                 \" is selected by \", list(\"plan(sequential)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MultisessionFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multisession, workers = workers)\"),  #>                 \".\\n\"), \"\\n\", list(list(\"The FutureBackend API\"),  #>                 list(\"\\n\", \"\\n\", \"The \", list(\"FutureBackend\"),  #>                   \" class specifies FutureBackend API,\\n\", \"that all backends must implement and comply to. Specifically,\\n\")),  #>             \"\\n\", \"\\n\", list(\"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                 \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                 \".\\n\", \"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                 \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureCondition.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureCondition-class.R,\",  #>             \"\\n\", \"%   R/protected_api-journal.R\", \"\\n\", list( #>                 \"FutureCondition\"), \"\\n\", list(\"FutureCondition\"),  #>             \"\\n\", list(\"FutureMessage\"), \"\\n\", list(\"FutureWarning\"),  #>             \"\\n\", list(\"FutureError\"), \"\\n\", list(\"RngFutureCondition\"),  #>             \"\\n\", list(\"RngFutureWarning\"), \"\\n\", list(\"RngFutureError\"),  #>             \"\\n\", list(\"UnexpectedFutureResultError\"), \"\\n\",  #>             list(\"GlobalEnvMisuseFutureCondition\"), \"\\n\", list( #>                 \"GlobalEnvMisuseFutureWarning\"), \"\\n\", list(\"GlobalEnvMisuseFutureError\"),  #>             \"\\n\", list(\"ConnectionMisuseFutureCondition\"), \"\\n\",  #>             list(\"ConnectionMisuseFutureWarning\"), \"\\n\", list( #>                 \"ConnectionMisuseFutureError\"), \"\\n\", list(\"DeviceMisuseFutureCondition\"),  #>             \"\\n\", list(\"DeviceMisuseFutureWarning\"), \"\\n\", list( #>                 \"DeviceMisuseFutureError\"), \"\\n\", list(\"DefaultDeviceMisuseFutureCondition\"),  #>             \"\\n\", list(\"DefaultDeviceMisuseFutureWarning\"), \"\\n\",  #>             list(\"DefaultDeviceMisuseFutureError\"), \"\\n\", list( #>                 \"FutureLaunchError\"), \"\\n\", list(\"FutureInterruptError\"),  #>             \"\\n\", list(\"FutureCanceledError\"), \"\\n\", list(\"FutureDroppedError\"),  #>             \"\\n\", list(\"FutureJournalCondition\"), \"\\n\", list( #>                 \"A condition (message, warning, or error) that occurred while orchestrating a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureCondition(\\n\", \"  message,\\n\",  #>                 \"  call = NULL,\\n\", \"  by = session_uuid(),\\n\",  #>                 \"  when = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  label = future[[\\\"label\\\"]],\\n\", \"  future = NULL,\\n\",  #>                 \"  drop = FALSE\\n\", \")\\n\", \"\\n\", \"FutureMessage(\\n\",  #>                 \"  message,\\n\", \"  call = NULL,\\n\", \"  ...,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"FutureWarning(\\n\", \"  message,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\", \"\\n\", \"FutureError(message, call = NULL, ..., uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"RngFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\", \"\\n\", \"RngFutureWarning(...)\\n\",  #>                 \"\\n\", \"RngFutureError(...)\\n\", \"\\n\", \"UnexpectedFutureResultError(future, hint = NULL)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"GlobalEnvMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"ConnectionMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"ConnectionMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"ConnectionMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"DeviceMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"DeviceMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"DeviceMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"DefaultDeviceMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  incidents = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"DefaultDeviceMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"DefaultDeviceMisuseFutureError(...)\\n\",  #>                 \"\\n\", \"FutureLaunchError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureInterruptError(\\n\", \"  message = \\\"A future was interrupted\\\",\\n\",  #>                 \"  when = Sys.time(),\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"FutureCanceledError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureDroppedError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureJournalCondition(\\n\", \"  message,\\n\",  #>                 \"  journal,\\n\", \"  call = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\"), \"\\n\", list(\"\\n\",  #>                 list(list(\"message\"), list(\"A message condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"call\"), list(\"(optional) The call stack that led up to the condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"by\"), list(\"(optional) A session UUID object.\")),  #>                 \"\\n\", \"\\n\", list(list(\"when\"), list(\"(optional) A \",  #>                   list(\"POSIXct\"), \" timestamp for when the condition was\\n\",  #>                   \"created.\")), \"\\n\", \"\\n\", list(list(\"uuid\"),  #>                   list(\"(optional) A universally unique identifier for the future\\n\",  #>                     \"associated with this FutureCondition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"label\"), list(\"(optional) A future label.\")),  #>                 \"\\n\", \"\\n\", list(list(\"future\"), list(\"(optional) The \",  #>                   list(\"Future\"), \" involved.\")), \"\\n\", \"\\n\",  #>                 list(list(\"drop\"), list(\"If TRUE, the \", list( #>                   \"future\"), \" argument is only used to populate\\n\",  #>                   \"future metadata, but is not stored in the condition object created.\")),  #>                 \"\\n\", \"\\n\", list(list(\"hint\"), list(\"(optional) A string with a suggestion on what might be wrong.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureCondition which inherits from class\\n\",  #>                 list(\"condition\"), \" and FutureMessage, FutureWarning,\\n\",  #>                 \"and FutureError all inherits from FutureCondition.\\n\",  #>                 \"Moreover, a FutureError inherits from \", list( #>                   \"error\"), \",\\n\", \"a FutureWarning from \", list( #>                   \"warning\"), \", and\\n\", \"a FutureMessage from \",  #>                 list(\"message\"), \".\\n\"), \"\\n\", list(\"\\n\", \"While \",  #>                 list(\"orchestrating\"), \" (creating, launching, querying, collection)\\n\",  #>                 \"futures, unexpected run-time errors (and other types of conditions) may\\n\",  #>                 \"occur.  Such conditions are coerced to a corresponding FutureCondition\\n\",  #>                 \"class to help distinguish them from conditions that occur due to the\\n\",  #>                 list(\"evaluation\"), \" of the future.\\n\"), \"\\n\",  #>             list(\"internal\"), \"\\n\"), FutureGlobals.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureGlobals-class.R\",  #>             \"\\n\", list(\"FutureGlobals\"), \"\\n\", list(\"FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals\"), \"\\n\", list(\"as.FutureGlobals.FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals.Globals\"), \"\\n\", list( #>                 \"as.FutureGlobals.list\"), \"\\n\", list(\"[.FutureGlobals\"),  #>             \"\\n\", list(\"c.FutureGlobals\"), \"\\n\", list(\"unique.FutureGlobals\"),  #>             \"\\n\", list(\"A representation of a set of globals used with futures\"),  #>             \"\\n\", list(\"\\n\", \"FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"A named list.\")),  #>                 \"\\n\", \"\\n\", list(list(\"resolved\"), list(\"A logical indicating whether these globals\\n\",  #>                   \"have been scanned for and resolved futures or not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"total_size\"), list(\"The total size of all globals, if known.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class \",  #>                 list(\"FutureGlobals\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A representation of a set of globals used with futures\\n\"),  #>             \"\\n\", list(\"\\n\", \"This class extends the \", list( #>                 \"Globals\"), \" class by adding\\n\", \"attributes \",  #>                 list(\"resolved\"), \" and \", list(\"total_size\"),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureResult.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureResult-class.R\",  #>             \"\\n\", list(\"FutureResult\"), \"\\n\", list(\"FutureResult\"),  #>             \"\\n\", list(\"as.character.FutureResult\"), \"\\n\", list( #>                 \"print.FutureResult\"), \"\\n\", list(\"Results from resolving a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureResult(\\n\", \"  value = NULL,\\n\",  #>                 \"  visible = TRUE,\\n\", \"  stdout = NULL,\\n\",  #>                 \"  conditions = NULL,\\n\", \"  rng = FALSE,\\n\",  #>                 \"  ...,\\n\", \"  uuid = NULL,\\n\", \"  started = .POSIXct(NA_real_),\\n\",  #>                 \"  finished = Sys.time(),\\n\", \"  version = \\\"1.8\\\"\\n\",  #>                 \")\\n\", \"\\n\", list(list(\"as.character\"), list( #>                   \"FutureResult\")), \"(x, ...)\\n\", \"\\n\", list( #>                   list(\"print\"), list(\"FutureResult\")), \"(x, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"value\"), list(\"The value of the future expression.\\n\",  #>                 \"If the expression was not fully resolved (e.g. an error) occurred,\\n\",  #>                 \"the the value is \", list(\"NULL\"), \".\")), \"\\n\",  #>                 \"\\n\", list(list(\"visible\"), list(\"If TRUE, the value was visible, otherwise invisible.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A list of zero or more list elements each containing\\n\",  #>                   \"a captured \", list(\"condition\"), \" and possibly more meta data such as the\\n\",  #>                   \"call stack and a timestamp.\")), \"\\n\", \"\\n\",  #>                 list(list(\"rng\"), list(\"If TRUE, the \", list( #>                   \".Random.seed\"), \" was updated from resolving the\\n\",  #>                   \"future, otherwise not.\")), \"\\n\", \"\\n\", list( #>                   list(\"started, finished\"), list(list(\"POSIXct\"),  #>                     \" timestamps\\n\", \"when the evaluation of the future expression was started and finished.\")),  #>                 \"\\n\", \"\\n\", list(list(\"version\"), list(\"The version format of the results.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional named results to be returned.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureResult.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Results from resolving a future\\n\"),  #>             \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                 list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                 list(\"not\"), \" part of the frontend Future API.\\n\"),  #>             \"\\n\", list(list(\"Note to developers\"), list(\"\\n\",  #>                 \"\\n\", \"The FutureResult structure is \", list( #>                   \"under development\"), \" and may change at anytime,\\n\",  #>                 \"e.g. elements may be renamed or removed.  Because of this, please avoid\\n\",  #>                 \"accessing the elements directly in code.  Feel free to reach out if you need\\n\",  #>                 \"to do so in your code.\\n\")), \"\\n\", \"\\n\", list( #>                 \"internal\"), \"\\n\"), `MultiprocessFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in\", \"\\n\", \"%   R/backend_api-03.MultiprocessFutureBackend-class.R\",  #>             \"\\n\", list(\"MultiprocessFuture-class\"), \"\\n\", list( #>                 \"MultiprocessFuture-class\"), \"\\n\", list(\"MultiprocessFuture\"),  #>             \"\\n\", list(\"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", \"MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":d, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"MultiprocessFuture()\"), \" returns an object of class \",  #>                 list(\"MultiprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), `UniprocessFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-UniprocessFuture-class.R\",  #>             \"\\n\", list(\"UniprocessFuture-class\"), \"\\n\", list( #>                 \"UniprocessFuture-class\"), \"\\n\", list(\"UniprocessFuture\"),  #>             \"\\n\", list(\"An uniprocess future is a future whose value will be resolved synchronously in the current process\"),  #>             \"\\n\", list(\"\\n\", \"UniprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":d, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"UniprocessFuture()\"), \" returns an object of class \",  #>                 list(\"UniprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"An uniprocess future is a future whose value will be resolved synchronously in the current process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), backtrace.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/utils_api-backtrace.R\",  #>             \"\\n\", list(\"backtrace\"), \"\\n\", list(\"backtrace\"),  #>             \"\\n\", list(\"Back trace the expressions evaluated when an error was caught\"),  #>             \"\\n\", list(\"\\n\", \"backtrace(future, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A future with a caught error.\")),  #>                 \"\\n\", \"\\n\", list(list(\"envir\"), list(\"the environment where to locate the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"A list with the future's call stack that led up to the error.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Back trace the expressions evaluated when an error was caught\\n\"),  #>             \"\\n\", list(\"\\n\", \"my_log <- function(x) log(x)\\n\",  #>                 \"foo <- function(...) my_log(...)\\n\", \"\\n\", \"f <- future({ foo(\\\"a\\\") })\\n\",  #>                 \"res <- tryCatch({\\n\", \"  v <- value(f)\\n\", \"}, error = function(ex) {\\n\",  #>                 \"  t <- backtrace(f)\\n\", \"  print(t)\\n\", \"})\\n\",  #>                 list(\"\\n\", \"## R CMD check: make sure any open connections are closed afterward\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\", \"\\n\"), \"\\n\"),  #>             cancel.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-cancel.R\",  #>                 \"\\n\", list(\"cancel\"), \"\\n\", list(\"cancel\"), \"\\n\",  #>                 list(\"Cancel a future\"), \"\\n\", list(\"\\n\", \"cancel(x, interrupt = TRUE, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"x\"), list(\"A Future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"interrupt\"), list(\"If TRUE, running futures are interrupted, if the\\n\",  #>                     \"future backend supports it.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"cancel()\"), \" returns (invisibly) the canceled \",  #>                   list(\"Future\"), \"s after\\n\", \"flagging them as \\\"canceled\\\" and possibly interrupting them as well.\\n\",  #>                   \"\\n\", \"Canceling a lazy or a finished future has no effect.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Cancels futures, with the option to interrupt running ones.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"if ((interactive() || .Platform[[\\\"OS.type\\\"]] != \\\"windows\\\")) withAutoprint({ # examplesIf\"),  #>                   \"\\n\", \"## Set up two parallel workers\\n\", \"plan(multisession, workers = 2)\\n\",  #>                   \"\\n\", \"## Launch two long running futures\\n\",  #>                   \"fs <- lapply(c(1, 2), function(duration) {\\n\",  #>                   \"  future({\\n\", \"    Sys.sleep(duration)\\n\",  #>                   \"    42\\n\", \"  })\\n\", \"})\\n\", \"\\n\", \"## Wait until at least one of the futures is resolved\\n\",  #>                   \"while (!any(resolved(fs))) Sys.sleep(0.1)\\n\",  #>                   \"\\n\", \"## Cancel the future that is not yet resolved\\n\",  #>                   \"r <- resolved(fs)\\n\", \"cancel(fs[!r])\\n\",  #>                   \"\\n\", \"## Get the value of the resolved future\\n\",  #>                   \"f <- fs[r]\\n\", \"v <- value(f)\\n\", \"message(\\\"Result: \\\", v)\\n\",  #>                   \"\\n\", \"## The value of the canceled future is an error\\n\",  #>                   \"try(v <- value(fs[!r]))\\n\", \"\\n\", \"## Shut down parallel workers\\n\",  #>                   \"plan(sequential)\\n\", list(\"}) # examplesIf\"),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A canceled future can be \",  #>                   list(list(\"reset()\")), \" to a lazy, vanilla future\\n\",  #>                   \"such that it can be relaunched, possibly on another future backend.\\n\"),  #>                 \"\\n\"), cluster.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.ClusterFutureBackend-class.R\",  #>                 \"\\n\", list(\"cluster\"), \"\\n\", list(\"cluster\"),  #>                 \"\\n\", list(\"Create a cluster future whose value will be resolved asynchronously in a parallel process\"),  #>                 \"\\n\", list(\"\\n\", \"cluster(\\n\", \"  ...,\\n\", \"  workers = availableWorkers(constraints = \\\"connections\\\"),\\n\",  #>                   \"  persistent = FALSE\\n\", \")\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"workers\"), list(\"A \", list( #>                     list(\"cluster\")), \" object,\\n\", \"a character vector of host names, a positive numeric scalar,\\n\",  #>                     \"or a function.\\n\", \"If a character vector or a numeric scalar, a \",  #>                     list(\"cluster\"), \" object\\n\", \"is created using \",  #>                     list(list(\"makeClusterPSOCK\"), \"(workers)\"),  #>                     \".\\n\", \"If a function, it is called without arguments \",  #>                     list(\"when the future\\n\", \"is created\"),  #>                     \" and its value is used to configure the workers.\\n\",  #>                     \"The function should return any of the above types.\\n\",  #>                     \"If \", list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                     \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                     \"sequential future. To override this fallback, use \",  #>                     list(\"workers = I(1)\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"persistent\"), list(\"If FALSE, the evaluation environment is cleared\\n\",  #>                     \"from objects prior to the evaluation of the future.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"WARNING: This function must never be called.\\n\",  #>                   \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A cluster future is a future that uses cluster evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another process\"), \".\\n\", \"\\n\",  #>                   \"This function is must \", list(\"not\"), \" be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures via a single background R process on the local machine\\n\",  #>                     \"plan(cluster, workers = I(1))\\n\", \"\\n\",  #>                     \"# Evaluate futures via two background R processes on the local machine\\n\",  #>                     \"plan(cluster, workers = 2)\\n\", \"\\n\", \"# Evaluate futures via a single R process on another machine on on the\\n\",  #>                     \"# local area network (LAN)\\n\", \"plan(cluster, workers = \\\"raspberry-pi\\\")\\n\",  #>                     \"\\n\", \"# Evaluate futures via a single R process running on a remote machine\\n\",  #>                     \"plan(cluster, workers = \\\"pi.example.org\\\")\\n\",  #>                     \"\\n\", \"# Evaluate futures via four R processes, one running on the local machine,\\n\",  #>                     \"# two running on LAN machine 'n1' and one on a remote machine\\n\",  #>                     \"plan(cluster, workers = c(\\\"localhost\\\", \\\"n1\\\", \\\"n1\\\", \\\"pi.example.org\\\"))\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use cluster futures\\n\",  #>                   \"cl <- parallel::makeCluster(2, timeout = 60)\\n\",  #>                   \"plan(cluster, workers = cl)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A cluster future is evaluated in a separate process.\\n\",  #>                   \"## Regardless, changing the value of a global variable will\\n\",  #>                   \"## not affect the result of the future.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\", \"\\n\",  #>                   \"## CLEANUP\\n\", \"parallel::stopCluster(cl)\\n\",  #>                   \"\\n\"), \"\\n\"), \"\\n\", list(\"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                   \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                   \".\\n\"), \"\\n\"), clusterExportSticky.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>                 \"\\n\", list(\"clusterExportSticky\"), \"\\n\", list( #>                   \"clusterExportSticky\"), \"\\n\", list(\"Export globals to the sticky-globals environment of the cluster nodes\"),  #>                 \"\\n\", list(\"\\n\", \"clusterExportSticky(cl, globals)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"cl\"), list(\"(cluster) A cluster object as returned by\\n\",  #>                   list(list(\"parallel::makeCluster()\")), \".\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(list) A named list of sticky globals to be exported.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"(invisible; cluster) The cluster object.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Export globals to the sticky-globals environment of the cluster nodes\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This requires that the \", list( #>                   \"future\"), \" package is installed on the cluster\\n\",  #>                   \"nodes.\\n\"), \"\\n\", list(\"internal\"), \"\\n\"),  #>             find_references.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-marshalling.R\",  #>                 \"\\n\", list(\"find_references\"), \"\\n\", list(\"find_references\"),  #>                 \"\\n\", list(\"assert_no_references\"), \"\\n\", list( #>                   \"Get the first or all references of an \", list(),  #>                   \" object\"), \"\\n\", list(\"\\n\", \"find_references(x, first_only = FALSE)\\n\",  #>                   \"\\n\", \"assert_no_references(\\n\", \"  x,\\n\",  #>                   \"  action = c(\\\"error\\\", \\\"warning\\\", \\\"message\\\", \\\"string\\\"),\\n\",  #>                   \"  source = c(\\\"globals\\\", \\\"value\\\")\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"x\"), list(\"The \",  #>                   list(), \" object to be checked.\")), \"\\n\", \"\\n\",  #>                   list(list(\"first_only\"), list(\"If \", list(\"TRUE\"),  #>                     \", only the first reference is returned,\\n\",  #>                     \"otherwise all references.\")), \"\\n\", \"\\n\",  #>                   list(list(\"action\"), list(\"Type of action to take if a reference is found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"source\"), list(\"Is the source of \",  #>                     list(\"x\"), \" the globals or the value of the future?\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"find_references()\"),  #>                   \" returns a list of zero or more references\\n\",  #>                   \"identified.\\n\", \"\\n\", \"If a reference is detected, an informative error, warning, message,\\n\",  #>                   \"or a character string is produced, otherwise \",  #>                   list(\"NULL\"), \" is returned\\n\", \"invisibly.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Get the first or all references of an \",  #>                   list(), \" object\\n\", \"\\n\", \"Assert that there are no references among the identified globals\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), future.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-future.R, R/utils_api-futureCall.R,\",  #>                 \"\\n\", \"%   R/utils_api-minifuture.R\", \"\\n\", list( #>                   \"future\"), \"\\n\", list(\"future\"), \"\\n\", list( #>                   \"futureCall\"), \"\\n\", list(\"minifuture\"), \"\\n\",  #>                 list(\"Create a future\"), \"\\n\", list(\"\\n\", \"future(\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  lazy = FALSE,\\n\",  #>                   \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  conditions = \\\"condition\\\",\\n\", \"  label = NULL,\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", \"futureCall(\\n\", \"  FUN,\\n\",  #>                   \"  args = list(),\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  lazy = FALSE,\\n\", \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  conditions = \\\"condition\\\",\\n\", \"  label = NULL,\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", \"minifuture(\\n\", \"  expr,\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  globals = NULL,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = NA,\\n\",  #>                   \"  conditions = NULL,\\n\", \"  seed = NULL,\\n\",  #>                   \"  ...,\\n\", \"  envir = parent.frame()\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \",  #>                   list(), \" \", list(\"expression\"), \".\")), \"\\n\",  #>                   \"\\n\", list(list(\"envir\"), list(\"The \", list( #>                     \"environment\"), \" from where global objects should be\\n\",  #>                     \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                     list(\"If TRUE, argument \", list(\"expr\"),  #>                       \" is\\n\", list(list(\"substitute\"), \"()\"),  #>                       \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                       \"eagerly (starting immediately), otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                     \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                     \"random numbers are produced (also during parallelization).\\n\",  #>                     \"If FALSE (default), it is assumed that the future expression neither\\n\",  #>                     \"needs nor uses random number generation.\\n\",  #>                     \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integers)\\n\",  #>                     \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                     \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                     \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                     \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                     \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                     \"ignored, an informative warning, or error will be produced.\\n\",  #>                     \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                     list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                     \"to control how globals are handled.\\n\",  #>                     \"For details, see section 'Globals used by future expressions'\\n\",  #>                     \"in the help for \", list(list(\"future()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(\"packages\"),  #>                     list(\"(optional) a character vector specifying packages\\n\",  #>                       \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                     \"and re-outputted when \", list(\"value()\"),  #>                     \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                     \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                     \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                     \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                     \"captured output across futures.\\n\", \"Using \",  #>                     list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                     \"behavior of such unhandled standard output depends on the future backend.\")),  #>                   \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of condition classes to be captured\\n\",  #>                     \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                     \"and warnings.  To drop all conditions, use \",  #>                     list(\"conditions = character(0)\"), \".\\n\",  #>                     \"Errors are always relayed.\\n\", \"Attribute \",  #>                     list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                     list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                     \" will capture\\n\", \"all \", list(\"condition\"),  #>                     \" classes except those that inherit from the \",  #>                     list(\"message\"), \" class.\\n\", \"Using \", list( #>                       \"conditions = structure(..., drop = TRUE)\"),  #>                     \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as they have\\n\",  #>                     \"been relayed, e.g. by \", list(\"value(f)\"),  #>                     \". This can help decrease the overall\\n\",  #>                     \"memory consumed by captured conditions across futures.\\n\",  #>                     \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                     \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                     \"future backend and the environment from which R runs.\")),  #>                   \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"FUN\"), list(\"A \", list( #>                     \"function\"), \" to be evaluated.\")), \"\\n\",  #>                   \"\\n\", list(list(\"args\"), list(\"A \", list(\"list\"),  #>                     \" of arguments passed to function \", list( #>                       \"FUN\"), \".\")), \"\\n\", \"\\n\", list(list(list()),  #>                     list(\"Additional arguments passed to \", list( #>                       list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", list(\"future()\"), \" returns \", list( #>                   \"Future\"), \" that evaluates expression \", list( #>                   \"expr\"), \".\\n\", \"\\n\", list(\"futureCall()\"),  #>                   \" returns a \", list(\"Future\"), \" that calls function \",  #>                   list(\"FUN\"), \" with\\n\", \"arguments \", list( #>                     \"args\"), \".\\n\", \"\\n\", list(\"minifuture(expr)\"),  #>                   \" creates a future with minimal overhead, by disabling\\n\",  #>                   \"user-friendly behaviors, e.g. automatic identification of global\\n\",  #>                   \"variables and packages needed, and relaying of output. Unless you have\\n\",  #>                   \"good reasons for using this function, please use \",  #>                   list(list(\"future()\")), \" instead.\\n\", \"This function exists mainly for the purpose of profiling and identifying\\n\",  #>                   \"which automatic features of \", list(list(\"future()\")),  #>                   \" introduce extra overhead.\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"html\"), list(list(list(\"logo.png\"),  #>                     list(\"options: style='float: right;' alt='logo' width='120'\")))),  #>                   \"\\n\", \"Creates a future that evaluates an \",  #>                   list(), \" expression or\\n\", \"a future that calls an \",  #>                   list(), \" function with a set of arguments.\\n\",  #>                   \"How, when, and where these futures are evaluated can be configured\\n\",  #>                   \"using \", list(list(\"plan()\")), \" such that they are evaluated in parallel on,\\n\",  #>                   \"for instance, the current machine, on a remote machine, or via a\\n\",  #>                   \"job queue on a compute cluster.\\n\", \"Importantly, any \",  #>                   list(), \" code using futures remains the same regardless\\n\",  #>                   \"of these settings and there is no need to modify the code when\\n\",  #>                   \"switching from, say, sequential to parallel processing.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The state of a future is either unresolved or resolved.\\n\",  #>                   \"The value of a future can be retrieved using \",  #>                   list(\"v <- \", list(\"value\"), \"(f)\"), \".\\n\",  #>                   \"Querying the value of a non-resolved future will \",  #>                   list(\"block\"), \" the call\\n\", \"until the future is resolved.\\n\",  #>                   \"It is possible to check whether a future is resolved or not\\n\",  #>                   \"without blocking by using \", list(list(\"resolved\"),  #>                     \"(f)\"), \".\\n\", \"It is possible to \", list( #>                     list(\"cancel()\")), \" a future that is being resolved.\\n\",  #>                   \"Failed, canceled, and interrupted futures can be \",  #>                   list(list(\"reset()\")), \" to a\\n\", \"lazy, vanilla future that can be relaunched.\\n\",  #>                   \"\\n\", \"The \", list(\"futureCall()\"), \" function works analogously to\\n\",  #>                   list(list(\"do.call\"), \"()\"), \", which calls a function with a set of\\n\",  #>                   \"arguments.  The difference is that \", list( #>                     \"do.call()\"), \" returns the value of\\n\",  #>                   \"the call whereas \", list(\"futureCall()\"),  #>                   \" returns a future.\\n\"), \"\\n\", list(list(\"Eager or lazy evaluation\"),  #>                   list(\"\\n\", \"\\n\", \"By default, a future is resolved using \",  #>                     list(\"eager\"), \" evaluation\\n\", \"(\", list( #>                       \"lazy = FALSE\"), \").  This means that the expression starts to\\n\",  #>                     \"be evaluated as soon as the future is created.\\n\",  #>                     \"\\n\", \"As an alternative, the future can be resolved using \",  #>                     list(\"lazy\"), \"\\n\", \"evaluation (\", list( #>                       \"lazy = TRUE\"), \").  This means that the expression\\n\",  #>                     \"will only be evaluated when the value of the future is requested.\\n\",  #>                     list(\"Note that this means that the expression may not be evaluated\\n\",  #>                       \"at all - it is guaranteed to be evaluated if the value is requested\"),  #>                     \".\\n\")), \"\\n\", \"\\n\", list(list(\"Globals used by future expressions\"),  #>                   list(\"\\n\", \"\\n\", \"Global objects (short \",  #>                     list(\"globals\"), \") are objects (e.g. variables and\\n\",  #>                     \"functions) that are needed in order for the future expression to be\\n\",  #>                     \"evaluated while not being local objects that are defined by the future\\n\",  #>                     \"expression. For example, in\\n\", list(\"\\n\",  #>                       \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b })\\n\"),  #>                     \"\\n\", \"variable \", list(\"a\"), \" is a global of future assignment \",  #>                     list(\"f\"), \" whereas\\n\", list(\"b\"), \" is a local variable.\\n\",  #>                     \"In order for the future to be resolved successfully (and correctly),\\n\",  #>                     \"all globals need to be gathered when the future is created such that\\n\",  #>                     \"they are available whenever and wherever the future is resolved.\\n\",  #>                     \"\\n\", \"The default behavior (\", list(\"globals = TRUE\"),  #>                     \"),\\n\", \"is that globals are automatically identified and gathered.\\n\",  #>                     \"More precisely, globals are identified via code inspection of the\\n\",  #>                     \"future expression \", list(\"expr\"), \" and their values are retrieved with\\n\",  #>                     \"environment \", list(\"envir\"), \" as the starting point (basically via\\n\",  #>                     list(\"get(global, envir = envir, inherits = TRUE)\"),  #>                     \").\\n\", list(\"In most cases, such automatic collection of globals is sufficient\\n\",  #>                       \"and less tedious and error prone than if they are manually specified\"),  #>                     \".\\n\", \"\\n\", \"However, for full control, it is also possible to explicitly specify\\n\",  #>                     \"exactly which globals are by providing their names as a character\\n\",  #>                     \"vector.\\n\", \"In the above example, we could use\\n\",  #>                     list(\"\\n\", \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b }, globals = \\\"a\\\")\\n\"),  #>                     \"\\n\", \"\\n\", \"Yet another alternative is to explicitly also specify their values\\n\",  #>                     \"using a named list as in\\n\", list(\"\\n\",  #>                       \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b }, globals = list(a = a))\\n\"),  #>                     \"\\n\", \"or\\n\", list(\"\\n\", \"  f <- future({ b <- 2; a * b }, globals = list(a = 42))\\n\"),  #>                     \"\\n\", \"\\n\", \"Specifying globals explicitly avoids the overhead added from\\n\",  #>                     \"automatically identifying the globals and gathering their values.\\n\",  #>                     \"Furthermore, if we know that the future expression does not make use\\n\",  #>                     \"of any global variables, we can disable the automatic search for\\n\",  #>                     \"globals by using\\n\", list(\"\\n\", \"  f <- future({ a <- 42; b <- 2; a * b }, globals = FALSE)\\n\"),  #>                     \"\\n\", \"\\n\", \"Future expressions often make use of functions from one or more packages.\\n\",  #>                     \"As long as these functions are part of the set of globals, the future\\n\",  #>                     \"package will make sure that those packages are attached when the future\\n\",  #>                     \"is resolved.  Because there is no need for such globals to be frozen\\n\",  #>                     \"or exported, the future package will not export them, which reduces\\n\",  #>                     \"the amount of transferred objects.\\n\", \"For example, in\\n\",  #>                     list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({ median(x) })\\n\"),  #>                     \"\\n\", \"variable \", list(\"x\"), \" and \", list( #>                       \"median()\"), \" are globals, but only \",  #>                     list(\"x\"), \"\\n\", \"is exported whereas \",  #>                     list(\"median()\"), \", which is part of the \",  #>                     list(\"stats\"), \"\\n\", \"package, is not exported.  Instead it is made sure that the \",  #>                     list(\"stats\"), \"\\n\", \"package is on the search path when the future expression is evaluated.\\n\",  #>                     \"Effectively, the above becomes\\n\", list( #>                       \"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                       \"    library(stats)\\n\", \"    median(x)\\n\",  #>                       \"  })\\n\"), \"\\n\", \"To manually specify this, one can either do\\n\",  #>                     list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                       \"    median(x)\\n\", \"  }, globals = list(x = x, median = stats::median)\\n\"),  #>                     \"\\n\", \"or\\n\", list(\"\\n\", \"  x <- rnorm(1000)\\n\",  #>                       \"  f <- future({\\n\", \"    library(stats)\\n\",  #>                       \"    median(x)\\n\", \"  }, globals = list(x = x))\\n\"),  #>                     \"\\n\", \"Both are effectively the same.\\n\",  #>                     \"\\n\", \"Although rarely needed, a combination of automatic identification and manual\\n\",  #>                     \"specification of globals is supported via attributes \",  #>                     list(\"add\"), \" (to add\\n\", \"false negatives) and \",  #>                     list(\"ignore\"), \" (to ignore false positives) on value\\n\",  #>                     list(\"TRUE\"), \".  For example, with\\n\", list( #>                       \"globals = structure(TRUE, ignore = \\\"b\\\", add = \\\"a\\\")\"),  #>                     \" any globals\\n\", \"automatically identified, except \",  #>                     list(\"b\"), \", will be used, in addition to\\n\",  #>                     \"global \", list(\"a\"), \".\\n\")), \"\\n\", \"\\n\",  #>                 list(\"\\n\", \"## Evaluate futures in parallel\\n\",  #>                   \"plan(multisession)\\n\", \"\\n\", \"## Data\\n\",  #>                   \"x <- rnorm(100)\\n\", \"y <- 2 * x + 0.2 + rnorm(100)\\n\",  #>                   \"w <- 1 + x ^ 2\\n\", \"\\n\", \"\\n\", \"## EXAMPLE: Regular assignments (evaluated sequentially)\\n\",  #>                   \"fitA <- lm(y ~ x, weights = w)      ## with offset\\n\",  #>                   \"fitB <- lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                   \"fitC <- {\\n\", \"  w <- 1 + abs(x)  ## Different weights\\n\",  #>                   \"  lm(y ~ x, weights = w)\\n\", \"}\\n\", \"print(fitA)\\n\",  #>                   \"print(fitB)\\n\", \"print(fitC)\\n\", \"\\n\", \"\\n\",  #>                   \"## EXAMPLE: Future assignments (evaluated in parallel)\\n\",  #>                   \"fitA %<-% lm(y ~ x, weights = w)      ## with offset\\n\",  #>                   \"fitB %<-% lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                   \"fitC %<-% {\\n\", \"  w <- 1 + abs(x)\\n\", \"  lm(y ~ x, weights = w)\\n\",  #>                   \"}\\n\", \"print(fitA)\\n\", \"print(fitB)\\n\", \"print(fitC)\\n\",  #>                   \"\\n\", \"\\n\", \"## EXAMPLE: Explicitly create futures (evaluated in parallel)\\n\",  #>                   \"## and retrieve their values\\n\", \"fA <- future( lm(y ~ x, weights = w) )\\n\",  #>                   \"fB <- future( lm(y ~ x - 1, weights = w) )\\n\",  #>                   \"fC <- future({\\n\", \"  w <- 1 + abs(x)\\n\",  #>                   \"  lm(y ~ x, weights = w)\\n\", \"})\\n\", \"fitA <- value(fA)\\n\",  #>                   \"fitB <- value(fB)\\n\", \"fitC <- value(fC)\\n\",  #>                   \"print(fitA)\\n\", \"print(fitB)\\n\", \"print(fitC)\\n\",  #>                   \"\\n\", list(\"\\n\", \"## Make sure to \\\"close\\\" an multisession workers on Windows\\n\",  #>                     \"plan(sequential)\\n\"), \"\\n\", \"## EXAMPLE: futureCall() and do.call()\\n\",  #>                   \"x <- 1:100\\n\", \"y0 <- do.call(sum, args = list(x))\\n\",  #>                   \"print(y0)\\n\", \"\\n\", \"f1 <- futureCall(sum, args = list(x))\\n\",  #>                   \"y1 <- value(f1)\\n\", \"print(y1)\\n\"), \"\\n\",  #>                 list(\"\\n\", \"How, when, and where futures are resolved is determined by the\\n\",  #>                   list(\"future backend\"), \", which can be set by the end user using the\\n\",  #>                   list(list(\"plan()\")), \" function.\\n\"), \"\\n\",  #>                 list(\"\\n\", \"The future logo was designed by Dan LaBar and tweaked by Henrik Bengtsson.\\n\"),  #>                 \"\\n\"), futureAssign.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/delayed_api-futureAssign.R,\",  #>                 \"\\n\", \"%   R/infix_api-01-futureAssign_OP.R, R/infix_api-02-globals_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-03-seed_OP.R, R/infix_api-04-stdout_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-05-conditions_OP.R, R/infix_api-06-lazy_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-07-label_OP.R, R/infix_api-08-plan_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-09-tweak_OP.R\", \"\\n\",  #>                 list(\"futureAssign\"), \"\\n\", list(\"futureAssign\"),  #>                 \"\\n\", list(\"%<-%\"), \"\\n\", list(\"%->%\"), \"\\n\",  #>                 list(\"%globals%\"), \"\\n\", list(\"%packages%\"),  #>                 \"\\n\", list(\"%seed%\"), \"\\n\", list(\"%stdout%\"),  #>                 \"\\n\", list(\"%conditions%\"), \"\\n\", list(\"%lazy%\"),  #>                 \"\\n\", list(\"%label%\"), \"\\n\", list(\"%plan%\"),  #>                 \"\\n\", list(\"%tweak%\"), \"\\n\", list(\"Create a future assignment\"),  #>                 \"\\n\", list(\"\\n\", \"futureAssign(\\n\", \"  x,\\n\",  #>                   \"  value,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  lazy = FALSE,\\n\",  #>                   \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  conditions = \\\"condition\\\",\\n\", \"  label = NULL,\\n\",  #>                   \"  ...,\\n\", \"  assign.env = envir\\n\", \")\\n\",  #>                   \"\\n\", \"x %<-% value\\n\", \"\\n\", \"fassignment %globals% globals\\n\",  #>                   \"fassignment %packages% packages\\n\", \"\\n\",  #>                   \"fassignment %seed% seed\\n\", \"\\n\", \"fassignment %stdout% capture\\n\",  #>                   \"\\n\", \"fassignment %conditions% capture\\n\",  #>                   \"\\n\", \"fassignment %lazy% lazy\\n\", \"\\n\", \"fassignment %label% label\\n\",  #>                   \"\\n\", \"fassignment %plan% strategy\\n\", \"\\n\",  #>                   \"fassignment %tweak% tweaks\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"the name of a future variable, which will hold the value\\n\",  #>                     \"of the future expression (as a promise).\")),  #>                   \"\\n\", \"\\n\", list(list(\"value\"), list(\"An \",  #>                     list(), \" \", list(\"expression\"), \".\")), \"\\n\",  #>                   \"\\n\", list(list(\"envir\"), list(\"The \", list( #>                     \"environment\"), \" from where global objects should be\\n\",  #>                     \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                     list(\"If TRUE, argument \", list(\"expr\"),  #>                       \" is\\n\", list(list(\"substitute\"), \"()\"),  #>                       \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                       \"eagerly (starting immediately), otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                     \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                     \"random numbers are produced (also during parallelization).\\n\",  #>                     \"If FALSE (default), it is assumed that the future expression neither\\n\",  #>                     \"needs nor uses random number generation.\\n\",  #>                     \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integers)\\n\",  #>                     \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                     \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                     \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                     \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                     \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                     \"ignored, an informative warning, or error will be produced.\\n\",  #>                     \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                     list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                     \"to control how globals are handled.\\n\",  #>                     \"For details, see section 'Globals used by future expressions'\\n\",  #>                     \"in the help for \", list(list(\"future()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(\"packages\"),  #>                     list(\"(optional) a character vector specifying packages\\n\",  #>                       \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                     \"and re-outputted when \", list(\"value()\"),  #>                     \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                     \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                     \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                     \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                     \"captured output across futures.\\n\", \"Using \",  #>                     list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                     \"behavior of such unhandled standard output depends on the future backend.\")),  #>                   \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of condition classes to be captured\\n\",  #>                     \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                     \"and warnings.  To drop all conditions, use \",  #>                     list(\"conditions = character(0)\"), \".\\n\",  #>                     \"Errors are always relayed.\\n\", \"Attribute \",  #>                     list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                     list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                     \" will capture\\n\", \"all \", list(\"condition\"),  #>                     \" classes except those that inherit from the \",  #>                     list(\"message\"), \" class.\\n\", \"Using \", list( #>                       \"conditions = structure(..., drop = TRUE)\"),  #>                     \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as they have\\n\",  #>                     \"been relayed, e.g. by \", list(\"value(f)\"),  #>                     \". This can help decrease the overall\\n\",  #>                     \"memory consumed by captured conditions across futures.\\n\",  #>                     \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                     \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                     \"future backend and the environment from which R runs.\")),  #>                   \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"assign.env\"), list(\"The \",  #>                     list(\"environment\"), \" to which the variable\\n\",  #>                     \"should be assigned.\")), \"\\n\", \"\\n\", list( #>                     list(\"fassignment\"), list(\"The future assignment, e.g.\\n\",  #>                       list(\"x %<-% { expr }\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"capture\"), list(\"If TRUE, the standard output will be captured, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"strategy\"), list(\"The backend controlling how the future is\\n\",  #>                     \"resolved. See \", list(list(\"plan()\")), \" for further details.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tweaks\"), list(\"A named list (or vector) with arguments that\\n\",  #>                     \"should be changed relative to the current backend.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Additional arguments passed to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", list(\"futureAssign()\"), \" and \", list( #>                   \"x %<-% expr\"), \" returns the \", list(\"Future\"),  #>                   \" invisibly,\\n\", \"e.g. \", list(\"f <- futureAssign(\\\"x\\\", expr)\"),  #>                   \" and \", list(\"f <- (x %<-% expr)\"), \".\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"x %<-% value\"), \" (also known as a \\\"future assignment\\\") and\\n\",  #>                   list(\"futureAssign(\\\"x\\\", value)\"), \" create a \",  #>                   list(\"Future\"), \" that evaluates the expression\\n\",  #>                   \"(\", list(\"value\"), \") and binds it to variable \",  #>                   list(\"x\"), \" (as a\\n\", list(\"promise\"), \"). The expression is evaluated in parallel\\n\",  #>                   \"in the background. Later on, when \", list( #>                     \"x\"), \" is first queried, the value of the future\\n\",  #>                   \"is automatically retrieved as if it were a regular variable and \",  #>                   list(\"x\"), \" is\\n\", \"materialized as a regular value.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"For a future created via a future assignment, \",  #>                   list(\"x %<-% value\"), \" or\\n\", list(\"futureAssign(\\\"x\\\", value)\"),  #>                   \", the value is bound to a promise, which when\\n\",  #>                   \"queried will internally call \", list(list( #>                     \"value()\")), \"  on the future and which will then\\n\",  #>                   \"be resolved into a regular variable bound to that value. For example, with\\n\",  #>                   \"future assignment \", list(\"x %<-% value\"),  #>                   \", the first time variable \", list(\"x\"), \" is queried\\n\",  #>                   \"the call blocks if, and only if, the future is not yet resolved. As soon\\n\",  #>                   \"as it is resolved, and any succeeding queries, querying \",  #>                   list(\"x\"), \" will\\n\", \"immediately give the value.\\n\",  #>                   \"\\n\", \"The future assignment construct \", list( #>                     \"x %<-% value\"), \" is not a formal assignment\\n\",  #>                   \"per se, but a binary infix operator on objects \",  #>                   list(\"x\"), \" and expression \", list(\"value\"),  #>                   \".\\n\", \"However, by using non-standard evaluation, this construct can emulate an\\n\",  #>                   \"assignment operator similar to \", list(\"x <- value\"),  #>                   \". Due to \", list(), \"'s precedence rules\\n\",  #>                   \"of operators, future expressions often need to be explicitly bracketed,\\n\",  #>                   \"e.g. \", list(\"x %<-% { a + b }\"), \".\\n\"),  #>                 \"\\n\", list(list(\"Adjust future arguments of a future assignment\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", list(list(\"future()\")),  #>                     \" and \", list(list(\"futureAssign()\")), \" take several arguments that can be used\\n\",  #>                     \"to explicitly specify what global variables and packages the future should\\n\",  #>                     \"use. They can also be used to override default behaviors of the future,\\n\",  #>                     \"e.g. whether output should be relayed or not. When using a future\\n\",  #>                     \"assignment, these arguments can be specified via corresponding\\n\",  #>                     \"assignment expression.  For example, \",  #>                     list(\"x %<-% { rnorm(10) } %seed% TRUE\"),  #>                     \"\\n\", \"corresponds to \", list(\"futureAssign(\\\"x\\\", { rnorm(10) }, seed = TRUE)\"),  #>                     \". Here are\\n\", \"several examples.\\n\", \"\\n\",  #>                     \"To explicitly specify variables and functions that a future assignment\\n\",  #>                     \"should use, use \", list(\"%globals%\"), \". To explicitly specify which packages need\\n\",  #>                     \"to be attached for the evaluation to succeed, use \",  #>                     list(\"%packages%\"), \". For\\n\", \"example,\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x <- rnorm(1000)\\n\", \"> y %<-% { median(x) } %globals% list(x = x) %packages% \\\"stats\\\"\\n\",  #>                       \"> y\\n\", \"[1] -0.03956372\\n\"), list(list( #>                       \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                     \"The \", list(\"median()\"), \" function is part of the 'stats' package.\\n\",  #>                     \"\\n\", \"To declare that you will generate random numbers, use \",  #>                     list(\"%seed%\"), \", e.g.\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { rnorm(3) } %seed% TRUE\\n\",  #>                       \"> x\\n\", \"[1] -0.2590562 -1.2262495  0.8858702\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\", \"\\n\", \"To disable relaying of standard output (e.g. \",  #>                     list(\"print()\"), \", \", list(\"cat()\"), \", and\\n\",  #>                     list(\"str()\"), \"), while keeping relaying of conditions (e.g. \",  #>                     list(\"message()\"), \" and\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %stdout% FALSE\\n\",  #>                       \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hi there\\n\",  #>                       \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To disable relaying of conditions, use \",  #>                     list(\"%conditions%\"), \", e.g.\\n\", \"\\n\", list( #>                       list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %conditions% character(0)\\n\",  #>                       \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                       \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\", \"\\n\", list( #>                       list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { print(1:10); message(\\\"Hello\\\"); 42 } %stdout% FALSE\\n\",  #>                       \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                       \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To create a future without launching it such that it will only be\\n\",  #>                     \"processed if the value is really needed, use \",  #>                     list(\"%lazy%\"), \", e.g.\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { Sys.sleep(5); 42 } %lazy% TRUE\\n\",  #>                       \"> y <- sum(1:10)\\n\", \"> system.time(z <- x + y)\\n\",  #>                       \"  user  system elapsed \\n\", \"  0.004   0.000   5.008\\n\",  #>                       \"> z\\n\", \"[1] 97\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\")), \"\\n\", \"\\n\",  #>                 list(list(\"Error handling\"), list(\"\\n\", \"\\n\",  #>                   \"\\n\", \"Because future assignments are promises, errors produced by the\\n\",  #>                   \"future expression will not be signaled until the value of the future is\\n\",  #>                   \"requested. For example, if you create a future assignment that produces\\n\",  #>                   \"an error, you will not be affected by the error until you \\\"touch\\\" the\\n\",  #>                   \"future-assignment variable. For example,\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> y <- sum(1:10)\\n\",  #>                     \"> z <- x + y\\n\", \"Error in eval(quote({ : boom\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Use alternative future backend for future assignment\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Futures are evaluated on the future backend that the user has specified\\n\",  #>                     \"by \", list(list(\"plan()\")), \". With regular futures, we can temporarily use another future\\n\",  #>                     \"backend by wrapping our code in \", list( #>                       \"with(plan(...), { ... })\"), \", or temporarily\\n\",  #>                     \"inside a function using \", list(\"with(plan(...), local = TRUE)\"),  #>                     \". To achieve the\\n\", \"same for a specific future assignment, use \",  #>                     list(\"%plan%\"), \", e.g.\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> plan(multisession)\\n\", \"> x %<-% { 42 }\\n\",  #>                       \"> y %<-% { 13 } %plan% sequential\\n\",  #>                       \"> z <- x + y\\n\", \"> z\\n\", \"[1] 55\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\", \"\\n\", \"Here \", list(\"x\"), \" is resolved in the background via the \",  #>                     list(\"multisession\"), \" backend,\\n\", \"whereas \",  #>                     list(\"y\"), \" is resolved sequentially in the main R session.\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Getting the future object of a future assignment\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"The underlying \", list( #>                     \"Future\"), \" of a future variable \", list( #>                     \"x\"), \" can be retrieved without\\n\", \"blocking using \",  #>                     list(\"f <- \", list(\"futureOf\"), \"(x)\"), \", e.g.\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> f_x <- futureOf(x)\\n\",  #>                       \"> resolved(f_x)\\n\", \"[1] TRUE\\n\", \"> x\\n\",  #>                       \"Error in eval(quote({ : boom\\n\", \"> value(f_x)\\n\",  #>                       \"Error in eval(quote({ : boom\\n\"), list( #>                       list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                     \"\\n\", \"Technically, both the future and the variable (promise) are assigned at\\n\",  #>                     \"the same time to environment \", list(\"assign.env\"),  #>                     \" where the name of the future is\\n\", list( #>                       \".future_<name>\"), \".\\n\")), \"\\n\", \"\\n\"),  #>             futureOf.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/delayed_api-futureOf.R\",  #>                 \"\\n\", list(\"futureOf\"), \"\\n\", list(\"futureOf\"),  #>                 \"\\n\", list(\"Get the future of a future variable\"),  #>                 \"\\n\", list(\"\\n\", \"futureOf(\\n\", \"  var = NULL,\\n\",  #>                   \"  envir = parent.frame(),\\n\", \"  mustExist = TRUE,\\n\",  #>                   \"  default = NA,\\n\", \"  drop = FALSE\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"var\"), list(\"the variable.  If NULL, all futures in the\\n\",  #>                   \"environment are returned.\")), \"\\n\", \"\\n\",  #>                   list(list(\"envir\"), list(\"the environment where to search from.\")),  #>                   \"\\n\", \"\\n\", list(list(\"mustExist\"), list(\"If TRUE and the variable does not exist, then\\n\",  #>                     \"an informative error is thrown, otherwise NA is returned.\")),  #>                   \"\\n\", \"\\n\", list(list(\"default\"), list(\"the default value if future was not found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"if TRUE and \",  #>                     list(\"var\"), \" is NULL, then returned list\\n\",  #>                     \"only contains futures, otherwise also \",  #>                     list(\"default\"), \" values.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \" (or \", list( #>                   \"default\"), \").\\n\", \"If \", list(\"var\"), \" is NULL, then a named list of Future:s is returned.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Get the future of a future variable that has been created directly\\n\",  #>                   \"or indirectly via \", list(list(\"future()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"a %<-% { 1 }\\n\",  #>                   \"\\n\", \"f <- futureOf(a)\\n\", \"print(f)\\n\", \"\\n\",  #>                   \"b %<-% { 2 }\\n\", \"\\n\", \"f <- futureOf(b)\\n\",  #>                   \"print(f)\\n\", \"\\n\", \"## All futures\\n\", \"fs <- futureOf()\\n\",  #>                   \"print(fs)\\n\", \"\\n\", \"\\n\", \"## Futures part of environment\\n\",  #>                   \"env <- new.env()\\n\", \"env$c %<-% { 3 }\\n\",  #>                   \"\\n\", \"f <- futureOf(env$c)\\n\", \"print(f)\\n\",  #>                   \"\\n\", \"f2 <- futureOf(c, envir = env)\\n\", \"print(f2)\\n\",  #>                   \"\\n\", \"f3 <- futureOf(\\\"c\\\", envir = env)\\n\",  #>                   \"print(f3)\\n\", \"\\n\", \"fs <- futureOf(envir = env)\\n\",  #>                   \"print(fs)\\n\"), \"\\n\"), futureSessionInfo.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-futureSessionInfo.R\",  #>                 \"\\n\", list(\"futureSessionInfo\"), \"\\n\", list(\"futureSessionInfo\"),  #>                 \"\\n\", list(\"Get future-specific session information and validate current backend\"),  #>                 \"\\n\", list(\"\\n\", \"futureSessionInfo(test = TRUE, anonymize = TRUE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"test\"), list(\"If TRUE, one or more futures are created to query workers\\n\",  #>                   \"and validate their information.\")), \"\\n\",  #>                   \"\\n\", list(list(\"anonymize\"), list(\"If TRUE, user names and host names are anonymized.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Nothing.\\n\"), \"\\n\",  #>                 list(\"\\n\", \"Get future-specific session information and validate current backend\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession, workers = 2)\\n\",  #>                   \"futureSessionInfo()\\n\", \"plan(sequential)\\n\"),  #>                 \"\\n\"), futures.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-futures.R\",  #>                 \"\\n\", list(\"futures\"), \"\\n\", list(\"futures\"),  #>                 \"\\n\", list(\"Get all futures in a container\"),  #>                 \"\\n\", list(\"\\n\", \"futures(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"An environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"An object of same type as \",  #>                   list(\"x\"), \" and with the same names\\n\", \"and/or dimensions, if set.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets all futures in an environment, a list, or a list environment\\n\",  #>                   \"and returns an object of the same class (and dimensions).\\n\",  #>                   \"Non-future elements are returned as is.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is useful for retrieve futures that were created via\\n\",  #>                   \"future assignments (\", list(\"%<-%\"), \") and therefore stored as promises.\\n\",  #>                   \"This function turns such promises into standard \",  #>                   list(\"Future\"), \"\\n\", \"objects.\\n\"), \"\\n\"),  #>             getExpression.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"getExpression\"), \"\\n\", list(\"getExpression\"),  #>                 \"\\n\", list(\"getExpression.Future\"), \"\\n\", list( #>                   \"Inject code for the next type of future to use for nested futures\"),  #>                 \"\\n\", list(\"\\n\", \"getExpression(future, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"Current future.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A future expression with code injected to set what\\n\",  #>                   \"type of future to use for nested futures, iff any.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Inject code for the next type of future to use for nested futures\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If there is no future backend specified after this one, the default\\n\",  #>                   \"is to use \", list(\"sequential\"), \" futures.  This conservative approach protects\\n\",  #>                   \"against spawning off recursive futures by mistake, especially\\n\",  #>                   list(\"multicore\"), \" and \", list(\"multisession\"),  #>                   \" ones.\\n\", \"The default will also set \", list( #>                     \"options(mc.cores = 1L)\"), \" (*) so that\\n\",  #>                   \"no parallel \", list(), \" processes are spawned off by functions such as\\n\",  #>                   list(\"parallel::mclapply()\"), \" and friends.\\n\",  #>                   \"\\n\", \"Currently it is not possible to specify what type of nested\\n\",  #>                   \"futures to be used, meaning the above default will always be\\n\",  #>                   \"used.\\n\", \"See \", list(list(\"https://github.com/futureverse/future/issues/37\"),  #>                     list(\"Issue #37\")), \"\\n\", \"for plans on adding support for custom nested future types.\\n\",  #>                   \"\\n\", \"(*) Ideally we would set \", list(\"mc.cores = 0\"),  #>                   \" but that will unfortunately\\n\", \"cause \",  #>                   list(\"mclapply()\"), \" and friends to generate an error saying\\n\",  #>                   \"\\\"'mc.cores' must be >= 1\\\".  Ideally those functions should\\n\",  #>                   \"fall back to using the non-multicore alternative in this\\n\",  #>                   \"case, e.g. \", list(\"mclapply(...)\"), \" => \",  #>                   list(\"lapply(...)\"), \".\\n\", \"See \", list(\"https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7\"),  #>                   \"\\n\", \"for a discussion on this.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), getGlobalsAndPackages.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-globals.R\",  #>                 \"\\n\", list(\"getGlobalsAndPackages\"), \"\\n\", list( #>                   \"getGlobalsAndPackages\"), \"\\n\", list(\"Retrieves global variables of an expression and their associated packages\"),  #>                 \"\\n\", list(\"\\n\", \"getGlobalsAndPackages(\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  tweak = tweakExpression,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  locals = getOption(\\\"future.globals.globalsOf.locals\\\", TRUE),\\n\",  #>                   \"  resolve = getOption(\\\"future.globals.resolve\\\"),\\n\",  #>                   \"  persistent = FALSE,\\n\", \"  maxSize = getOption(\\\"future.globals.maxSize\\\", 500 * 1024^2),\\n\",  #>                   \"  onReference = getOption(\\\"future.globals.onReference\\\", \\\"ignore\\\"),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"expr\"), list(\"An \", list(), \" expression whose globals should be found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The environment from which globals should be searched.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tweak\"), list(\"(optional) A function that takes an expression and returned a modified one.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, a named list, or a \",  #>                     list(\"Globals\"), \" object.  If TRUE, globals are identified by code inspection based on \",  #>                     list(\"expr\"), \" and \", list(\"tweak\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If FALSE, no globals are used.  If a character vector, then globals are identified by lookup based their names \",  #>                     list(\"globals\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If a named list or a Globals object, the globals are used as is.\")),  #>                   \"\\n\", \"\\n\", list(list(\"locals\"), list(\"Should globals part of any \\\"local\\\" environment of\\n\",  #>                     \"a function be included or not?\")), \"\\n\",  #>                   \"\\n\", list(list(\"resolve\"), list(\"If TRUE, any future that is a global variables (or part of one) is resolved and replaced by a \\\"constant\\\" future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"persistent\"), list(\"If TRUE, non-existing globals (= identified in expression but not found in memory) are always silently ignored and assumed to be existing in the evaluation environment.  If FALSE, non-existing globals are by default ignored, but may also trigger an informative error if option \",  #>                     list(\"future.globals.onMissing\"), \" in \",  #>                     list(\"\\\"error\\\"\"), \" (should only be used for troubleshooting).\")),  #>                   \"\\n\", \"\\n\", list(list(\"maxSize\"), list(\"The maximum allowed total size (in bytes) of globals---for\\n\",  #>                     \"the purpose of preventing too large exports / transfers happening by\\n\",  #>                     \"mistake.  If the total size of the global objects are greater than this\\n\",  #>                     \"limit, an informative error message is produced. If\\n\",  #>                     list(\"maxSize = +Inf\"), \", then this assertion is skipped. (Default: 500 MiB).\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A named list with elements \",  #>                   list(\"expr\"), \" (the tweaked expression), \",  #>                   list(\"globals\"), \" (a named list of class \",  #>                   list(\"FutureGlobals\"), \") and \", list(\"packages\"),  #>                   \" (a character string).\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Retrieves global variables of an expression and their associated packages\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Internally, \", list(list(\"globalsOf\"),  #>                   \"()\"), \" is used to identify globals and associated packages from the expression.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), makeClusterFuture.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-makeClusterFuture.R\",  #>                 \"\\n\", list(\"makeClusterFuture\"), \"\\n\", list(\"makeClusterFuture\"),  #>                 \"\\n\", list(\"FUTURE\"), \"\\n\", list(\"Create a Future Cluster of Stateless Workers for Parallel Processing\"),  #>                 \"\\n\", list(\"\\n\", \"makeClusterFuture(specs = nbrOfWorkers(), ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"specs\"), list(\"Ignored.\\n\",  #>                   \"If specified, the value should equal \", list( #>                     \"nbrOfWorkers()\"), \" (default).\\n\", \"A missing value corresponds to specifying \",  #>                   list(\"nbrOfWorkers()\"), \".\\n\", \"This argument exists only to support\\n\",  #>                   list(\"parallel::makeCluster(NA, type = future::FUTURE)\"),  #>                   \".\")), \"\\n\", \"\\n\", list(list(list()), list( #>                   \"Named arguments passed to \", list(list(\"future()\")),  #>                   \".\")), \"\\n\"), \"\\n\", list(\"\\n\", \"Returns a \",  #>                   list(\"parallel\"), \" \", list(\"cluster\"), \" object of class \",  #>                   list(\"FutureCluster\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                   list(\"WARNING: Please note that this sets up a stateless set of cluster nodes,\\n\",  #>                     \"which means that \", list(\"clusterEvalQ(cl, { a <- 3.14 })\"),  #>                     \" will not work.\\n\", \"Consider this a first beta version and use it with great care,\\n\",  #>                     \"particularly because of the stateless nature of the cluster.\\n\",  #>                     \"For now, I recommend to manually validate that you can get identical\\n\",  #>                     \"results using this cluster type with what you get from using the\\n\",  #>                     \"classical \", list(\"parallel::makeCluster()\"),  #>                     \" cluster type.\"), \"\\n\"), \"\\n\", list(list( #>                   \"Future Clusters are Stateless\"), list(\"\\n\",  #>                   \"\\n\", \"Traditionally, a cluster nodes has a one-to-one mapping to a cluster\\n\",  #>                   \"worker process. For example, \", list(\"cl <- makeCluster(2, type = \\\"PSOCK\\\")\"),  #>                   \"\\n\", \"launches two parallel worker processes in the background, where\\n\",  #>                   \"cluster node \", list(\"cl[[1]]\"), \" maps to worker #1 and node \",  #>                   list(\"cl[[2]]\"), \" to\\n\", \"worker #2, and that never changes through the lifespan of these\\n\",  #>                   \"workers. This one-to-one mapping allows for deterministic\\n\",  #>                   \"configuration of workers. For examples, some code may assign globals\\n\",  #>                   \"with values specific to each worker, e.g.\\n\",  #>                   list(\"clusterEvalQ(cl[1], { a <- 3.14 })\"),  #>                   \" and\\n\", list(\"clusterEvalQ(cl[2], { a <- 2.71 })\"),  #>                   \".\\n\", \"\\n\", \"In contrast, there is no one-to-one mapping between cluster nodes\\n\",  #>                   \"and the parallel workers when using a future cluster. This is because\\n\",  #>                   \"we cannot make assumptions on where are parallel task will be\\n\",  #>                   \"processed. Where a parallel task is processes is up to the future\\n\",  #>                   \"backend to decide - some backends do this deterministically, whereas\\n\",  #>                   \"others other resolves task at the first available worker. Also, the\\n\",  #>                   \"worker processes might be \", list(\"transient\"),  #>                   \" for some future backends, i.e.\\n\", \"the only exist for the life-span of the parallel task and then\\n\",  #>                   \"terminates.\\n\", \"\\n\", \"Because of this, one must not rely in node-specific behaviors,\\n\",  #>                   \"because that concept does not make sense with a future cluster.\\n\",  #>                   \"To protect against this, any attempt to address a subset of future\\n\",  #>                   \"cluster nodes, results in an error, e.g. \",  #>                   list(\"clusterEvalQ(cl[1], ...)\"), \",\\n\", list( #>                     \"clusterEvalQ(cl[1:2], ...)\"), \", and \",  #>                   list(\"clusterEvalQ(cl[2:1], ...)\"), \" in\\n\",  #>                   \"the above example will all give an error.\\n\",  #>                   \"\\n\", \"Exceptions to the latter limitation are \",  #>                   list(\"clusterSetRNGStream()\"), \"\\n\", \"and \",  #>                   list(\"clusterExport()\"), \", which can be safely used with future clusters.\\n\",  #>                   \"See below for more details.\\n\")), \"\\n\", \"\\n\",  #>                 list(list(\"clusterSetRNGStream\"), list(\"\\n\",  #>                   \"\\n\", list(list(\"parallel::clusterSetRNGStream()\")),  #>                   \"\\n\", \"distributes \\\"L'Ecuyer-CMRG\\\" RNG\\n\",  #>                   \"streams to the cluster nodes, which record them such that the next\\n\",  #>                   \"round of futures will use them. When used, the RNG state after the\\n\",  #>                   \"futures are resolved are recorded accordingly, such that the next\\n\",  #>                   \"round again of future will use those, and so on. This strategy\\n\",  #>                   \"makes sure \", list(\"clusterSetRNGStream()\"),  #>                   \" has the expected effect although\\n\", \"futures are stateless.\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"clusterExport\"), list( #>                   \"\\n\", \"\\n\", list(list(\"parallel::clusterExport()\")),  #>                   \" assign values to the cluster nodes.\\n\", \"Specifically, these values are recorded and are used as globals\\n\",  #>                   \"for all futures created there on.\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"clusterEvalQ\"), list(\"\\n\", \"\\n\",  #>                   \"If \", list(\"clusterEvalQ()\"), \" is called, the call is ignored, and an error\\n\",  #>                   \"is produced. The error can be de-escalated to a warning by setting\\n\",  #>                   \"R option \", list(\"future.ClusterFuture.clusterEvalQ\"),  #>                   \" to \", list(\"\\\"warning\\\"\"), \".\\n\")), \"\\n\",  #>                 \"\\n\", list(\"\\n\", list(\"if ((getRversion() >= \\\"4.4.0\\\")) withAutoprint({ # examplesIf\"),  #>                   \"\\n\", \"plan(multisession)\\n\", \"cl <- makeClusterFuture()\\n\",  #>                   \"\\n\", \"parallel::clusterSetRNGStream(cl)\\n\",  #>                   \"\\n\", \"y <- parallel::parLapply(cl, 11:13, function(x) {\\n\",  #>                   \"  message(\\\"Process ID: \\\", Sys.getpid())\\n\",  #>                   \"  mean(rnorm(n = x))\\n\", \"})\\n\", \"str(y)\\n\",  #>                   \"\\n\", \"plan(sequential)\\n\", list(\"}) # examplesIf\"),  #>                   \"\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), mandelbrot.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/demo_api-mandelbrot.R\",  #>                 \"\\n\", list(\"mandelbrot\"), \"\\n\", list(\"mandelbrot\"),  #>                 \"\\n\", list(\"as.raster.Mandelbrot\"), \"\\n\", list( #>                   \"plot.Mandelbrot\"), \"\\n\", list(\"mandelbrot_tiles\"),  #>                 \"\\n\", list(\"mandelbrot.matrix\"), \"\\n\", list(\"mandelbrot.numeric\"),  #>                 \"\\n\", list(\"Mandelbrot convergence counts\"),  #>                 \"\\n\", list(\"\\n\", \"mandelbrot(...)\\n\", \"\\n\", list( #>                   list(\"mandelbrot\"), list(\"matrix\")), \"(Z, maxIter = 200L, tau = 2, ...)\\n\",  #>                   \"\\n\", list(list(\"mandelbrot\"), list(\"numeric\")),  #>                   \"(\\n\", \"  xmid = -0.75,\\n\", \"  ymid = 0,\\n\",  #>                   \"  side = 3,\\n\", \"  resolution = 400L,\\n\",  #>                   \"  maxIter = 200L,\\n\", \"  tau = 2,\\n\", \"  ...\\n\",  #>                   \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"Z\"), list( #>                   \"A complex matrix for which convergence\\n\",  #>                   \"counts should be calculated.\")), \"\\n\", \"\\n\",  #>                   list(list(\"maxIter\"), list(\"Maximum number of iterations per bin.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tau\"), list(\"A threshold; the radius when calling\\n\",  #>                     \"divergence (Mod(z) > tau).\")), \"\\n\", \"\\n\",  #>                   list(list(\"xmid, ymid, side, resolution\"),  #>                     list(\"Alternative specification of\\n\", \"the complex plane \",  #>                       list(\"Z\"), \", where\\n\", list(\"mean(Re(Z)) == xmid\"),  #>                       \",\\n\", list(\"mean(Im(Z)) == ymid\"), \",\\n\",  #>                       list(\"diff(range(Re(Z))) == side\"), \",\\n\",  #>                       list(\"diff(range(Im(Z))) == side\"), \", and\\n\",  #>                       list(\"dim(Z) == c(resolution, resolution)\"),  #>                       \".\")), \"\\n\"), \"\\n\", list(\"\\n\", \"Returns an integer matrix (of class Mandelbrot) with\\n\",  #>                   \"non-negative counts.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Mandelbrot convergence counts\\n\"), \"\\n\", list( #>                   \"\\n\", \"counts <- mandelbrot(xmid = -0.75, ymid = 0, side = 3)\\n\",  #>                   \"str(counts)\\n\", list(\"\\n\", \"plot(counts)\\n\"),  #>                   \"\\n\", \"\\n\", list(\"\\n\", \"demo(\\\"mandelbrot\\\", package = \\\"future\\\", ask = FALSE)\\n\"),  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"The internal Mandelbrot algorithm was inspired by and\\n\",  #>                   \"adopted from similar GPL code of Martin Maechler available\\n\",  #>                   \"from ftp://stat.ethz.ch/U/maechler/R/ on 2005-02-18 (sic!).\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), multicore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"multicore\"), \"\\n\", list(\"multicore\"),  #>                 \"\\n\", list(\"MulticoreFuture\"), \"\\n\", list(\"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\"),  #>                 \"\\n\", list(\"\\n\", \"multicore(..., workers = availableCores(constraints = \\\"multicore\\\"))\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\\n\",  #>                   \"If \", list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"sequential future. To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"WARNING: This function must never be called.\\n\",  #>                   \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A multicore future is a future that uses multicore evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another process\"), \".\\n\", \"\\n\",  #>                   \"This function is must \", list(\"not\"), \" be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many forked\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multicore)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two forked processes\\n\",  #>                     \"plan(multicore, workers = 2)\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\"), \"\\n\",  #>                 list(list(\"Support for forked (\\\"multicore\\\") processing\"),  #>                   list(\"\\n\", \"\\n\", \"Not all operating systems support process forking and thereby not multicore\\n\",  #>                     \"futures.  For instance, forking is not supported on Microsoft Windows.\\n\",  #>                     \"Moreover, process forking may break some R environments such as RStudio.\\n\",  #>                     \"Because of this, the future package disables process forking also in\\n\",  #>                     \"such cases.  See \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \" for details.\\n\", \"Trying to create multicore futures on non-supported systems or when\\n\",  #>                     \"forking is disabled will result in multicore futures falling back to\\n\",  #>                     \"becoming \", list(\"sequential\"), \" futures.  If used in RStudio, there will be an\\n\",  #>                     \"informative warning:\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"> plan(multicore)\\n\", \"Warning message:\\n\",  #>                       \"In supportsMulticoreAndRStudio(...) :\\n\",  #>                       \"  [ONE-TIME WARNING] Forked processing ('multicore') is not supported when\\n\",  #>                       \"running R from RStudio because it is considered unstable. For more details,\\n\",  #>                       \"how to control forked processing or not, and how to silence this warning in\\n\",  #>                       \"future R sessions, see ?parallelly::supportsMulticore\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(\"\\n\", \"## Use multicore futures\\n\",  #>                   \"plan(multicore)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multicore future is evaluated in a separate forked\\n\",  #>                   \"## process.  Changing the value of a global variable\\n\",  #>                   \"## will not affect the result of the future.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\",  #>                 list(\"\\n\", \"For processing in multiple background \",  #>                   list(), \" sessions, see\\n\", list(\"multisession\"),  #>                   \" futures.\\n\", \"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                   \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                   \".\\n\", \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\", \"Use \", list(list(\"availableCores\"),  #>                     \"(\\\"multicore\\\") > 1L\"), \" to check\\n\", \"whether multicore futures are supported or not on the current\\n\",  #>                   \"system.\\n\"), \"\\n\"), multisession.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in\", \"\\n\",  #>                 \"%   R/backend_api-13.MultisessionFutureBackend-class.R\",  #>                 \"\\n\", list(\"multisession\"), \"\\n\", list(\"multisession\"),  #>                 \"\\n\", list(\"MultisessionFuture\"), \"\\n\", list( #>                   \"Create a multisession future whose value will be resolved asynchronously in a parallel \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"multisession(\\n\",  #>                   \"  ...,\\n\", \"  workers = availableCores(constraints = \\\"connections-16\\\"),\\n\",  #>                   \"  rscript_libs = .libPaths()\\n\", \")\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\\n\",  #>                   \"If \", list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"sequential future. To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"rscript_libs\"), list(\"A character vector of \",  #>                     list(), \" package library folders that\\n\",  #>                     \"the workers should use.  The default is \",  #>                     list(\".libPaths()\"), \" so that multisession\\n\",  #>                     \"workers inherits the same library path as the main \",  #>                     list(), \" session.\\n\", \"To avoid this, use \",  #>                     list(\"plan(multisession, ..., rscript_libs = NULL)\"),  #>                     \".\\n\", list(\"Important: Note that the library path is set on the workers when they are\\n\",  #>                       \"created, i.e. when \", list(\"plan(multisession)\"),  #>                       \" is called.  Any changes to\\n\", list(\".libPaths()\"),  #>                       \" in the main R session after the workers have been created\\n\",  #>                       \"will have no effect.\"), \"\\n\", \"This is passed down as-is to \",  #>                     list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(list()), list( #>                     \"Additional arguments passed to \", list(list( #>                       \"Future()\")), \".\")), \"\\n\"), \"\\n\", list( #>                   \"\\n\", \"A MultisessionFuture.\\n\", \"If \", list( #>                     \"workers == 1\"), \", then all processing is done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"lazy future.  To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", list(\"WARNING: This function must never be called.\\n\",  #>                     \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A multisession future is a future that uses multisession evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another \", list(), \" session\"),  #>                   \".\\n\", \"\\n\", \"This function is must \", list( #>                     \"not\"), \" be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many background\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multisession)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two background\\n\",  #>                     \"# processes\\n\", \"plan(multisession, workers = 2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"The background \", list(), \" sessions (the \\\"workers\\\") are created using\\n\",  #>                   list(list(\"makeClusterPSOCK()\")), \".\\n\", \"\\n\",  #>                   \"For the total number of\\n\", list(), \" sessions available including the current/main \",  #>                   list(), \" process, see\\n\", list(list(\"parallelly::availableCores()\")),  #>                   \".\\n\", \"\\n\", \"A multisession future is a special type of cluster future.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use multisession futures\\n\",  #>                   \"plan(multisession)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multisession future is evaluated in a separate R session.\\n\",  #>                   \"## Changing the value of a global variable will not affect\\n\",  #>                   \"## the result of the future.\\n\", \"a <- 7\\n\",  #>                   \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\", \"print(v)\\n\",  #>                   \"stopifnot(v == 0)\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\"), \"\\n\", list(\"\\n\",  #>                   \"For processing in multiple forked \", list(),  #>                   \" sessions, see\\n\", list(\"multicore\"), \" futures.\\n\",  #>                   \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\"), \"\\n\"), nbrOfWorkers.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-nbrOfWorkers.R\",  #>                 \"\\n\", list(\"nbrOfWorkers\"), \"\\n\", list(\"nbrOfWorkers\"),  #>                 \"\\n\", list(\"nbrOfFreeWorkers\"), \"\\n\", list(\"Get the number of workers available\"),  #>                 \"\\n\", list(\"\\n\", \"nbrOfWorkers(evaluator = NULL)\\n\",  #>                   \"\\n\", \"nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"evaluator\"), list( #>                   \"A future evaluator function.\\n\", \"If NULL (default), the current evaluator as returned\\n\",  #>                   \"by \", list(list(\"plan()\")), \" is used.\")),  #>                   \"\\n\", \"\\n\", list(list(\"background\"), list(\"If TRUE, only workers that can process a future in the\\n\",  #>                     \"background are considered.  If FALSE, also workers running in the main \",  #>                     list(), \"\\n\", \"process are considered, e.g. when using the 'sequential' backend.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used; reserved for future use.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"nbrOfWorkers()\"),  #>                   \" returns a positive number in \", list(list( #>                     \"{1, 2, 3, ...}\")), \", which\\n\", \"for some future backends may also be \",  #>                   list(\"+Inf\"), \".\\n\", \"\\n\", list(\"nbrOfFreeWorkers()\"),  #>                   \" returns a non-negative number in\\n\", list( #>                     list(\"{0, 1, 2, 3, ...}\")), \" which is less than or equal to \",  #>                   list(\"nbrOfWorkers()\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get the number of workers available\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession)\\n\", \"nbrOfWorkers()  ## == availableCores()\\n\",  #>                   \"\\n\", \"plan(sequential)\\n\", \"nbrOfWorkers()  ## == 1\\n\"),  #>                 \"\\n\"), nullcon.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\"nullcon\"), \"\\n\", list(\"nullcon\"),  #>                 \"\\n\", list(\"Creates a connection to the system null device\"),  #>                 \"\\n\", list(\"\\n\", \"nullcon()\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Returns a open, binary \", list(list(\"base::connection()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Creates a connection to the system null device\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), plan.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R, R/utils_api-plan-with.R,\",  #>                 \"\\n\", \"%   R/utils_api-tweak.R\", \"\\n\", list(\"plan\"),  #>                 \"\\n\", list(\"plan\"), \"\\n\", list(\"with.FutureStrategyList\"),  #>                 \"\\n\", list(\"tweak\"), \"\\n\", list(\"Plan how to resolve a future\"),  #>                 \"\\n\", list(\"\\n\", \"plan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  ...,\\n\", \"  substitute = TRUE,\\n\", \"  .skip = FALSE,\\n\",  #>                   \"  .call = TRUE,\\n\", \"  .cleanup = NA,\\n\",  #>                   \"  .init = TRUE\\n\", \")\\n\", \"\\n\", list(list( #>                     \"with\"), list(\"FutureStrategyList\")), \"(data, expr, ..., local = FALSE, envir = parent.frame(), .cleanup = NA)\\n\",  #>                   \"\\n\", \"tweak(strategy, ..., penvir = parent.frame())\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"strategy\"), list( #>                   \"A future backend or the name of one.\")), \"\\n\",  #>                   \"\\n\", list(list(\"substitute\"), list(\"If \",  #>                     list(\"TRUE\"), \", the \", list(\"strategy\"),  #>                     \" expression is\\n\", list(\"substitute()\"),  #>                     \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\".skip\"), list(\"(internal) If \", list( #>                       \"TRUE\"), \", then attempts to set a future backend\\n\",  #>                       \"that is the same as what is currently in use, will be skipped.\")),  #>                   \"\\n\", \"\\n\", list(list(\".call\"), list(\"(internal) Used for recording the call to this function.\")),  #>                   \"\\n\", \"\\n\", list(list(\".cleanup\"), list(\"(internal) Used to stop implicitly started clusters.\")),  #>                   \"\\n\", \"\\n\", list(list(\".init\"), list(\"(internal) Used to initiate workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"data\"), list(\"The future plan to use temporarily, e.g. \",  #>                     list(\"plan(multisession)\"), \".\")), \"\\n\",  #>                   \"\\n\", list(list(\"expr\"), list(\"The R expression to be evaluated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"local\"), list(\"If TRUE, then the future plan specified by \",  #>                     list(\"data\"), \"\\n\", \"is applied temporarily in the calling frame. Argument \",  #>                     list(\"expr\"), \" must\\n\", \"not be specified if \",  #>                     list(\"local = TRUE\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"envir\"), list(\"The environment where the future plan should be set and the\\n\",  #>                     \"expression evaluated.\")), \"\\n\", \"\\n\", list( #>                     list(\"penvir\"), list(\"The environment used when searching for a future\\n\",  #>                       \"function by its name.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Additional arguments overriding the default arguments\\n\",  #>                     \"of the evaluation function.  Which additional arguments are supported\\n\",  #>                     \"depends on which future backend is used, e.g. several support\\n\",  #>                     \"argument \", list(\"workers\"), \" but not all. For details, see the individual\\n\",  #>                     \"backends of which some are linked to below.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"plan()\"), \" returns the previous plan invisibly if a new future backend\\n\",  #>                   \"is chosen, otherwise it returns the current one visibly.\\n\",  #>                   \"\\n\", \"The value of the expression evaluated (invisibly).\\n\",  #>                   \"\\n\", \"a future function.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"This function allows \", list(\"the user\"),  #>                   \" to plan the future, more specifically,\\n\",  #>                   \"it specifies how \", list(list(\"future()\")),  #>                   \"s are resolved,\\n\", \"e.g. sequentially or in parallel.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The default backend is \", list( #>                   list(\"sequential\")), \", but another one can be set\\n\",  #>                   \"using \", list(\"plan()\"), \", e.g. \", list(\"plan(multisession)\"),  #>                   \" will launch parallel workers\\n\", \"running in the background, which then will be used to resolve futures.\\n\",  #>                   \"To shut down background workers launched this way, call \",  #>                   list(\"plan(sequential)\"), \".\\n\"), \"\\n\", list( #>                   list(\"Built-in evaluation strategies\"), list( #>                     \"\\n\", \"\\n\", \"The \", list(\"future\"), \" package provides the following built-in backends:\\n\",  #>                     \"\\n\", list(\"\\n\", list(list(list(list(\"sequential\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures sequentially in the current \",  #>                       list(), \" process, e.g.\\n\", list(\"plan(sequential)\"),  #>                       \".\\n\")), \"\\n\", list(list(list(list(\"multisession\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                       list(), \" sessions running in the background on the same machine, e.g.\\n\",  #>                       list(\"plan(multisession)\"), \" and \", list( #>                         \"plan(multisession, workers = 2)\"), \".\\n\")),  #>                       \"\\n\", list(list(list(list(\"multicore\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(\"forked\"), \" \", list(), \" processes running in the background on\\n\",  #>                         \"the same machine, e.g.\\n\", list(\"plan(multicore)\"),  #>                         \" and \", list(\"plan(multicore, workers = 2)\"),  #>                         \".\\n\", \"This backend is not supported on Windows.\\n\")),  #>                       \"\\n\", list(list(list(list(\"cluster\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(), \" sessions running typically on one or more machines, e.g.\\n\",  #>                         list(\"plan(cluster)\"), \", \", list(\"plan(cluster, workers = 2)\"),  #>                         \", and\\n\", list(\"plan(cluster, workers = c(\\\"n1\\\", \\\"n1\\\", \\\"n2\\\", \\\"server.remote.org\\\"))\"),  #>                         \".\\n\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Other evaluation strategies available\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"In addition to the built-in ones, additional parallel backends are\\n\",  #>                     \"implemented in future-backend packages \",  #>                     list(\"future.callr\"), \" and\\n\", list(\"future.mirai\"),  #>                     \" that leverage R package \", list(\"callr\"),  #>                     \" and\\n\", list(\"mirai\"), \":\\n\", \"\\n\", list( #>                       \"\\n\", list(list(list(\"callr\"), \":\"), list( #>                         \"\\n\", \"Similar to \", list(\"multisession\"),  #>                         \", this resolves futures in parallel in\\n\",  #>                         \"background \", list(), \" sessions on the local machine via the \",  #>                         list(\"callr\"), \"\\n\", \"package, e.g. \",  #>                         list(\"plan(future.callr::callr)\"), \" and\\n\",  #>                         list(\"plan(future.callr::callr, workers = 2)\"),  #>                         \". The difference is that\\n\", \"each future is processed in a fresh parallel R worker, which is\\n\",  #>                         \"automatically shut down as soon as the future is resolved.\\n\",  #>                         \"This can help decrease the overall memory usage. Moreover, contrary\\n\",  #>                         \"to \", list(\"multisession\"), \", \", list( #>                           \"callr\"), \" does not rely on socket connections,\\n\",  #>                         \"which means it is not limited by the number of connections that\\n\",  #>                         list(), \" can have open at any time.\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"mirai_multisession\"),  #>                         \":\"), list(\"\\n\", \"Similar to \", list( #>                         \"multisession\"), \", this resolves futures in parallel in\\n\",  #>                         \"background \", list(), \" sessions on the local machine via the \",  #>                         list(\"mirai\"), \"\\n\", \"package, e.g. \",  #>                         list(\"plan(future.mirai::mirai_multisession)\"),  #>                         \" and\\n\", list(\"plan(future.mirai::mirai_multisession, workers = 2)\"),  #>                         \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"mirai_cluster\"),  #>                         \":\"), list(\"\\n\", \"Similar to \", list( #>                         \"cluster\"), \", this resolves futures in parallel via\\n\",  #>                         \"pre-configured \", list(), \" \", list( #>                           \"mirai\"), \" daemon processes, e.g.\\n\",  #>                         list(\"plan(future.mirai::mirai_cluster)\"),  #>                         \".\\n\")), \"\\n\"), \"\\n\", \"\\n\", \"Another example is the \",  #>                     list(\"future.batchtools\"), \" package, which leverages\\n\",  #>                     list(\"batchtools\"), \" package, to resolve futures via high-performance compute\\n\",  #>                     \"(HPC) job schedulers, e.g. LSF, Slurm, TORQUE/PBS, Grid Engine, and\\n\",  #>                     \"OpenLava;\\n\", \"\\n\", list(\"\\n\", list(list( #>                       list(\"batchtools_slurm\"), \":\"), list(\"\\n\",  #>                       \"The backend resolves futures via the Slurm scheduler, e.g.\\n\",  #>                       list(\"plan(future.batchtools::batchtools_slurm)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_torque\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the TORQUE/PBS scheduler, e.g.\\n\",  #>                       list(\"plan(future.batchtools::batchtools_torque)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_sge\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the Grid Engine (SGE, AGE) scheduler,\\n\",  #>                       \"e.g. \", list(\"plan(future.batchtools::batchtools_sge)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_lsf\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the Load Sharing Facility (LSF)\\n\",  #>                       \"scheduler, e.g. \", list(\"plan(future.batchtools::batchtools_lsf)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_openlava\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the OpenLava scheduler, e.g.\\n\",  #>                       list(\"plan(future.batchtools::batchtools_openlava)\"),  #>                       \".\\n\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"For package developers\"), list(\"\\n\",  #>                     \"\\n\", \"\\n\", \"Please refrain from modifying the future backend inside your packages /\\n\",  #>                     \"functions, i.e. do not call \", list(\"plan()\"),  #>                     \" in your code. Instead, leave\\n\", \"the control on what backend to use to the end user. This idea is part of\\n\",  #>                     \"the core philosophy of the future framework---as a developer you can never\\n\",  #>                     \"know what future backends the user have access to. Moreover, by not making\\n\",  #>                     \"any assumptions about what backends are available, your code will also work\\n\",  #>                     \"automatically with any new backends developed after you wrote your code.\\n\",  #>                     \"\\n\", \"If you think it is necessary to modify the future backend within a\\n\",  #>                     \"function, then make sure to undo the changes when exiting the function.\\n\",  #>                     \"This can be achieved by using \", list(\"with(plan(...), local = TRUE)\"),  #>                     \", e.g.\\n\", \"\\n\", list(\"\\n\", \"  my_fcn <- function(x) {\\n\",  #>                       \"    with(plan(multisession), local = TRUE)\\n\",  #>                       \"    y <- analyze(x)\\n\", \"    summarize(y)\\n\",  #>                       \"  }\\n\"), \"\\n\", \"\\n\", \"This is important because the end-user might have already set the future\\n\",  #>                     \"strategy elsewhere for other purposes and will most likely not know that\\n\",  #>                     \"calling your function will break their setup.\\n\",  #>                     list(\"Remember, your package and its functions might be used in a greater\\n\",  #>                       \"context where multiple packages and functions are involved and those might\\n\",  #>                       \"also rely on the future framework, so it is important to avoid stepping on\\n\",  #>                       \"others' toes.\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Using plan() in scripts and vignettes\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"When writing scripts or vignettes that use futures, try to place any\\n\",  #>                     \"call to \", list(\"plan()\"), \" as far up (i.e. as early on) in the code as possible.\\n\",  #>                     \"This will help users to quickly identify where the future plan is set up\\n\",  #>                     \"and allow them to modify it to their computational resources.\\n\",  #>                     \"Even better is to leave it to the user to set the \",  #>                     list(\"plan()\"), \" prior to\\n\", list(\"source()\"),  #>                     \":ing the script or running the vignette.\\n\",  #>                     \"If a \", list(list(\".future.R\")), \" exists in the current directory and / or in\\n\",  #>                     \"the user's home directory, it is sourced when the \",  #>                     list(\"future\"), \" package is\\n\", list(\"loaded\"),  #>                     \". Because of this, the \", list(\".future.R\"),  #>                     \" file provides a\\n\", \"convenient place for users to set the \",  #>                     list(\"plan()\"), \".\\n\", \"This behavior can be controlled via an \",  #>                     list(), \" option---see\\n\", list(\"future options\"),  #>                     \" for more details.\\n\")), \"\\n\", \"\\n\", list( #>                   \"\\n\", \"a <- b <- c <- NA_real_\\n\", \"\\n\", \"# An sequential future\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A sequential future with lazy evaluation\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"}, lazy = TRUE)\\n\", \"y <- value(f)\\n\", \"print(y)\\n\",  #>                   \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A multicore future (specified as a string)\\n\",  #>                   \"plan(\\\"multicore\\\")\\n\", \"f <- future({\\n\",  #>                   \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"## Multisession futures gives an error on R CMD check on\\n\",  #>                   \"## Windows (but not Linux or macOS) for unknown reasons.\\n\",  #>                   \"## The same code works in package tests.\\n\",  #>                   list(\"\\n\", \"\\n\", \"# A multisession future (specified via a string variable)\\n\",  #>                     \"plan(\\\"future::multisession\\\")\\n\", \"f <- future({\\n\",  #>                     \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                     \"  a * b * c\\n\", \"})\\n\", \"y <- value(f)\\n\",  #>                     \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                     \"\\n\"), \"\\n\", \"\\n\", \"\\n\", \"## Explicitly specifying number of workers\\n\",  #>                   \"## (default is parallelly::availableCores())\\n\",  #>                   \"plan(multicore, workers = 2)\\n\", \"message(\\\"Number of parallel workers: \\\", nbrOfWorkers())\\n\",  #>                   \"\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\", \"# Evaluate a future using the 'multisession' plan\\n\",  #>                   \"with(plan(multisession, workers = 2), {\\n\",  #>                   \"  f <- future(Sys.getpid())\\n\", \"  w_pid <- value(f)\\n\",  #>                   \"})\\n\", \"print(c(main = Sys.getpid(), worker = w_pid))\\n\",  #>                   \"\\n\", \"\\n\", \"\\n\", \"# Evaluate a future locally using the 'multisession' plan\\n\",  #>                   \"local({\\n\", \"  with(plan(multisession, workers = 2), local = TRUE)\\n\",  #>                   \"\\n\", \"  f <- future(Sys.getpid())\\n\", \"  w_pid <- value(f)\\n\",  #>                   \"  print(c(main = Sys.getpid(), worker = w_pid))\\n\",  #>                   \"})\\n\", \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"Use \",  #>                   list(list(\"plan()\")), \" to set a future to become the\\n\",  #>                   \"new default strategy.\\n\"), \"\\n\"), private_length.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\".length\"), \"\\n\", list(\".length\"),  #>                 \"\\n\", list(\"Gets the length of an object without dispatching\"),  #>                 \"\\n\", list(\"\\n\", \".length(x)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"Any \", list(),  #>                     \" object.\")), \"\\n\"), \"\\n\", list(\"\\n\", \"A non-negative integer.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets the length of an object without dispatching\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function returns \", list( #>                   \"length(unclass(x))\"), \", but tries to avoid\\n\",  #>                   \"calling \", list(\"unclass(x)\"), \" unless necessary.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\".subset\"), \"()\"),  #>                   \" and \", list(list(\".subset2\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), `re-exports.Rd` = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/000.re-exports.R\",  #>                 \"\\n\", list(\"re-exports\"), \"\\n\", list(\"re-exports\"),  #>                 \"\\n\", list(\"availableCores\"), \"\\n\", list(\"availableWorkers\"),  #>                 \"\\n\", list(\"makeClusterPSOCK\"), \"\\n\", list(\"supportsMulticore\"),  #>                 \"\\n\", list(\"Functions Moved to 'parallelly'\"),  #>                 \"\\n\", list(\"\\n\", \"The following function used to be part of \",  #>                   list(\"future\"), \", but has since\\n\", \"been migrated to \",  #>                   list(\"parallelly\"), \". The migration started with\\n\",  #>                   list(\"future\"), \" 1.20.0 (November 2020). They were moved because they\\n\",  #>                   \"are also useful outside of the \", list(\"future\"),  #>                   \" framework.\\n\"), \"\\n\", list(\"\\n\", list(\"If you are using any of these from the \",  #>                   list(\"future\"), \" package, please\\n\", \"switch to use the ones from the \",  #>                   list(\"parallelly\"), \" package. Thank you!\"),  #>                   \"\\n\", list(\"\\n\", list(), \" \", list(list(\"parallelly::as.cluster()\")),  #>                     \"    (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::autoStopCluster()\")),  #>                     \"   (no longer re-exported)\\n\", list(), \" \",  #>                     list(list(\"parallelly::availableCores()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                     \"    (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                     \"     (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \"\\n\"), \"\\n\", \"\\n\", \"For backward-compatible reasons, \",  #>                   list(\"some\"), \" of these functions remain\\n\",  #>                   \"available as exact copies also from this package (as re-exports), e.g.\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- parallelly::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"can still be accessed as:\\n\", \"\\n\",  #>                   list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- future::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", list(\"Note that it is the goal to remove all of the above from this package.\"),  #>                   \"\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), readImmediateConditions.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"readImmediateConditions\"), \"\\n\",  #>                 list(\"readImmediateConditions\"), \"\\n\", list(\"saveImmediateCondition\"),  #>                 \"\\n\", list(\"Writes and Reads 'immediateCondition' RDS Files\"),  #>                 \"\\n\", list(\"\\n\", \"readImmediateConditions(\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir(),\\n\", \"  pattern = \\\"[.]rds$\\\",\\n\",  #>                   \"  include = getOption(\\\"future.relay.immediate\\\", \\\"immediateCondition\\\"),\\n\",  #>                   \"  signal = FALSE,\\n\", \"  remove = TRUE\\n\",  #>                   \")\\n\", \"\\n\", \"saveImmediateCondition(\\n\", \"  cond,\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir()\\n\", \")\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"path\"), list(\"(character string) The folder where the RDS files are.\")),  #>                   \"\\n\", \"\\n\", list(list(\"pattern\"), list(\"(character string) A regular expression selecting\\n\",  #>                     \"the RDS files to be read.\")), \"\\n\", \"\\n\",  #>                   list(list(\"include\"), list(\"(character vector) The class or classes of the objects\\n\",  #>                     \"to be kept.\")), \"\\n\", \"\\n\", list(list(\"signal\"),  #>                     list(\"(logical) If TRUE, the condition read are signaled.\")),  #>                   \"\\n\", \"\\n\", list(list(\"remove\"), list(\"(logical) If TRUE, the RDS files used are removed on exit.\")),  #>                   \"\\n\", \"\\n\", list(list(\"cond\"), list(\"A condition of class \",  #>                     list(\"immediateCondition\"), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"readImmediateConditions()\"),  #>                   \" returns an unnamed \", list(\"base::list\"),  #>                   \" of\\n\", \"named lists with elements \", list( #>                     \"condition\"), \" and \", list(\"signaled\"),  #>                   \", where\\n\", \"the \", list(\"condition\"), \" elements hold \",  #>                   list(\"immediateCondition\"), \" objects.\\n\",  #>                   \"\\n\", list(\"saveImmediateCondition()\"), \" returns, invisibly, the pathname of\\n\",  #>                   \"the RDS written.\\n\"), \"\\n\", list(\"\\n\", \"Writes and Reads 'immediateCondition' RDS Files\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), requestCore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"requestCore\"), \"\\n\", list(\"requestCore\"),  #>                 \"\\n\", list(\"Request a core for multicore processing\"),  #>                 \"\\n\", list(\"\\n\", \"requestCore(\\n\", \"  await,\\n\",  #>                   \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                   \"  timeout,\\n\", \"  delta,\\n\", \"  alpha\\n\",  #>                   \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"await\"),  #>                   list(\"A function used to try to \\\"collect\\\"\\n\",  #>                     \"finished multicore subprocesses.\")), \"\\n\",  #>                   \"\\n\", list(list(\"workers\"), list(\"Total number of workers available.\")),  #>                   \"\\n\", \"\\n\", list(list(\"timeout\"), list(\"Maximum waiting time (in seconds) allowed\\n\",  #>                     \"before a timeout error is generated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"delta\"), list(\"Then base interval (in seconds) to wait\\n\",  #>                     \"between each try.\")), \"\\n\", \"\\n\", list(list( #>                     \"alpha\"), list(\"A multiplicative factor used to increase\\n\",  #>                     \"the wait interval after each try.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Invisible TRUE. If no cores are available after\\n\",  #>                   \"extensive waiting, then a timeout error is thrown.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If no cores are available, the current process\\n\",  #>                   \"blocks until a core is available.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), reset.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-reset.R\",  #>                 \"\\n\", list(\"reset\"), \"\\n\", list(\"reset\"), \"\\n\",  #>                 list(\"Reset a finished, failed, canceled, or interrupted future to a lazy future\"),  #>                 \"\\n\", list(\"\\n\", \"reset(x, ...)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"A Future.\")), \"\\n\",  #>                   \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"reset()\"), \" returns a lazy, vanilla \",  #>                   list(\"Future\"), \" that can be relaunched.\\n\",  #>                   \"Resetting a running future results in a \",  #>                   list(\"FutureError\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                   \"A future that has successfully completed, was \",  #>                   list(\"canceled\"), \" or interrupted,\\n\", \"or has failed due to an error, can be relaunched after resetting it.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"A lazy, vanilla \", list(\"Future\"),  #>                   \" can be reused in another R session. For\\n\",  #>                   \"instance, if we do:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"a <- 2\\n\", \"f <- future(42 * a, lazy = TRUE)\\n\",  #>                     \"saveRDS(f, \\\"myfuture.rds\\\")\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"Then we can read and evaluate the future in another R session using:\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"f <- readRDS(\\\"myfuture.rds\\\")\\n\",  #>                     \"v <- value(f)\\n\", \"print(v)\\n\", \"#> [1] 84\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"## Like mean(), but fails 90% of the time\\n\",  #>                   \"shaky_mean <- function(x) {\\n\", \"  if (as.double(Sys.time()) %% 1 < 0.90) stop(\\\"boom\\\")\\n\",  #>                   \"  mean(x)\\n\", \"}\\n\", \"\\n\", \"x <- rnorm(100)\\n\",  #>                   \"\\n\", \"## Calculate the mean of 'x' with a risk of failing randomly\\n\",  #>                   \"f <- future({ shaky_mean(x) })\\n\", \"\\n\", \"## Relaunch until success\\n\",  #>                   \"repeat({\\n\", \"  v <- tryCatch(value(f), error = identity)\\n\",  #>                   \"  if (!inherits(v, \\\"error\\\")) break\\n\", \"  message(\\\"Resetting failed future, and retry in 0.1 seconds\\\")\\n\",  #>                   \"  f <- reset(f)\\n\", \"  Sys.sleep(0.1)\\n\",  #>                   \"})\\n\", \"cat(\\\"mean:\\\", v, \\\"\\\\n\\\")\\n\"), \"\\n\"),  #>             resetWorkers.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R\",  #>                 \"\\n\", list(\"resetWorkers\"), \"\\n\", list(\"resetWorkers\"),  #>                 \"\\n\", list(\"Free up active background workers\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"A FutureStrategy.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Free up active background workers\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function will resolve any active futures that are currently\\n\",  #>                   \"being evaluated on background workers.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(plan())\\n\", \"\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), resolve.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-resolve.R\",  #>                 \"\\n\", list(\"resolve\"), \"\\n\", list(\"resolve\"),  #>                 \"\\n\", list(\"Resolve one or more futures synchronously\"),  #>                 \"\\n\", list(\"\\n\", \"resolve(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  result = FALSE,\\n\",  #>                   \"  stdout = FALSE,\\n\", \"  signal = FALSE,\\n\",  #>                   \"  force = FALSE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"x\"), list(\"A \", list(\"Future\"), \" to be resolved, or a list, an environment, or a\\n\",  #>                   \"list environment of futures to be resolved.\")),  #>                   \"\\n\", \"\\n\", list(list(\"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"result\"), list(\"(internal) If TRUE, the results are \",  #>                     list(\"retrieved\"), \", otherwise not.\\n\",  #>                     \"Note that this only collects the results from the parallel worker, which\\n\",  #>                     \"can help lower the overall latency if there are multiple concurrent futures.\\n\",  #>                     \"This does \", list(\"not\"), \" return the collected results.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"(internal) If TRUE, captured standard output is relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"signal\"), list(\"(internal) If TRUE, captured \",  #>                     list(\"conditions\"), \" are relayed,\\n\", \"otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed are relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns \", list(\"x\"), \" (regardless of subsetting or not).\\n\",  #>                   \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is produced.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"This function provides an efficient mechanism for waiting for multiple\\n\",  #>                   \"futures in a container (e.g. list or environment) to be resolved while in\\n\",  #>                   \"the meanwhile retrieving values of already resolved futures.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is resolves synchronously, i.e. it blocks until \",  #>                   list(\"x\"), \" and\\n\", \"any containing futures are resolved.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"To resolve a future \", list( #>                   \"variable\"), \", first retrieve its\\n\", list( #>                   \"Future\"), \" object using \", list(list(\"futureOf()\")),  #>                   \", e.g.\\n\", list(\"resolve(futureOf(x))\"), \".\\n\"),  #>                 \"\\n\"), resolved.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.ClusterFutureBackend-class.R,\",  #>                 \"\\n\", \"%   R/backend_api-11.MulticoreFutureBackend-class.R, R/core_api-resolved.R\",  #>                 \"\\n\", list(\"resolved.ClusterFuture\"), \"\\n\", list( #>                   \"resolved.ClusterFuture\"), \"\\n\", list(\"resolved.MulticoreFuture\"),  #>                 \"\\n\", list(\"resolved\"), \"\\n\", list(\"resolved.default\"),  #>                 \"\\n\", list(\"resolved.list\"), \"\\n\", list(\"resolved.environment\"),  #>                 \"\\n\", list(\"resolved.Future\"), \"\\n\", list(\"Check whether a future is resolved or not\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"resolved\"), list( #>                   \"ClusterFuture\")), \"(x, timeout = NULL, ...)\\n\",  #>                   \"\\n\", list(list(\"resolved\"), list(\"MulticoreFuture\")),  #>                   \"(x, timeout = NULL, ...)\\n\", \"\\n\", \"resolved(x, ...)\\n\",  #>                   \"\\n\", list(list(\"resolved\"), list(\"default\")),  #>                   \"(x, ...)\\n\", \"\\n\", list(list(\"resolved\"),  #>                     list(\"list\")), \"(x, ...)\\n\", \"\\n\", list(list( #>                     \"resolved\"), list(\"environment\")), \"(x, ...)\\n\",  #>                   \"\\n\", list(list(\"resolved\"), list(\"Future\")),  #>                   \"(x, ...)\\n\"), \"\\n\", list(\"\\n\", list(list(\"x\"),  #>                   list(\"A \", list(\"Future\"), \", a list, or an environment (which also\\n\",  #>                     \"includes \", list(\"list environment\"), \").\")),  #>                   \"\\n\", \"\\n\", list(list(\"timeout\"), list(\"(numeric) The maximum time (in seconds) for polling the worker\\n\",  #>                     \"for a response. If no response is available within this time limit, FALSE is\\n\",  #>                     \"returned assuming the future is still being processed.\\n\",  #>                     \"If NULL, the value defaults to \", list(\"getOption(\\\"future.<type>.resolved.timeout\\\")\"),  #>                     \",\\n\", \"then \", list(\"getOption(\\\"future.resolved.timeout\\\")\"),  #>                     \", and finally 0.01 (seconds),\\n\", \"where \",  #>                     list(\"<type>\"), \" corresponds to the type of future, e.g. \",  #>                     list(\"cluster\"), \" and \", list(\"multicore\"),  #>                     \".\")), \"\\n\", \"\\n\", list(list(list()), list( #>                     \"Not used.\")), \"\\n\"), \"\\n\", list(\"\\n\", \"A logical vector of the same length and dimensions as \",  #>                   list(\"x\"), \".\\n\", \"Each element is TRUE unless the corresponding element is a\\n\",  #>                   \"non-resolved future in case it is FALSE.\\n\",  #>                   \"It never signals an error.\\n\", \"\\n\", \"The default method always returns TRUE.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Check whether a future is resolved or not\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"resolved()\"), \" attempts to launch a lazy future, if there is an available\\n\",  #>                   \"worker, otherwise not.\\n\", \"\\n\", list(\"resolved()\"),  #>                   \" methods must always return \", list(\"TRUE\"),  #>                   \" or \", list(\"FALSE\"), \" values, must\\n\", \"always launch lazy futures, and must never block indefinitely. This is\\n\",  #>                   \"because it should always be possible to poll futures until they are\\n\",  #>                   \"resolved using \", list(\"resolved()\"), \", e.g.\\n\",  #>                   list(\"while (!all(resolved(futures))) Sys.sleep(5)\"),  #>                   \".\\n\", \"\\n\", \"Each future backend must implement a \",  #>                   list(\"resolved()\"), \" method. It should return\\n\",  #>                   \"either TRUE or FALSE, or throw a \", list(\"FutureError\"),  #>                   \" (which indicates a\\n\", \"significant, often unrecoverable infrastructure problem, or an interrupt).\\n\"),  #>                 \"\\n\", list(list(\"Behavior of cluster and multisession futures\"),  #>                   list(\"\\n\", \"\\n\", \"If all worker slots are occupied, \",  #>                     list(\"resolved()\"), \" for \", list(\"ClusterFuture\"),  #>                     \" and\\n\", list(\"MultisessionFuture\"), \" will attempt to free one up by checking whether\\n\",  #>                     \"one of the futures is \", list(\"resolved\"),  #>                     \". If there is one, then its result is\\n\",  #>                     \"collected in order to free up one worker slot.\\n\",  #>                     \"\\n\", list(\"resolved()\"), \" for \", list(\"ClusterFuture\"),  #>                     \" may receive immediate condition objects, rather\\n\",  #>                     \"than a \", list(\"FutureResult\"), \", when polling the worker for results. In such cases, the\\n\",  #>                     \"condition object is collected and another poll it performed. Up to 100 immediate\\n\",  #>                     \"conditions may be collected this way per \",  #>                     list(\"resolved()\"), \" call, before considering\\n\",  #>                     \"the future non-resolved and FALSE being returned.\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Behavior of multicore futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"resolved()\"), \" for \",  #>                     list(\"MulticoreFuture\"), \" may receive immediate condition objects, rather than a\\n\",  #>                     list(\"FutureResult\"), \", when polling the worker for results. In such cases, \",  #>                     list(\"all\"), \" such condition\\n\", \"objects are collected, before considering the future non-resolved and FALSE being returned.\\n\")),  #>                 \"\\n\", \"\\n\"), result.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-result.R\",  #>                 \"\\n\", list(\"result.Future\"), \"\\n\", list(\"result.Future\"),  #>                 \"\\n\", list(\"result\"), \"\\n\", list(\"Get the results of a resolved future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"result\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"FutureResult\"),  #>                   \" object.\\n\", \"It may signal a \", list(\"FutureError\"),  #>                   \", if there is a significant orchestration\\n\",  #>                   \"error. For example, if the parallel worker process terminated abruptly\\n\",  #>                   \"(\\\"crashed\\\"), then a \", list(\"FutureInterruptError\"),  #>                   \" is signaled.\\n\"), \"\\n\", list(\"\\n\", \"Get the results of a resolved future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                   list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                   list(\"not\"), \" part of the frontend Future API.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), run.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"run.Future\"), \"\\n\", list(\"run.Future\"),  #>                 \"\\n\", list(\"run\"), \"\\n\", list(\"Run a future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"run\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"Future\"),  #>                   \" object.\\n\"), \"\\n\", list(\"\\n\", \"Run a future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function can only be called once per future.\\n\",  #>                   \"Further calls will result in an informative error.\\n\",  #>                   \"If a future is not run when its value is queried,\\n\",  #>                   \"then it is run at that point.\\n\"), \"\\n\", list( #>                   \"internal\"), \"\\n\"), save_rds.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"save_rds\"), \"\\n\", list(\"save_rds\"),  #>                 \"\\n\", list(\"Robustly Saves an Object to RDS File Atomically\"),  #>                 \"\\n\", list(\"\\n\", \"save_rds(object, pathname, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"The \",  #>                   list(), \" object to be save.\")), \"\\n\", \"\\n\",  #>                   list(list(\"pathname\"), list(\"RDS file to written.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional arguments passed to \",  #>                     list(list(\"base::saveRDS()\")), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The pathname of the RDS written.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Robustly Saves an Object to RDS File Atomically\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Uses \", list(\"base::saveRDS\"),  #>                   \" internally but writes the object atomically by first\\n\",  #>                   \"writing to a temporary file which is then renamed.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sequential.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.SequentialFutureBackend-class.R\",  #>                 \"\\n\", list(\"sequential\"), \"\\n\", list(\"sequential\"),  #>                 \"\\n\", list(\"uniprocess\"), \"\\n\", list(\"Create a sequential future whose value will be in the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sequential(..., envir = parent.frame())\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"envir\"), list(\"The \",  #>                   list(\"environment\"), \" from where global objects should be\\n\",  #>                   \"identified.\")), \"\\n\", \"\\n\", list(list(list()),  #>                   list(\"Not used.\")), \"\\n\"), \"\\n\", list(\"\\n\",  #>                   list(\"WARNING: This function must never be called.\\n\",  #>                     \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A sequential future is a future that is evaluated sequentially in the\\n\",  #>                   \"current \", list(), \" session similarly to how \",  #>                   list(), \" expressions are evaluated in \", list(),  #>                   \".\\n\", \"The only difference to \", list(), \" itself is that globals are validated\\n\",  #>                   \"by default just as for all other types of futures in this package.\\n\",  #>                   \"\\n\", \"This function is must \", list(\"not\"),  #>                   \" be called directly.  Instead, the\\n\", \"typical usages are:\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures sequentially in the current R process\\n\",  #>                     \"plan(sequential)\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\"), \"\\n\", list( #>                   \"\\n\", \"## Use sequential futures\\n\", \"plan(sequential)\\n\",  #>                   \"\\n\", \"## A global variable\\n\", \"a <- 0\\n\",  #>                   \"\\n\", \"## Create a sequential future\\n\", \"f <- future({\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"\\n\", \"## Since 'a' is a global variable in future 'f' which\\n\",  #>                   \"## is eagerly resolved (default), this global has already\\n\",  #>                   \"## been resolved / incorporated, and any changes to 'a'\\n\",  #>                   \"## at this point will _not_ affect the value of 'f'.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\"),  #>             sessionDetails.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-sessionDetails.R\",  #>                 \"\\n\", list(\"sessionDetails\"), \"\\n\", list(\"sessionDetails\"),  #>                 \"\\n\", list(\"Outputs details on the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sessionDetails(env = FALSE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"env\"), list(\"If TRUE, \",  #>                   list(\"Sys.getenv()\"), \" information is returned.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Invisibly a list of all details.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Outputs details on the current \",  #>                   list(), \" session\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), signalConditions.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-signalConditions.R\",  #>                 \"\\n\", list(\"signalConditions\"), \"\\n\", list(\"signalConditions\"),  #>                 \"\\n\", list(\"Signals Captured Conditions\"), \"\\n\",  #>                 list(\"\\n\", \"signalConditions(\\n\", \"  future,\\n\",  #>                   \"  include = \\\"condition\\\",\\n\", \"  exclude = NULL,\\n\",  #>                   \"  resignal = TRUE,\\n\", \"  ...\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A resolved \",  #>                   list(\"Future\"), \".\")), \"\\n\", \"\\n\", list(list( #>                   \"include\"), list(\"A character string of \",  #>                   list(\"condition\"), \"\\n\", \"classes to signal.\")),  #>                   \"\\n\", \"\\n\", list(list(\"exclude\"), list(\"A character string of \",  #>                     list(\"condition\"), \"\\n\", \"classes \", list( #>                       \"not\"), \" to signal.\")), \"\\n\", \"\\n\", list( #>                     list(\"resignal\"), list(\"If TRUE, then already signaled conditions are signaled\\n\",  #>                       \"again, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns the \", list(\"Future\"),  #>                   \" where conditioned that were signaled\\n\",  #>                   \"have been flagged to have been signaled.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Captured conditions that meet the \",  #>                   list(\"include\"), \" and \", list(\"exclude\"),  #>                   \"\\n\", \"requirements are signaled \", list(\"in the order as they were captured\"),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Conditions are signaled by\\n\",  #>                   list(list(\"signalCondition\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sticky_globals.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>                 \"\\n\", list(\"sticky_globals\"), \"\\n\", list(\"sticky_globals\"),  #>                 \"\\n\", list(\"Place a sticky-globals environment immediately after the global environment\"),  #>                 \"\\n\", list(\"\\n\", \"sticky_globals(erase = FALSE, name = \\\"future:sticky_globals\\\", pos = 2L)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"erase\"), list(\"(logical) If TRUE, the environment is erased, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"name\"), list(\"(character) The name of the environment on the \",  #>                     list(\"base::search\"), \"\\n\", \"path.\")), \"\\n\",  #>                   \"\\n\", list(list(\"pos\"), list(\"(integer) The position on the search path where the\\n\",  #>                     \"environment should be positioned.  If \",  #>                     list(\"pos == 0L\"), \", then the environment\\n\",  #>                     \"is detached, if it exists.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"(invisible; environment) The environment.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Place a sticky-globals environment immediately after the global environment\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), usedCores.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"usedCores\"), \"\\n\", list(\"usedCores\"),  #>                 \"\\n\", list(\"Get number of cores currently used\"),  #>                 \"\\n\", list(\"\\n\", \"usedCores()\\n\"), \"\\n\", list( #>                   \"\\n\", \"A non-negative integer.\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get number of children (and don't count the current process)\\n\",  #>                   \"used by the current \", list(), \" session.  The number of children\\n\",  #>                   \"is the total number of subprocesses launched by this\\n\",  #>                   \"process that are still running and whose values have yet\\n\",  #>                   \"not been collected.\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), value.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-value.R\",  #>                 \"\\n\", list(\"value\"), \"\\n\", list(\"value\"), \"\\n\",  #>                 list(\"value.Future\"), \"\\n\", list(\"value.list\"),  #>                 \"\\n\", list(\"value.listenv\"), \"\\n\", list(\"value.environment\"),  #>                 \"\\n\", list(\"The value of a future or the values of all elements in a container\"),  #>                 \"\\n\", list(\"\\n\", \"value(...)\\n\", \"\\n\", list(list( #>                   \"value\"), list(\"Future\")), \"(future, stdout = TRUE, signal = TRUE, drop = FALSE, ...)\\n\",  #>                   \"\\n\", list(list(\"value\"), list(\"list\")), \"(\\n\",  #>                   \"  x,\\n\", \"  idxs = NULL,\\n\", \"  recursive = 0,\\n\",  #>                   \"  reduce = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  signal = TRUE,\\n\", \"  cancel = TRUE,\\n\",  #>                   \"  interrupt = cancel,\\n\", \"  inorder = TRUE,\\n\",  #>                   \"  drop = FALSE,\\n\", \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"listenv\")), \"(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  reduce = NULL,\\n\",  #>                   \"  stdout = TRUE,\\n\", \"  signal = TRUE,\\n\",  #>                   \"  cancel = TRUE,\\n\", \"  interrupt = cancel,\\n\",  #>                   \"  inorder = TRUE,\\n\", \"  drop = FALSE,\\n\",  #>                   \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"environment\")), \"(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"future, x\"), list(\"A \",  #>                   list(\"Future\"), \", an environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE, standard output captured while resolving futures\\n\",  #>                     \"is relayed, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(\"signal\"), list(\"If TRUE, \", list( #>                     \"conditions\"), \" captured while resolving\\n\",  #>                     \"futures are relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"If TRUE, resolved futures are minimized in size and invalidated\\n\",  #>                     \"as soon as their values have been collected and any output and\\n\",  #>                     \"conditions have been relayed.\\n\", \"Combining \",  #>                     list(\"drop = TRUE\"), \" with \", list(\"inorder = FALSE\"),  #>                     \" reduces the memory use\\n\", \"sooner, especially avoiding the risk of holding on to future values until\\n\",  #>                     \"the very end.\")), \"\\n\", \"\\n\", list(list( #>                     \"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"reduce\"), list(\"An optional function for reducing all the values.\\n\",  #>                     \"Optional attribute \", list(\"init\"), \" can be used to set initial value for the\\n\",  #>                     \"reduction. If not specified, the first value will be used as the\\n\",  #>                     \"initial value.\\n\", \"Reduction of values is done as soon as possible, but always in the\\n\",  #>                     \"same order as \", list(\"x\"), \", unless \",  #>                     list(\"inorder\"), \" is FALSE.\")), \"\\n\", \"\\n\",  #>                   list(list(\"cancel, interrupt\"), list(\"If TRUE and \",  #>                     list(\"signal\"), \" is TRUE, non-resolved futures\\n\",  #>                     \"are canceled as soon as an error is detected in one of the futures,\\n\",  #>                     \"before signaling the error. Argument \",  #>                     list(\"interrupt\"), \" is passed to \", list( #>                       \"cancel()\"), \"\\n\", \"controlling whether non-resolved futures should also be interrupted.\")),  #>                   \"\\n\", \"\\n\", list(list(\"inorder\"), list(\"If TRUE, then standard output and conditions are relayed,\\n\",  #>                     \"and value reduction is done in the order the futures occur in \",  #>                     list(\"x\"), \", but\\n\", \"always as soon as possible. This is achieved by buffering the details\\n\",  #>                     \"until they can be released. By setting \",  #>                     list(\"inorder = FALSE\"), \", no buffering\\n\",  #>                     \"takes place and everything is relayed and reduced as soon as a new future\\n\",  #>                     \"is resolved. Regardless, the values are always returned in the same\\n\",  #>                     \"order as \", list(\"x\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed are relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"value()\"), \" of a Future object returns the value of the future, which can\\n\",  #>                   \"be any type of \", list(), \" object.\\n\", \"\\n\",  #>                   list(\"value()\"), \" of a list, an environment, or a list environment returns an\\n\",  #>                   \"object with the same number of elements and of the same class.\\n\",  #>                   \"Names and dimension attributes are preserved, if available.\\n\",  #>                   \"All future elements are replaced by their corresponding \",  #>                   list(\"value()\"), \" values.\\n\", \"For all other elements, the existing object is kept as-is.\\n\",  #>                   \"\\n\", \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is relayed. Any remaining, non-resolved futures in \",  #>                   list(\"x\"), \" are\\n\", \"canceled, prior to signaling such an error.\\n\",  #>                   \"If the future was interrupted, canceled, or the parallel worker terminated\\n\",  #>                   \"abruptly (\\\"crashed\\\"), then a \", list(\"FutureInterruptError\"),  #>                   \" is signaled.\\n\"), \"\\n\", list(\"\\n\", \"Gets the value of a future or the values of all elements (including futures)\\n\",  #>                   \"in a container such as a list, an environment, or a list environment.\\n\",  #>                   \"If one or more futures are unresolved, then this function blocks until all\\n\",  #>                   \"queried futures are resolved.\\n\"), \"\\n\", list( #>                   \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## A single future\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"x <- sample(100, size = 50)\\n\", \"f <- future(mean(x))\\n\",  #>                   \"v <- value(f)\\n\", \"message(\\\"The average of 50 random numbers in [1,100] is: \\\", v)\\n\",  #>                   \"\\n\", \"\\n\", \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## Ten futures\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"xs <- replicate(10, { list(sample(100, size = 50)) })\\n\",  #>                   \"fs <- lapply(xs, function(x) { future(mean(x)) })\\n\",  #>                   \"\\n\", \"## The 10 values as a list (because 'fs' is a list)\\n\",  #>                   \"vs <- value(fs)\\n\", \"message(\\\"The ten averages are:\\\")\\n\",  #>                   \"str(vs)\\n\", \"\\n\", \"## The 10 values as a vector (by manually unlisting)\\n\",  #>                   \"vs <- value(fs)\\n\", \"vs <- unlist(vs)\\n\",  #>                   \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## The values as a vector (by reducing)\\n\",  #>                   \"vs <- value(fs, reduce = c)\\n\", \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## Calculate the sum of the averages (by reducing)\\n\",  #>                   \"total <- value(fs, reduce = `+`)\\n\", \"message(\\\"The sum of the ten averages is: \\\", total)\\n\"),  #>                 \"\\n\"), `zzz-future.options.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-options.R\",  #>                 \"\\n\", list(\"zzz-future.options\"), \"\\n\", list( #>                   \"zzz-future.options\"), \"\\n\", list(\"future.options\"),  #>                 \"\\n\", list(\"future.startup.script\"), \"\\n\", list( #>                   \"future.debug\"), \"\\n\", list(\"future.demo.mandelbrot.region\"),  #>                 \"\\n\", list(\"future.demo.mandelbrot.nrow\"), \"\\n\",  #>                 list(\"future.fork.multithreading.enable\"), \"\\n\",  #>                 list(\"future.globals.maxSize\"), \"\\n\", list(\"future.globals.method\"),  #>                 \"\\n\", list(\"future.globals.onMissing\"), \"\\n\",  #>                 list(\"future.globals.resolve\"), \"\\n\", list(\"future.globals.onReference\"),  #>                 \"\\n\", list(\"future.plan\"), \"\\n\", list(\"future.onFutureCondition.keepFuture\"),  #>                 \"\\n\", list(\"future.resolve.recursive\"), \"\\n\",  #>                 list(\"future.connections.onMisuse\"), \"\\n\", list( #>                   \"future.defaultDevice.onMisuse\"), \"\\n\", list( #>                   \"future.devices.onMisuse\"), \"\\n\", list(\"future.globalenv.onMisuse\"),  #>                 \"\\n\", list(\"future.rng.onMisuse\"), \"\\n\", list( #>                   \"future.wait.alpha\"), \"\\n\", list(\"future.wait.interval\"),  #>                 \"\\n\", list(\"future.wait.timeout\"), \"\\n\", list( #>                   \"future.output.windows.reencode\"), \"\\n\", list( #>                   \"future.journal\"), \"\\n\", list(\"future.globals.objectSize.method\"),  #>                 \"\\n\", list(\"future.ClusterFuture.clusterEvalQ\"),  #>                 \"\\n\", list(\"R_FUTURE_STARTUP_SCRIPT\"), \"\\n\",  #>                 list(\"R_FUTURE_DEBUG\"), \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_REGION\"),  #>                 \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_NROW\"),  #>                 \"\\n\", list(\"R_FUTURE_FORK_MULTITHREADING_ENABLE\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_MAXSIZE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_METHOD\"), \"\\n\", list(\"R_FUTURE_GLOBALS_ONMISSING\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_RESOLVE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_ONREFERENCE\"), \"\\n\", list( #>                   \"R_FUTURE_PLAN\"), \"\\n\", list(\"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\"),  #>                 \"\\n\", list(\"R_FUTURE_RESOLVE_RECURSIVE\"), \"\\n\",  #>                 list(\"R_FUTURE_CONNECTIONS_ONMISUSE\"), \"\\n\",  #>                 list(\"R_FUTURE_DEVICES_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_DEFAULTDEVICE_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_GLOBALENV_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_RNG_ONMISUSE\"), \"\\n\", list(\"R_FUTURE_WAIT_ALPHA\"),  #>                 \"\\n\", list(\"R_FUTURE_WAIT_INTERVAL\"), \"\\n\", list( #>                   \"R_FUTURE_WAIT_TIMEOUT\"), \"\\n\", list(\"R_FUTURE_RESOLVED_TIMEOUT\"),  #>                 \"\\n\", list(\"R_FUTURE_OUTPUT_WINDOWS_REENCODE\"),  #>                 \"\\n\", list(\"R_FUTURE_JOURNAL\"), \"\\n\", list(\"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\"),  #>                 \"\\n\", list(\"R_FUTURE_CLUSTERFUTURE_CLUSTEREVALQ\"),  #>                 \"\\n\", list(\"future.cmdargs\"), \"\\n\", list(\".future.R\"),  #>                 \"\\n\", list(\"Options used for futures\"), \"\\n\",  #>                 list(\"\\n\", \"Below are the \", list(), \" options and environment variables that are used by the\\n\",  #>                   list(\"future\"), \" package and packages enhancing it.\",  #>                   list(), \"\\n\", list(), \"\\n\", list(\"WARNING: Note that the names and the default values of these options may\\n\",  #>                     \"change in future versions of the package.  Please use with care until\\n\",  #>                     \"further notice.\"), \"\\n\"), \"\\n\", list(list( #>                   \"Packages must not change future options\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Just like for other R options, as a package developer you must \",  #>                     list(\"not\"), \" change\\n\", \"any of the below \",  #>                     list(\"future.*\"), \" options.  Only the end-user should set these.\\n\",  #>                     \"If you find yourself having to tweak one of the options, make sure to\\n\",  #>                     \"undo your changes immediately afterward.  For example, if you want to\\n\",  #>                     \"bump up the \", list(\"future.globals.maxSize\"),  #>                     \" limit when creating a future,\\n\", \"use something like the following inside your function:\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB\\n\",  #>                       \"on.exit(options(oopts))\\n\", \"f <- future({ expr })  ## Launch a future with large objects\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(list(\"Options for controlling futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.plan\"), \":\"), list(\"(character string or future function) Default future backend used unless otherwise specified via \",  #>                     list(list(\"plan()\")), \". This will also be the future plan set when calling \",  #>                     list(\"plan(\\\"default\\\")\"), \".  If not specified, this option may be set when the \",  #>                     list(\"future\"), \" package is \", list(\"loaded\"),  #>                     \" if command-line option \", list(\"--parallel=ncores\"),  #>                     \" (short \", list(\"-p ncores\"), \") is specified; if \",  #>                     list(\"ncores > 1\"), \", then option \", list( #>                       \"future.plan\"), \" is set to \", list(\"multisession\"),  #>                     \" otherwise \", list(\"sequential\"), \" (in addition to option \",  #>                     list(\"mc.cores\"), \" being set to \", list( #>                       \"ncores\"), \", if \", list(\"ncores >= 1\"),  #>                     \"). (Default: \", list(\"sequential\"), \")\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.maxSize\"),  #>                       \":\"), list(\"(numeric) Maximum allowed total size (in bytes) of global variables identified. This is used to protect against exporting too large objects to parallel workers by mistake. Transferring large objects over a network, or over the internet, can be slow and therefore introduce a large bottleneck that increases the overall processing time. It can also result in large egress or ingress costs, which may exist on some systems. If set of \",  #>                       list(\"+Inf\"), \", then the check for large globals is skipped. (Default: \",  #>                       list(\"500 * 1024 ^ 2\"), \" = 500 MiB)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.onReference\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) Controls whether the identified globals should be scanned for so called \",  #>                       list(\"references\"), \" (e.g. external pointers and connections) or not.  It is unlikely that another \",  #>                       list(), \" process (\\\"worker\\\") can use a global that uses a internal reference of the master \",  #>                       list(), \" process---we call such objects \",  #>                       list(\"non-exportable globals\"), \".\\n\",  #>                       \"If this option is \", list(\"\\\"error\\\"\"),  #>                       \", an informative error message is produced if a non-exportable global is detected.\\n\",  #>                       \"If \", list(\"\\\"warning\\\"\"), \", a warning is produced, but the processing will continue; it is likely that the future will be resolved with a run-time error unless processed in the master \",  #>                       list(), \" process (e.g. \", list(\"plan(sequential)\"),  #>                       \" and \", list(\"plan(multicore)\"), \").\\n\",  #>                       \"If \", list(\"\\\"ignore\\\"\"), \", no scan is performed.\\n\",  #>                       \"(Default: \", list(\"\\\"ignore\\\"\"), \" but may change)\\n\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.resolve.recursive\"),  #>                       \":\"), list(\"(integer) An integer specifying the maximum recursive depth to which futures should be resolved. If negative, nothing is resolved.  If \",  #>                       list(\"0\"), \", only the future itself is resolved.  If \",  #>                       list(\"1\"), \", the future and any of its elements that are futures are resolved, and so on. If \",  #>                       list(\"+Inf\"), \", infinite search depth is used. (Default: \",  #>                       list(\"0\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.onFutureCondition.keepFuture\"),  #>                       \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                       \", a \", list(\"FutureCondition\"), \" keeps a copy of the \",  #>                       list(\"Future\"), \" object that triggered the condition. If \",  #>                       list(\"FALSE\"), \", it is dropped. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.wait.timeout\"), \":\"), list( #>                       \"(numeric) Maximum waiting time (in seconds) for a future to resolve or for a free worker to become available before a timeout error is generated. (Default: \",  #>                       list(\"30 * 24 * 60 * 60\"), \" (= 30 days))\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.interval\"),  #>                       \":\"), list(\"(numeric) Initial interval (in\\n\",  #>                       \"seconds) between polls. This controls the polling frequency for finding\\n\",  #>                       \"an available worker when all workers are currently busy. It also controls\\n\",  #>                       \"the polling frequency of \", list(\"resolve()\"),  #>                       \". (Default: \", list(\"0.01\"), \" = 1 ms)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.alpha\"),  #>                       \":\"), list(\"(numeric) Positive scale factor used to increase the interval after each poll. (Default: \",  #>                       list(\"1.01\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for built-in sanity checks\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Ideally, the evaluation of a future should have no side effects. To\\n\",  #>                     \"protect against unexpected side effects, the future framework comes\\n\",  #>                     \"with a set of built-in tools for checking against this.\\n\",  #>                     \"Below R options control these built-in checks and what should happen\\n\",  #>                     \"if they fail. You may modify them for troubleshooting purposes, but\\n\",  #>                     \"please refrain from disabling these checks when there is an underlying\\n\",  #>                     \"problem that should be fixed.\\n\", \"\\n\",  #>                     list(\"Beta features: Please consider these checks to be \\\"under construction\\\".\"),  #>                     \"\\n\", \"\\n\", list(\"\\n\", list(list(list(\"future.connections.onMisuse\"),  #>                       \":\"), list(\"(character string)\\n\", \"A future must close any connections it opens and must not close\\n\",  #>                       \"connections it did not open itself.\\n\",  #>                       \"If such misuse is detected and this option is set to \",  #>                       list(\"\\\"error\\\"\"), \",\\n\", \"then an informative error is produced. If it is set to \",  #>                       list(\"\\\"warning\\\"\"), \",\\n\", \"a warning is produced. If\",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed.\\n\",  #>                       \"(Default: \", list(\"\\\"warning\\\"\"), \")\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"future.defaultDevice.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"A future must open graphics devices explicitly, if it creates new\\n\",  #>                         \"plots. It should not rely on the default graphics device that\\n\",  #>                         \"is given by R option \", list(\"\\\"default\\\"\"),  #>                         \", because that rarely does what\\n\",  #>                         \"is intended.\\n\", \"If such misuse is detected and this option is set to \",  #>                         list(\"\\\"error\\\"\"), \",\\n\", \"then an informative error is produced. If it is set to \",  #>                         list(\"\\\"warning\\\"\"), \",\\n\", \"a warning is produced. If\",  #>                         list(\"\\\"ignore\\\"\"), \", no check is performed.\\n\",  #>                         \"(Default: \", list(\"\\\"warning\\\"\"), \")\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"future.devices.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"A future must close any graphics devices it opens and must not close\\n\",  #>                         \"devices it did not open itself.\\n\",  #>                         \"If such misuse is detected and this option is set to \",  #>                         list(\"\\\"error\\\"\"), \",\\n\", \"then an informative error is produced. If it is set to \",  #>                         list(\"\\\"warning\\\"\"), \",\\n\", \"a warning is produced. If\",  #>                         list(\"\\\"ignore\\\"\"), \", no check is performed.\\n\",  #>                         \"(Default: \", list(\"\\\"warning\\\"\"), \")\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"future.globalenv.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"Assigning variables to the global environment for the purpose of using\\n\",  #>                         \"the variable at a later time makes no sense with futures, because the\\n\",  #>                         \"next the future may be evaluated in different R process.\\n\",  #>                         \"To protect against mistakes, the future framework attempts to detect\\n\",  #>                         \"when variables are added to the global environment.\\n\",  #>                         \"If this is detected, and this option is set to \",  #>                         list(\"\\\"error\\\"\"), \", then an\\n\", \"informative error is produced. If \",  #>                         list(\"\\\"warning\\\"\"), \", then a warning is\\n\",  #>                         \"produced. If \", list(\"\\\"ignore\\\"\"),  #>                         \", no check is performed.\\n\", \"(Default: \",  #>                         list(\"\\\"ignore\\\"\"), \")\\n\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.rng.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"If random numbers are used in futures, then parallel RNG should be\\n\",  #>                         list(\"declared\"), \" in order to get statistical sound RNGs. You can declare\\n\",  #>                         \"this by specifying future argument \",  #>                         list(\"seed = TRUE\"), \". The defaults in the\\n\",  #>                         \"future framework assume that \", list( #>                           \"no\"), \" random number generation (RNG) is\\n\",  #>                         \"taken place in the future expression because L'Ecuyer-CMRG RNGs come\\n\",  #>                         \"with an unnecessary overhead if not needed.\\n\",  #>                         \"To protect against  mistakes of not declaring use of the RNG, the\\n\",  #>                         \"future framework detects when random numbers were used despite not\\n\",  #>                         \"declaring such use.\\n\", \"If this is detected, and this options is set \",  #>                         list(\"\\\"error\\\"\"), \", then an\\n\", \"informative error is produced. If \",  #>                         list(\"\\\"warning\\\"\"), \", then a warning is\\n\",  #>                         \"produced.  If \", list(\"\\\"ignore\\\"\"),  #>                         \", no check is performed.\\n\", \"(Default: \",  #>                         list(\"\\\"warning\\\"\"), \")\\n\")), \"\\n\"),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(list(\"Options for debugging futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.debug\"), \":\"), list(\"(logical) If \",  #>                     list(\"TRUE\"), \", extensive debug messages are generated. (Default: \",  #>                     list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for controlling package startup\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.startup.script\"), \":\"), list(\"(character vector or a logical) Specifies zero of more future startup scripts to be sourced when the \",  #>                     list(\"future\"), \" package is \", list(\"attached\"),  #>                     \". It is only the first existing script that is sourced. If none of the specified files exist, nothing is sourced---there will be neither a warning nor an error.\\n\",  #>                     \"If this option is not specified, environment variable \",  #>                     list(\"R_FUTURE_STARTUP_SCRIPT\"), \" is considered, where multiple scripts may be separated by either a colon (\",  #>                     list(\":\"), \") or a semicolon (\", list(\";\"),  #>                     \"). If neither is set, or either is set to \",  #>                     list(\"TRUE\"), \", the default is to look for a \",  #>                     list(\".future.R\"), \" script in the current directory and then in the user's home directory.  To disable future startup scripts, set the option or the environment variable to \",  #>                     list(\"FALSE\"), \".  \", list(\"Importantly\"),  #>                     \", this option is \", list(\"always\"), \" set to \",  #>                     list(\"FALSE\"), \" if the \", list(\"future\"),  #>                     \" package is loaded as part of a future expression being evaluated, e.g. in a background process. In other words, they are sourced in the main \",  #>                     list(), \" process but not in future processes. (Default: \",  #>                     list(\"TRUE\"), \" in main \", list(), \" process and \",  #>                     list(\"FALSE\"), \" in future processes / during future evaluation)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.cmdargs\"),  #>                       \":\"), list(\"(character vector) Overrides \",  #>                       list(list(\"commandArgs\"), \"()\"), \" when the \",  #>                       list(\"future\"), \" package is \", list(\"loaded\"),  #>                       \".\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Options for configuring low-level system behaviors\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", list(\"\\n\", list(list( #>                     list(\"future.fork.multithreading.enable\"),  #>                     \" (\", list(\"beta feature - may change\"),  #>                     \"):\"), list(\"(logical) Enable or disable \",  #>                     list(\"multi-threading\"), \" while using \",  #>                     list(\"forked\"), \" parallel processing.  If \",  #>                     list(\"FALSE\"), \", different multi-thread library settings are overridden such that they run in single-thread mode. Specifically, multi-threading will be disabled for OpenMP (which requires the \",  #>                     list(\"RhpcBLASctl\"), \" package) and for \",  #>                     list(\"RcppParallel\"), \". If \", list(\"TRUE\"),  #>                     \", or not set (the default), multi-threading is allowed.  Parallelization via multi-threaded processing (done in native code by some packages and external libraries) while at the same time using forked (aka \\\"multicore\\\") parallel processing is known to unstable.  Note that this is not only true when using \",  #>                     list(\"plan(multicore)\"), \" but also when using, for instance, \",  #>                     list(list(\"mclapply\"), \"()\"), \" of the \",  #>                     list(\"parallel\"), \" package. (Default: not set)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.output.windows.reencode\"),  #>                       \":\"), list(\"(logical) Enable or disable re-encoding of UTF-8 symbols that were incorrectly encoded while captured.  In R (< 4.2.0) and on older versions of MS Windows, R cannot capture UTF-8 symbols as-is when they are captured from the standard output.  For examples, a UTF-8 check mark symbol (\",  #>                       list(\"\\\"\\\\u2713\\\"\"), \") would be relayed as \",  #>                       list(\"\\\"<U+2713>\\\"\"), \" (a string with eight ASCII characters).  Setting this option to \",  #>                       list(\"TRUE\"), \" will cause \", list(\"value()\"),  #>                       \" to attempt to recover the intended UTF-8 symbols from \",  #>                       list(\"<U+nnnn>\"), \" string components, if, and only if, the string was captured by a future resolved on MS Windows. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for demos\"), list(\"\\n\",  #>                   \"\\n\", list(\"\\n\", list(list(list(\"future.demo.mandelbrot.region\"),  #>                     \":\"), list(\"(integer) Either a named list of \",  #>                     list(list(\"mandelbrot()\")), \" arguments or an integer in {1, 2, 3} specifying a predefined Mandelbrot region. (Default: \",  #>                     list(\"1L\"), \")\")), \"\\n\", \"\\n\", list(list( #>                     list(\"future.demo.mandelbrot.nrow\"), \":\"),  #>                     list(\"(integer) Number of rows and columns of tiles. (Default: \",  #>                       list(\"3L\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Deprecated or for internal prototyping\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"The following options exists only for troubleshooting purposes and must not\\n\",  #>                     \"be used in production.  If used, there is a risk that the results are\\n\",  #>                     \"non-reproducible if processed elsewhere.  To lower the risk of them being\\n\",  #>                     \"used by mistake, they are marked as deprecated and will produce warnings\\n\",  #>                     \"if set.\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                       \"future.globals.onMissing\"), \":\"), list( #>                       \"(character string) Action to take when non-existing global variables (\\\"globals\\\" or \\\"unknowns\\\") are identified when the future is created.  If \",  #>                       list(\"\\\"error\\\"\"), \", an error is generated immediately.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no action is taken and an attempt to evaluate the future expression will be made.  The latter is useful when there is a risk for false-positive globals being identified, e.g. when future expression contains non-standard evaluation (NSE).  (Default: \",  #>                       list(\"\\\"ignore\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.method\"),  #>                         \":\"), list(\"(character string) Method used to identify globals. For details, see \",  #>                         list(list(\"globalsOf\"), \"()\"), \". (Default: \",  #>                         list(\"\\\"ordered\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.resolve\"),  #>                         \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                         \", globals that are \", list(list(\"Future\")),  #>                         \" objects (typically created as \", list( #>                           \"explicit\"), \" futures) will be resolved and have their values (using \",  #>                         list(\"value()\"), \") collected.  Because searching for unresolved futures among globals (including their content) can be expensive, the default is not to do it and instead leave it to the run-time checks that assert proper ownership when resolving futures and collecting their values. (Default: \",  #>                         list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Environment variables that set R options\"),  #>                   list(\"\\n\", \"\\n\", \"All of the above \", list(),  #>                     \" \", list(\"future.*\"), \" options can be set by corresponding\\n\",  #>                     \"environment variable \", list(\"R_FUTURE_*\"),  #>                     \" \", list(\"when the \", list(\"future\"), \" package is\\n\",  #>                       \"loaded\"), \". This means that those environment variables must be set before\\n\",  #>                     \"the \", list(\"future\"), \" package is loaded in order to have an effect.\\n\",  #>                     \"For example, if \", list(\"R_FUTURE_RNG_ONMISUSE=\\\"ignore\\\"\"),  #>                     \", then option\\n\", list(\"future.rng.onMisuse\"),  #>                     \" is set to \", list(\"\\\"ignore\\\"\"), \" (character string).\\n\",  #>                     \"Similarly, if \", list(\"R_FUTURE_GLOBALS_MAXSIZE=\\\"50000000\\\"\"),  #>                     \", then option\\n\", list(\"future.globals.maxSize\"),  #>                     \" is set to \", list(\"50000000\"), \" (numeric).\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Options moved to the 'parallelly' package\"),  #>                   list(\"\\n\", \"\\n\", \"Several functions have been moved to the \",  #>                     list(\"parallelly\"), \" package:\\n\", list(\"\\n\",  #>                       list(), \" \", list(list(\"parallelly::availableCores()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                       \"\\n\"), \"\\n\", \"\\n\", \"The options and environment variables controlling those have been adjusted\\n\",  #>                     \"accordingly to have different prefixes.\\n\",  #>                     \"For example, option \", list(\"future.fork.enable\"),  #>                     \" has been renamed to\\n\", list(\"parallelly.fork.enable\"),  #>                     \" and the corresponding environment variable\\n\",  #>                     list(\"R_FUTURE_FORK_ENABLE\"), \" has been renamed to\\n\",  #>                     list(\"R_PARALLELLY_FORK_ENABLE\"), \".\\n\",  #>                     \"For backward compatibility reasons, the \",  #>                     list(\"parallelly\"), \" package will\\n\", \"support both versions for a long foreseeable time.\\n\",  #>                     \"See the \", list(\"parallelly::parallelly.options\"),  #>                     \" page for the settings.\\n\")), \"\\n\", \"\\n\",  #>                 list(\"\\n\", \"# Allow at most 5 MB globals per futures\\n\",  #>                   \"options(future.globals.maxSize = 5e6)\\n\",  #>                   \"\\n\", \"# Be strict; catch all RNG mistakes\\n\",  #>                   \"options(future.rng.onMisuse = \\\"error\\\")\\n\",  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"To set \", list(),  #>                   \" options or environment variables when \",  #>                   list(), \" starts (even before the \", list(\"future\"),  #>                   \" package is loaded), see the \", list(\"Startup\"),  #>                   \" help page.  The \", list(list(\"https://cran.r-project.org/package=startup\"),  #>                     list(list(\"startup\"))), \" package provides a friendly mechanism for configurating \",  #>                   list(), \"'s startup process.\\n\"), \"\\n\")), source = list( #>             `Future-class.Rd` = \"R/backend_api-Future-class.R\",  #>             `FutureBackend-class.Rd` = c(\"R/backend_api-01-FutureBackend-class.R\",  #>             \"R/backend_api-03.MultiprocessFutureBackend-class.R\",  #>             \"R/backend_api-11.ClusterFutureBackend-class.R\",  #>             \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             \"R/backend_api-11.SequentialFutureBackend-class.R\",  #>             \"R/backend_api-13.MultisessionFutureBackend-class.R\" #>             ), FutureCondition.Rd = c(\"R/protected_api-FutureCondition-class.R\",  #>             \"R/protected_api-journal.R\"), FutureGlobals.Rd = \"R/protected_api-FutureGlobals-class.R\",  #>             FutureResult.Rd = \"R/protected_api-FutureResult-class.R\",  #>             `MultiprocessFuture-class.Rd` = \"R/backend_api-03.MultiprocessFutureBackend-class.R\",  #>             `UniprocessFuture-class.Rd` = \"R/backend_api-UniprocessFuture-class.R\",  #>             backtrace.Rd = \"R/utils_api-backtrace.R\", cancel.Rd = \"R/core_api-cancel.R\",  #>             cluster.Rd = \"R/backend_api-11.ClusterFutureBackend-class.R\",  #>             clusterExportSticky.Rd = \"R/utils-sticky_globals.R\",  #>             find_references.Rd = \"R/utils-marshalling.R\", future.Rd = c(\"R/core_api-future.R\",  #>             \"R/utils_api-futureCall.R\", \"R/utils_api-minifuture.R\" #>             ), futureAssign.Rd = c(\"R/delayed_api-futureAssign.R\",  #>             \"R/infix_api-01-futureAssign_OP.R\", \"R/infix_api-02-globals_OP.R\",  #>             \"R/infix_api-03-seed_OP.R\", \"R/infix_api-04-stdout_OP.R\",  #>             \"R/infix_api-05-conditions_OP.R\", \"R/infix_api-06-lazy_OP.R\",  #>             \"R/infix_api-07-label_OP.R\", \"R/infix_api-08-plan_OP.R\",  #>             \"R/infix_api-09-tweak_OP.R\"), futureOf.Rd = \"R/delayed_api-futureOf.R\",  #>             futureSessionInfo.Rd = \"R/utils_api-futureSessionInfo.R\",  #>             futures.Rd = \"R/protected_api-futures.R\", getExpression.Rd = \"R/backend_api-Future-class.R\",  #>             getGlobalsAndPackages.Rd = \"R/protected_api-globals.R\",  #>             makeClusterFuture.Rd = \"R/utils_api-makeClusterFuture.R\",  #>             mandelbrot.Rd = \"R/demo_api-mandelbrot.R\", multicore.Rd = \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             multisession.Rd = \"R/backend_api-13.MultisessionFutureBackend-class.R\",  #>             nbrOfWorkers.Rd = \"R/utils_api-nbrOfWorkers.R\", nullcon.Rd = \"R/utils-basic.R\",  #>             plan.Rd = c(\"R/utils_api-plan.R\", \"R/utils_api-plan-with.R\",  #>             \"R/utils_api-tweak.R\"), private_length.Rd = \"R/utils-basic.R\",  #>             `re-exports.Rd` = \"R/000.re-exports.R\", readImmediateConditions.Rd = \"R/utils-immediateCondition.R\",  #>             requestCore.Rd = \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             reset.Rd = \"R/core_api-reset.R\", resetWorkers.Rd = \"R/utils_api-plan.R\",  #>             resolve.Rd = \"R/protected_api-resolve.R\", resolved.Rd = c(\"R/backend_api-11.ClusterFutureBackend-class.R\",  #>             \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             \"R/core_api-resolved.R\"), result.Rd = \"R/protected_api-result.R\",  #>             run.Rd = \"R/backend_api-Future-class.R\", save_rds.Rd = \"R/utils-immediateCondition.R\",  #>             sequential.Rd = \"R/backend_api-11.SequentialFutureBackend-class.R\",  #>             sessionDetails.Rd = \"R/utils_api-sessionDetails.R\",  #>             signalConditions.Rd = \"R/protected_api-signalConditions.R\",  #>             sticky_globals.Rd = \"R/utils-sticky_globals.R\", usedCores.Rd = \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             value.Rd = \"R/core_api-value.R\", `zzz-future.options.Rd` = \"R/utils-options.R\"),  #>         keywords = list(\"internal\", \"internal\", \"internal\", \"internal\",  #>             \"internal\", \"internal\", \"internal\", character(0),  #>             character(0), character(0), \"internal\", \"internal\",  #>             character(0), character(0), character(0), character(0),  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             \"internal\", character(0), character(0), character(0),  #>             \"internal\", character(0), \"internal\", \"internal\",  #>             \"internal\", \"internal\", character(0), \"internal\",  #>             character(0), character(0), \"internal\", \"internal\",  #>             \"internal\", character(0), \"internal\", \"internal\",  #>             \"internal\", \"internal\", character(0), character(0)),  #>         concepts = list(character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0)), internal = c(TRUE, TRUE, TRUE, TRUE,  #>         TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE,  #>         FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE,  #>         FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE,  #>         TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE,  #>         TRUE, TRUE, FALSE, FALSE), lifecycle = list(NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL)), tutorials = list( #>         name = character(0), file_out = character(0), title = character(0),  #>         pagetitle = character(0), url = character(0)), vignettes = list( #>         name = c(\"future-1-overview\", \"future-2-output\", \"future-2b-backend\",  #>         \"future-3-topologies\", \"future-4-issues\", \"future-4-non-exportable-objects\",  #>         \"future-5-startup\", \"future-6-future-api-backend-specification\",  #>         \"future-7-for-package-developers\", \"future-8-how-future-is-validated\" #>         ), type = c(\"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\",  #>         \"rmd\", \"rmd\", \"rmd\", \"rmd\"), file_in = c(\"vignettes/future-1-overview.Rmd\",  #>         \"vignettes/future-2-output.Rmd\", \"vignettes/future-2b-backend.Rmd\",  #>         \"vignettes/future-3-topologies.Rmd\", \"vignettes/future-4-issues.Rmd\",  #>         \"vignettes/future-4-non-exportable-objects.Rmd\", \"vignettes/future-5-startup.Rmd\",  #>         \"vignettes/future-6-future-api-backend-specification.Rmd\",  #>         \"vignettes/future-7-for-package-developers.Rmd\", \"vignettes/future-8-how-future-is-validated.Rmd\" #>         ), file_out = c(\"articles/future-1-overview.html\", \"articles/future-2-output.html\",  #>         \"articles/future-2b-backend.html\", \"articles/future-3-topologies.html\",  #>         \"articles/future-4-issues.html\", \"articles/future-4-non-exportable-objects.html\",  #>         \"articles/future-5-startup.html\", \"articles/future-6-future-api-backend-specification.html\",  #>         \"articles/future-7-for-package-developers.html\", \"articles/future-8-how-future-is-validated.html\" #>         ), title = c(\"A Future for R: A Comprehensive Overview\",  #>         \"A Future for R: Text and Message Output\", \"A Future for R: Available Future Backends\",  #>         \"A Future for R: Future Topologies\", \"A Future for R: Common Issues with Solutions\",  #>         \"A Future for R: Non-Exportable Objects\", \"A Future for R: Controlling Default Future Strategy\",  #>         \"A Future for R: Future API Backend Specification\", \"A Future for R: Best Practices for Package Developers\",  #>         \"A Future for R: How the Future Framework is Validated\" #>         ), description = c(NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_, NA_character_), depth = c(1L,  #>         1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L))), examples = TRUE,  #>     run_dont_run = FALSE, seed = 1014L, lazy = FALSE, override = list(),  #>     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE,  #>     quiet = TRUE, cli_colors = 16777216L, hyperlinks = TRUE)),  #>     envir = base::quote(<environment>), quote = base::quote(TRUE)) #>  #> [[12]] #> (function (..., cli_colors, hyperlinks)  #> { #>     options(cli.num_colors = cli_colors, cli.hyperlink = hyperlinks,  #>         cli.hyperlink_run = hyperlinks) #>     pkgdown::build_site(...) #> })(pkg = base::quote(list(package = \"future\", version = \"1.69.0-9002\",  #>     src_path = \"/tmp/hb/RtmpF6eBvg/future\", meta = list(url = \"https://future.futureverse.org\",  #>         home = list(links = list(list(text = \"Roadmap/Milestones\",  #>             href = \"https://github.com/futureverse/future/milestones\"),  #>             list(text = \"The Futureverse Project\", href = \"https://www.futureverse.org/\"),  #>             list(text = \"Futureverse User Forum\", href = \"https://github.com/futureverse/future/discussions\"))),  #>         navbar = list(structure = list(right = c(\"search\", \"futureverse\",  #>         \"pkgs\", \"cran\", \"github\", \"lightswitch\")), components = list( #>             futureverse = list(icon = \"fas fa-home\", href = \"https://www.futureverse.org/\"),  #>             pkgs = list(text = \"Packages\", menu = list(list(text = \"doFuture (map-reduce)\",  #>                 href = \"https://doFuture.futureverse.org\"), list( #>                 text = \"furrr (map-reduce)\", href = \"https://furrr.futureverse.org\"),  #>                 list(text = \"future\", href = \"https://future.futureverse.org\"),  #>                 list(text = \"future.apply (map-reduce)\", href = \"https://future.apply.futureverse.org\"),  #>                 list(text = \"future.batchtools (backend)\", href = \"https://future.batchtools.futureverse.org\"),  #>                 list(text = \"future.callr (backend)\", href = \"https://future.callr.futureverse.org\"),  #>                 list(text = \"future.mirai (backend)\", href = \"https://future.mirai.futureverse.org\"),  #>                 list(text = \"future.tests\", href = \"https://future.tests.futureverse.org\"),  #>                 list(text = \"futurize (map-reduce)\", href = \"https://futurize.futureverse.org\"),  #>                 list(text = \"globals\", href = \"https://globals.futureverse.org\"),  #>                 list(text = \"listenv\", href = \"https://listenv.futureverse.org\"),  #>                 list(text = \"parallelly\", href = \"https://parallelly.futureverse.org\"),  #>                 list(text = \"progressr\", href = \"https://progressr.futureverse.org\"),  #>                 list(text = \"future.tools (experimental)\", href = \"https://future.tools.futureverse.org\"),  #>                 list(text = \"marshal (experimental)\", href = \"https://marshal.futureverse.org\"))),  #>             cran = list(icon = \"fab fa-r-project\", href = \"https://cloud.r-project.org/package=future\"))),  #>         search = list(exclude = \"README_ja.md\"), template = list( #>             params = list(docsearch = list(api_key = \"aa6e02fc501886fb0f7c91ac4e300456\",  #>                 index_name = \"futureverse\", algoliaOptions = list( #>                   facetFilters = \"project:future\")), ganalytics = \"G-SB3EQSD9FR\"),  #>             bootstrap = 5L, `light-switch` = TRUE)), desc = <environment>,  #>     bs_version = 5L, development = list(destination = \"dev\",  #>         mode = \"default\", version_label = \"muted\", in_dev = FALSE,  #>         prefix = \"\"), prefix = \"\", dst_path = \"/tmp/hb/RtmpF6eBvg/future/docs\",  #>     lang = \"en-US\", install_metadata = FALSE, figures = list( #>         dev = \"ragg::agg_png\", dpi = 96L, dev.args = list(),  #>         fig.ext = \"png\", fig.width = 7.29166666666667, fig.height = NULL,  #>         fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL,  #>         other.parameters = list()), repo = list(url = list(home = \"https://github.com/futureverse/future/\",  #>         source = \"https://github.com/futureverse/future/blob/HEAD/\",  #>         issue = \"https://github.com/futureverse/future/issues/\",  #>         user = \"https://github.com/\")), topics = list(name = c(`Future-class.Rd` = \"Future-class\",  #>     `FutureBackend-class.Rd` = \"FutureBackend-class\", FutureCondition.Rd = \"FutureCondition\",  #>     FutureGlobals.Rd = \"FutureGlobals\", FutureResult.Rd = \"FutureResult\",  #>     `MultiprocessFuture-class.Rd` = \"MultiprocessFuture-class\",  #>     `UniprocessFuture-class.Rd` = \"UniprocessFuture-class\", backtrace.Rd = \"backtrace\",  #>     cancel.Rd = \"cancel\", cluster.Rd = \"cluster\", clusterExportSticky.Rd = \"clusterExportSticky\",  #>     find_references.Rd = \"find_references\", future.Rd = \"future\",  #>     futureAssign.Rd = \"futureAssign\", futureOf.Rd = \"futureOf\",  #>     futureSessionInfo.Rd = \"futureSessionInfo\", futures.Rd = \"futures\",  #>     getExpression.Rd = \"getExpression\", getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>     makeClusterFuture.Rd = \"makeClusterFuture\", mandelbrot.Rd = \"mandelbrot\",  #>     multicore.Rd = \"multicore\", multisession.Rd = \"multisession\",  #>     nbrOfWorkers.Rd = \"nbrOfWorkers\", nullcon.Rd = \"nullcon\",  #>     plan.Rd = \"plan\", private_length.Rd = \".length\", `re-exports.Rd` = \"re-exports\",  #>     readImmediateConditions.Rd = \"readImmediateConditions\", requestCore.Rd = \"requestCore\",  #>     reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\", resolve.Rd = \"resolve\",  #>     resolved.Rd = \"resolved.ClusterFuture\", result.Rd = \"result.Future\",  #>     run.Rd = \"run.Future\", save_rds.Rd = \"save_rds\", sequential.Rd = \"sequential\",  #>     sessionDetails.Rd = \"sessionDetails\", signalConditions.Rd = \"signalConditions\",  #>     sticky_globals.Rd = \"sticky_globals\", usedCores.Rd = \"usedCores\",  #>     value.Rd = \"value\", `zzz-future.options.Rd` = \"zzz-future.options\" #>     ), file_in = c(\"Future-class.Rd\", \"FutureBackend-class.Rd\",  #>     \"FutureCondition.Rd\", \"FutureGlobals.Rd\", \"FutureResult.Rd\",  #>     \"MultiprocessFuture-class.Rd\", \"UniprocessFuture-class.Rd\",  #>     \"backtrace.Rd\", \"cancel.Rd\", \"cluster.Rd\", \"clusterExportSticky.Rd\",  #>     \"find_references.Rd\", \"future.Rd\", \"futureAssign.Rd\", \"futureOf.Rd\",  #>     \"futureSessionInfo.Rd\", \"futures.Rd\", \"getExpression.Rd\",  #>     \"getGlobalsAndPackages.Rd\", \"makeClusterFuture.Rd\", \"mandelbrot.Rd\",  #>     \"multicore.Rd\", \"multisession.Rd\", \"nbrOfWorkers.Rd\", \"nullcon.Rd\",  #>     \"plan.Rd\", \"private_length.Rd\", \"re-exports.Rd\", \"readImmediateConditions.Rd\",  #>     \"requestCore.Rd\", \"reset.Rd\", \"resetWorkers.Rd\", \"resolve.Rd\",  #>     \"resolved.Rd\", \"result.Rd\", \"run.Rd\", \"save_rds.Rd\", \"sequential.Rd\",  #>     \"sessionDetails.Rd\", \"signalConditions.Rd\", \"sticky_globals.Rd\",  #>     \"usedCores.Rd\", \"value.Rd\", \"zzz-future.options.Rd\"), file_out = c(\"Future-class.html\",  #>     \"FutureBackend-class.html\", \"FutureCondition.html\", \"FutureGlobals.html\",  #>     \"FutureResult.html\", \"MultiprocessFuture-class.html\", \"UniprocessFuture-class.html\",  #>     \"backtrace.html\", \"cancel.html\", \"cluster.html\", \"clusterExportSticky.html\",  #>     \"find_references.html\", \"future.html\", \"futureAssign.html\",  #>     \"futureOf.html\", \"futureSessionInfo.html\", \"futures.html\",  #>     \"getExpression.html\", \"getGlobalsAndPackages.html\", \"makeClusterFuture.html\",  #>     \"mandelbrot.html\", \"multicore.html\", \"multisession.html\",  #>     \"nbrOfWorkers.html\", \"nullcon.html\", \"plan.html\", \"private_length.html\",  #>     \"re-exports.html\", \"readImmediateConditions.html\", \"requestCore.html\",  #>     \"reset.html\", \"resetWorkers.html\", \"resolve.html\", \"resolved.html\",  #>     \"result.html\", \"run.html\", \"save_rds.html\", \"sequential.html\",  #>     \"sessionDetails.html\", \"signalConditions.html\", \"sticky_globals.html\",  #>     \"usedCores.html\", \"value.html\", \"zzz-future.options.html\" #>     ), alias = list(`Future-class.Rd` = c(\"Future-class\", \"Future\" #>     ), `FutureBackend-class.Rd` = c(\"FutureBackend-class\", \"FutureBackend\",  #>     \"launchFuture\", \"listFutures\", \"interruptFuture\", \"validateFutureGlobals\",  #>     \"stopWorkers\", \"MultiprocessFutureBackend\", \"ClusterFutureBackend\",  #>     \"MulticoreFutureBackend\", \"SequentialFutureBackend\", \"MultisessionFutureBackend\" #>     ), FutureCondition.Rd = c(\"FutureCondition\", \"FutureMessage\",  #>     \"FutureWarning\", \"FutureError\", \"RngFutureCondition\", \"RngFutureWarning\",  #>     \"RngFutureError\", \"UnexpectedFutureResultError\", \"GlobalEnvMisuseFutureCondition\",  #>     \"GlobalEnvMisuseFutureWarning\", \"GlobalEnvMisuseFutureError\",  #>     \"ConnectionMisuseFutureCondition\", \"ConnectionMisuseFutureWarning\",  #>     \"ConnectionMisuseFutureError\", \"DeviceMisuseFutureCondition\",  #>     \"DeviceMisuseFutureWarning\", \"DeviceMisuseFutureError\", \"DefaultDeviceMisuseFutureCondition\",  #>     \"DefaultDeviceMisuseFutureWarning\", \"DefaultDeviceMisuseFutureError\",  #>     \"FutureLaunchError\", \"FutureInterruptError\", \"FutureCanceledError\",  #>     \"FutureDroppedError\", \"FutureJournalCondition\"), FutureGlobals.Rd = c(\"FutureGlobals\",  #>     \"as.FutureGlobals\", \"as.FutureGlobals.FutureGlobals\", \"as.FutureGlobals.Globals\",  #>     \"as.FutureGlobals.list\", \"[.FutureGlobals\", \"c.FutureGlobals\",  #>     \"unique.FutureGlobals\"), FutureResult.Rd = c(\"FutureResult\",  #>     \"as.character.FutureResult\", \"print.FutureResult\"), `MultiprocessFuture-class.Rd` = c(\"MultiprocessFuture-class\",  #>     \"MultiprocessFuture\"), `UniprocessFuture-class.Rd` = c(\"UniprocessFuture-class\",  #>     \"UniprocessFuture\"), backtrace.Rd = \"backtrace\", cancel.Rd = \"cancel\",  #>         cluster.Rd = \"cluster\", clusterExportSticky.Rd = \"clusterExportSticky\",  #>         find_references.Rd = c(\"find_references\", \"assert_no_references\" #>         ), future.Rd = c(\"future\", \"futureCall\", \"minifuture\" #>         ), futureAssign.Rd = c(\"futureAssign\", \"%<-%\", \"%->%\",  #>         \"%globals%\", \"%packages%\", \"%seed%\", \"%stdout%\", \"%conditions%\",  #>         \"%lazy%\", \"%label%\", \"%plan%\", \"%tweak%\"), futureOf.Rd = \"futureOf\",  #>         futureSessionInfo.Rd = \"futureSessionInfo\", futures.Rd = \"futures\",  #>         getExpression.Rd = c(\"getExpression\", \"getExpression.Future\" #>         ), getGlobalsAndPackages.Rd = \"getGlobalsAndPackages\",  #>         makeClusterFuture.Rd = c(\"makeClusterFuture\", \"FUTURE\" #>         ), mandelbrot.Rd = c(\"mandelbrot\", \"as.raster.Mandelbrot\",  #>         \"plot.Mandelbrot\", \"mandelbrot_tiles\", \"mandelbrot.matrix\",  #>         \"mandelbrot.numeric\"), multicore.Rd = c(\"multicore\",  #>         \"MulticoreFuture\"), multisession.Rd = c(\"multisession\",  #>         \"MultisessionFuture\"), nbrOfWorkers.Rd = c(\"nbrOfWorkers\",  #>         \"nbrOfFreeWorkers\"), nullcon.Rd = \"nullcon\", plan.Rd = c(\"plan\",  #>         \"with.FutureStrategyList\", \"tweak\"), private_length.Rd = \".length\",  #>         `re-exports.Rd` = c(\"re-exports\", \"availableCores\", \"availableWorkers\",  #>         \"makeClusterPSOCK\", \"supportsMulticore\"), readImmediateConditions.Rd = c(\"readImmediateConditions\",  #>         \"saveImmediateCondition\"), requestCore.Rd = \"requestCore\",  #>         reset.Rd = \"reset\", resetWorkers.Rd = \"resetWorkers\",  #>         resolve.Rd = \"resolve\", resolved.Rd = c(\"resolved.ClusterFuture\",  #>         \"resolved.MulticoreFuture\", \"resolved\", \"resolved.default\",  #>         \"resolved.list\", \"resolved.environment\", \"resolved.Future\" #>         ), result.Rd = c(\"result.Future\", \"result\"), run.Rd = c(\"run.Future\",  #>         \"run\"), save_rds.Rd = \"save_rds\", sequential.Rd = c(\"sequential\",  #>         \"uniprocess\"), sessionDetails.Rd = \"sessionDetails\",  #>         signalConditions.Rd = \"signalConditions\", sticky_globals.Rd = \"sticky_globals\",  #>         usedCores.Rd = \"usedCores\", value.Rd = c(\"value\", \"value.Future\",  #>         \"value.list\", \"value.listenv\", \"value.environment\"),  #>         `zzz-future.options.Rd` = c(\"zzz-future.options\", \"future.options\",  #>         \"future.startup.script\", \"future.debug\", \"future.demo.mandelbrot.region\",  #>         \"future.demo.mandelbrot.nrow\", \"future.fork.multithreading.enable\",  #>         \"future.globals.maxSize\", \"future.globals.method\", \"future.globals.onMissing\",  #>         \"future.globals.resolve\", \"future.globals.onReference\",  #>         \"future.plan\", \"future.onFutureCondition.keepFuture\",  #>         \"future.resolve.recursive\", \"future.connections.onMisuse\",  #>         \"future.defaultDevice.onMisuse\", \"future.devices.onMisuse\",  #>         \"future.globalenv.onMisuse\", \"future.rng.onMisuse\", \"future.wait.alpha\",  #>         \"future.wait.interval\", \"future.wait.timeout\", \"future.output.windows.reencode\",  #>         \"future.journal\", \"future.globals.objectSize.method\",  #>         \"future.ClusterFuture.clusterEvalQ\", \"R_FUTURE_STARTUP_SCRIPT\",  #>         \"R_FUTURE_DEBUG\", \"R_FUTURE_DEMO_MANDELBROT_REGION\",  #>         \"R_FUTURE_DEMO_MANDELBROT_NROW\", \"R_FUTURE_FORK_MULTITHREADING_ENABLE\",  #>         \"R_FUTURE_GLOBALS_MAXSIZE\", \"R_FUTURE_GLOBALS_METHOD\",  #>         \"R_FUTURE_GLOBALS_ONMISSING\", \"R_FUTURE_GLOBALS_RESOLVE\",  #>         \"R_FUTURE_GLOBALS_ONREFERENCE\", \"R_FUTURE_PLAN\", \"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\",  #>         \"R_FUTURE_RESOLVE_RECURSIVE\", \"R_FUTURE_CONNECTIONS_ONMISUSE\",  #>         \"R_FUTURE_DEVICES_ONMISUSE\", \"R_FUTURE_DEFAULTDEVICE_ONMISUSE\",  #>         \"R_FUTURE_GLOBALENV_ONMISUSE\", \"R_FUTURE_RNG_ONMISUSE\",  #>         \"R_FUTURE_WAIT_ALPHA\", \"R_FUTURE_WAIT_INTERVAL\", \"R_FUTURE_WAIT_TIMEOUT\",  #>         \"R_FUTURE_RESOLVED_TIMEOUT\", \"R_FUTURE_OUTPUT_WINDOWS_REENCODE\",  #>         \"R_FUTURE_JOURNAL\", \"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\",  #>         \"R_FUTURE_CLUSTERFUTURE_CLUSTEREVALQ\", \"future.cmdargs\",  #>         \".future.R\")), funs = list(`Future-class.Rd` = \"Future()\",  #>         `FutureBackend-class.Rd` = c(\"FutureBackend()\", \"launchFuture()\",  #>         \"listFutures()\", \"interruptFuture()\", \"validateFutureGlobals()\",  #>         \"stopWorkers()\", \"MultiprocessFutureBackend()\", \"ClusterFutureBackend()\",  #>         \"MulticoreFutureBackend()\", \"SequentialFutureBackend()\",  #>         \"MultisessionFutureBackend()\"), FutureCondition.Rd = c(\"FutureCondition()\",  #>         \"FutureMessage()\", \"FutureWarning()\", \"FutureError()\",  #>         \"RngFutureCondition()\", \"RngFutureWarning()\", \"RngFutureError()\",  #>         \"UnexpectedFutureResultError()\", \"GlobalEnvMisuseFutureCondition()\",  #>         \"GlobalEnvMisuseFutureWarning()\", \"GlobalEnvMisuseFutureError()\",  #>         \"ConnectionMisuseFutureCondition()\", \"ConnectionMisuseFutureWarning()\",  #>         \"ConnectionMisuseFutureError()\", \"DeviceMisuseFutureCondition()\",  #>         \"DeviceMisuseFutureWarning()\", \"DeviceMisuseFutureError()\",  #>         \"DefaultDeviceMisuseFutureCondition()\", \"DefaultDeviceMisuseFutureWarning()\",  #>         \"DefaultDeviceMisuseFutureError()\", \"FutureLaunchError()\",  #>         \"FutureInterruptError()\", \"FutureCanceledError()\", \"FutureDroppedError()\",  #>         \"FutureJournalCondition()\"), FutureGlobals.Rd = \"FutureGlobals()\",  #>         FutureResult.Rd = c(\"FutureResult()\", \"as.character(<i>&lt;FutureResult&gt;<\/i>)\",  #>         \"print(<i>&lt;FutureResult&gt;<\/i>)\"), `MultiprocessFuture-class.Rd` = \"MultiprocessFuture()\",  #>         `UniprocessFuture-class.Rd` = \"UniprocessFuture()\", backtrace.Rd = \"backtrace()\",  #>         cancel.Rd = \"cancel()\", cluster.Rd = \"cluster()\", clusterExportSticky.Rd = \"clusterExportSticky()\",  #>         find_references.Rd = c(\"find_references()\", \"assert_no_references()\" #>         ), future.Rd = c(\"future()\", \"futureCall()\", \"minifuture()\" #>         ), futureAssign.Rd = c(\"futureAssign()\", \"`%&lt;-%`\",  #>         \"`%globals%`\", \"`%packages%`\", \"`%seed%`\", \"`%stdout%`\",  #>         \"`%conditions%`\", \"`%lazy%`\", \"`%label%`\", \"`%plan%`\",  #>         \"`%tweak%`\"), futureOf.Rd = \"futureOf()\", futureSessionInfo.Rd = \"futureSessionInfo()\",  #>         futures.Rd = \"futures()\", getExpression.Rd = \"getExpression()\",  #>         getGlobalsAndPackages.Rd = \"getGlobalsAndPackages()\",  #>         makeClusterFuture.Rd = \"makeClusterFuture()\", mandelbrot.Rd = \"mandelbrot()\",  #>         multicore.Rd = \"multicore()\", multisession.Rd = \"multisession()\",  #>         nbrOfWorkers.Rd = c(\"nbrOfWorkers()\", \"nbrOfFreeWorkers()\" #>         ), nullcon.Rd = \"nullcon()\", plan.Rd = c(\"plan()\", \"with(<i>&lt;FutureStrategyList&gt;<\/i>)\",  #>         \"tweak()\"), private_length.Rd = \".length()\", `re-exports.Rd` = character(0),  #>         readImmediateConditions.Rd = c(\"readImmediateConditions()\",  #>         \"saveImmediateCondition()\"), requestCore.Rd = \"requestCore()\",  #>         reset.Rd = \"reset()\", resetWorkers.Rd = \"resetWorkers()\",  #>         resolve.Rd = \"resolve()\", resolved.Rd = \"resolved()\",  #>         result.Rd = \"result(<i>&lt;Future&gt;<\/i>)\", run.Rd = \"run(<i>&lt;Future&gt;<\/i>)\",  #>         save_rds.Rd = \"save_rds()\", sequential.Rd = \"sequential()\",  #>         sessionDetails.Rd = \"sessionDetails()\", signalConditions.Rd = \"signalConditions()\",  #>         sticky_globals.Rd = \"sticky_globals()\", usedCores.Rd = \"usedCores()\",  #>         value.Rd = \"value()\", `zzz-future.options.Rd` = character(0)),  #>         title = c(`Future-class.Rd` = \"A future represents a value that will be available at some point in the future\",  #>         `FutureBackend-class.Rd` = \"Configure a backend that controls how and where futures are evaluated\",  #>         FutureCondition.Rd = \"A condition (message, warning, or error) that occurred while orchestrating a future\",  #>         FutureGlobals.Rd = \"A representation of a set of globals used with futures\",  #>         FutureResult.Rd = \"Results from resolving a future\",  #>         `MultiprocessFuture-class.Rd` = \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\",  #>         `UniprocessFuture-class.Rd` = \"An uniprocess future is a future whose value will be resolved synchronously in the current process\",  #>         backtrace.Rd = \"Back trace the expressions evaluated when an error was caught\",  #>         cancel.Rd = \"Cancel a future\", cluster.Rd = \"Create a cluster future whose value will be resolved asynchronously in a parallel process\",  #>         clusterExportSticky.Rd = \"Export globals to the sticky-globals environment of the cluster nodes\",  #>         find_references.Rd = \"Get the first or all references of an <span style=\\\"R\\\">R<\/span> object\",  #>         future.Rd = \"Create a future\", futureAssign.Rd = \"Create a future assignment\",  #>         futureOf.Rd = \"Get the future of a future variable\",  #>         futureSessionInfo.Rd = \"Get future-specific session information and validate current backend\",  #>         futures.Rd = \"Get all futures in a container\", getExpression.Rd = \"Inject code for the next type of future to use for nested futures\",  #>         getGlobalsAndPackages.Rd = \"Retrieves global variables of an expression and their associated packages\",  #>         makeClusterFuture.Rd = \"Create a Future Cluster of Stateless Workers for Parallel Processing\",  #>         mandelbrot.Rd = \"Mandelbrot convergence counts\", multicore.Rd = \"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\",  #>         multisession.Rd = \"Create a multisession future whose value will be resolved asynchronously in a parallel <span style=\\\"R\\\">R<\/span> session\",  #>         nbrOfWorkers.Rd = \"Get the number of workers available\",  #>         nullcon.Rd = \"Creates a connection to the system null device\",  #>         plan.Rd = \"Plan how to resolve a future\", private_length.Rd = \"Gets the length of an object without dispatching\",  #>         `re-exports.Rd` = \"Functions Moved to 'parallelly'\",  #>         readImmediateConditions.Rd = \"Writes and Reads 'immediateCondition' RDS Files\",  #>         requestCore.Rd = \"Request a core for multicore processing\",  #>         reset.Rd = \"Reset a finished, failed, canceled, or interrupted future to a lazy future\",  #>         resetWorkers.Rd = \"Free up active background workers\",  #>         resolve.Rd = \"Resolve one or more futures synchronously\",  #>         resolved.Rd = \"Check whether a future is resolved or not\",  #>         result.Rd = \"Get the results of a resolved future\", run.Rd = \"Run a future\",  #>         save_rds.Rd = \"Robustly Saves an Object to RDS File Atomically\",  #>         sequential.Rd = \"Create a sequential future whose value will be in the current <span style=\\\"R\\\">R<\/span> session\",  #>         sessionDetails.Rd = \"Outputs details on the current <span style=\\\"R\\\">R<\/span> session\",  #>         signalConditions.Rd = \"Signals Captured Conditions\",  #>         sticky_globals.Rd = \"Place a sticky-globals environment immediately after the global environment\",  #>         usedCores.Rd = \"Get number of cores currently used\",  #>         value.Rd = \"The value of a future or the values of all elements in a container\",  #>         `zzz-future.options.Rd` = \"Options used for futures\"),  #>         rd = list(`Future-class.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>             \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>             \"\\n\", list(\"Future-class\"), \"\\n\", list(\"Future-class\"),  #>             \"\\n\", list(\"Future\"), \"\\n\", list(\"A future represents a value that will be available at some point in the future\"),  #>             \"\\n\", list(\"\\n\", \"Future(\\n\", \"  expr = NULL,\\n\",  #>                 \"  envir = parent.frame(),\\n\", \"  substitute = TRUE,\\n\",  #>                 \"  stdout = TRUE,\\n\", \"  conditions = \\\"condition\\\",\\n\",  #>                 \"  globals = list(),\\n\", \"  packages = NULL,\\n\",  #>                 \"  seed = FALSE,\\n\", \"  lazy = FALSE,\\n\", \"  label = NULL,\\n\",  #>                 \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                 \"expr\"), list(\"An \", list(), \" \", list(\"expression\"),  #>                 \".\")), \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The \",  #>                 list(\"environment\"), \" from where global objects should be\\n\",  #>                 \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                 list(\"If TRUE, argument \", list(\"expr\"), \" is\\n\",  #>                   list(list(\"substitute\"), \"()\"), \":d, otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                   \"and re-outputted when \", list(\"value()\"),  #>                   \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                   \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                   \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                   \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                   \"captured output across futures.\\n\", \"Using \",  #>                   list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                   \"behavior of such unhandled standard output depends on the future backend.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of condition classes to be captured\\n\",  #>                   \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                   \"and warnings.  To drop all conditions, use \",  #>                   list(\"conditions = character(0)\"), \".\\n\", \"Errors are always relayed.\\n\",  #>                   \"Attribute \", list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                   list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                   \" will capture\\n\", \"all \", list(\"condition\"),  #>                   \" classes except those that inherit from the \",  #>                   list(\"message\"), \" class.\\n\", \"Using \", list( #>                     \"conditions = structure(..., drop = TRUE)\"),  #>                   \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as they have\\n\",  #>                   \"been relayed, e.g. by \", list(\"value(f)\"),  #>                   \". This can help decrease the overall\\n\", \"memory consumed by captured conditions across futures.\\n\",  #>                   \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                   \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                   \"future backend and the environment from which R runs.\")),  #>                 \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                   \"to control how globals are handled.\\n\", \"For details, see section 'Globals used by future expressions'\\n\",  #>                   \"in the help for \", list(list(\"future()\")),  #>                   \".\")), \"\\n\", \"\\n\", list(list(\"packages\"), list( #>                   \"(optional) a character vector specifying packages\\n\",  #>                   \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                   \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                   \"random numbers are produced (also during parallelization).\\n\",  #>                   \"If FALSE (default), it is assumed that the future expression neither\\n\",  #>                   \"needs nor uses random number generation.\\n\",  #>                   \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integers)\\n\",  #>                   \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                   \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                   \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                   \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                   \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                   \"ignored, an informative warning, or error will be produced.\\n\",  #>                   \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                   list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                 \"\\n\", \"\\n\", list(list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                   \"eagerly (starting immediately), otherwise not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements of the future.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"Future()\"), \" returns an object of class \",  #>                 list(\"Future\"), \".\\n\"), \"\\n\", list(\"\\n\", \"A \",  #>                 list(\"future\"), \" is an abstraction for a \",  #>                 list(\"value\"), \" that may be\\n\", \"available at some point in the future.  A future can either be\\n\",  #>                 list(\"unresolved\"), \" or \", list(\"resolved\"),  #>                 \", a state which can be checked\\n\", \"with \",  #>                 list(list(\"resolved()\")), \".  As long as it is \",  #>                 list(\"unresolved\"), \", the\\n\", \"value is not available.  As soon as it is \",  #>                 list(\"resolved\"), \", the value\\n\", \"is available via \",  #>                 list(list(\"value\"), \"()\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A Future object is itself an \", list(\"environment\"),  #>                 \".\\n\"), \"\\n\", list(\"\\n\", \"One function that creates a Future is \",  #>                 list(list(\"future()\")), \".\\n\", \"It returns a Future that evaluates an \",  #>                 list(), \" expression in the future.\\n\", \"An alternative approach is to use the \",  #>                 list(list(\"%<-%\")), \" infix\\n\", \"assignment operator, which creates a future from the\\n\",  #>                 \"right-hand-side (RHS) \", list(), \" expression and assigns its future value\\n\",  #>                 \"to a variable as a \", list(list(\"promise\")),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), `FutureBackend-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-01-FutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-03.MultiprocessFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-11.ClusterFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-11.MulticoreFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-11.SequentialFutureBackend-class.R,\",  #>             \"\\n\", \"%   R/backend_api-13.MultisessionFutureBackend-class.R\",  #>             \"\\n\", list(\"FutureBackend-class\"), \"\\n\", list(\"FutureBackend-class\"),  #>             \"\\n\", list(\"FutureBackend\"), \"\\n\", list(\"launchFuture\"),  #>             \"\\n\", list(\"listFutures\"), \"\\n\", list(\"interruptFuture\"),  #>             \"\\n\", list(\"validateFutureGlobals\"), \"\\n\", list(\"stopWorkers\"),  #>             \"\\n\", list(\"MultiprocessFutureBackend\"), \"\\n\", list( #>                 \"ClusterFutureBackend\"), \"\\n\", list(\"MulticoreFutureBackend\"),  #>             \"\\n\", list(\"SequentialFutureBackend\"), \"\\n\", list( #>                 \"MultisessionFutureBackend\"), \"\\n\", list(\"Configure a backend that controls how and where futures are evaluated\"),  #>             \"\\n\", list(\"\\n\", \"FutureBackend(\\n\", \"  ...,\\n\",  #>                 \"  earlySignal = FALSE,\\n\", \"  gc = FALSE,\\n\",  #>                 \"  maxSizeOfObjects = getOption(\\\"future.globals.maxSize\\\", +Inf),\\n\",  #>                 \"  interrupts = TRUE,\\n\", \"  hooks = FALSE\\n\",  #>                 \")\\n\", \"\\n\", \"launchFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"listFutures(backend, ...)\\n\", \"\\n\", \"interruptFuture(backend, future, ...)\\n\",  #>                 \"\\n\", \"validateFutureGlobals(backend, future, ...)\\n\",  #>                 \"\\n\", \"stopWorkers(backend, ...)\\n\", \"\\n\", \"MultiprocessFutureBackend(\\n\",  #>                 \"  ...,\\n\", \"  wait.timeout = getOption(\\\"future.wait.timeout\\\", 24 * 60 * 60),\\n\",  #>                 \"  wait.interval = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                 \"  wait.alpha = getOption(\\\"future.wait.alpha\\\", 1.01)\\n\",  #>                 \")\\n\", \"\\n\", \"ClusterFutureBackend(\\n\", \"  workers = availableWorkers(constraints = \\\"connections\\\"),\\n\",  #>                 \"  gc = TRUE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  interrupts = FALSE,\\n\", \"  persistent = FALSE,\\n\",  #>                 \"  ...\\n\", \")\\n\", \"\\n\", \"MulticoreFutureBackend(\\n\",  #>                 \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                 \"  maxSizeOfObjects = +Inf,\\n\", \"  ...\\n\", \")\\n\",  #>                 \"\\n\", \"SequentialFutureBackend(..., maxSizeOfObjects = +Inf)\\n\",  #>                 \"\\n\", \"MultisessionFutureBackend(\\n\", \"  workers = availableCores(constraints = \\\"connections-16\\\"),\\n\",  #>                 \"  rscript_libs = .libPaths(),\\n\", \"  interrupts = TRUE,\\n\",  #>                 \"  gc = FALSE,\\n\", \"  earlySignal = FALSE,\\n\",  #>                 \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                 \"earlySignal\"), list(\"Overrides the default behavior on whether futures\\n\",  #>                 \"should resignal (\\\"relay\\\") conditions captured as soon as possible, or\\n\",  #>                 \"delayed, for instance, until \", list(list(\"value()\")),  #>                 \" is called on the future.\\n\", \"(Default: \",  #>                 list(\"FALSE\"), \")\")), \"\\n\", \"\\n\", list(list(\"gc\"),  #>                 list(\"Overrides the default behavior of whether futures should trigger\\n\",  #>                   \"garbage collection via \", list(list(\"gc()\")),  #>                   \" on the parallel worker after the value has\\n\",  #>                   \"been collected from the worker.\\n\", \"This can help to release memory sooner than letting R itself on the parallel\\n\",  #>                   \"worker decided when it is needed. Releasing memory sooner can help to fit\\n\",  #>                   \"more parallel workers on a machine with limited amount of total memory.\\n\",  #>                   \"(Default: \", list(\"FALSE\"), \")\")), \"\\n\", \"\\n\",  #>                 list(list(\"maxSizeOfObjects\"), list(\"The maximum allowed total size, in bytes, of all\\n\",  #>                   \"objects to and from the parallel worker allows.\\n\",  #>                   \"This can help to protect against unexpectedly large data transfers between\\n\",  #>                   \"the parent process and the parallel workers - data that is often transferred\\n\",  #>                   \"over the network, which sometimes also includes the internet. For instance,\\n\",  #>                   \"if you sit at home and have set up a future backend with workers running\\n\",  #>                   \"remotely at your university or company, then you might want to use this\\n\",  #>                   \"protection to avoid transferring giga- or terabytes of data without noticing.\\n\",  #>                   \"(Default: \", list(list(\"500 \\\\cdot 1024^2\")),  #>                   \" bytes = 500 MiB, unless overridden by a\\n\",  #>                   \"FutureBackend subclass, or by R option \",  #>                   list(\"future.globals.maxSize\"), \" (sic!))\")),  #>                 \"\\n\", \"\\n\", list(list(\"interrupts\"), list(\"If FALSE, attempts to interrupt futures will not take\\n\",  #>                   \"place on this backend, even if the backend supports it. This is useful\\n\",  #>                   \"when, for instance, it takes a long time to interrupt a future.\")),  #>                 \"\\n\", \"\\n\", list(list(\"backend\"), list(\"a \",  #>                   list(\"FutureBackend\"), \".\")), \"\\n\", \"\\n\", list( #>                   list(\"future\"), list(\"a \", list(\"Future\"),  #>                     \" to be started.\")), \"\\n\", \"\\n\", list(list( #>                   \"wait.timeout\"), list(\"Number of seconds before timing out.\")),  #>                 \"\\n\", \"\\n\", list(list(\"wait.interval\"), list( #>                   \"Baseline number of seconds between retries.\")),  #>                 \"\\n\", \"\\n\", list(list(\"wait.alpha\"), list(\"Scale factor increasing waiting interval after each\\n\",  #>                   \"attempt.\")), \"\\n\", \"\\n\", list(list(\"workers\"),  #>                   list(\"...\")), \"\\n\", \"\\n\", list(list(\"persistent\"),  #>                   list(\"(deprecated) ...\")), \"\\n\", \"\\n\", list( #>                   list(list()), list(\"(optional) not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", list(\"FutureBackend()\"),  #>                 \" returns a FutureBackend object, which inherits an\\n\",  #>                 \"environment. Specific future backends are defined by subclasses\\n\",  #>                 \"implementing the FutureBackend API.\\n\", \"\\n\",  #>                 list(\"launchFuture()\"), \" returns the launched \",  #>                 list(\"Future\"), \" object.\\n\", \"\\n\", list(\"interruptFuture()\"),  #>                 \" returns the interrupted \", list(\"Future\"),  #>                 \" object,\\n\", \"if supported, other the unmodified future.\\n\",  #>                 \"\\n\", list(\"stopWorkers()\"), \" returns TRUE if the workers were shut down,\\n\",  #>                 \"otherwise FALSE.\\n\"), \"\\n\", list(\"\\n\", list( #>                 \"This functionality is only for developers who wish to implement their\\n\",  #>                 \"own future backend.  End-users and package developers use futureverse,\\n\",  #>                 \"does not need to know about these functions.\"),  #>                 \"\\n\", \"\\n\", \"If you are looking for available future backends to choose from, please\\n\",  #>                 \"see the 'A Future for R: Available Future Backends' vignette and\\n\",  #>                 list(\"https://www.futureverse.org/backends.html\"),  #>                 \".\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"ClusterFutureBackend\"),  #>                 \" is selected by\\n\", list(\"plan(cluster, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MulticoreFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multicore, workers = workers)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"SequentialFutureBackend\"),  #>                 \" is selected by \", list(\"plan(sequential)\"),  #>                 \".\\n\", \"\\n\", \"The \", list(\"MultisessionFutureBackend\"),  #>                 \" backend is selected by\\n\", list(\"plan(multisession, workers = workers)\"),  #>                 \".\\n\"), \"\\n\", list(list(\"The FutureBackend API\"),  #>                 list(\"\\n\", \"\\n\", \"The \", list(\"FutureBackend\"),  #>                   \" class specifies FutureBackend API,\\n\", \"that all backends must implement and comply to. Specifically,\\n\")),  #>             \"\\n\", \"\\n\", list(\"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                 \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                 \".\\n\", \"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                 \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureCondition.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureCondition-class.R,\",  #>             \"\\n\", \"%   R/protected_api-journal.R\", \"\\n\", list( #>                 \"FutureCondition\"), \"\\n\", list(\"FutureCondition\"),  #>             \"\\n\", list(\"FutureMessage\"), \"\\n\", list(\"FutureWarning\"),  #>             \"\\n\", list(\"FutureError\"), \"\\n\", list(\"RngFutureCondition\"),  #>             \"\\n\", list(\"RngFutureWarning\"), \"\\n\", list(\"RngFutureError\"),  #>             \"\\n\", list(\"UnexpectedFutureResultError\"), \"\\n\",  #>             list(\"GlobalEnvMisuseFutureCondition\"), \"\\n\", list( #>                 \"GlobalEnvMisuseFutureWarning\"), \"\\n\", list(\"GlobalEnvMisuseFutureError\"),  #>             \"\\n\", list(\"ConnectionMisuseFutureCondition\"), \"\\n\",  #>             list(\"ConnectionMisuseFutureWarning\"), \"\\n\", list( #>                 \"ConnectionMisuseFutureError\"), \"\\n\", list(\"DeviceMisuseFutureCondition\"),  #>             \"\\n\", list(\"DeviceMisuseFutureWarning\"), \"\\n\", list( #>                 \"DeviceMisuseFutureError\"), \"\\n\", list(\"DefaultDeviceMisuseFutureCondition\"),  #>             \"\\n\", list(\"DefaultDeviceMisuseFutureWarning\"), \"\\n\",  #>             list(\"DefaultDeviceMisuseFutureError\"), \"\\n\", list( #>                 \"FutureLaunchError\"), \"\\n\", list(\"FutureInterruptError\"),  #>             \"\\n\", list(\"FutureCanceledError\"), \"\\n\", list(\"FutureDroppedError\"),  #>             \"\\n\", list(\"FutureJournalCondition\"), \"\\n\", list( #>                 \"A condition (message, warning, or error) that occurred while orchestrating a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureCondition(\\n\", \"  message,\\n\",  #>                 \"  call = NULL,\\n\", \"  by = session_uuid(),\\n\",  #>                 \"  when = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  label = future[[\\\"label\\\"]],\\n\", \"  future = NULL,\\n\",  #>                 \"  drop = FALSE\\n\", \")\\n\", \"\\n\", \"FutureMessage(\\n\",  #>                 \"  message,\\n\", \"  call = NULL,\\n\", \"  ...,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"FutureWarning(\\n\", \"  message,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\", \"\\n\", \"FutureError(message, call = NULL, ..., uuid = future[[\\\"uuid\\\"]], future = NULL)\\n\",  #>                 \"\\n\", \"RngFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\", \"\\n\", \"RngFutureWarning(...)\\n\",  #>                 \"\\n\", \"RngFutureError(...)\\n\", \"\\n\", \"UnexpectedFutureResultError(future, hint = NULL)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"GlobalEnvMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"GlobalEnvMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"ConnectionMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"ConnectionMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"ConnectionMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"DeviceMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  differences = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"DeviceMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"DeviceMisuseFutureError(...)\\n\", \"\\n\",  #>                 \"DefaultDeviceMisuseFutureCondition(\\n\", \"  message = NULL,\\n\",  #>                 \"  call = NULL,\\n\", \"  ...,\\n\", \"  incidents = NULL,\\n\",  #>                 \"  uuid = future[[\\\"uuid\\\"]],\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"DefaultDeviceMisuseFutureWarning(...)\\n\",  #>                 \"\\n\", \"DefaultDeviceMisuseFutureError(...)\\n\",  #>                 \"\\n\", \"FutureLaunchError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureInterruptError(\\n\", \"  message = \\\"A future was interrupted\\\",\\n\",  #>                 \"  when = Sys.time(),\\n\", \"  future = NULL\\n\",  #>                 \")\\n\", \"\\n\", \"FutureCanceledError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureDroppedError(..., future = NULL)\\n\",  #>                 \"\\n\", \"FutureJournalCondition(\\n\", \"  message,\\n\",  #>                 \"  journal,\\n\", \"  call = NULL,\\n\", \"  uuid = future[[\\\"uuid\\\"]],\\n\",  #>                 \"  future = NULL\\n\", \")\\n\"), \"\\n\", list(\"\\n\",  #>                 list(list(\"message\"), list(\"A message condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"call\"), list(\"(optional) The call stack that led up to the condition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"by\"), list(\"(optional) A session UUID object.\")),  #>                 \"\\n\", \"\\n\", list(list(\"when\"), list(\"(optional) A \",  #>                   list(\"POSIXct\"), \" timestamp for when the condition was\\n\",  #>                   \"created.\")), \"\\n\", \"\\n\", list(list(\"uuid\"),  #>                   list(\"(optional) A universally unique identifier for the future\\n\",  #>                     \"associated with this FutureCondition.\")),  #>                 \"\\n\", \"\\n\", list(list(\"label\"), list(\"(optional) A future label.\")),  #>                 \"\\n\", \"\\n\", list(list(\"future\"), list(\"(optional) The \",  #>                   list(\"Future\"), \" involved.\")), \"\\n\", \"\\n\",  #>                 list(list(\"drop\"), list(\"If TRUE, the \", list( #>                   \"future\"), \" argument is only used to populate\\n\",  #>                   \"future metadata, but is not stored in the condition object created.\")),  #>                 \"\\n\", \"\\n\", list(list(\"hint\"), list(\"(optional) A string with a suggestion on what might be wrong.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureCondition which inherits from class\\n\",  #>                 list(\"condition\"), \" and FutureMessage, FutureWarning,\\n\",  #>                 \"and FutureError all inherits from FutureCondition.\\n\",  #>                 \"Moreover, a FutureError inherits from \", list( #>                   \"error\"), \",\\n\", \"a FutureWarning from \", list( #>                   \"warning\"), \", and\\n\", \"a FutureMessage from \",  #>                 list(\"message\"), \".\\n\"), \"\\n\", list(\"\\n\", \"While \",  #>                 list(\"orchestrating\"), \" (creating, launching, querying, collection)\\n\",  #>                 \"futures, unexpected run-time errors (and other types of conditions) may\\n\",  #>                 \"occur.  Such conditions are coerced to a corresponding FutureCondition\\n\",  #>                 \"class to help distinguish them from conditions that occur due to the\\n\",  #>                 list(\"evaluation\"), \" of the future.\\n\"), \"\\n\",  #>             list(\"internal\"), \"\\n\"), FutureGlobals.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureGlobals-class.R\",  #>             \"\\n\", list(\"FutureGlobals\"), \"\\n\", list(\"FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals\"), \"\\n\", list(\"as.FutureGlobals.FutureGlobals\"),  #>             \"\\n\", list(\"as.FutureGlobals.Globals\"), \"\\n\", list( #>                 \"as.FutureGlobals.list\"), \"\\n\", list(\"[.FutureGlobals\"),  #>             \"\\n\", list(\"c.FutureGlobals\"), \"\\n\", list(\"unique.FutureGlobals\"),  #>             \"\\n\", list(\"A representation of a set of globals used with futures\"),  #>             \"\\n\", list(\"\\n\", \"FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"A named list.\")),  #>                 \"\\n\", \"\\n\", list(list(\"resolved\"), list(\"A logical indicating whether these globals\\n\",  #>                   \"have been scanned for and resolved futures or not.\")),  #>                 \"\\n\", \"\\n\", list(list(\"total_size\"), list(\"The total size of all globals, if known.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class \",  #>                 list(\"FutureGlobals\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                 \"A representation of a set of globals used with futures\\n\"),  #>             \"\\n\", list(\"\\n\", \"This class extends the \", list( #>                 \"Globals\"), \" class by adding\\n\", \"attributes \",  #>                 list(\"resolved\"), \" and \", list(\"total_size\"),  #>                 \".\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), FutureResult.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/protected_api-FutureResult-class.R\",  #>             \"\\n\", list(\"FutureResult\"), \"\\n\", list(\"FutureResult\"),  #>             \"\\n\", list(\"as.character.FutureResult\"), \"\\n\", list( #>                 \"print.FutureResult\"), \"\\n\", list(\"Results from resolving a future\"),  #>             \"\\n\", list(\"\\n\", \"FutureResult(\\n\", \"  value = NULL,\\n\",  #>                 \"  visible = TRUE,\\n\", \"  stdout = NULL,\\n\",  #>                 \"  conditions = NULL,\\n\", \"  rng = FALSE,\\n\",  #>                 \"  ...,\\n\", \"  uuid = NULL,\\n\", \"  started = .POSIXct(NA_real_),\\n\",  #>                 \"  finished = Sys.time(),\\n\", \"  version = \\\"1.8\\\"\\n\",  #>                 \")\\n\", \"\\n\", list(list(\"as.character\"), list( #>                   \"FutureResult\")), \"(x, ...)\\n\", \"\\n\", list( #>                   list(\"print\"), list(\"FutureResult\")), \"(x, ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"value\"), list(\"The value of the future expression.\\n\",  #>                 \"If the expression was not fully resolved (e.g. an error) occurred,\\n\",  #>                 \"the the value is \", list(\"NULL\"), \".\")), \"\\n\",  #>                 \"\\n\", list(list(\"visible\"), list(\"If TRUE, the value was visible, otherwise invisible.\")),  #>                 \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A list of zero or more list elements each containing\\n\",  #>                   \"a captured \", list(\"condition\"), \" and possibly more meta data such as the\\n\",  #>                   \"call stack and a timestamp.\")), \"\\n\", \"\\n\",  #>                 list(list(\"rng\"), list(\"If TRUE, the \", list( #>                   \".Random.seed\"), \" was updated from resolving the\\n\",  #>                   \"future, otherwise not.\")), \"\\n\", \"\\n\", list( #>                   list(\"started, finished\"), list(list(\"POSIXct\"),  #>                     \" timestamps\\n\", \"when the evaluation of the future expression was started and finished.\")),  #>                 \"\\n\", \"\\n\", list(list(\"version\"), list(\"The version format of the results.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional named results to be returned.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"An object of class FutureResult.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Results from resolving a future\\n\"),  #>             \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                 list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                 list(\"not\"), \" part of the frontend Future API.\\n\"),  #>             \"\\n\", list(list(\"Note to developers\"), list(\"\\n\",  #>                 \"\\n\", \"The FutureResult structure is \", list( #>                   \"under development\"), \" and may change at anytime,\\n\",  #>                 \"e.g. elements may be renamed or removed.  Because of this, please avoid\\n\",  #>                 \"accessing the elements directly in code.  Feel free to reach out if you need\\n\",  #>                 \"to do so in your code.\\n\")), \"\\n\", \"\\n\", list( #>                 \"internal\"), \"\\n\"), `MultiprocessFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in\", \"\\n\", \"%   R/backend_api-03.MultiprocessFutureBackend-class.R\",  #>             \"\\n\", list(\"MultiprocessFuture-class\"), \"\\n\", list( #>                 \"MultiprocessFuture-class\"), \"\\n\", list(\"MultiprocessFuture\"),  #>             \"\\n\", list(\"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\"),  #>             \"\\n\", list(\"\\n\", \"MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":d, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"MultiprocessFuture()\"), \" returns an object of class \",  #>                 list(\"MultiprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"A multiprocess future is a future whose value will be resolved asynchronously in a parallel process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), `UniprocessFuture-class.Rd` = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/backend_api-UniprocessFuture-class.R\",  #>             \"\\n\", list(\"UniprocessFuture-class\"), \"\\n\", list( #>                 \"UniprocessFuture-class\"), \"\\n\", list(\"UniprocessFuture\"),  #>             \"\\n\", list(\"An uniprocess future is a future whose value will be resolved synchronously in the current process\"),  #>             \"\\n\", list(\"\\n\", \"UniprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \", list(),  #>                 \" \", list(\"expression\"), \".\")), \"\\n\", \"\\n\", list( #>                 list(\"substitute\"), list(\"If TRUE, argument \",  #>                   list(\"expr\"), \" is\\n\", list(list(\"substitute\"),  #>                     \"()\"), \":d, otherwise not.\")), \"\\n\", \"\\n\",  #>                 list(list(\"envir\"), list(\"The \", list(\"environment\"),  #>                   \" from where global objects should be\\n\", \"identified.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Additional named elements passed to \",  #>                   list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>             list(\"\\n\", list(\"UniprocessFuture()\"), \" returns an object of class \",  #>                 list(\"UniprocessFuture\"), \".\\n\"), \"\\n\", list( #>                 \"\\n\", \"An uniprocess future is a future whose value will be resolved synchronously in the current process\\n\"),  #>             \"\\n\", list(\"internal\"), \"\\n\"), backtrace.Rd = list( #>             \"% Generated by roxygen2: do not edit by hand\", \"\\n\",  #>             \"% Please edit documentation in R/utils_api-backtrace.R\",  #>             \"\\n\", list(\"backtrace\"), \"\\n\", list(\"backtrace\"),  #>             \"\\n\", list(\"Back trace the expressions evaluated when an error was caught\"),  #>             \"\\n\", list(\"\\n\", \"backtrace(future, envir = parent.frame(), ...)\\n\"),  #>             \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A future with a caught error.\")),  #>                 \"\\n\", \"\\n\", list(list(\"envir\"), list(\"the environment where to locate the future.\")),  #>                 \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                 \"\\n\"), \"\\n\", list(\"\\n\", \"A list with the future's call stack that led up to the error.\\n\"),  #>             \"\\n\", list(\"\\n\", \"Back trace the expressions evaluated when an error was caught\\n\"),  #>             \"\\n\", list(\"\\n\", \"my_log <- function(x) log(x)\\n\",  #>                 \"foo <- function(...) my_log(...)\\n\", \"\\n\", \"f <- future({ foo(\\\"a\\\") })\\n\",  #>                 \"res <- tryCatch({\\n\", \"  v <- value(f)\\n\", \"}, error = function(ex) {\\n\",  #>                 \"  t <- backtrace(f)\\n\", \"  print(t)\\n\", \"})\\n\",  #>                 list(\"\\n\", \"## R CMD check: make sure any open connections are closed afterward\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\", \"\\n\"), \"\\n\"),  #>             cancel.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-cancel.R\",  #>                 \"\\n\", list(\"cancel\"), \"\\n\", list(\"cancel\"), \"\\n\",  #>                 list(\"Cancel a future\"), \"\\n\", list(\"\\n\", \"cancel(x, interrupt = TRUE, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"x\"), list(\"A Future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"interrupt\"), list(\"If TRUE, running futures are interrupted, if the\\n\",  #>                     \"future backend supports it.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"cancel()\"), \" returns (invisibly) the canceled \",  #>                   list(\"Future\"), \"s after\\n\", \"flagging them as \\\"canceled\\\" and possibly interrupting them as well.\\n\",  #>                   \"\\n\", \"Canceling a lazy or a finished future has no effect.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Cancels futures, with the option to interrupt running ones.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"if ((interactive() || .Platform[[\\\"OS.type\\\"]] != \\\"windows\\\")) withAutoprint({ # examplesIf\"),  #>                   \"\\n\", \"## Set up two parallel workers\\n\", \"plan(multisession, workers = 2)\\n\",  #>                   \"\\n\", \"## Launch two long running futures\\n\",  #>                   \"fs <- lapply(c(1, 2), function(duration) {\\n\",  #>                   \"  future({\\n\", \"    Sys.sleep(duration)\\n\",  #>                   \"    42\\n\", \"  })\\n\", \"})\\n\", \"\\n\", \"## Wait until at least one of the futures is resolved\\n\",  #>                   \"while (!any(resolved(fs))) Sys.sleep(0.1)\\n\",  #>                   \"\\n\", \"## Cancel the future that is not yet resolved\\n\",  #>                   \"r <- resolved(fs)\\n\", \"cancel(fs[!r])\\n\",  #>                   \"\\n\", \"## Get the value of the resolved future\\n\",  #>                   \"f <- fs[r]\\n\", \"v <- value(f)\\n\", \"message(\\\"Result: \\\", v)\\n\",  #>                   \"\\n\", \"## The value of the canceled future is an error\\n\",  #>                   \"try(v <- value(fs[!r]))\\n\", \"\\n\", \"## Shut down parallel workers\\n\",  #>                   \"plan(sequential)\\n\", list(\"}) # examplesIf\"),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A canceled future can be \",  #>                   list(list(\"reset()\")), \" to a lazy, vanilla future\\n\",  #>                   \"such that it can be relaunched, possibly on another future backend.\\n\"),  #>                 \"\\n\"), cluster.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.ClusterFutureBackend-class.R\",  #>                 \"\\n\", list(\"cluster\"), \"\\n\", list(\"cluster\"),  #>                 \"\\n\", list(\"Create a cluster future whose value will be resolved asynchronously in a parallel process\"),  #>                 \"\\n\", list(\"\\n\", \"cluster(\\n\", \"  ...,\\n\", \"  workers = availableWorkers(constraints = \\\"connections\\\"),\\n\",  #>                   \"  persistent = FALSE\\n\", \")\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"workers\"), list(\"A \", list( #>                     list(\"cluster\")), \" object,\\n\", \"a character vector of host names, a positive numeric scalar,\\n\",  #>                     \"or a function.\\n\", \"If a character vector or a numeric scalar, a \",  #>                     list(\"cluster\"), \" object\\n\", \"is created using \",  #>                     list(list(\"makeClusterPSOCK\"), \"(workers)\"),  #>                     \".\\n\", \"If a function, it is called without arguments \",  #>                     list(\"when the future\\n\", \"is created\"),  #>                     \" and its value is used to configure the workers.\\n\",  #>                     \"The function should return any of the above types.\\n\",  #>                     \"If \", list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                     \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                     \"sequential future. To override this fallback, use \",  #>                     list(\"workers = I(1)\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"persistent\"), list(\"If FALSE, the evaluation environment is cleared\\n\",  #>                     \"from objects prior to the evaluation of the future.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"WARNING: This function must never be called.\\n\",  #>                   \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A cluster future is a future that uses cluster evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another process\"), \".\\n\", \"\\n\",  #>                   \"This function is must \", list(\"not\"), \" be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures via a single background R process on the local machine\\n\",  #>                     \"plan(cluster, workers = I(1))\\n\", \"\\n\",  #>                     \"# Evaluate futures via two background R processes on the local machine\\n\",  #>                     \"plan(cluster, workers = 2)\\n\", \"\\n\", \"# Evaluate futures via a single R process on another machine on on the\\n\",  #>                     \"# local area network (LAN)\\n\", \"plan(cluster, workers = \\\"raspberry-pi\\\")\\n\",  #>                     \"\\n\", \"# Evaluate futures via a single R process running on a remote machine\\n\",  #>                     \"plan(cluster, workers = \\\"pi.example.org\\\")\\n\",  #>                     \"\\n\", \"# Evaluate futures via four R processes, one running on the local machine,\\n\",  #>                     \"# two running on LAN machine 'n1' and one on a remote machine\\n\",  #>                     \"plan(cluster, workers = c(\\\"localhost\\\", \\\"n1\\\", \\\"n1\\\", \\\"pi.example.org\\\"))\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use cluster futures\\n\",  #>                   \"cl <- parallel::makeCluster(2, timeout = 60)\\n\",  #>                   \"plan(cluster, workers = cl)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A cluster future is evaluated in a separate process.\\n\",  #>                   \"## Regardless, changing the value of a global variable will\\n\",  #>                   \"## not affect the result of the future.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\", \"\\n\",  #>                   \"## CLEANUP\\n\", \"parallel::stopCluster(cl)\\n\",  #>                   \"\\n\"), \"\\n\"), \"\\n\", list(\"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                   \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                   \".\\n\"), \"\\n\"), clusterExportSticky.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>                 \"\\n\", list(\"clusterExportSticky\"), \"\\n\", list( #>                   \"clusterExportSticky\"), \"\\n\", list(\"Export globals to the sticky-globals environment of the cluster nodes\"),  #>                 \"\\n\", list(\"\\n\", \"clusterExportSticky(cl, globals)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"cl\"), list(\"(cluster) A cluster object as returned by\\n\",  #>                   list(list(\"parallel::makeCluster()\")), \".\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(list) A named list of sticky globals to be exported.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"(invisible; cluster) The cluster object.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Export globals to the sticky-globals environment of the cluster nodes\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This requires that the \", list( #>                   \"future\"), \" package is installed on the cluster\\n\",  #>                   \"nodes.\\n\"), \"\\n\", list(\"internal\"), \"\\n\"),  #>             find_references.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-marshalling.R\",  #>                 \"\\n\", list(\"find_references\"), \"\\n\", list(\"find_references\"),  #>                 \"\\n\", list(\"assert_no_references\"), \"\\n\", list( #>                   \"Get the first or all references of an \", list(),  #>                   \" object\"), \"\\n\", list(\"\\n\", \"find_references(x, first_only = FALSE)\\n\",  #>                   \"\\n\", \"assert_no_references(\\n\", \"  x,\\n\",  #>                   \"  action = c(\\\"error\\\", \\\"warning\\\", \\\"message\\\", \\\"string\\\"),\\n\",  #>                   \"  source = c(\\\"globals\\\", \\\"value\\\")\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"x\"), list(\"The \",  #>                   list(), \" object to be checked.\")), \"\\n\", \"\\n\",  #>                   list(list(\"first_only\"), list(\"If \", list(\"TRUE\"),  #>                     \", only the first reference is returned,\\n\",  #>                     \"otherwise all references.\")), \"\\n\", \"\\n\",  #>                   list(list(\"action\"), list(\"Type of action to take if a reference is found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"source\"), list(\"Is the source of \",  #>                     list(\"x\"), \" the globals or the value of the future?\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"find_references()\"),  #>                   \" returns a list of zero or more references\\n\",  #>                   \"identified.\\n\", \"\\n\", \"If a reference is detected, an informative error, warning, message,\\n\",  #>                   \"or a character string is produced, otherwise \",  #>                   list(\"NULL\"), \" is returned\\n\", \"invisibly.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Get the first or all references of an \",  #>                   list(), \" object\\n\", \"\\n\", \"Assert that there are no references among the identified globals\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), future.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-future.R, R/utils_api-futureCall.R,\",  #>                 \"\\n\", \"%   R/utils_api-minifuture.R\", \"\\n\", list( #>                   \"future\"), \"\\n\", list(\"future\"), \"\\n\", list( #>                   \"futureCall\"), \"\\n\", list(\"minifuture\"), \"\\n\",  #>                 list(\"Create a future\"), \"\\n\", list(\"\\n\", \"future(\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  lazy = FALSE,\\n\",  #>                   \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  conditions = \\\"condition\\\",\\n\", \"  label = NULL,\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", \"futureCall(\\n\", \"  FUN,\\n\",  #>                   \"  args = list(),\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  lazy = FALSE,\\n\", \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  conditions = \\\"condition\\\",\\n\", \"  label = NULL,\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", \"minifuture(\\n\", \"  expr,\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  globals = NULL,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = NA,\\n\",  #>                   \"  conditions = NULL,\\n\", \"  seed = NULL,\\n\",  #>                   \"  ...,\\n\", \"  envir = parent.frame()\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"expr\"), list(\"An \",  #>                   list(), \" \", list(\"expression\"), \".\")), \"\\n\",  #>                   \"\\n\", list(list(\"envir\"), list(\"The \", list( #>                     \"environment\"), \" from where global objects should be\\n\",  #>                     \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                     list(\"If TRUE, argument \", list(\"expr\"),  #>                       \" is\\n\", list(list(\"substitute\"), \"()\"),  #>                       \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                       \"eagerly (starting immediately), otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                     \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                     \"random numbers are produced (also during parallelization).\\n\",  #>                     \"If FALSE (default), it is assumed that the future expression neither\\n\",  #>                     \"needs nor uses random number generation.\\n\",  #>                     \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integers)\\n\",  #>                     \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                     \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                     \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                     \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                     \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                     \"ignored, an informative warning, or error will be produced.\\n\",  #>                     \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                     list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                     \"to control how globals are handled.\\n\",  #>                     \"For details, see section 'Globals used by future expressions'\\n\",  #>                     \"in the help for \", list(list(\"future()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(\"packages\"),  #>                     list(\"(optional) a character vector specifying packages\\n\",  #>                       \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                     \"and re-outputted when \", list(\"value()\"),  #>                     \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                     \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                     \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                     \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                     \"captured output across futures.\\n\", \"Using \",  #>                     list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                     \"behavior of such unhandled standard output depends on the future backend.\")),  #>                   \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of condition classes to be captured\\n\",  #>                     \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                     \"and warnings.  To drop all conditions, use \",  #>                     list(\"conditions = character(0)\"), \".\\n\",  #>                     \"Errors are always relayed.\\n\", \"Attribute \",  #>                     list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                     list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                     \" will capture\\n\", \"all \", list(\"condition\"),  #>                     \" classes except those that inherit from the \",  #>                     list(\"message\"), \" class.\\n\", \"Using \", list( #>                       \"conditions = structure(..., drop = TRUE)\"),  #>                     \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as they have\\n\",  #>                     \"been relayed, e.g. by \", list(\"value(f)\"),  #>                     \". This can help decrease the overall\\n\",  #>                     \"memory consumed by captured conditions across futures.\\n\",  #>                     \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                     \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                     \"future backend and the environment from which R runs.\")),  #>                   \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"FUN\"), list(\"A \", list( #>                     \"function\"), \" to be evaluated.\")), \"\\n\",  #>                   \"\\n\", list(list(\"args\"), list(\"A \", list(\"list\"),  #>                     \" of arguments passed to function \", list( #>                       \"FUN\"), \".\")), \"\\n\", \"\\n\", list(list(list()),  #>                     list(\"Additional arguments passed to \", list( #>                       list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", list(\"future()\"), \" returns \", list( #>                   \"Future\"), \" that evaluates expression \", list( #>                   \"expr\"), \".\\n\", \"\\n\", list(\"futureCall()\"),  #>                   \" returns a \", list(\"Future\"), \" that calls function \",  #>                   list(\"FUN\"), \" with\\n\", \"arguments \", list( #>                     \"args\"), \".\\n\", \"\\n\", list(\"minifuture(expr)\"),  #>                   \" creates a future with minimal overhead, by disabling\\n\",  #>                   \"user-friendly behaviors, e.g. automatic identification of global\\n\",  #>                   \"variables and packages needed, and relaying of output. Unless you have\\n\",  #>                   \"good reasons for using this function, please use \",  #>                   list(list(\"future()\")), \" instead.\\n\", \"This function exists mainly for the purpose of profiling and identifying\\n\",  #>                   \"which automatic features of \", list(list(\"future()\")),  #>                   \" introduce extra overhead.\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"html\"), list(list(list(\"logo.png\"),  #>                     list(\"options: style='float: right;' alt='logo' width='120'\")))),  #>                   \"\\n\", \"Creates a future that evaluates an \",  #>                   list(), \" expression or\\n\", \"a future that calls an \",  #>                   list(), \" function with a set of arguments.\\n\",  #>                   \"How, when, and where these futures are evaluated can be configured\\n\",  #>                   \"using \", list(list(\"plan()\")), \" such that they are evaluated in parallel on,\\n\",  #>                   \"for instance, the current machine, on a remote machine, or via a\\n\",  #>                   \"job queue on a compute cluster.\\n\", \"Importantly, any \",  #>                   list(), \" code using futures remains the same regardless\\n\",  #>                   \"of these settings and there is no need to modify the code when\\n\",  #>                   \"switching from, say, sequential to parallel processing.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The state of a future is either unresolved or resolved.\\n\",  #>                   \"The value of a future can be retrieved using \",  #>                   list(\"v <- \", list(\"value\"), \"(f)\"), \".\\n\",  #>                   \"Querying the value of a non-resolved future will \",  #>                   list(\"block\"), \" the call\\n\", \"until the future is resolved.\\n\",  #>                   \"It is possible to check whether a future is resolved or not\\n\",  #>                   \"without blocking by using \", list(list(\"resolved\"),  #>                     \"(f)\"), \".\\n\", \"It is possible to \", list( #>                     list(\"cancel()\")), \" a future that is being resolved.\\n\",  #>                   \"Failed, canceled, and interrupted futures can be \",  #>                   list(list(\"reset()\")), \" to a\\n\", \"lazy, vanilla future that can be relaunched.\\n\",  #>                   \"\\n\", \"The \", list(\"futureCall()\"), \" function works analogously to\\n\",  #>                   list(list(\"do.call\"), \"()\"), \", which calls a function with a set of\\n\",  #>                   \"arguments.  The difference is that \", list( #>                     \"do.call()\"), \" returns the value of\\n\",  #>                   \"the call whereas \", list(\"futureCall()\"),  #>                   \" returns a future.\\n\"), \"\\n\", list(list(\"Eager or lazy evaluation\"),  #>                   list(\"\\n\", \"\\n\", \"By default, a future is resolved using \",  #>                     list(\"eager\"), \" evaluation\\n\", \"(\", list( #>                       \"lazy = FALSE\"), \").  This means that the expression starts to\\n\",  #>                     \"be evaluated as soon as the future is created.\\n\",  #>                     \"\\n\", \"As an alternative, the future can be resolved using \",  #>                     list(\"lazy\"), \"\\n\", \"evaluation (\", list( #>                       \"lazy = TRUE\"), \").  This means that the expression\\n\",  #>                     \"will only be evaluated when the value of the future is requested.\\n\",  #>                     list(\"Note that this means that the expression may not be evaluated\\n\",  #>                       \"at all - it is guaranteed to be evaluated if the value is requested\"),  #>                     \".\\n\")), \"\\n\", \"\\n\", list(list(\"Globals used by future expressions\"),  #>                   list(\"\\n\", \"\\n\", \"Global objects (short \",  #>                     list(\"globals\"), \") are objects (e.g. variables and\\n\",  #>                     \"functions) that are needed in order for the future expression to be\\n\",  #>                     \"evaluated while not being local objects that are defined by the future\\n\",  #>                     \"expression. For example, in\\n\", list(\"\\n\",  #>                       \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b })\\n\"),  #>                     \"\\n\", \"variable \", list(\"a\"), \" is a global of future assignment \",  #>                     list(\"f\"), \" whereas\\n\", list(\"b\"), \" is a local variable.\\n\",  #>                     \"In order for the future to be resolved successfully (and correctly),\\n\",  #>                     \"all globals need to be gathered when the future is created such that\\n\",  #>                     \"they are available whenever and wherever the future is resolved.\\n\",  #>                     \"\\n\", \"The default behavior (\", list(\"globals = TRUE\"),  #>                     \"),\\n\", \"is that globals are automatically identified and gathered.\\n\",  #>                     \"More precisely, globals are identified via code inspection of the\\n\",  #>                     \"future expression \", list(\"expr\"), \" and their values are retrieved with\\n\",  #>                     \"environment \", list(\"envir\"), \" as the starting point (basically via\\n\",  #>                     list(\"get(global, envir = envir, inherits = TRUE)\"),  #>                     \").\\n\", list(\"In most cases, such automatic collection of globals is sufficient\\n\",  #>                       \"and less tedious and error prone than if they are manually specified\"),  #>                     \".\\n\", \"\\n\", \"However, for full control, it is also possible to explicitly specify\\n\",  #>                     \"exactly which globals are by providing their names as a character\\n\",  #>                     \"vector.\\n\", \"In the above example, we could use\\n\",  #>                     list(\"\\n\", \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b }, globals = \\\"a\\\")\\n\"),  #>                     \"\\n\", \"\\n\", \"Yet another alternative is to explicitly also specify their values\\n\",  #>                     \"using a named list as in\\n\", list(\"\\n\",  #>                       \"  a <- 42\\n\", \"  f <- future({ b <- 2; a * b }, globals = list(a = a))\\n\"),  #>                     \"\\n\", \"or\\n\", list(\"\\n\", \"  f <- future({ b <- 2; a * b }, globals = list(a = 42))\\n\"),  #>                     \"\\n\", \"\\n\", \"Specifying globals explicitly avoids the overhead added from\\n\",  #>                     \"automatically identifying the globals and gathering their values.\\n\",  #>                     \"Furthermore, if we know that the future expression does not make use\\n\",  #>                     \"of any global variables, we can disable the automatic search for\\n\",  #>                     \"globals by using\\n\", list(\"\\n\", \"  f <- future({ a <- 42; b <- 2; a * b }, globals = FALSE)\\n\"),  #>                     \"\\n\", \"\\n\", \"Future expressions often make use of functions from one or more packages.\\n\",  #>                     \"As long as these functions are part of the set of globals, the future\\n\",  #>                     \"package will make sure that those packages are attached when the future\\n\",  #>                     \"is resolved.  Because there is no need for such globals to be frozen\\n\",  #>                     \"or exported, the future package will not export them, which reduces\\n\",  #>                     \"the amount of transferred objects.\\n\", \"For example, in\\n\",  #>                     list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({ median(x) })\\n\"),  #>                     \"\\n\", \"variable \", list(\"x\"), \" and \", list( #>                       \"median()\"), \" are globals, but only \",  #>                     list(\"x\"), \"\\n\", \"is exported whereas \",  #>                     list(\"median()\"), \", which is part of the \",  #>                     list(\"stats\"), \"\\n\", \"package, is not exported.  Instead it is made sure that the \",  #>                     list(\"stats\"), \"\\n\", \"package is on the search path when the future expression is evaluated.\\n\",  #>                     \"Effectively, the above becomes\\n\", list( #>                       \"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                       \"    library(stats)\\n\", \"    median(x)\\n\",  #>                       \"  })\\n\"), \"\\n\", \"To manually specify this, one can either do\\n\",  #>                     list(\"\\n\", \"  x <- rnorm(1000)\\n\", \"  f <- future({\\n\",  #>                       \"    median(x)\\n\", \"  }, globals = list(x = x, median = stats::median)\\n\"),  #>                     \"\\n\", \"or\\n\", list(\"\\n\", \"  x <- rnorm(1000)\\n\",  #>                       \"  f <- future({\\n\", \"    library(stats)\\n\",  #>                       \"    median(x)\\n\", \"  }, globals = list(x = x))\\n\"),  #>                     \"\\n\", \"Both are effectively the same.\\n\",  #>                     \"\\n\", \"Although rarely needed, a combination of automatic identification and manual\\n\",  #>                     \"specification of globals is supported via attributes \",  #>                     list(\"add\"), \" (to add\\n\", \"false negatives) and \",  #>                     list(\"ignore\"), \" (to ignore false positives) on value\\n\",  #>                     list(\"TRUE\"), \".  For example, with\\n\", list( #>                       \"globals = structure(TRUE, ignore = \\\"b\\\", add = \\\"a\\\")\"),  #>                     \" any globals\\n\", \"automatically identified, except \",  #>                     list(\"b\"), \", will be used, in addition to\\n\",  #>                     \"global \", list(\"a\"), \".\\n\")), \"\\n\", \"\\n\",  #>                 list(\"\\n\", \"## Evaluate futures in parallel\\n\",  #>                   \"plan(multisession)\\n\", \"\\n\", \"## Data\\n\",  #>                   \"x <- rnorm(100)\\n\", \"y <- 2 * x + 0.2 + rnorm(100)\\n\",  #>                   \"w <- 1 + x ^ 2\\n\", \"\\n\", \"\\n\", \"## EXAMPLE: Regular assignments (evaluated sequentially)\\n\",  #>                   \"fitA <- lm(y ~ x, weights = w)      ## with offset\\n\",  #>                   \"fitB <- lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                   \"fitC <- {\\n\", \"  w <- 1 + abs(x)  ## Different weights\\n\",  #>                   \"  lm(y ~ x, weights = w)\\n\", \"}\\n\", \"print(fitA)\\n\",  #>                   \"print(fitB)\\n\", \"print(fitC)\\n\", \"\\n\", \"\\n\",  #>                   \"## EXAMPLE: Future assignments (evaluated in parallel)\\n\",  #>                   \"fitA %<-% lm(y ~ x, weights = w)      ## with offset\\n\",  #>                   \"fitB %<-% lm(y ~ x - 1, weights = w)  ## without offset\\n\",  #>                   \"fitC %<-% {\\n\", \"  w <- 1 + abs(x)\\n\", \"  lm(y ~ x, weights = w)\\n\",  #>                   \"}\\n\", \"print(fitA)\\n\", \"print(fitB)\\n\", \"print(fitC)\\n\",  #>                   \"\\n\", \"\\n\", \"## EXAMPLE: Explicitly create futures (evaluated in parallel)\\n\",  #>                   \"## and retrieve their values\\n\", \"fA <- future( lm(y ~ x, weights = w) )\\n\",  #>                   \"fB <- future( lm(y ~ x - 1, weights = w) )\\n\",  #>                   \"fC <- future({\\n\", \"  w <- 1 + abs(x)\\n\",  #>                   \"  lm(y ~ x, weights = w)\\n\", \"})\\n\", \"fitA <- value(fA)\\n\",  #>                   \"fitB <- value(fB)\\n\", \"fitC <- value(fC)\\n\",  #>                   \"print(fitA)\\n\", \"print(fitB)\\n\", \"print(fitC)\\n\",  #>                   \"\\n\", list(\"\\n\", \"## Make sure to \\\"close\\\" an multisession workers on Windows\\n\",  #>                     \"plan(sequential)\\n\"), \"\\n\", \"## EXAMPLE: futureCall() and do.call()\\n\",  #>                   \"x <- 1:100\\n\", \"y0 <- do.call(sum, args = list(x))\\n\",  #>                   \"print(y0)\\n\", \"\\n\", \"f1 <- futureCall(sum, args = list(x))\\n\",  #>                   \"y1 <- value(f1)\\n\", \"print(y1)\\n\"), \"\\n\",  #>                 list(\"\\n\", \"How, when, and where futures are resolved is determined by the\\n\",  #>                   list(\"future backend\"), \", which can be set by the end user using the\\n\",  #>                   list(list(\"plan()\")), \" function.\\n\"), \"\\n\",  #>                 list(\"\\n\", \"The future logo was designed by Dan LaBar and tweaked by Henrik Bengtsson.\\n\"),  #>                 \"\\n\"), futureAssign.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/delayed_api-futureAssign.R,\",  #>                 \"\\n\", \"%   R/infix_api-01-futureAssign_OP.R, R/infix_api-02-globals_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-03-seed_OP.R, R/infix_api-04-stdout_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-05-conditions_OP.R, R/infix_api-06-lazy_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-07-label_OP.R, R/infix_api-08-plan_OP.R,\",  #>                 \"\\n\", \"%   R/infix_api-09-tweak_OP.R\", \"\\n\",  #>                 list(\"futureAssign\"), \"\\n\", list(\"futureAssign\"),  #>                 \"\\n\", list(\"%<-%\"), \"\\n\", list(\"%->%\"), \"\\n\",  #>                 list(\"%globals%\"), \"\\n\", list(\"%packages%\"),  #>                 \"\\n\", list(\"%seed%\"), \"\\n\", list(\"%stdout%\"),  #>                 \"\\n\", list(\"%conditions%\"), \"\\n\", list(\"%lazy%\"),  #>                 \"\\n\", list(\"%label%\"), \"\\n\", list(\"%plan%\"),  #>                 \"\\n\", list(\"%tweak%\"), \"\\n\", list(\"Create a future assignment\"),  #>                 \"\\n\", list(\"\\n\", \"futureAssign(\\n\", \"  x,\\n\",  #>                   \"  value,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  substitute = TRUE,\\n\", \"  lazy = FALSE,\\n\",  #>                   \"  seed = FALSE,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  packages = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  conditions = \\\"condition\\\",\\n\", \"  label = NULL,\\n\",  #>                   \"  ...,\\n\", \"  assign.env = envir\\n\", \")\\n\",  #>                   \"\\n\", \"x %<-% value\\n\", \"\\n\", \"fassignment %globals% globals\\n\",  #>                   \"fassignment %packages% packages\\n\", \"\\n\",  #>                   \"fassignment %seed% seed\\n\", \"\\n\", \"fassignment %stdout% capture\\n\",  #>                   \"\\n\", \"fassignment %conditions% capture\\n\",  #>                   \"\\n\", \"fassignment %lazy% lazy\\n\", \"\\n\", \"fassignment %label% label\\n\",  #>                   \"\\n\", \"fassignment %plan% strategy\\n\", \"\\n\",  #>                   \"fassignment %tweak% tweaks\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"the name of a future variable, which will hold the value\\n\",  #>                     \"of the future expression (as a promise).\")),  #>                   \"\\n\", \"\\n\", list(list(\"value\"), list(\"An \",  #>                     list(), \" \", list(\"expression\"), \".\")), \"\\n\",  #>                   \"\\n\", list(list(\"envir\"), list(\"The \", list( #>                     \"environment\"), \" from where global objects should be\\n\",  #>                     \"identified.\")), \"\\n\", \"\\n\", list(list(\"substitute\"),  #>                     list(\"If TRUE, argument \", list(\"expr\"),  #>                       \" is\\n\", list(list(\"substitute\"), \"()\"),  #>                       \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\"lazy\"), list(\"If FALSE (default), the future is resolved\\n\",  #>                       \"eagerly (starting immediately), otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"seed\"), list(\"(optional) If TRUE, the random seed, that is, the state of the\\n\",  #>                     \"random number generator (RNG) will be set such that statistically sound\\n\",  #>                     \"random numbers are produced (also during parallelization).\\n\",  #>                     \"If FALSE (default), it is assumed that the future expression neither\\n\",  #>                     \"needs nor uses random number generation.\\n\",  #>                     \"To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integers)\\n\",  #>                     \"or a regular RNG seed (a single integer).  If the latter, then a\\n\",  #>                     \"L'Ecuyer-CMRG seed will be automatically created based on the given seed.\\n\",  #>                     \"Furthermore, if FALSE, then the future will be monitored to make sure it\\n\",  #>                     \"does not use random numbers.  If it does and depending on the value of\\n\",  #>                     \"option \", list(\"future.rng.onMisuse\"), \", the check is\\n\",  #>                     \"ignored, an informative warning, or error will be produced.\\n\",  #>                     \"If \", list(\"seed\"), \" is NULL, then the effect is as with \",  #>                     list(\"seed = FALSE\"), \"\\n\", \"but without the RNG check being performed.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, or a named list\\n\",  #>                     \"to control how globals are handled.\\n\",  #>                     \"For details, see section 'Globals used by future expressions'\\n\",  #>                     \"in the help for \", list(list(\"future()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(\"packages\"),  #>                     list(\"(optional) a character vector specifying packages\\n\",  #>                       \"to be attached in the \", list(), \" environment evaluating the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE (default), then the standard output is captured,\\n\",  #>                     \"and re-outputted when \", list(\"value()\"),  #>                     \" is called.\\n\", \"If FALSE, any output is silenced (by sinking it to the null device as\\n\",  #>                     \"it is outputted).\\n\", \"Using \", list(\"stdout = structure(TRUE, drop = TRUE)\"),  #>                     \" causes the captured\\n\", \"standard output to be dropped from the future object as soon as it has\\n\",  #>                     \"been relayed. This can help decrease the overall memory consumed by\\n\",  #>                     \"captured output across futures.\\n\", \"Using \",  #>                     list(\"stdout = NA\"), \" fully avoids intercepting the standard output;\\n\",  #>                     \"behavior of such unhandled standard output depends on the future backend.\")),  #>                   \"\\n\", \"\\n\", list(list(\"conditions\"), list(\"A character string of condition classes to be captured\\n\",  #>                     \"and relayed.  The default is to relay all conditions, including messages\\n\",  #>                     \"and warnings.  To drop all conditions, use \",  #>                     list(\"conditions = character(0)\"), \".\\n\",  #>                     \"Errors are always relayed.\\n\", \"Attribute \",  #>                     list(\"exclude\"), \" can be used to ignore specific classes, e.g.\\n\",  #>                     list(\"conditions = structure(\\\"condition\\\", exclude = \\\"message\\\")\"),  #>                     \" will capture\\n\", \"all \", list(\"condition\"),  #>                     \" classes except those that inherit from the \",  #>                     list(\"message\"), \" class.\\n\", \"Using \", list( #>                       \"conditions = structure(..., drop = TRUE)\"),  #>                     \" causes any captured\\n\", \"conditions to be dropped from the future object as soon as they have\\n\",  #>                     \"been relayed, e.g. by \", list(\"value(f)\"),  #>                     \". This can help decrease the overall\\n\",  #>                     \"memory consumed by captured conditions across futures.\\n\",  #>                     \"Using \", list(\"conditions = NULL\"), \" (not recommended) avoids intercepting conditions,\\n\",  #>                     \"except from errors; behavior of such unhandled conditions depends on the\\n\",  #>                     \"future backend and the environment from which R runs.\")),  #>                   \"\\n\", \"\\n\", list(list(\"label\"), list(\"A character string label attached to the future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"assign.env\"), list(\"The \",  #>                     list(\"environment\"), \" to which the variable\\n\",  #>                     \"should be assigned.\")), \"\\n\", \"\\n\", list( #>                     list(\"fassignment\"), list(\"The future assignment, e.g.\\n\",  #>                       list(\"x %<-% { expr }\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"capture\"), list(\"If TRUE, the standard output will be captured, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"strategy\"), list(\"The backend controlling how the future is\\n\",  #>                     \"resolved. See \", list(list(\"plan()\")), \" for further details.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tweaks\"), list(\"A named list (or vector) with arguments that\\n\",  #>                     \"should be changed relative to the current backend.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Additional arguments passed to \",  #>                     list(list(\"Future()\")), \".\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", list(\"futureAssign()\"), \" and \", list( #>                   \"x %<-% expr\"), \" returns the \", list(\"Future\"),  #>                   \" invisibly,\\n\", \"e.g. \", list(\"f <- futureAssign(\\\"x\\\", expr)\"),  #>                   \" and \", list(\"f <- (x %<-% expr)\"), \".\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"x %<-% value\"), \" (also known as a \\\"future assignment\\\") and\\n\",  #>                   list(\"futureAssign(\\\"x\\\", value)\"), \" create a \",  #>                   list(\"Future\"), \" that evaluates the expression\\n\",  #>                   \"(\", list(\"value\"), \") and binds it to variable \",  #>                   list(\"x\"), \" (as a\\n\", list(\"promise\"), \"). The expression is evaluated in parallel\\n\",  #>                   \"in the background. Later on, when \", list( #>                     \"x\"), \" is first queried, the value of the future\\n\",  #>                   \"is automatically retrieved as if it were a regular variable and \",  #>                   list(\"x\"), \" is\\n\", \"materialized as a regular value.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"For a future created via a future assignment, \",  #>                   list(\"x %<-% value\"), \" or\\n\", list(\"futureAssign(\\\"x\\\", value)\"),  #>                   \", the value is bound to a promise, which when\\n\",  #>                   \"queried will internally call \", list(list( #>                     \"value()\")), \"  on the future and which will then\\n\",  #>                   \"be resolved into a regular variable bound to that value. For example, with\\n\",  #>                   \"future assignment \", list(\"x %<-% value\"),  #>                   \", the first time variable \", list(\"x\"), \" is queried\\n\",  #>                   \"the call blocks if, and only if, the future is not yet resolved. As soon\\n\",  #>                   \"as it is resolved, and any succeeding queries, querying \",  #>                   list(\"x\"), \" will\\n\", \"immediately give the value.\\n\",  #>                   \"\\n\", \"The future assignment construct \", list( #>                     \"x %<-% value\"), \" is not a formal assignment\\n\",  #>                   \"per se, but a binary infix operator on objects \",  #>                   list(\"x\"), \" and expression \", list(\"value\"),  #>                   \".\\n\", \"However, by using non-standard evaluation, this construct can emulate an\\n\",  #>                   \"assignment operator similar to \", list(\"x <- value\"),  #>                   \". Due to \", list(), \"'s precedence rules\\n\",  #>                   \"of operators, future expressions often need to be explicitly bracketed,\\n\",  #>                   \"e.g. \", list(\"x %<-% { a + b }\"), \".\\n\"),  #>                 \"\\n\", list(list(\"Adjust future arguments of a future assignment\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", list(list(\"future()\")),  #>                     \" and \", list(list(\"futureAssign()\")), \" take several arguments that can be used\\n\",  #>                     \"to explicitly specify what global variables and packages the future should\\n\",  #>                     \"use. They can also be used to override default behaviors of the future,\\n\",  #>                     \"e.g. whether output should be relayed or not. When using a future\\n\",  #>                     \"assignment, these arguments can be specified via corresponding\\n\",  #>                     \"assignment expression.  For example, \",  #>                     list(\"x %<-% { rnorm(10) } %seed% TRUE\"),  #>                     \"\\n\", \"corresponds to \", list(\"futureAssign(\\\"x\\\", { rnorm(10) }, seed = TRUE)\"),  #>                     \". Here are\\n\", \"several examples.\\n\", \"\\n\",  #>                     \"To explicitly specify variables and functions that a future assignment\\n\",  #>                     \"should use, use \", list(\"%globals%\"), \". To explicitly specify which packages need\\n\",  #>                     \"to be attached for the evaluation to succeed, use \",  #>                     list(\"%packages%\"), \". For\\n\", \"example,\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x <- rnorm(1000)\\n\", \"> y %<-% { median(x) } %globals% list(x = x) %packages% \\\"stats\\\"\\n\",  #>                       \"> y\\n\", \"[1] -0.03956372\\n\"), list(list( #>                       \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                     \"The \", list(\"median()\"), \" function is part of the 'stats' package.\\n\",  #>                     \"\\n\", \"To declare that you will generate random numbers, use \",  #>                     list(\"%seed%\"), \", e.g.\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { rnorm(3) } %seed% TRUE\\n\",  #>                       \"> x\\n\", \"[1] -0.2590562 -1.2262495  0.8858702\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\", \"\\n\", \"To disable relaying of standard output (e.g. \",  #>                     list(\"print()\"), \", \", list(\"cat()\"), \", and\\n\",  #>                     list(\"str()\"), \"), while keeping relaying of conditions (e.g. \",  #>                     list(\"message()\"), \" and\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %stdout% FALSE\\n\",  #>                       \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hi there\\n\",  #>                       \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To disable relaying of conditions, use \",  #>                     list(\"%conditions%\"), \", e.g.\\n\", \"\\n\", list( #>                       list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { cat(\\\"Hello\\\\n\\\"); message(\\\"Hi there\\\"); 42 } %conditions% character(0)\\n\",  #>                       \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                       \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\", \"\\n\", list( #>                       list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { print(1:10); message(\\\"Hello\\\"); 42 } %stdout% FALSE\\n\",  #>                       \"> y <- 13\\n\", \"> z <- x + y\\n\", \"Hello\\n\",  #>                       \"> z\\n\", \"[1] 55\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\", \"\\n\", \"To create a future without launching it such that it will only be\\n\",  #>                     \"processed if the value is really needed, use \",  #>                     list(\"%lazy%\"), \", e.g.\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { Sys.sleep(5); 42 } %lazy% TRUE\\n\",  #>                       \"> y <- sum(1:10)\\n\", \"> system.time(z <- x + y)\\n\",  #>                       \"  user  system elapsed \\n\", \"  0.004   0.000   5.008\\n\",  #>                       \"> z\\n\", \"[1] 97\\n\"), list(list(\"html\"),  #>                       list(list(\"<\/div>\"))), \"\\n\")), \"\\n\", \"\\n\",  #>                 list(list(\"Error handling\"), list(\"\\n\", \"\\n\",  #>                   \"\\n\", \"Because future assignments are promises, errors produced by the\\n\",  #>                   \"future expression will not be signaled until the value of the future is\\n\",  #>                   \"requested. For example, if you create a future assignment that produces\\n\",  #>                   \"an error, you will not be affected by the error until you \\\"touch\\\" the\\n\",  #>                   \"future-assignment variable. For example,\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> y <- sum(1:10)\\n\",  #>                     \"> z <- x + y\\n\", \"Error in eval(quote({ : boom\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Use alternative future backend for future assignment\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Futures are evaluated on the future backend that the user has specified\\n\",  #>                     \"by \", list(list(\"plan()\")), \". With regular futures, we can temporarily use another future\\n\",  #>                     \"backend by wrapping our code in \", list( #>                       \"with(plan(...), { ... })\"), \", or temporarily\\n\",  #>                     \"inside a function using \", list(\"with(plan(...), local = TRUE)\"),  #>                     \". To achieve the\\n\", \"same for a specific future assignment, use \",  #>                     list(\"%plan%\"), \", e.g.\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> plan(multisession)\\n\", \"> x %<-% { 42 }\\n\",  #>                       \"> y %<-% { 13 } %plan% sequential\\n\",  #>                       \"> z <- x + y\\n\", \"> z\\n\", \"[1] 55\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\", \"\\n\", \"Here \", list(\"x\"), \" is resolved in the background via the \",  #>                     list(\"multisession\"), \" backend,\\n\", \"whereas \",  #>                     list(\"y\"), \" is resolved sequentially in the main R session.\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Getting the future object of a future assignment\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"The underlying \", list( #>                     \"Future\"), \" of a future variable \", list( #>                     \"x\"), \" can be retrieved without\\n\", \"blocking using \",  #>                     list(\"f <- \", list(\"futureOf\"), \"(x)\"), \", e.g.\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                     list(\"> x %<-% { stop(\\\"boom\\\") }\\n\", \"> f_x <- futureOf(x)\\n\",  #>                       \"> resolved(f_x)\\n\", \"[1] TRUE\\n\", \"> x\\n\",  #>                       \"Error in eval(quote({ : boom\\n\", \"> value(f_x)\\n\",  #>                       \"Error in eval(quote({ : boom\\n\"), list( #>                       list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                     \"\\n\", \"Technically, both the future and the variable (promise) are assigned at\\n\",  #>                     \"the same time to environment \", list(\"assign.env\"),  #>                     \" where the name of the future is\\n\", list( #>                       \".future_<name>\"), \".\\n\")), \"\\n\", \"\\n\"),  #>             futureOf.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/delayed_api-futureOf.R\",  #>                 \"\\n\", list(\"futureOf\"), \"\\n\", list(\"futureOf\"),  #>                 \"\\n\", list(\"Get the future of a future variable\"),  #>                 \"\\n\", list(\"\\n\", \"futureOf(\\n\", \"  var = NULL,\\n\",  #>                   \"  envir = parent.frame(),\\n\", \"  mustExist = TRUE,\\n\",  #>                   \"  default = NA,\\n\", \"  drop = FALSE\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"var\"), list(\"the variable.  If NULL, all futures in the\\n\",  #>                   \"environment are returned.\")), \"\\n\", \"\\n\",  #>                   list(list(\"envir\"), list(\"the environment where to search from.\")),  #>                   \"\\n\", \"\\n\", list(list(\"mustExist\"), list(\"If TRUE and the variable does not exist, then\\n\",  #>                     \"an informative error is thrown, otherwise NA is returned.\")),  #>                   \"\\n\", \"\\n\", list(list(\"default\"), list(\"the default value if future was not found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"if TRUE and \",  #>                     list(\"var\"), \" is NULL, then returned list\\n\",  #>                     \"only contains futures, otherwise also \",  #>                     list(\"default\"), \" values.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"A \", list(\"Future\"), \" (or \", list( #>                   \"default\"), \").\\n\", \"If \", list(\"var\"), \" is NULL, then a named list of Future:s is returned.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Get the future of a future variable that has been created directly\\n\",  #>                   \"or indirectly via \", list(list(\"future()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"a %<-% { 1 }\\n\",  #>                   \"\\n\", \"f <- futureOf(a)\\n\", \"print(f)\\n\", \"\\n\",  #>                   \"b %<-% { 2 }\\n\", \"\\n\", \"f <- futureOf(b)\\n\",  #>                   \"print(f)\\n\", \"\\n\", \"## All futures\\n\", \"fs <- futureOf()\\n\",  #>                   \"print(fs)\\n\", \"\\n\", \"\\n\", \"## Futures part of environment\\n\",  #>                   \"env <- new.env()\\n\", \"env$c %<-% { 3 }\\n\",  #>                   \"\\n\", \"f <- futureOf(env$c)\\n\", \"print(f)\\n\",  #>                   \"\\n\", \"f2 <- futureOf(c, envir = env)\\n\", \"print(f2)\\n\",  #>                   \"\\n\", \"f3 <- futureOf(\\\"c\\\", envir = env)\\n\",  #>                   \"print(f3)\\n\", \"\\n\", \"fs <- futureOf(envir = env)\\n\",  #>                   \"print(fs)\\n\"), \"\\n\"), futureSessionInfo.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-futureSessionInfo.R\",  #>                 \"\\n\", list(\"futureSessionInfo\"), \"\\n\", list(\"futureSessionInfo\"),  #>                 \"\\n\", list(\"Get future-specific session information and validate current backend\"),  #>                 \"\\n\", list(\"\\n\", \"futureSessionInfo(test = TRUE, anonymize = TRUE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"test\"), list(\"If TRUE, one or more futures are created to query workers\\n\",  #>                   \"and validate their information.\")), \"\\n\",  #>                   \"\\n\", list(list(\"anonymize\"), list(\"If TRUE, user names and host names are anonymized.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Nothing.\\n\"), \"\\n\",  #>                 list(\"\\n\", \"Get future-specific session information and validate current backend\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession, workers = 2)\\n\",  #>                   \"futureSessionInfo()\\n\", \"plan(sequential)\\n\"),  #>                 \"\\n\"), futures.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-futures.R\",  #>                 \"\\n\", list(\"futures\"), \"\\n\", list(\"futures\"),  #>                 \"\\n\", list(\"Get all futures in a container\"),  #>                 \"\\n\", list(\"\\n\", \"futures(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"An environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"An object of same type as \",  #>                   list(\"x\"), \" and with the same names\\n\", \"and/or dimensions, if set.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets all futures in an environment, a list, or a list environment\\n\",  #>                   \"and returns an object of the same class (and dimensions).\\n\",  #>                   \"Non-future elements are returned as is.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is useful for retrieve futures that were created via\\n\",  #>                   \"future assignments (\", list(\"%<-%\"), \") and therefore stored as promises.\\n\",  #>                   \"This function turns such promises into standard \",  #>                   list(\"Future\"), \"\\n\", \"objects.\\n\"), \"\\n\"),  #>             getExpression.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"getExpression\"), \"\\n\", list(\"getExpression\"),  #>                 \"\\n\", list(\"getExpression.Future\"), \"\\n\", list( #>                   \"Inject code for the next type of future to use for nested futures\"),  #>                 \"\\n\", list(\"\\n\", \"getExpression(future, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"Current future.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A future expression with code injected to set what\\n\",  #>                   \"type of future to use for nested futures, iff any.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Inject code for the next type of future to use for nested futures\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If there is no future backend specified after this one, the default\\n\",  #>                   \"is to use \", list(\"sequential\"), \" futures.  This conservative approach protects\\n\",  #>                   \"against spawning off recursive futures by mistake, especially\\n\",  #>                   list(\"multicore\"), \" and \", list(\"multisession\"),  #>                   \" ones.\\n\", \"The default will also set \", list( #>                     \"options(mc.cores = 1L)\"), \" (*) so that\\n\",  #>                   \"no parallel \", list(), \" processes are spawned off by functions such as\\n\",  #>                   list(\"parallel::mclapply()\"), \" and friends.\\n\",  #>                   \"\\n\", \"Currently it is not possible to specify what type of nested\\n\",  #>                   \"futures to be used, meaning the above default will always be\\n\",  #>                   \"used.\\n\", \"See \", list(list(\"https://github.com/futureverse/future/issues/37\"),  #>                     list(\"Issue #37\")), \"\\n\", \"for plans on adding support for custom nested future types.\\n\",  #>                   \"\\n\", \"(*) Ideally we would set \", list(\"mc.cores = 0\"),  #>                   \" but that will unfortunately\\n\", \"cause \",  #>                   list(\"mclapply()\"), \" and friends to generate an error saying\\n\",  #>                   \"\\\"'mc.cores' must be >= 1\\\".  Ideally those functions should\\n\",  #>                   \"fall back to using the non-multicore alternative in this\\n\",  #>                   \"case, e.g. \", list(\"mclapply(...)\"), \" => \",  #>                   list(\"lapply(...)\"), \".\\n\", \"See \", list(\"https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7\"),  #>                   \"\\n\", \"for a discussion on this.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), getGlobalsAndPackages.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-globals.R\",  #>                 \"\\n\", list(\"getGlobalsAndPackages\"), \"\\n\", list( #>                   \"getGlobalsAndPackages\"), \"\\n\", list(\"Retrieves global variables of an expression and their associated packages\"),  #>                 \"\\n\", list(\"\\n\", \"getGlobalsAndPackages(\\n\",  #>                   \"  expr,\\n\", \"  envir = parent.frame(),\\n\",  #>                   \"  tweak = tweakExpression,\\n\", \"  globals = TRUE,\\n\",  #>                   \"  locals = getOption(\\\"future.globals.globalsOf.locals\\\", TRUE),\\n\",  #>                   \"  resolve = getOption(\\\"future.globals.resolve\\\"),\\n\",  #>                   \"  persistent = FALSE,\\n\", \"  maxSize = getOption(\\\"future.globals.maxSize\\\", 500 * 1024^2),\\n\",  #>                   \"  onReference = getOption(\\\"future.globals.onReference\\\", \\\"ignore\\\"),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"expr\"), list(\"An \", list(), \" expression whose globals should be found.\")),  #>                   \"\\n\", \"\\n\", list(list(\"envir\"), list(\"The environment from which globals should be searched.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tweak\"), list(\"(optional) A function that takes an expression and returned a modified one.\")),  #>                   \"\\n\", \"\\n\", list(list(\"globals\"), list(\"(optional) a logical, a character vector, a named list, or a \",  #>                     list(\"Globals\"), \" object.  If TRUE, globals are identified by code inspection based on \",  #>                     list(\"expr\"), \" and \", list(\"tweak\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If FALSE, no globals are used.  If a character vector, then globals are identified by lookup based their names \",  #>                     list(\"globals\"), \" searching from environment \",  #>                     list(\"envir\"), \".  If a named list or a Globals object, the globals are used as is.\")),  #>                   \"\\n\", \"\\n\", list(list(\"locals\"), list(\"Should globals part of any \\\"local\\\" environment of\\n\",  #>                     \"a function be included or not?\")), \"\\n\",  #>                   \"\\n\", list(list(\"resolve\"), list(\"If TRUE, any future that is a global variables (or part of one) is resolved and replaced by a \\\"constant\\\" future.\")),  #>                   \"\\n\", \"\\n\", list(list(\"persistent\"), list(\"If TRUE, non-existing globals (= identified in expression but not found in memory) are always silently ignored and assumed to be existing in the evaluation environment.  If FALSE, non-existing globals are by default ignored, but may also trigger an informative error if option \",  #>                     list(\"future.globals.onMissing\"), \" in \",  #>                     list(\"\\\"error\\\"\"), \" (should only be used for troubleshooting).\")),  #>                   \"\\n\", \"\\n\", list(list(\"maxSize\"), list(\"The maximum allowed total size (in bytes) of globals---for\\n\",  #>                     \"the purpose of preventing too large exports / transfers happening by\\n\",  #>                     \"mistake.  If the total size of the global objects are greater than this\\n\",  #>                     \"limit, an informative error message is produced. If\\n\",  #>                     list(\"maxSize = +Inf\"), \", then this assertion is skipped. (Default: 500 MiB).\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A named list with elements \",  #>                   list(\"expr\"), \" (the tweaked expression), \",  #>                   list(\"globals\"), \" (a named list of class \",  #>                   list(\"FutureGlobals\"), \") and \", list(\"packages\"),  #>                   \" (a character string).\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Retrieves global variables of an expression and their associated packages\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Internally, \", list(list(\"globalsOf\"),  #>                   \"()\"), \" is used to identify globals and associated packages from the expression.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), makeClusterFuture.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-makeClusterFuture.R\",  #>                 \"\\n\", list(\"makeClusterFuture\"), \"\\n\", list(\"makeClusterFuture\"),  #>                 \"\\n\", list(\"FUTURE\"), \"\\n\", list(\"Create a Future Cluster of Stateless Workers for Parallel Processing\"),  #>                 \"\\n\", list(\"\\n\", \"makeClusterFuture(specs = nbrOfWorkers(), ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"specs\"), list(\"Ignored.\\n\",  #>                   \"If specified, the value should equal \", list( #>                     \"nbrOfWorkers()\"), \" (default).\\n\", \"A missing value corresponds to specifying \",  #>                   list(\"nbrOfWorkers()\"), \".\\n\", \"This argument exists only to support\\n\",  #>                   list(\"parallel::makeCluster(NA, type = future::FUTURE)\"),  #>                   \".\")), \"\\n\", \"\\n\", list(list(list()), list( #>                   \"Named arguments passed to \", list(list(\"future()\")),  #>                   \".\")), \"\\n\"), \"\\n\", list(\"\\n\", \"Returns a \",  #>                   list(\"parallel\"), \" \", list(\"cluster\"), \" object of class \",  #>                   list(\"FutureCluster\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                   list(\"WARNING: Please note that this sets up a stateless set of cluster nodes,\\n\",  #>                     \"which means that \", list(\"clusterEvalQ(cl, { a <- 3.14 })\"),  #>                     \" will not work.\\n\", \"Consider this a first beta version and use it with great care,\\n\",  #>                     \"particularly because of the stateless nature of the cluster.\\n\",  #>                     \"For now, I recommend to manually validate that you can get identical\\n\",  #>                     \"results using this cluster type with what you get from using the\\n\",  #>                     \"classical \", list(\"parallel::makeCluster()\"),  #>                     \" cluster type.\"), \"\\n\"), \"\\n\", list(list( #>                   \"Future Clusters are Stateless\"), list(\"\\n\",  #>                   \"\\n\", \"Traditionally, a cluster nodes has a one-to-one mapping to a cluster\\n\",  #>                   \"worker process. For example, \", list(\"cl <- makeCluster(2, type = \\\"PSOCK\\\")\"),  #>                   \"\\n\", \"launches two parallel worker processes in the background, where\\n\",  #>                   \"cluster node \", list(\"cl[[1]]\"), \" maps to worker #1 and node \",  #>                   list(\"cl[[2]]\"), \" to\\n\", \"worker #2, and that never changes through the lifespan of these\\n\",  #>                   \"workers. This one-to-one mapping allows for deterministic\\n\",  #>                   \"configuration of workers. For examples, some code may assign globals\\n\",  #>                   \"with values specific to each worker, e.g.\\n\",  #>                   list(\"clusterEvalQ(cl[1], { a <- 3.14 })\"),  #>                   \" and\\n\", list(\"clusterEvalQ(cl[2], { a <- 2.71 })\"),  #>                   \".\\n\", \"\\n\", \"In contrast, there is no one-to-one mapping between cluster nodes\\n\",  #>                   \"and the parallel workers when using a future cluster. This is because\\n\",  #>                   \"we cannot make assumptions on where are parallel task will be\\n\",  #>                   \"processed. Where a parallel task is processes is up to the future\\n\",  #>                   \"backend to decide - some backends do this deterministically, whereas\\n\",  #>                   \"others other resolves task at the first available worker. Also, the\\n\",  #>                   \"worker processes might be \", list(\"transient\"),  #>                   \" for some future backends, i.e.\\n\", \"the only exist for the life-span of the parallel task and then\\n\",  #>                   \"terminates.\\n\", \"\\n\", \"Because of this, one must not rely in node-specific behaviors,\\n\",  #>                   \"because that concept does not make sense with a future cluster.\\n\",  #>                   \"To protect against this, any attempt to address a subset of future\\n\",  #>                   \"cluster nodes, results in an error, e.g. \",  #>                   list(\"clusterEvalQ(cl[1], ...)\"), \",\\n\", list( #>                     \"clusterEvalQ(cl[1:2], ...)\"), \", and \",  #>                   list(\"clusterEvalQ(cl[2:1], ...)\"), \" in\\n\",  #>                   \"the above example will all give an error.\\n\",  #>                   \"\\n\", \"Exceptions to the latter limitation are \",  #>                   list(\"clusterSetRNGStream()\"), \"\\n\", \"and \",  #>                   list(\"clusterExport()\"), \", which can be safely used with future clusters.\\n\",  #>                   \"See below for more details.\\n\")), \"\\n\", \"\\n\",  #>                 list(list(\"clusterSetRNGStream\"), list(\"\\n\",  #>                   \"\\n\", list(list(\"parallel::clusterSetRNGStream()\")),  #>                   \"\\n\", \"distributes \\\"L'Ecuyer-CMRG\\\" RNG\\n\",  #>                   \"streams to the cluster nodes, which record them such that the next\\n\",  #>                   \"round of futures will use them. When used, the RNG state after the\\n\",  #>                   \"futures are resolved are recorded accordingly, such that the next\\n\",  #>                   \"round again of future will use those, and so on. This strategy\\n\",  #>                   \"makes sure \", list(\"clusterSetRNGStream()\"),  #>                   \" has the expected effect although\\n\", \"futures are stateless.\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"clusterExport\"), list( #>                   \"\\n\", \"\\n\", list(list(\"parallel::clusterExport()\")),  #>                   \" assign values to the cluster nodes.\\n\", \"Specifically, these values are recorded and are used as globals\\n\",  #>                   \"for all futures created there on.\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"clusterEvalQ\"), list(\"\\n\", \"\\n\",  #>                   \"If \", list(\"clusterEvalQ()\"), \" is called, the call is ignored, and an error\\n\",  #>                   \"is produced. The error can be de-escalated to a warning by setting\\n\",  #>                   \"R option \", list(\"future.ClusterFuture.clusterEvalQ\"),  #>                   \" to \", list(\"\\\"warning\\\"\"), \".\\n\")), \"\\n\",  #>                 \"\\n\", list(\"\\n\", list(\"if ((getRversion() >= \\\"4.4.0\\\")) withAutoprint({ # examplesIf\"),  #>                   \"\\n\", \"plan(multisession)\\n\", \"cl <- makeClusterFuture()\\n\",  #>                   \"\\n\", \"parallel::clusterSetRNGStream(cl)\\n\",  #>                   \"\\n\", \"y <- parallel::parLapply(cl, 11:13, function(x) {\\n\",  #>                   \"  message(\\\"Process ID: \\\", Sys.getpid())\\n\",  #>                   \"  mean(rnorm(n = x))\\n\", \"})\\n\", \"str(y)\\n\",  #>                   \"\\n\", \"plan(sequential)\\n\", list(\"}) # examplesIf\"),  #>                   \"\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), mandelbrot.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/demo_api-mandelbrot.R\",  #>                 \"\\n\", list(\"mandelbrot\"), \"\\n\", list(\"mandelbrot\"),  #>                 \"\\n\", list(\"as.raster.Mandelbrot\"), \"\\n\", list( #>                   \"plot.Mandelbrot\"), \"\\n\", list(\"mandelbrot_tiles\"),  #>                 \"\\n\", list(\"mandelbrot.matrix\"), \"\\n\", list(\"mandelbrot.numeric\"),  #>                 \"\\n\", list(\"Mandelbrot convergence counts\"),  #>                 \"\\n\", list(\"\\n\", \"mandelbrot(...)\\n\", \"\\n\", list( #>                   list(\"mandelbrot\"), list(\"matrix\")), \"(Z, maxIter = 200L, tau = 2, ...)\\n\",  #>                   \"\\n\", list(list(\"mandelbrot\"), list(\"numeric\")),  #>                   \"(\\n\", \"  xmid = -0.75,\\n\", \"  ymid = 0,\\n\",  #>                   \"  side = 3,\\n\", \"  resolution = 400L,\\n\",  #>                   \"  maxIter = 200L,\\n\", \"  tau = 2,\\n\", \"  ...\\n\",  #>                   \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"Z\"), list( #>                   \"A complex matrix for which convergence\\n\",  #>                   \"counts should be calculated.\")), \"\\n\", \"\\n\",  #>                   list(list(\"maxIter\"), list(\"Maximum number of iterations per bin.\")),  #>                   \"\\n\", \"\\n\", list(list(\"tau\"), list(\"A threshold; the radius when calling\\n\",  #>                     \"divergence (Mod(z) > tau).\")), \"\\n\", \"\\n\",  #>                   list(list(\"xmid, ymid, side, resolution\"),  #>                     list(\"Alternative specification of\\n\", \"the complex plane \",  #>                       list(\"Z\"), \", where\\n\", list(\"mean(Re(Z)) == xmid\"),  #>                       \",\\n\", list(\"mean(Im(Z)) == ymid\"), \",\\n\",  #>                       list(\"diff(range(Re(Z))) == side\"), \",\\n\",  #>                       list(\"diff(range(Im(Z))) == side\"), \", and\\n\",  #>                       list(\"dim(Z) == c(resolution, resolution)\"),  #>                       \".\")), \"\\n\"), \"\\n\", list(\"\\n\", \"Returns an integer matrix (of class Mandelbrot) with\\n\",  #>                   \"non-negative counts.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Mandelbrot convergence counts\\n\"), \"\\n\", list( #>                   \"\\n\", \"counts <- mandelbrot(xmid = -0.75, ymid = 0, side = 3)\\n\",  #>                   \"str(counts)\\n\", list(\"\\n\", \"plot(counts)\\n\"),  #>                   \"\\n\", \"\\n\", list(\"\\n\", \"demo(\\\"mandelbrot\\\", package = \\\"future\\\", ask = FALSE)\\n\"),  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"The internal Mandelbrot algorithm was inspired by and\\n\",  #>                   \"adopted from similar GPL code of Martin Maechler available\\n\",  #>                   \"from ftp://stat.ethz.ch/U/maechler/R/ on 2005-02-18 (sic!).\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), multicore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"multicore\"), \"\\n\", list(\"multicore\"),  #>                 \"\\n\", list(\"MulticoreFuture\"), \"\\n\", list(\"Create a multicore future whose value will be resolved asynchronously in a forked parallel process\"),  #>                 \"\\n\", list(\"\\n\", \"multicore(..., workers = availableCores(constraints = \\\"multicore\\\"))\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\\n\",  #>                   \"If \", list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"sequential future. To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"WARNING: This function must never be called.\\n\",  #>                   \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A multicore future is a future that uses multicore evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another process\"), \".\\n\", \"\\n\",  #>                   \"This function is must \", list(\"not\"), \" be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many forked\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multicore)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two forked processes\\n\",  #>                     \"plan(multicore, workers = 2)\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\"), \"\\n\",  #>                 list(list(\"Support for forked (\\\"multicore\\\") processing\"),  #>                   list(\"\\n\", \"\\n\", \"Not all operating systems support process forking and thereby not multicore\\n\",  #>                     \"futures.  For instance, forking is not supported on Microsoft Windows.\\n\",  #>                     \"Moreover, process forking may break some R environments such as RStudio.\\n\",  #>                     \"Because of this, the future package disables process forking also in\\n\",  #>                     \"such cases.  See \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \" for details.\\n\", \"Trying to create multicore futures on non-supported systems or when\\n\",  #>                     \"forking is disabled will result in multicore futures falling back to\\n\",  #>                     \"becoming \", list(\"sequential\"), \" futures.  If used in RStudio, there will be an\\n\",  #>                     \"informative warning:\\n\", \"\\n\", list(list( #>                       \"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"> plan(multicore)\\n\", \"Warning message:\\n\",  #>                       \"In supportsMulticoreAndRStudio(...) :\\n\",  #>                       \"  [ONE-TIME WARNING] Forked processing ('multicore') is not supported when\\n\",  #>                       \"running R from RStudio because it is considered unstable. For more details,\\n\",  #>                       \"how to control forked processing or not, and how to silence this warning in\\n\",  #>                       \"future R sessions, see ?parallelly::supportsMulticore\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(\"\\n\", \"## Use multicore futures\\n\",  #>                   \"plan(multicore)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multicore future is evaluated in a separate forked\\n\",  #>                   \"## process.  Changing the value of a global variable\\n\",  #>                   \"## will not affect the result of the future.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\",  #>                 list(\"\\n\", \"For processing in multiple background \",  #>                   list(), \" sessions, see\\n\", list(\"multisession\"),  #>                   \" futures.\\n\", \"\\n\", \"For alternative future backends, see the 'A Future for R: Available Future\\n\",  #>                   \"Backends' vignette and \", list(\"https://www.futureverse.org/backends.html\"),  #>                   \".\\n\", \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\", \"Use \", list(list(\"availableCores\"),  #>                     \"(\\\"multicore\\\") > 1L\"), \" to check\\n\", \"whether multicore futures are supported or not on the current\\n\",  #>                   \"system.\\n\"), \"\\n\"), multisession.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in\", \"\\n\",  #>                 \"%   R/backend_api-13.MultisessionFutureBackend-class.R\",  #>                 \"\\n\", list(\"multisession\"), \"\\n\", list(\"multisession\"),  #>                 \"\\n\", list(\"MultisessionFuture\"), \"\\n\", list( #>                   \"Create a multisession future whose value will be resolved asynchronously in a parallel \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"multisession(\\n\",  #>                   \"  ...,\\n\", \"  workers = availableCores(constraints = \\\"connections-16\\\"),\\n\",  #>                   \"  rscript_libs = .libPaths()\\n\", \")\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"workers\"), list(\"The number of parallel processes to use.\\n\",  #>                   \"If a function, it is called without arguments \",  #>                   list(\"when the future\\n\", \"is created\"), \" and its value is used to configure the workers.\\n\",  #>                   \"If \", list(\"workers == 1\"), \", then all processing using done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"sequential future. To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"rscript_libs\"), list(\"A character vector of \",  #>                     list(), \" package library folders that\\n\",  #>                     \"the workers should use.  The default is \",  #>                     list(\".libPaths()\"), \" so that multisession\\n\",  #>                     \"workers inherits the same library path as the main \",  #>                     list(), \" session.\\n\", \"To avoid this, use \",  #>                     list(\"plan(multisession, ..., rscript_libs = NULL)\"),  #>                     \".\\n\", list(\"Important: Note that the library path is set on the workers when they are\\n\",  #>                       \"created, i.e. when \", list(\"plan(multisession)\"),  #>                       \" is called.  Any changes to\\n\", list(\".libPaths()\"),  #>                       \" in the main R session after the workers have been created\\n\",  #>                       \"will have no effect.\"), \"\\n\", \"This is passed down as-is to \",  #>                     list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \".\")), \"\\n\", \"\\n\", list(list(list()), list( #>                     \"Additional arguments passed to \", list(list( #>                       \"Future()\")), \".\")), \"\\n\"), \"\\n\", list( #>                   \"\\n\", \"A MultisessionFuture.\\n\", \"If \", list( #>                     \"workers == 1\"), \", then all processing is done in the\\n\",  #>                   \"current/main \", list(), \" session and we therefore fall back to using a\\n\",  #>                   \"lazy future.  To override this fallback, use \",  #>                   list(\"workers = I(1)\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", list(\"WARNING: This function must never be called.\\n\",  #>                     \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A multisession future is a future that uses multisession evaluation,\\n\",  #>                   \"which means that its \", list(\"value is computed and resolved in\\n\",  #>                     \"parallel in another \", list(), \" session\"),  #>                   \".\\n\", \"\\n\", \"This function is must \", list( #>                     \"not\"), \" be called directly.  Instead, the\\n\",  #>                   \"typical usages are:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures in parallel on the local machine via as many background\\n\",  #>                     \"# processes as available to the current R process\\n\",  #>                     \"plan(multisession)\\n\", \"\\n\", \"# Evaluate futures in parallel on the local machine via two background\\n\",  #>                     \"# processes\\n\", \"plan(multisession, workers = 2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"The background \", list(), \" sessions (the \\\"workers\\\") are created using\\n\",  #>                   list(list(\"makeClusterPSOCK()\")), \".\\n\", \"\\n\",  #>                   \"For the total number of\\n\", list(), \" sessions available including the current/main \",  #>                   list(), \" process, see\\n\", list(list(\"parallelly::availableCores()\")),  #>                   \".\\n\", \"\\n\", \"A multisession future is a special type of cluster future.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"\\n\", \"\\n\", \"## Use multisession futures\\n\",  #>                   \"plan(multisession)\\n\", \"\\n\", \"## A global variable\\n\",  #>                   \"a <- 0\\n\", \"\\n\", \"## Create future (explicitly)\\n\",  #>                   \"f <- future({\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                   \"  a * b * c\\n\", \"})\\n\", \"\\n\", \"## A multisession future is evaluated in a separate R session.\\n\",  #>                   \"## Changing the value of a global variable will not affect\\n\",  #>                   \"## the result of the future.\\n\", \"a <- 7\\n\",  #>                   \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\", \"print(v)\\n\",  #>                   \"stopifnot(v == 0)\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\"), \"\\n\"), \"\\n\", list(\"\\n\",  #>                   \"For processing in multiple forked \", list(),  #>                   \" sessions, see\\n\", list(\"multicore\"), \" futures.\\n\",  #>                   \"\\n\", \"Use \", list(list(\"parallelly::availableCores()\")),  #>                   \" to see the total number of\\n\", \"cores that are available for the current \",  #>                   list(), \" session.\\n\"), \"\\n\"), nbrOfWorkers.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-nbrOfWorkers.R\",  #>                 \"\\n\", list(\"nbrOfWorkers\"), \"\\n\", list(\"nbrOfWorkers\"),  #>                 \"\\n\", list(\"nbrOfFreeWorkers\"), \"\\n\", list(\"Get the number of workers available\"),  #>                 \"\\n\", list(\"\\n\", \"nbrOfWorkers(evaluator = NULL)\\n\",  #>                   \"\\n\", \"nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"evaluator\"), list( #>                   \"A future evaluator function.\\n\", \"If NULL (default), the current evaluator as returned\\n\",  #>                   \"by \", list(list(\"plan()\")), \" is used.\")),  #>                   \"\\n\", \"\\n\", list(list(\"background\"), list(\"If TRUE, only workers that can process a future in the\\n\",  #>                     \"background are considered.  If FALSE, also workers running in the main \",  #>                     list(), \"\\n\", \"process are considered, e.g. when using the 'sequential' backend.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used; reserved for future use.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"nbrOfWorkers()\"),  #>                   \" returns a positive number in \", list(list( #>                     \"{1, 2, 3, ...}\")), \", which\\n\", \"for some future backends may also be \",  #>                   list(\"+Inf\"), \".\\n\", \"\\n\", list(\"nbrOfFreeWorkers()\"),  #>                   \" returns a non-negative number in\\n\", list( #>                     list(\"{0, 1, 2, 3, ...}\")), \" which is less than or equal to \",  #>                   list(\"nbrOfWorkers()\"), \".\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get the number of workers available\\n\"),  #>                 \"\\n\", list(\"\\n\", \"plan(multisession)\\n\", \"nbrOfWorkers()  ## == availableCores()\\n\",  #>                   \"\\n\", \"plan(sequential)\\n\", \"nbrOfWorkers()  ## == 1\\n\"),  #>                 \"\\n\"), nullcon.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\"nullcon\"), \"\\n\", list(\"nullcon\"),  #>                 \"\\n\", list(\"Creates a connection to the system null device\"),  #>                 \"\\n\", list(\"\\n\", \"nullcon()\\n\"), \"\\n\", list(\"\\n\",  #>                   \"Returns a open, binary \", list(list(\"base::connection()\")),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Creates a connection to the system null device\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), plan.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R, R/utils_api-plan-with.R,\",  #>                 \"\\n\", \"%   R/utils_api-tweak.R\", \"\\n\", list(\"plan\"),  #>                 \"\\n\", list(\"plan\"), \"\\n\", list(\"with.FutureStrategyList\"),  #>                 \"\\n\", list(\"tweak\"), \"\\n\", list(\"Plan how to resolve a future\"),  #>                 \"\\n\", list(\"\\n\", \"plan(\\n\", \"  strategy = NULL,\\n\",  #>                   \"  ...,\\n\", \"  substitute = TRUE,\\n\", \"  .skip = FALSE,\\n\",  #>                   \"  .call = TRUE,\\n\", \"  .cleanup = NA,\\n\",  #>                   \"  .init = TRUE\\n\", \")\\n\", \"\\n\", list(list( #>                     \"with\"), list(\"FutureStrategyList\")), \"(data, expr, ..., local = FALSE, envir = parent.frame(), .cleanup = NA)\\n\",  #>                   \"\\n\", \"tweak(strategy, ..., penvir = parent.frame())\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"strategy\"), list( #>                   \"A future backend or the name of one.\")), \"\\n\",  #>                   \"\\n\", list(list(\"substitute\"), list(\"If \",  #>                     list(\"TRUE\"), \", the \", list(\"strategy\"),  #>                     \" expression is\\n\", list(\"substitute()\"),  #>                     \":d, otherwise not.\")), \"\\n\", \"\\n\", list( #>                     list(\".skip\"), list(\"(internal) If \", list( #>                       \"TRUE\"), \", then attempts to set a future backend\\n\",  #>                       \"that is the same as what is currently in use, will be skipped.\")),  #>                   \"\\n\", \"\\n\", list(list(\".call\"), list(\"(internal) Used for recording the call to this function.\")),  #>                   \"\\n\", \"\\n\", list(list(\".cleanup\"), list(\"(internal) Used to stop implicitly started clusters.\")),  #>                   \"\\n\", \"\\n\", list(list(\".init\"), list(\"(internal) Used to initiate workers.\")),  #>                   \"\\n\", \"\\n\", list(list(\"data\"), list(\"The future plan to use temporarily, e.g. \",  #>                     list(\"plan(multisession)\"), \".\")), \"\\n\",  #>                   \"\\n\", list(list(\"expr\"), list(\"The R expression to be evaluated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"local\"), list(\"If TRUE, then the future plan specified by \",  #>                     list(\"data\"), \"\\n\", \"is applied temporarily in the calling frame. Argument \",  #>                     list(\"expr\"), \" must\\n\", \"not be specified if \",  #>                     list(\"local = TRUE\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"envir\"), list(\"The environment where the future plan should be set and the\\n\",  #>                     \"expression evaluated.\")), \"\\n\", \"\\n\", list( #>                     list(\"penvir\"), list(\"The environment used when searching for a future\\n\",  #>                       \"function by its name.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Additional arguments overriding the default arguments\\n\",  #>                     \"of the evaluation function.  Which additional arguments are supported\\n\",  #>                     \"depends on which future backend is used, e.g. several support\\n\",  #>                     \"argument \", list(\"workers\"), \" but not all. For details, see the individual\\n\",  #>                     \"backends of which some are linked to below.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"plan()\"), \" returns the previous plan invisibly if a new future backend\\n\",  #>                   \"is chosen, otherwise it returns the current one visibly.\\n\",  #>                   \"\\n\", \"The value of the expression evaluated (invisibly).\\n\",  #>                   \"\\n\", \"a future function.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"This function allows \", list(\"the user\"),  #>                   \" to plan the future, more specifically,\\n\",  #>                   \"it specifies how \", list(list(\"future()\")),  #>                   \"s are resolved,\\n\", \"e.g. sequentially or in parallel.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The default backend is \", list( #>                   list(\"sequential\")), \", but another one can be set\\n\",  #>                   \"using \", list(\"plan()\"), \", e.g. \", list(\"plan(multisession)\"),  #>                   \" will launch parallel workers\\n\", \"running in the background, which then will be used to resolve futures.\\n\",  #>                   \"To shut down background workers launched this way, call \",  #>                   list(\"plan(sequential)\"), \".\\n\"), \"\\n\", list( #>                   list(\"Built-in evaluation strategies\"), list( #>                     \"\\n\", \"\\n\", \"The \", list(\"future\"), \" package provides the following built-in backends:\\n\",  #>                     \"\\n\", list(\"\\n\", list(list(list(list(\"sequential\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures sequentially in the current \",  #>                       list(), \" process, e.g.\\n\", list(\"plan(sequential)\"),  #>                       \".\\n\")), \"\\n\", list(list(list(list(\"multisession\")),  #>                       \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                       list(), \" sessions running in the background on the same machine, e.g.\\n\",  #>                       list(\"plan(multisession)\"), \" and \", list( #>                         \"plan(multisession, workers = 2)\"), \".\\n\")),  #>                       \"\\n\", list(list(list(list(\"multicore\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(\"forked\"), \" \", list(), \" processes running in the background on\\n\",  #>                         \"the same machine, e.g.\\n\", list(\"plan(multicore)\"),  #>                         \" and \", list(\"plan(multicore, workers = 2)\"),  #>                         \".\\n\", \"This backend is not supported on Windows.\\n\")),  #>                       \"\\n\", list(list(list(list(\"cluster\")),  #>                         \":\"), list(\"\\n\", \"Resolves futures asynchronously (in parallel) in separate\\n\",  #>                         list(), \" sessions running typically on one or more machines, e.g.\\n\",  #>                         list(\"plan(cluster)\"), \", \", list(\"plan(cluster, workers = 2)\"),  #>                         \", and\\n\", list(\"plan(cluster, workers = c(\\\"n1\\\", \\\"n1\\\", \\\"n2\\\", \\\"server.remote.org\\\"))\"),  #>                         \".\\n\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Other evaluation strategies available\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"In addition to the built-in ones, additional parallel backends are\\n\",  #>                     \"implemented in future-backend packages \",  #>                     list(\"future.callr\"), \" and\\n\", list(\"future.mirai\"),  #>                     \" that leverage R package \", list(\"callr\"),  #>                     \" and\\n\", list(\"mirai\"), \":\\n\", \"\\n\", list( #>                       \"\\n\", list(list(list(\"callr\"), \":\"), list( #>                         \"\\n\", \"Similar to \", list(\"multisession\"),  #>                         \", this resolves futures in parallel in\\n\",  #>                         \"background \", list(), \" sessions on the local machine via the \",  #>                         list(\"callr\"), \"\\n\", \"package, e.g. \",  #>                         list(\"plan(future.callr::callr)\"), \" and\\n\",  #>                         list(\"plan(future.callr::callr, workers = 2)\"),  #>                         \". The difference is that\\n\", \"each future is processed in a fresh parallel R worker, which is\\n\",  #>                         \"automatically shut down as soon as the future is resolved.\\n\",  #>                         \"This can help decrease the overall memory usage. Moreover, contrary\\n\",  #>                         \"to \", list(\"multisession\"), \", \", list( #>                           \"callr\"), \" does not rely on socket connections,\\n\",  #>                         \"which means it is not limited by the number of connections that\\n\",  #>                         list(), \" can have open at any time.\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"mirai_multisession\"),  #>                         \":\"), list(\"\\n\", \"Similar to \", list( #>                         \"multisession\"), \", this resolves futures in parallel in\\n\",  #>                         \"background \", list(), \" sessions on the local machine via the \",  #>                         list(\"mirai\"), \"\\n\", \"package, e.g. \",  #>                         list(\"plan(future.mirai::mirai_multisession)\"),  #>                         \" and\\n\", list(\"plan(future.mirai::mirai_multisession, workers = 2)\"),  #>                         \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"mirai_cluster\"),  #>                         \":\"), list(\"\\n\", \"Similar to \", list( #>                         \"cluster\"), \", this resolves futures in parallel via\\n\",  #>                         \"pre-configured \", list(), \" \", list( #>                           \"mirai\"), \" daemon processes, e.g.\\n\",  #>                         list(\"plan(future.mirai::mirai_cluster)\"),  #>                         \".\\n\")), \"\\n\"), \"\\n\", \"\\n\", \"Another example is the \",  #>                     list(\"future.batchtools\"), \" package, which leverages\\n\",  #>                     list(\"batchtools\"), \" package, to resolve futures via high-performance compute\\n\",  #>                     \"(HPC) job schedulers, e.g. LSF, Slurm, TORQUE/PBS, Grid Engine, and\\n\",  #>                     \"OpenLava;\\n\", \"\\n\", list(\"\\n\", list(list( #>                       list(\"batchtools_slurm\"), \":\"), list(\"\\n\",  #>                       \"The backend resolves futures via the Slurm scheduler, e.g.\\n\",  #>                       list(\"plan(future.batchtools::batchtools_slurm)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_torque\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the TORQUE/PBS scheduler, e.g.\\n\",  #>                       list(\"plan(future.batchtools::batchtools_torque)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_sge\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the Grid Engine (SGE, AGE) scheduler,\\n\",  #>                       \"e.g. \", list(\"plan(future.batchtools::batchtools_sge)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_lsf\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the Load Sharing Facility (LSF)\\n\",  #>                       \"scheduler, e.g. \", list(\"plan(future.batchtools::batchtools_lsf)\"),  #>                       \".\\n\")), \"\\n\", \"\\n\", list(list(list(\"batchtools_openlava\"),  #>                       \":\"), list(\"\\n\", \"The backend resolves futures via the OpenLava scheduler, e.g.\\n\",  #>                       list(\"plan(future.batchtools::batchtools_openlava)\"),  #>                       \".\\n\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"For package developers\"), list(\"\\n\",  #>                     \"\\n\", \"\\n\", \"Please refrain from modifying the future backend inside your packages /\\n\",  #>                     \"functions, i.e. do not call \", list(\"plan()\"),  #>                     \" in your code. Instead, leave\\n\", \"the control on what backend to use to the end user. This idea is part of\\n\",  #>                     \"the core philosophy of the future framework---as a developer you can never\\n\",  #>                     \"know what future backends the user have access to. Moreover, by not making\\n\",  #>                     \"any assumptions about what backends are available, your code will also work\\n\",  #>                     \"automatically with any new backends developed after you wrote your code.\\n\",  #>                     \"\\n\", \"If you think it is necessary to modify the future backend within a\\n\",  #>                     \"function, then make sure to undo the changes when exiting the function.\\n\",  #>                     \"This can be achieved by using \", list(\"with(plan(...), local = TRUE)\"),  #>                     \", e.g.\\n\", \"\\n\", list(\"\\n\", \"  my_fcn <- function(x) {\\n\",  #>                       \"    with(plan(multisession), local = TRUE)\\n\",  #>                       \"    y <- analyze(x)\\n\", \"    summarize(y)\\n\",  #>                       \"  }\\n\"), \"\\n\", \"\\n\", \"This is important because the end-user might have already set the future\\n\",  #>                     \"strategy elsewhere for other purposes and will most likely not know that\\n\",  #>                     \"calling your function will break their setup.\\n\",  #>                     list(\"Remember, your package and its functions might be used in a greater\\n\",  #>                       \"context where multiple packages and functions are involved and those might\\n\",  #>                       \"also rely on the future framework, so it is important to avoid stepping on\\n\",  #>                       \"others' toes.\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Using plan() in scripts and vignettes\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"When writing scripts or vignettes that use futures, try to place any\\n\",  #>                     \"call to \", list(\"plan()\"), \" as far up (i.e. as early on) in the code as possible.\\n\",  #>                     \"This will help users to quickly identify where the future plan is set up\\n\",  #>                     \"and allow them to modify it to their computational resources.\\n\",  #>                     \"Even better is to leave it to the user to set the \",  #>                     list(\"plan()\"), \" prior to\\n\", list(\"source()\"),  #>                     \":ing the script or running the vignette.\\n\",  #>                     \"If a \", list(list(\".future.R\")), \" exists in the current directory and / or in\\n\",  #>                     \"the user's home directory, it is sourced when the \",  #>                     list(\"future\"), \" package is\\n\", list(\"loaded\"),  #>                     \". Because of this, the \", list(\".future.R\"),  #>                     \" file provides a\\n\", \"convenient place for users to set the \",  #>                     list(\"plan()\"), \".\\n\", \"This behavior can be controlled via an \",  #>                     list(), \" option---see\\n\", list(\"future options\"),  #>                     \" for more details.\\n\")), \"\\n\", \"\\n\", list( #>                   \"\\n\", \"a <- b <- c <- NA_real_\\n\", \"\\n\", \"# An sequential future\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A sequential future with lazy evaluation\\n\",  #>                   \"plan(sequential)\\n\", \"f <- future({\\n\", \"  a <- 7\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"}, lazy = TRUE)\\n\", \"y <- value(f)\\n\", \"print(y)\\n\",  #>                   \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"\\n\", \"# A multicore future (specified as a string)\\n\",  #>                   \"plan(\\\"multicore\\\")\\n\", \"f <- future({\\n\",  #>                   \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"y <- value(f)\\n\", \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                   \"\\n\", \"## Multisession futures gives an error on R CMD check on\\n\",  #>                   \"## Windows (but not Linux or macOS) for unknown reasons.\\n\",  #>                   \"## The same code works in package tests.\\n\",  #>                   list(\"\\n\", \"\\n\", \"# A multisession future (specified via a string variable)\\n\",  #>                     \"plan(\\\"future::multisession\\\")\\n\", \"f <- future({\\n\",  #>                     \"  a <- 7\\n\", \"  b <- 3\\n\", \"  c <- 2\\n\",  #>                     \"  a * b * c\\n\", \"})\\n\", \"y <- value(f)\\n\",  #>                     \"print(y)\\n\", \"str(list(a = a, b = b, c = c)) ## All NAs\\n\",  #>                     \"\\n\"), \"\\n\", \"\\n\", \"\\n\", \"## Explicitly specifying number of workers\\n\",  #>                   \"## (default is parallelly::availableCores())\\n\",  #>                   \"plan(multicore, workers = 2)\\n\", \"message(\\\"Number of parallel workers: \\\", nbrOfWorkers())\\n\",  #>                   \"\\n\", \"\\n\", \"## Explicitly close multisession workers by switching plan\\n\",  #>                   \"plan(sequential)\\n\", \"# Evaluate a future using the 'multisession' plan\\n\",  #>                   \"with(plan(multisession, workers = 2), {\\n\",  #>                   \"  f <- future(Sys.getpid())\\n\", \"  w_pid <- value(f)\\n\",  #>                   \"})\\n\", \"print(c(main = Sys.getpid(), worker = w_pid))\\n\",  #>                   \"\\n\", \"\\n\", \"\\n\", \"# Evaluate a future locally using the 'multisession' plan\\n\",  #>                   \"local({\\n\", \"  with(plan(multisession, workers = 2), local = TRUE)\\n\",  #>                   \"\\n\", \"  f <- future(Sys.getpid())\\n\", \"  w_pid <- value(f)\\n\",  #>                   \"  print(c(main = Sys.getpid(), worker = w_pid))\\n\",  #>                   \"})\\n\", \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"Use \",  #>                   list(list(\"plan()\")), \" to set a future to become the\\n\",  #>                   \"new default strategy.\\n\"), \"\\n\"), private_length.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-basic.R\",  #>                 \"\\n\", list(\".length\"), \"\\n\", list(\".length\"),  #>                 \"\\n\", list(\"Gets the length of an object without dispatching\"),  #>                 \"\\n\", list(\"\\n\", \".length(x)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"Any \", list(),  #>                     \" object.\")), \"\\n\"), \"\\n\", list(\"\\n\", \"A non-negative integer.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Gets the length of an object without dispatching\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function returns \", list( #>                   \"length(unclass(x))\"), \", but tries to avoid\\n\",  #>                   \"calling \", list(\"unclass(x)\"), \" unless necessary.\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\".subset\"), \"()\"),  #>                   \" and \", list(list(\".subset2\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), `re-exports.Rd` = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/000.re-exports.R\",  #>                 \"\\n\", list(\"re-exports\"), \"\\n\", list(\"re-exports\"),  #>                 \"\\n\", list(\"availableCores\"), \"\\n\", list(\"availableWorkers\"),  #>                 \"\\n\", list(\"makeClusterPSOCK\"), \"\\n\", list(\"supportsMulticore\"),  #>                 \"\\n\", list(\"Functions Moved to 'parallelly'\"),  #>                 \"\\n\", list(\"\\n\", \"The following function used to be part of \",  #>                   list(\"future\"), \", but has since\\n\", \"been migrated to \",  #>                   list(\"parallelly\"), \". The migration started with\\n\",  #>                   list(\"future\"), \" 1.20.0 (November 2020). They were moved because they\\n\",  #>                   \"are also useful outside of the \", list(\"future\"),  #>                   \" framework.\\n\"), \"\\n\", list(\"\\n\", list(\"If you are using any of these from the \",  #>                   list(\"future\"), \" package, please\\n\", \"switch to use the ones from the \",  #>                   list(\"parallelly\"), \" package. Thank you!\"),  #>                   \"\\n\", list(\"\\n\", list(), \" \", list(list(\"parallelly::as.cluster()\")),  #>                     \"    (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::autoStopCluster()\")),  #>                     \"   (no longer re-exported)\\n\", list(), \" \",  #>                     list(list(\"parallelly::availableCores()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                     \"    (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                     \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                     \"     (no longer re-exported)\\n\", list(),  #>                     \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                     \"\\n\"), \"\\n\", \"\\n\", \"For backward-compatible reasons, \",  #>                   list(\"some\"), \" of these functions remain\\n\",  #>                   \"available as exact copies also from this package (as re-exports), e.g.\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- parallelly::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", \"can still be accessed as:\\n\", \"\\n\",  #>                   list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"cl <- future::makeClusterPSOCK(2)\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\",  #>                   \"\\n\", list(\"Note that it is the goal to remove all of the above from this package.\"),  #>                   \"\\n\"), \"\\n\", list(\"internal\"), \"\\n\"), readImmediateConditions.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"readImmediateConditions\"), \"\\n\",  #>                 list(\"readImmediateConditions\"), \"\\n\", list(\"saveImmediateCondition\"),  #>                 \"\\n\", list(\"Writes and Reads 'immediateCondition' RDS Files\"),  #>                 \"\\n\", list(\"\\n\", \"readImmediateConditions(\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir(),\\n\", \"  pattern = \\\"[.]rds$\\\",\\n\",  #>                   \"  include = getOption(\\\"future.relay.immediate\\\", \\\"immediateCondition\\\"),\\n\",  #>                   \"  signal = FALSE,\\n\", \"  remove = TRUE\\n\",  #>                   \")\\n\", \"\\n\", \"saveImmediateCondition(\\n\", \"  cond,\\n\",  #>                   \"  path = immediateConditionsPath(rootPath = rootPath),\\n\",  #>                   \"  rootPath = tempdir()\\n\", \")\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"path\"), list(\"(character string) The folder where the RDS files are.\")),  #>                   \"\\n\", \"\\n\", list(list(\"pattern\"), list(\"(character string) A regular expression selecting\\n\",  #>                     \"the RDS files to be read.\")), \"\\n\", \"\\n\",  #>                   list(list(\"include\"), list(\"(character vector) The class or classes of the objects\\n\",  #>                     \"to be kept.\")), \"\\n\", \"\\n\", list(list(\"signal\"),  #>                     list(\"(logical) If TRUE, the condition read are signaled.\")),  #>                   \"\\n\", \"\\n\", list(list(\"remove\"), list(\"(logical) If TRUE, the RDS files used are removed on exit.\")),  #>                   \"\\n\", \"\\n\", list(list(\"cond\"), list(\"A condition of class \",  #>                     list(\"immediateCondition\"), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"readImmediateConditions()\"),  #>                   \" returns an unnamed \", list(\"base::list\"),  #>                   \" of\\n\", \"named lists with elements \", list( #>                     \"condition\"), \" and \", list(\"signaled\"),  #>                   \", where\\n\", \"the \", list(\"condition\"), \" elements hold \",  #>                   list(\"immediateCondition\"), \" objects.\\n\",  #>                   \"\\n\", list(\"saveImmediateCondition()\"), \" returns, invisibly, the pathname of\\n\",  #>                   \"the RDS written.\\n\"), \"\\n\", list(\"\\n\", \"Writes and Reads 'immediateCondition' RDS Files\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), requestCore.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"requestCore\"), \"\\n\", list(\"requestCore\"),  #>                 \"\\n\", list(\"Request a core for multicore processing\"),  #>                 \"\\n\", list(\"\\n\", \"requestCore(\\n\", \"  await,\\n\",  #>                   \"  workers = availableCores(constraints = \\\"multicore\\\"),\\n\",  #>                   \"  timeout,\\n\", \"  delta,\\n\", \"  alpha\\n\",  #>                   \")\\n\"), \"\\n\", list(\"\\n\", list(list(\"await\"),  #>                   list(\"A function used to try to \\\"collect\\\"\\n\",  #>                     \"finished multicore subprocesses.\")), \"\\n\",  #>                   \"\\n\", list(list(\"workers\"), list(\"Total number of workers available.\")),  #>                   \"\\n\", \"\\n\", list(list(\"timeout\"), list(\"Maximum waiting time (in seconds) allowed\\n\",  #>                     \"before a timeout error is generated.\")),  #>                   \"\\n\", \"\\n\", list(list(\"delta\"), list(\"Then base interval (in seconds) to wait\\n\",  #>                     \"between each try.\")), \"\\n\", \"\\n\", list(list( #>                     \"alpha\"), list(\"A multiplicative factor used to increase\\n\",  #>                     \"the wait interval after each try.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Invisible TRUE. If no cores are available after\\n\",  #>                   \"extensive waiting, then a timeout error is thrown.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"If no cores are available, the current process\\n\",  #>                   \"blocks until a core is available.\\n\"), \"\\n\",  #>                 list(\"internal\"), \"\\n\"), reset.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-reset.R\",  #>                 \"\\n\", list(\"reset\"), \"\\n\", list(\"reset\"), \"\\n\",  #>                 list(\"Reset a finished, failed, canceled, or interrupted future to a lazy future\"),  #>                 \"\\n\", list(\"\\n\", \"reset(x, ...)\\n\"), \"\\n\", list( #>                   \"\\n\", list(list(\"x\"), list(\"A Future.\")), \"\\n\",  #>                   \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"reset()\"), \" returns a lazy, vanilla \",  #>                   list(\"Future\"), \" that can be relaunched.\\n\",  #>                   \"Resetting a running future results in a \",  #>                   list(\"FutureError\"), \".\\n\"), \"\\n\", list(\"\\n\",  #>                   \"A future that has successfully completed, was \",  #>                   list(\"canceled\"), \" or interrupted,\\n\", \"or has failed due to an error, can be relaunched after resetting it.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"A lazy, vanilla \", list(\"Future\"),  #>                   \" can be reused in another R session. For\\n\",  #>                   \"instance, if we do:\\n\", \"\\n\", list(list(\"html\"),  #>                     list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"a <- 2\\n\", \"f <- future(42 * a, lazy = TRUE)\\n\",  #>                     \"saveRDS(f, \\\"myfuture.rds\\\")\\n\"), list(list( #>                     \"html\"), list(list(\"<\/div>\"))), \"\\n\", \"\\n\",  #>                   \"Then we can read and evaluate the future in another R session using:\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode\\\">\"))),  #>                   list(\"library(future)\\n\", \"f <- readRDS(\\\"myfuture.rds\\\")\\n\",  #>                     \"v <- value(f)\\n\", \"print(v)\\n\", \"#> [1] 84\\n\"),  #>                   list(list(\"html\"), list(list(\"<\/div>\"))), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"## Like mean(), but fails 90% of the time\\n\",  #>                   \"shaky_mean <- function(x) {\\n\", \"  if (as.double(Sys.time()) %% 1 < 0.90) stop(\\\"boom\\\")\\n\",  #>                   \"  mean(x)\\n\", \"}\\n\", \"\\n\", \"x <- rnorm(100)\\n\",  #>                   \"\\n\", \"## Calculate the mean of 'x' with a risk of failing randomly\\n\",  #>                   \"f <- future({ shaky_mean(x) })\\n\", \"\\n\", \"## Relaunch until success\\n\",  #>                   \"repeat({\\n\", \"  v <- tryCatch(value(f), error = identity)\\n\",  #>                   \"  if (!inherits(v, \\\"error\\\")) break\\n\", \"  message(\\\"Resetting failed future, and retry in 0.1 seconds\\\")\\n\",  #>                   \"  f <- reset(f)\\n\", \"  Sys.sleep(0.1)\\n\",  #>                   \"})\\n\", \"cat(\\\"mean:\\\", v, \\\"\\\\n\\\")\\n\"), \"\\n\"),  #>             resetWorkers.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-plan.R\",  #>                 \"\\n\", list(\"resetWorkers\"), \"\\n\", list(\"resetWorkers\"),  #>                 \"\\n\", list(\"Free up active background workers\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"x\"), list(\"A FutureStrategy.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Free up active background workers\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function will resolve any active futures that are currently\\n\",  #>                   \"being evaluated on background workers.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"resetWorkers(plan())\\n\", \"\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), resolve.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-resolve.R\",  #>                 \"\\n\", list(\"resolve\"), \"\\n\", list(\"resolve\"),  #>                 \"\\n\", list(\"Resolve one or more futures synchronously\"),  #>                 \"\\n\", list(\"\\n\", \"resolve(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  result = FALSE,\\n\",  #>                   \"  stdout = FALSE,\\n\", \"  signal = FALSE,\\n\",  #>                   \"  force = FALSE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"x\"), list(\"A \", list(\"Future\"), \" to be resolved, or a list, an environment, or a\\n\",  #>                   \"list environment of futures to be resolved.\")),  #>                   \"\\n\", \"\\n\", list(list(\"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"result\"), list(\"(internal) If TRUE, the results are \",  #>                     list(\"retrieved\"), \", otherwise not.\\n\",  #>                     \"Note that this only collects the results from the parallel worker, which\\n\",  #>                     \"can help lower the overall latency if there are multiple concurrent futures.\\n\",  #>                     \"This does \", list(\"not\"), \" return the collected results.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"(internal) If TRUE, captured standard output is relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"signal\"), list(\"(internal) If TRUE, captured \",  #>                     list(\"conditions\"), \" are relayed,\\n\", \"otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed are relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns \", list(\"x\"), \" (regardless of subsetting or not).\\n\",  #>                   \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is produced.\\n\"), \"\\n\", list(\"\\n\",  #>                   \"This function provides an efficient mechanism for waiting for multiple\\n\",  #>                   \"futures in a container (e.g. list or environment) to be resolved while in\\n\",  #>                   \"the meanwhile retrieving values of already resolved futures.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is resolves synchronously, i.e. it blocks until \",  #>                   list(\"x\"), \" and\\n\", \"any containing futures are resolved.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"To resolve a future \", list( #>                   \"variable\"), \", first retrieve its\\n\", list( #>                   \"Future\"), \" object using \", list(list(\"futureOf()\")),  #>                   \", e.g.\\n\", list(\"resolve(futureOf(x))\"), \".\\n\"),  #>                 \"\\n\"), resolved.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.ClusterFutureBackend-class.R,\",  #>                 \"\\n\", \"%   R/backend_api-11.MulticoreFutureBackend-class.R, R/core_api-resolved.R\",  #>                 \"\\n\", list(\"resolved.ClusterFuture\"), \"\\n\", list( #>                   \"resolved.ClusterFuture\"), \"\\n\", list(\"resolved.MulticoreFuture\"),  #>                 \"\\n\", list(\"resolved\"), \"\\n\", list(\"resolved.default\"),  #>                 \"\\n\", list(\"resolved.list\"), \"\\n\", list(\"resolved.environment\"),  #>                 \"\\n\", list(\"resolved.Future\"), \"\\n\", list(\"Check whether a future is resolved or not\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"resolved\"), list( #>                   \"ClusterFuture\")), \"(x, timeout = NULL, ...)\\n\",  #>                   \"\\n\", list(list(\"resolved\"), list(\"MulticoreFuture\")),  #>                   \"(x, timeout = NULL, ...)\\n\", \"\\n\", \"resolved(x, ...)\\n\",  #>                   \"\\n\", list(list(\"resolved\"), list(\"default\")),  #>                   \"(x, ...)\\n\", \"\\n\", list(list(\"resolved\"),  #>                     list(\"list\")), \"(x, ...)\\n\", \"\\n\", list(list( #>                     \"resolved\"), list(\"environment\")), \"(x, ...)\\n\",  #>                   \"\\n\", list(list(\"resolved\"), list(\"Future\")),  #>                   \"(x, ...)\\n\"), \"\\n\", list(\"\\n\", list(list(\"x\"),  #>                   list(\"A \", list(\"Future\"), \", a list, or an environment (which also\\n\",  #>                     \"includes \", list(\"list environment\"), \").\")),  #>                   \"\\n\", \"\\n\", list(list(\"timeout\"), list(\"(numeric) The maximum time (in seconds) for polling the worker\\n\",  #>                     \"for a response. If no response is available within this time limit, FALSE is\\n\",  #>                     \"returned assuming the future is still being processed.\\n\",  #>                     \"If NULL, the value defaults to \", list(\"getOption(\\\"future.<type>.resolved.timeout\\\")\"),  #>                     \",\\n\", \"then \", list(\"getOption(\\\"future.resolved.timeout\\\")\"),  #>                     \", and finally 0.01 (seconds),\\n\", \"where \",  #>                     list(\"<type>\"), \" corresponds to the type of future, e.g. \",  #>                     list(\"cluster\"), \" and \", list(\"multicore\"),  #>                     \".\")), \"\\n\", \"\\n\", list(list(list()), list( #>                     \"Not used.\")), \"\\n\"), \"\\n\", list(\"\\n\", \"A logical vector of the same length and dimensions as \",  #>                   list(\"x\"), \".\\n\", \"Each element is TRUE unless the corresponding element is a\\n\",  #>                   \"non-resolved future in case it is FALSE.\\n\",  #>                   \"It never signals an error.\\n\", \"\\n\", \"The default method always returns TRUE.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Check whether a future is resolved or not\\n\"),  #>                 \"\\n\", list(\"\\n\", list(\"resolved()\"), \" attempts to launch a lazy future, if there is an available\\n\",  #>                   \"worker, otherwise not.\\n\", \"\\n\", list(\"resolved()\"),  #>                   \" methods must always return \", list(\"TRUE\"),  #>                   \" or \", list(\"FALSE\"), \" values, must\\n\", \"always launch lazy futures, and must never block indefinitely. This is\\n\",  #>                   \"because it should always be possible to poll futures until they are\\n\",  #>                   \"resolved using \", list(\"resolved()\"), \", e.g.\\n\",  #>                   list(\"while (!all(resolved(futures))) Sys.sleep(5)\"),  #>                   \".\\n\", \"\\n\", \"Each future backend must implement a \",  #>                   list(\"resolved()\"), \" method. It should return\\n\",  #>                   \"either TRUE or FALSE, or throw a \", list(\"FutureError\"),  #>                   \" (which indicates a\\n\", \"significant, often unrecoverable infrastructure problem, or an interrupt).\\n\"),  #>                 \"\\n\", list(list(\"Behavior of cluster and multisession futures\"),  #>                   list(\"\\n\", \"\\n\", \"If all worker slots are occupied, \",  #>                     list(\"resolved()\"), \" for \", list(\"ClusterFuture\"),  #>                     \" and\\n\", list(\"MultisessionFuture\"), \" will attempt to free one up by checking whether\\n\",  #>                     \"one of the futures is \", list(\"resolved\"),  #>                     \". If there is one, then its result is\\n\",  #>                     \"collected in order to free up one worker slot.\\n\",  #>                     \"\\n\", list(\"resolved()\"), \" for \", list(\"ClusterFuture\"),  #>                     \" may receive immediate condition objects, rather\\n\",  #>                     \"than a \", list(\"FutureResult\"), \", when polling the worker for results. In such cases, the\\n\",  #>                     \"condition object is collected and another poll it performed. Up to 100 immediate\\n\",  #>                     \"conditions may be collected this way per \",  #>                     list(\"resolved()\"), \" call, before considering\\n\",  #>                     \"the future non-resolved and FALSE being returned.\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Behavior of multicore futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"resolved()\"), \" for \",  #>                     list(\"MulticoreFuture\"), \" may receive immediate condition objects, rather than a\\n\",  #>                     list(\"FutureResult\"), \", when polling the worker for results. In such cases, \",  #>                     list(\"all\"), \" such condition\\n\", \"objects are collected, before considering the future non-resolved and FALSE being returned.\\n\")),  #>                 \"\\n\", \"\\n\"), result.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-result.R\",  #>                 \"\\n\", list(\"result.Future\"), \"\\n\", list(\"result.Future\"),  #>                 \"\\n\", list(\"result\"), \"\\n\", list(\"Get the results of a resolved future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"result\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"FutureResult\"),  #>                   \" object.\\n\", \"It may signal a \", list(\"FutureError\"),  #>                   \", if there is a significant orchestration\\n\",  #>                   \"error. For example, if the parallel worker process terminated abruptly\\n\",  #>                   \"(\\\"crashed\\\"), then a \", list(\"FutureInterruptError\"),  #>                   \" is signaled.\\n\"), \"\\n\", list(\"\\n\", \"Get the results of a resolved future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function is only part of the \",  #>                   list(\"backend\"), \" Future API.\\n\", \"This function is \",  #>                   list(\"not\"), \" part of the frontend Future API.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), run.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-Future-class.R\",  #>                 \"\\n\", list(\"run.Future\"), \"\\n\", list(\"run.Future\"),  #>                 \"\\n\", list(\"run\"), \"\\n\", list(\"Run a future\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"run\"), list(\"Future\")),  #>                   \"(future, ...)\\n\"), \"\\n\", list(\"\\n\", list(list( #>                   \"future\"), list(\"A \", list(\"Future\"), \".\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"Not used.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"The \", list(\"Future\"),  #>                   \" object.\\n\"), \"\\n\", list(\"\\n\", \"Run a future\\n\"),  #>                 \"\\n\", list(\"\\n\", \"This function can only be called once per future.\\n\",  #>                   \"Further calls will result in an informative error.\\n\",  #>                   \"If a future is not run when its value is queried,\\n\",  #>                   \"then it is run at that point.\\n\"), \"\\n\", list( #>                   \"internal\"), \"\\n\"), save_rds.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-immediateCondition.R\",  #>                 \"\\n\", list(\"save_rds\"), \"\\n\", list(\"save_rds\"),  #>                 \"\\n\", list(\"Robustly Saves an Object to RDS File Atomically\"),  #>                 \"\\n\", list(\"\\n\", \"save_rds(object, pathname, ...)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"object\"), list(\"The \",  #>                   list(), \" object to be save.\")), \"\\n\", \"\\n\",  #>                   list(list(\"pathname\"), list(\"RDS file to written.\")),  #>                   \"\\n\", \"\\n\", list(list(list()), list(\"(optional) Additional arguments passed to \",  #>                     list(list(\"base::saveRDS()\")), \".\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"The pathname of the RDS written.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Robustly Saves an Object to RDS File Atomically\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Uses \", list(\"base::saveRDS\"),  #>                   \" internally but writes the object atomically by first\\n\",  #>                   \"writing to a temporary file which is then renamed.\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sequential.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.SequentialFutureBackend-class.R\",  #>                 \"\\n\", list(\"sequential\"), \"\\n\", list(\"sequential\"),  #>                 \"\\n\", list(\"uniprocess\"), \"\\n\", list(\"Create a sequential future whose value will be in the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sequential(..., envir = parent.frame())\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"envir\"), list(\"The \",  #>                   list(\"environment\"), \" from where global objects should be\\n\",  #>                   \"identified.\")), \"\\n\", \"\\n\", list(list(list()),  #>                   list(\"Not used.\")), \"\\n\"), \"\\n\", list(\"\\n\",  #>                   list(\"WARNING: This function must never be called.\\n\",  #>                     \"It may only be used with \", list(list(\"plan()\"))),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"A sequential future is a future that is evaluated sequentially in the\\n\",  #>                   \"current \", list(), \" session similarly to how \",  #>                   list(), \" expressions are evaluated in \", list(),  #>                   \".\\n\", \"The only difference to \", list(), \" itself is that globals are validated\\n\",  #>                   \"by default just as for all other types of futures in this package.\\n\",  #>                   \"\\n\", \"This function is must \", list(\"not\"),  #>                   \" be called directly.  Instead, the\\n\", \"typical usages are:\\n\",  #>                   \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                   list(\"# Evaluate futures sequentially in the current R process\\n\",  #>                     \"plan(sequential)\\n\"), list(list(\"html\"),  #>                     list(list(\"<\/div>\"))), \"\\n\"), \"\\n\", list( #>                   \"\\n\", \"## Use sequential futures\\n\", \"plan(sequential)\\n\",  #>                   \"\\n\", \"## A global variable\\n\", \"a <- 0\\n\",  #>                   \"\\n\", \"## Create a sequential future\\n\", \"f <- future({\\n\",  #>                   \"  b <- 3\\n\", \"  c <- 2\\n\", \"  a * b * c\\n\",  #>                   \"})\\n\", \"\\n\", \"## Since 'a' is a global variable in future 'f' which\\n\",  #>                   \"## is eagerly resolved (default), this global has already\\n\",  #>                   \"## been resolved / incorporated, and any changes to 'a'\\n\",  #>                   \"## at this point will _not_ affect the value of 'f'.\\n\",  #>                   \"a <- 7\\n\", \"print(a)\\n\", \"\\n\", \"v <- value(f)\\n\",  #>                   \"print(v)\\n\", \"stopifnot(v == 0)\\n\"), \"\\n\"),  #>             sessionDetails.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils_api-sessionDetails.R\",  #>                 \"\\n\", list(\"sessionDetails\"), \"\\n\", list(\"sessionDetails\"),  #>                 \"\\n\", list(\"Outputs details on the current \",  #>                   list(), \" session\"), \"\\n\", list(\"\\n\", \"sessionDetails(env = FALSE)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"env\"), list(\"If TRUE, \",  #>                   list(\"Sys.getenv()\"), \" information is returned.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", \"Invisibly a list of all details.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Outputs details on the current \",  #>                   list(), \" session\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), signalConditions.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/protected_api-signalConditions.R\",  #>                 \"\\n\", list(\"signalConditions\"), \"\\n\", list(\"signalConditions\"),  #>                 \"\\n\", list(\"Signals Captured Conditions\"), \"\\n\",  #>                 list(\"\\n\", \"signalConditions(\\n\", \"  future,\\n\",  #>                   \"  include = \\\"condition\\\",\\n\", \"  exclude = NULL,\\n\",  #>                   \"  resignal = TRUE,\\n\", \"  ...\\n\", \")\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"future\"), list(\"A resolved \",  #>                   list(\"Future\"), \".\")), \"\\n\", \"\\n\", list(list( #>                   \"include\"), list(\"A character string of \",  #>                   list(\"condition\"), \"\\n\", \"classes to signal.\")),  #>                   \"\\n\", \"\\n\", list(list(\"exclude\"), list(\"A character string of \",  #>                     list(\"condition\"), \"\\n\", \"classes \", list( #>                       \"not\"), \" to signal.\")), \"\\n\", \"\\n\", list( #>                     list(\"resignal\"), list(\"If TRUE, then already signaled conditions are signaled\\n\",  #>                       \"again, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"Not used.\")), \"\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Returns the \", list(\"Future\"),  #>                   \" where conditioned that were signaled\\n\",  #>                   \"have been flagged to have been signaled.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Captured conditions that meet the \",  #>                   list(\"include\"), \" and \", list(\"exclude\"),  #>                   \"\\n\", \"requirements are signaled \", list(\"in the order as they were captured\"),  #>                   \".\\n\"), \"\\n\", list(\"\\n\", \"Conditions are signaled by\\n\",  #>                   list(list(\"signalCondition\"), \"()\"), \".\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), sticky_globals.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-sticky_globals.R\",  #>                 \"\\n\", list(\"sticky_globals\"), \"\\n\", list(\"sticky_globals\"),  #>                 \"\\n\", list(\"Place a sticky-globals environment immediately after the global environment\"),  #>                 \"\\n\", list(\"\\n\", \"sticky_globals(erase = FALSE, name = \\\"future:sticky_globals\\\", pos = 2L)\\n\"),  #>                 \"\\n\", list(\"\\n\", list(list(\"erase\"), list(\"(logical) If TRUE, the environment is erased, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"name\"), list(\"(character) The name of the environment on the \",  #>                     list(\"base::search\"), \"\\n\", \"path.\")), \"\\n\",  #>                   \"\\n\", list(list(\"pos\"), list(\"(integer) The position on the search path where the\\n\",  #>                     \"environment should be positioned.  If \",  #>                     list(\"pos == 0L\"), \", then the environment\\n\",  #>                     \"is detached, if it exists.\")), \"\\n\"), \"\\n\",  #>                 list(\"\\n\", \"(invisible; environment) The environment.\\n\"),  #>                 \"\\n\", list(\"\\n\", \"Place a sticky-globals environment immediately after the global environment\\n\"),  #>                 \"\\n\", list(\"internal\"), \"\\n\"), usedCores.Rd = list( #>                 \"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/backend_api-11.MulticoreFutureBackend-class.R\",  #>                 \"\\n\", list(\"usedCores\"), \"\\n\", list(\"usedCores\"),  #>                 \"\\n\", list(\"Get number of cores currently used\"),  #>                 \"\\n\", list(\"\\n\", \"usedCores()\\n\"), \"\\n\", list( #>                   \"\\n\", \"A non-negative integer.\\n\"), \"\\n\", list( #>                   \"\\n\", \"Get number of children (and don't count the current process)\\n\",  #>                   \"used by the current \", list(), \" session.  The number of children\\n\",  #>                   \"is the total number of subprocesses launched by this\\n\",  #>                   \"process that are still running and whose values have yet\\n\",  #>                   \"not been collected.\\n\"), \"\\n\", list(\"internal\"),  #>                 \"\\n\"), value.Rd = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/core_api-value.R\",  #>                 \"\\n\", list(\"value\"), \"\\n\", list(\"value\"), \"\\n\",  #>                 list(\"value.Future\"), \"\\n\", list(\"value.list\"),  #>                 \"\\n\", list(\"value.listenv\"), \"\\n\", list(\"value.environment\"),  #>                 \"\\n\", list(\"The value of a future or the values of all elements in a container\"),  #>                 \"\\n\", list(\"\\n\", \"value(...)\\n\", \"\\n\", list(list( #>                   \"value\"), list(\"Future\")), \"(future, stdout = TRUE, signal = TRUE, drop = FALSE, ...)\\n\",  #>                   \"\\n\", list(list(\"value\"), list(\"list\")), \"(\\n\",  #>                   \"  x,\\n\", \"  idxs = NULL,\\n\", \"  recursive = 0,\\n\",  #>                   \"  reduce = NULL,\\n\", \"  stdout = TRUE,\\n\",  #>                   \"  signal = TRUE,\\n\", \"  cancel = TRUE,\\n\",  #>                   \"  interrupt = cancel,\\n\", \"  inorder = TRUE,\\n\",  #>                   \"  drop = FALSE,\\n\", \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"listenv\")), \"(\\n\", \"  x,\\n\", \"  idxs = NULL,\\n\",  #>                   \"  recursive = 0,\\n\", \"  reduce = NULL,\\n\",  #>                   \"  stdout = TRUE,\\n\", \"  signal = TRUE,\\n\",  #>                   \"  cancel = TRUE,\\n\", \"  interrupt = cancel,\\n\",  #>                   \"  inorder = TRUE,\\n\", \"  drop = FALSE,\\n\",  #>                   \"  force = TRUE,\\n\", \"  sleep = getOption(\\\"future.wait.interval\\\", 0.01),\\n\",  #>                   \"  ...\\n\", \")\\n\", \"\\n\", list(list(\"value\"),  #>                     list(\"environment\")), \"(x, ...)\\n\"), \"\\n\",  #>                 list(\"\\n\", list(list(\"future, x\"), list(\"A \",  #>                   list(\"Future\"), \", an environment, a list, or a list environment.\")),  #>                   \"\\n\", \"\\n\", list(list(\"stdout\"), list(\"If TRUE, standard output captured while resolving futures\\n\",  #>                     \"is relayed, otherwise not.\")), \"\\n\", \"\\n\",  #>                   list(list(\"signal\"), list(\"If TRUE, \", list( #>                     \"conditions\"), \" captured while resolving\\n\",  #>                     \"futures are relayed, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"drop\"), list(\"If TRUE, resolved futures are minimized in size and invalidated\\n\",  #>                     \"as soon as their values have been collected and any output and\\n\",  #>                     \"conditions have been relayed.\\n\", \"Combining \",  #>                     list(\"drop = TRUE\"), \" with \", list(\"inorder = FALSE\"),  #>                     \" reduces the memory use\\n\", \"sooner, especially avoiding the risk of holding on to future values until\\n\",  #>                     \"the very end.\")), \"\\n\", \"\\n\", list(list( #>                     \"idxs\"), list(\"(optional) integer or logical index specifying the subset of\\n\",  #>                     \"elements to check.\")), \"\\n\", \"\\n\", list( #>                     list(\"recursive\"), list(\"A non-negative number specifying how deep of a recursion\\n\",  #>                       \"should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,\\n\",  #>                       \"no recursion is performed.\")), \"\\n\", \"\\n\",  #>                   list(list(\"reduce\"), list(\"An optional function for reducing all the values.\\n\",  #>                     \"Optional attribute \", list(\"init\"), \" can be used to set initial value for the\\n\",  #>                     \"reduction. If not specified, the first value will be used as the\\n\",  #>                     \"initial value.\\n\", \"Reduction of values is done as soon as possible, but always in the\\n\",  #>                     \"same order as \", list(\"x\"), \", unless \",  #>                     list(\"inorder\"), \" is FALSE.\")), \"\\n\", \"\\n\",  #>                   list(list(\"cancel, interrupt\"), list(\"If TRUE and \",  #>                     list(\"signal\"), \" is TRUE, non-resolved futures\\n\",  #>                     \"are canceled as soon as an error is detected in one of the futures,\\n\",  #>                     \"before signaling the error. Argument \",  #>                     list(\"interrupt\"), \" is passed to \", list( #>                       \"cancel()\"), \"\\n\", \"controlling whether non-resolved futures should also be interrupted.\")),  #>                   \"\\n\", \"\\n\", list(list(\"inorder\"), list(\"If TRUE, then standard output and conditions are relayed,\\n\",  #>                     \"and value reduction is done in the order the futures occur in \",  #>                     list(\"x\"), \", but\\n\", \"always as soon as possible. This is achieved by buffering the details\\n\",  #>                     \"until they can be released. By setting \",  #>                     list(\"inorder = FALSE\"), \", no buffering\\n\",  #>                     \"takes place and everything is relayed and reduced as soon as a new future\\n\",  #>                     \"is resolved. Regardless, the values are always returned in the same\\n\",  #>                     \"order as \", list(\"x\"), \".\")), \"\\n\", \"\\n\",  #>                   list(list(\"force\"), list(\"(internal) If TRUE, captured standard output and captured\\n\",  #>                     list(\"conditions\"), \" already relayed are relayed again, otherwise not.\")),  #>                   \"\\n\", \"\\n\", list(list(\"sleep\"), list(\"Number of seconds to wait before checking if futures have been\\n\",  #>                     \"resolved since last time.\")), \"\\n\", \"\\n\",  #>                   list(list(list()), list(\"All arguments used by the S3 methods.\")),  #>                   \"\\n\"), \"\\n\", list(\"\\n\", list(\"value()\"), \" of a Future object returns the value of the future, which can\\n\",  #>                   \"be any type of \", list(), \" object.\\n\", \"\\n\",  #>                   list(\"value()\"), \" of a list, an environment, or a list environment returns an\\n\",  #>                   \"object with the same number of elements and of the same class.\\n\",  #>                   \"Names and dimension attributes are preserved, if available.\\n\",  #>                   \"All future elements are replaced by their corresponding \",  #>                   list(\"value()\"), \" values.\\n\", \"For all other elements, the existing object is kept as-is.\\n\",  #>                   \"\\n\", \"If \", list(\"signal\"), \" is TRUE and one of the futures produces an error, then\\n\",  #>                   \"that error is relayed. Any remaining, non-resolved futures in \",  #>                   list(\"x\"), \" are\\n\", \"canceled, prior to signaling such an error.\\n\",  #>                   \"If the future was interrupted, canceled, or the parallel worker terminated\\n\",  #>                   \"abruptly (\\\"crashed\\\"), then a \", list(\"FutureInterruptError\"),  #>                   \" is signaled.\\n\"), \"\\n\", list(\"\\n\", \"Gets the value of a future or the values of all elements (including futures)\\n\",  #>                   \"in a container such as a list, an environment, or a list environment.\\n\",  #>                   \"If one or more futures are unresolved, then this function blocks until all\\n\",  #>                   \"queried futures are resolved.\\n\"), \"\\n\", list( #>                   \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## A single future\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"x <- sample(100, size = 50)\\n\", \"f <- future(mean(x))\\n\",  #>                   \"v <- value(f)\\n\", \"message(\\\"The average of 50 random numbers in [1,100] is: \\\", v)\\n\",  #>                   \"\\n\", \"\\n\", \"\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"## Ten futures\\n\", \"## ------------------------------------------------------\\n\",  #>                   \"xs <- replicate(10, { list(sample(100, size = 50)) })\\n\",  #>                   \"fs <- lapply(xs, function(x) { future(mean(x)) })\\n\",  #>                   \"\\n\", \"## The 10 values as a list (because 'fs' is a list)\\n\",  #>                   \"vs <- value(fs)\\n\", \"message(\\\"The ten averages are:\\\")\\n\",  #>                   \"str(vs)\\n\", \"\\n\", \"## The 10 values as a vector (by manually unlisting)\\n\",  #>                   \"vs <- value(fs)\\n\", \"vs <- unlist(vs)\\n\",  #>                   \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## The values as a vector (by reducing)\\n\",  #>                   \"vs <- value(fs, reduce = c)\\n\", \"message(\\\"The ten averages are: \\\", paste(vs, collapse = \\\", \\\"))\\n\",  #>                   \"\\n\", \"## Calculate the sum of the averages (by reducing)\\n\",  #>                   \"total <- value(fs, reduce = `+`)\\n\", \"message(\\\"The sum of the ten averages is: \\\", total)\\n\"),  #>                 \"\\n\"), `zzz-future.options.Rd` = list(\"% Generated by roxygen2: do not edit by hand\",  #>                 \"\\n\", \"% Please edit documentation in R/utils-options.R\",  #>                 \"\\n\", list(\"zzz-future.options\"), \"\\n\", list( #>                   \"zzz-future.options\"), \"\\n\", list(\"future.options\"),  #>                 \"\\n\", list(\"future.startup.script\"), \"\\n\", list( #>                   \"future.debug\"), \"\\n\", list(\"future.demo.mandelbrot.region\"),  #>                 \"\\n\", list(\"future.demo.mandelbrot.nrow\"), \"\\n\",  #>                 list(\"future.fork.multithreading.enable\"), \"\\n\",  #>                 list(\"future.globals.maxSize\"), \"\\n\", list(\"future.globals.method\"),  #>                 \"\\n\", list(\"future.globals.onMissing\"), \"\\n\",  #>                 list(\"future.globals.resolve\"), \"\\n\", list(\"future.globals.onReference\"),  #>                 \"\\n\", list(\"future.plan\"), \"\\n\", list(\"future.onFutureCondition.keepFuture\"),  #>                 \"\\n\", list(\"future.resolve.recursive\"), \"\\n\",  #>                 list(\"future.connections.onMisuse\"), \"\\n\", list( #>                   \"future.defaultDevice.onMisuse\"), \"\\n\", list( #>                   \"future.devices.onMisuse\"), \"\\n\", list(\"future.globalenv.onMisuse\"),  #>                 \"\\n\", list(\"future.rng.onMisuse\"), \"\\n\", list( #>                   \"future.wait.alpha\"), \"\\n\", list(\"future.wait.interval\"),  #>                 \"\\n\", list(\"future.wait.timeout\"), \"\\n\", list( #>                   \"future.output.windows.reencode\"), \"\\n\", list( #>                   \"future.journal\"), \"\\n\", list(\"future.globals.objectSize.method\"),  #>                 \"\\n\", list(\"future.ClusterFuture.clusterEvalQ\"),  #>                 \"\\n\", list(\"R_FUTURE_STARTUP_SCRIPT\"), \"\\n\",  #>                 list(\"R_FUTURE_DEBUG\"), \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_REGION\"),  #>                 \"\\n\", list(\"R_FUTURE_DEMO_MANDELBROT_NROW\"),  #>                 \"\\n\", list(\"R_FUTURE_FORK_MULTITHREADING_ENABLE\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_MAXSIZE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_METHOD\"), \"\\n\", list(\"R_FUTURE_GLOBALS_ONMISSING\"),  #>                 \"\\n\", list(\"R_FUTURE_GLOBALS_RESOLVE\"), \"\\n\",  #>                 list(\"R_FUTURE_GLOBALS_ONREFERENCE\"), \"\\n\", list( #>                   \"R_FUTURE_PLAN\"), \"\\n\", list(\"R_FUTURE_ONFUTURECONDITION_KEEPFUTURE\"),  #>                 \"\\n\", list(\"R_FUTURE_RESOLVE_RECURSIVE\"), \"\\n\",  #>                 list(\"R_FUTURE_CONNECTIONS_ONMISUSE\"), \"\\n\",  #>                 list(\"R_FUTURE_DEVICES_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_DEFAULTDEVICE_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_GLOBALENV_ONMISUSE\"), \"\\n\", list( #>                   \"R_FUTURE_RNG_ONMISUSE\"), \"\\n\", list(\"R_FUTURE_WAIT_ALPHA\"),  #>                 \"\\n\", list(\"R_FUTURE_WAIT_INTERVAL\"), \"\\n\", list( #>                   \"R_FUTURE_WAIT_TIMEOUT\"), \"\\n\", list(\"R_FUTURE_RESOLVED_TIMEOUT\"),  #>                 \"\\n\", list(\"R_FUTURE_OUTPUT_WINDOWS_REENCODE\"),  #>                 \"\\n\", list(\"R_FUTURE_JOURNAL\"), \"\\n\", list(\"R_FUTURE_GLOBALS_OBJECTSIZE_METHOD\"),  #>                 \"\\n\", list(\"R_FUTURE_CLUSTERFUTURE_CLUSTEREVALQ\"),  #>                 \"\\n\", list(\"future.cmdargs\"), \"\\n\", list(\".future.R\"),  #>                 \"\\n\", list(\"Options used for futures\"), \"\\n\",  #>                 list(\"\\n\", \"Below are the \", list(), \" options and environment variables that are used by the\\n\",  #>                   list(\"future\"), \" package and packages enhancing it.\",  #>                   list(), \"\\n\", list(), \"\\n\", list(\"WARNING: Note that the names and the default values of these options may\\n\",  #>                     \"change in future versions of the package.  Please use with care until\\n\",  #>                     \"further notice.\"), \"\\n\"), \"\\n\", list(list( #>                   \"Packages must not change future options\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Just like for other R options, as a package developer you must \",  #>                     list(\"not\"), \" change\\n\", \"any of the below \",  #>                     list(\"future.*\"), \" options.  Only the end-user should set these.\\n\",  #>                     \"If you find yourself having to tweak one of the options, make sure to\\n\",  #>                     \"undo your changes immediately afterward.  For example, if you want to\\n\",  #>                     \"bump up the \", list(\"future.globals.maxSize\"),  #>                     \" limit when creating a future,\\n\", \"use something like the following inside your function:\\n\",  #>                     \"\\n\", list(list(\"html\"), list(list(\"<div class=\\\"sourceCode r\\\">\"))),  #>                     list(\"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB\\n\",  #>                       \"on.exit(options(oopts))\\n\", \"f <- future({ expr })  ## Launch a future with large objects\\n\"),  #>                     list(list(\"html\"), list(list(\"<\/div>\"))),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(list(\"Options for controlling futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.plan\"), \":\"), list(\"(character string or future function) Default future backend used unless otherwise specified via \",  #>                     list(list(\"plan()\")), \". This will also be the future plan set when calling \",  #>                     list(\"plan(\\\"default\\\")\"), \".  If not specified, this option may be set when the \",  #>                     list(\"future\"), \" package is \", list(\"loaded\"),  #>                     \" if command-line option \", list(\"--parallel=ncores\"),  #>                     \" (short \", list(\"-p ncores\"), \") is specified; if \",  #>                     list(\"ncores > 1\"), \", then option \", list( #>                       \"future.plan\"), \" is set to \", list(\"multisession\"),  #>                     \" otherwise \", list(\"sequential\"), \" (in addition to option \",  #>                     list(\"mc.cores\"), \" being set to \", list( #>                       \"ncores\"), \", if \", list(\"ncores >= 1\"),  #>                     \"). (Default: \", list(\"sequential\"), \")\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.maxSize\"),  #>                       \":\"), list(\"(numeric) Maximum allowed total size (in bytes) of global variables identified. This is used to protect against exporting too large objects to parallel workers by mistake. Transferring large objects over a network, or over the internet, can be slow and therefore introduce a large bottleneck that increases the overall processing time. It can also result in large egress or ingress costs, which may exist on some systems. If set of \",  #>                       list(\"+Inf\"), \", then the check for large globals is skipped. (Default: \",  #>                       list(\"500 * 1024 ^ 2\"), \" = 500 MiB)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.globals.onReference\"),  #>                       \": (\", list(\"beta feature - may change\"),  #>                       \")\"), list(\"(character string) Controls whether the identified globals should be scanned for so called \",  #>                       list(\"references\"), \" (e.g. external pointers and connections) or not.  It is unlikely that another \",  #>                       list(), \" process (\\\"worker\\\") can use a global that uses a internal reference of the master \",  #>                       list(), \" process---we call such objects \",  #>                       list(\"non-exportable globals\"), \".\\n\",  #>                       \"If this option is \", list(\"\\\"error\\\"\"),  #>                       \", an informative error message is produced if a non-exportable global is detected.\\n\",  #>                       \"If \", list(\"\\\"warning\\\"\"), \", a warning is produced, but the processing will continue; it is likely that the future will be resolved with a run-time error unless processed in the master \",  #>                       list(), \" process (e.g. \", list(\"plan(sequential)\"),  #>                       \" and \", list(\"plan(multicore)\"), \").\\n\",  #>                       \"If \", list(\"\\\"ignore\\\"\"), \", no scan is performed.\\n\",  #>                       \"(Default: \", list(\"\\\"ignore\\\"\"), \" but may change)\\n\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.resolve.recursive\"),  #>                       \":\"), list(\"(integer) An integer specifying the maximum recursive depth to which futures should be resolved. If negative, nothing is resolved.  If \",  #>                       list(\"0\"), \", only the future itself is resolved.  If \",  #>                       list(\"1\"), \", the future and any of its elements that are futures are resolved, and so on. If \",  #>                       list(\"+Inf\"), \", infinite search depth is used. (Default: \",  #>                       list(\"0\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.onFutureCondition.keepFuture\"),  #>                       \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                       \", a \", list(\"FutureCondition\"), \" keeps a copy of the \",  #>                       list(\"Future\"), \" object that triggered the condition. If \",  #>                       list(\"FALSE\"), \", it is dropped. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\", \"\\n\", list(list( #>                       list(\"future.wait.timeout\"), \":\"), list( #>                       \"(numeric) Maximum waiting time (in seconds) for a future to resolve or for a free worker to become available before a timeout error is generated. (Default: \",  #>                       list(\"30 * 24 * 60 * 60\"), \" (= 30 days))\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.interval\"),  #>                       \":\"), list(\"(numeric) Initial interval (in\\n\",  #>                       \"seconds) between polls. This controls the polling frequency for finding\\n\",  #>                       \"an available worker when all workers are currently busy. It also controls\\n\",  #>                       \"the polling frequency of \", list(\"resolve()\"),  #>                       \". (Default: \", list(\"0.01\"), \" = 1 ms)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.wait.alpha\"),  #>                       \":\"), list(\"(numeric) Positive scale factor used to increase the interval after each poll. (Default: \",  #>                       list(\"1.01\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for built-in sanity checks\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"Ideally, the evaluation of a future should have no side effects. To\\n\",  #>                     \"protect against unexpected side effects, the future framework comes\\n\",  #>                     \"with a set of built-in tools for checking against this.\\n\",  #>                     \"Below R options control these built-in checks and what should happen\\n\",  #>                     \"if they fail. You may modify them for troubleshooting purposes, but\\n\",  #>                     \"please refrain from disabling these checks when there is an underlying\\n\",  #>                     \"problem that should be fixed.\\n\", \"\\n\",  #>                     list(\"Beta features: Please consider these checks to be \\\"under construction\\\".\"),  #>                     \"\\n\", \"\\n\", list(\"\\n\", list(list(list(\"future.connections.onMisuse\"),  #>                       \":\"), list(\"(character string)\\n\", \"A future must close any connections it opens and must not close\\n\",  #>                       \"connections it did not open itself.\\n\",  #>                       \"If such misuse is detected and this option is set to \",  #>                       list(\"\\\"error\\\"\"), \",\\n\", \"then an informative error is produced. If it is set to \",  #>                       list(\"\\\"warning\\\"\"), \",\\n\", \"a warning is produced. If\",  #>                       list(\"\\\"ignore\\\"\"), \", no check is performed.\\n\",  #>                       \"(Default: \", list(\"\\\"warning\\\"\"), \")\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"future.defaultDevice.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"A future must open graphics devices explicitly, if it creates new\\n\",  #>                         \"plots. It should not rely on the default graphics device that\\n\",  #>                         \"is given by R option \", list(\"\\\"default\\\"\"),  #>                         \", because that rarely does what\\n\",  #>                         \"is intended.\\n\", \"If such misuse is detected and this option is set to \",  #>                         list(\"\\\"error\\\"\"), \",\\n\", \"then an informative error is produced. If it is set to \",  #>                         list(\"\\\"warning\\\"\"), \",\\n\", \"a warning is produced. If\",  #>                         list(\"\\\"ignore\\\"\"), \", no check is performed.\\n\",  #>                         \"(Default: \", list(\"\\\"warning\\\"\"), \")\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"future.devices.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"A future must close any graphics devices it opens and must not close\\n\",  #>                         \"devices it did not open itself.\\n\",  #>                         \"If such misuse is detected and this option is set to \",  #>                         list(\"\\\"error\\\"\"), \",\\n\", \"then an informative error is produced. If it is set to \",  #>                         list(\"\\\"warning\\\"\"), \",\\n\", \"a warning is produced. If\",  #>                         list(\"\\\"ignore\\\"\"), \", no check is performed.\\n\",  #>                         \"(Default: \", list(\"\\\"warning\\\"\"), \")\\n\")),  #>                       \"\\n\", \"\\n\", list(list(list(\"future.globalenv.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"Assigning variables to the global environment for the purpose of using\\n\",  #>                         \"the variable at a later time makes no sense with futures, because the\\n\",  #>                         \"next the future may be evaluated in different R process.\\n\",  #>                         \"To protect against mistakes, the future framework attempts to detect\\n\",  #>                         \"when variables are added to the global environment.\\n\",  #>                         \"If this is detected, and this option is set to \",  #>                         list(\"\\\"error\\\"\"), \", then an\\n\", \"informative error is produced. If \",  #>                         list(\"\\\"warning\\\"\"), \", then a warning is\\n\",  #>                         \"produced. If \", list(\"\\\"ignore\\\"\"),  #>                         \", no check is performed.\\n\", \"(Default: \",  #>                         list(\"\\\"ignore\\\"\"), \")\\n\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.rng.onMisuse\"),  #>                         \":\"), list(\"(character string)\\n\", \"If random numbers are used in futures, then parallel RNG should be\\n\",  #>                         list(\"declared\"), \" in order to get statistical sound RNGs. You can declare\\n\",  #>                         \"this by specifying future argument \",  #>                         list(\"seed = TRUE\"), \". The defaults in the\\n\",  #>                         \"future framework assume that \", list( #>                           \"no\"), \" random number generation (RNG) is\\n\",  #>                         \"taken place in the future expression because L'Ecuyer-CMRG RNGs come\\n\",  #>                         \"with an unnecessary overhead if not needed.\\n\",  #>                         \"To protect against  mistakes of not declaring use of the RNG, the\\n\",  #>                         \"future framework detects when random numbers were used despite not\\n\",  #>                         \"declaring such use.\\n\", \"If this is detected, and this options is set \",  #>                         list(\"\\\"error\\\"\"), \", then an\\n\", \"informative error is produced. If \",  #>                         list(\"\\\"warning\\\"\"), \", then a warning is\\n\",  #>                         \"produced.  If \", list(\"\\\"ignore\\\"\"),  #>                         \", no check is performed.\\n\", \"(Default: \",  #>                         list(\"\\\"warning\\\"\"), \")\\n\")), \"\\n\"),  #>                     \"\\n\")), \"\\n\", \"\\n\", list(list(\"Options for debugging futures\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.debug\"), \":\"), list(\"(logical) If \",  #>                     list(\"TRUE\"), \", extensive debug messages are generated. (Default: \",  #>                     list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for controlling package startup\"),  #>                   list(\"\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                     \"future.startup.script\"), \":\"), list(\"(character vector or a logical) Specifies zero of more future startup scripts to be sourced when the \",  #>                     list(\"future\"), \" package is \", list(\"attached\"),  #>                     \". It is only the first existing script that is sourced. If none of the specified files exist, nothing is sourced---there will be neither a warning nor an error.\\n\",  #>                     \"If this option is not specified, environment variable \",  #>                     list(\"R_FUTURE_STARTUP_SCRIPT\"), \" is considered, where multiple scripts may be separated by either a colon (\",  #>                     list(\":\"), \") or a semicolon (\", list(\";\"),  #>                     \"). If neither is set, or either is set to \",  #>                     list(\"TRUE\"), \", the default is to look for a \",  #>                     list(\".future.R\"), \" script in the current directory and then in the user's home directory.  To disable future startup scripts, set the option or the environment variable to \",  #>                     list(\"FALSE\"), \".  \", list(\"Importantly\"),  #>                     \", this option is \", list(\"always\"), \" set to \",  #>                     list(\"FALSE\"), \" if the \", list(\"future\"),  #>                     \" package is loaded as part of a future expression being evaluated, e.g. in a background process. In other words, they are sourced in the main \",  #>                     list(), \" process but not in future processes. (Default: \",  #>                     list(\"TRUE\"), \" in main \", list(), \" process and \",  #>                     list(\"FALSE\"), \" in future processes / during future evaluation)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.cmdargs\"),  #>                       \":\"), list(\"(character vector) Overrides \",  #>                       list(list(\"commandArgs\"), \"()\"), \" when the \",  #>                       list(\"future\"), \" package is \", list(\"loaded\"),  #>                       \".\")), \"\\n\"), \"\\n\")), \"\\n\", \"\\n\", list( #>                   list(\"Options for configuring low-level system behaviors\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", list(\"\\n\", list(list( #>                     list(\"future.fork.multithreading.enable\"),  #>                     \" (\", list(\"beta feature - may change\"),  #>                     \"):\"), list(\"(logical) Enable or disable \",  #>                     list(\"multi-threading\"), \" while using \",  #>                     list(\"forked\"), \" parallel processing.  If \",  #>                     list(\"FALSE\"), \", different multi-thread library settings are overridden such that they run in single-thread mode. Specifically, multi-threading will be disabled for OpenMP (which requires the \",  #>                     list(\"RhpcBLASctl\"), \" package) and for \",  #>                     list(\"RcppParallel\"), \". If \", list(\"TRUE\"),  #>                     \", or not set (the default), multi-threading is allowed.  Parallelization via multi-threaded processing (done in native code by some packages and external libraries) while at the same time using forked (aka \\\"multicore\\\") parallel processing is known to unstable.  Note that this is not only true when using \",  #>                     list(\"plan(multicore)\"), \" but also when using, for instance, \",  #>                     list(list(\"mclapply\"), \"()\"), \" of the \",  #>                     list(\"parallel\"), \" package. (Default: not set)\")),  #>                     \"\\n\", \"\\n\", list(list(list(\"future.output.windows.reencode\"),  #>                       \":\"), list(\"(logical) Enable or disable re-encoding of UTF-8 symbols that were incorrectly encoded while captured.  In R (< 4.2.0) and on older versions of MS Windows, R cannot capture UTF-8 symbols as-is when they are captured from the standard output.  For examples, a UTF-8 check mark symbol (\",  #>                       list(\"\\\"\\\\u2713\\\"\"), \") would be relayed as \",  #>                       list(\"\\\"<U+2713>\\\"\"), \" (a string with eight ASCII characters).  Setting this option to \",  #>                       list(\"TRUE\"), \" will cause \", list(\"value()\"),  #>                       \" to attempt to recover the intended UTF-8 symbols from \",  #>                       list(\"<U+nnnn>\"), \" string components, if, and only if, the string was captured by a future resolved on MS Windows. (Default: \",  #>                       list(\"TRUE\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Options for demos\"), list(\"\\n\",  #>                   \"\\n\", list(\"\\n\", list(list(list(\"future.demo.mandelbrot.region\"),  #>                     \":\"), list(\"(integer) Either a named list of \",  #>                     list(list(\"mandelbrot()\")), \" arguments or an integer in {1, 2, 3} specifying a predefined Mandelbrot region. (Default: \",  #>                     list(\"1L\"), \")\")), \"\\n\", \"\\n\", list(list( #>                     list(\"future.demo.mandelbrot.nrow\"), \":\"),  #>                     list(\"(integer) Number of rows and columns of tiles. (Default: \",  #>                       list(\"3L\"), \")\")), \"\\n\"), \"\\n\")), \"\\n\",  #>                 \"\\n\", list(list(\"Deprecated or for internal prototyping\"),  #>                   list(\"\\n\", \"\\n\", \"\\n\", \"The following options exists only for troubleshooting purposes and must not\\n\",  #>                     \"be used in production.  If used, there is a risk that the results are\\n\",  #>                     \"non-reproducible if processed elsewhere.  To lower the risk of them being\\n\",  #>                     \"used by mistake, they are marked as deprecated and will produce warnings\\n\",  #>                     \"if set.\\n\", \"\\n\", list(\"\\n\", list(list(list( #>                       \"future.globals.onMissing\"), \":\"), list( #>                       \"(character string) Action to take when non-existing global variables (\\\"globals\\\" or \\\"unknowns\\\") are identified when the future is created.  If \",  #>                       list(\"\\\"error\\\"\"), \", an error is generated immediately.  If \",  #>                       list(\"\\\"ignore\\\"\"), \", no action is taken and an attempt to evaluate the future expression will be made.  The latter is useful when there is a risk for false-positive globals being identified, e.g. when future expression contains non-standard evaluation (NSE).  (Default: \",  #>                       list(\"\\\"ignore\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.method\"),  #>                         \":\"), list(\"(character string) Method used to identify globals. For details, see \",  #>                         list(list(\"globalsOf\"), \"()\"), \". (Default: \",  #>                         list(\"\\\"ordered\\\"\"), \")\")), \"\\n\", \"\\n\",  #>                       list(list(list(\"future.globals.resolve\"),  #>                         \":\"), list(\"(logical) If \", list(\"TRUE\"),  #>                         \", globals that are \", list(list(\"Future\")),  #>                         \" objects (typically created as \", list( #>                           \"explicit\"), \" futures) will be resolved and have their values (using \",  #>                         list(\"value()\"), \") collected.  Because searching for unresolved futures among globals (including their content) can be expensive, the default is not to do it and instead leave it to the run-time checks that assert proper ownership when resolving futures and collecting their values. (Default: \",  #>                         list(\"FALSE\"), \")\")), \"\\n\"), \"\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Environment variables that set R options\"),  #>                   list(\"\\n\", \"\\n\", \"All of the above \", list(),  #>                     \" \", list(\"future.*\"), \" options can be set by corresponding\\n\",  #>                     \"environment variable \", list(\"R_FUTURE_*\"),  #>                     \" \", list(\"when the \", list(\"future\"), \" package is\\n\",  #>                       \"loaded\"), \". This means that those environment variables must be set before\\n\",  #>                     \"the \", list(\"future\"), \" package is loaded in order to have an effect.\\n\",  #>                     \"For example, if \", list(\"R_FUTURE_RNG_ONMISUSE=\\\"ignore\\\"\"),  #>                     \", then option\\n\", list(\"future.rng.onMisuse\"),  #>                     \" is set to \", list(\"\\\"ignore\\\"\"), \" (character string).\\n\",  #>                     \"Similarly, if \", list(\"R_FUTURE_GLOBALS_MAXSIZE=\\\"50000000\\\"\"),  #>                     \", then option\\n\", list(\"future.globals.maxSize\"),  #>                     \" is set to \", list(\"50000000\"), \" (numeric).\\n\")),  #>                 \"\\n\", \"\\n\", list(list(\"Options moved to the 'parallelly' package\"),  #>                   list(\"\\n\", \"\\n\", \"Several functions have been moved to the \",  #>                     list(\"parallelly\"), \" package:\\n\", list(\"\\n\",  #>                       list(), \" \", list(list(\"parallelly::availableCores()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::availableWorkers()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterMPI()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeClusterPSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::makeNodePSOCK()\")),  #>                       \"\\n\", list(), \" \", list(list(\"parallelly::supportsMulticore()\")),  #>                       \"\\n\"), \"\\n\", \"\\n\", \"The options and environment variables controlling those have been adjusted\\n\",  #>                     \"accordingly to have different prefixes.\\n\",  #>                     \"For example, option \", list(\"future.fork.enable\"),  #>                     \" has been renamed to\\n\", list(\"parallelly.fork.enable\"),  #>                     \" and the corresponding environment variable\\n\",  #>                     list(\"R_FUTURE_FORK_ENABLE\"), \" has been renamed to\\n\",  #>                     list(\"R_PARALLELLY_FORK_ENABLE\"), \".\\n\",  #>                     \"For backward compatibility reasons, the \",  #>                     list(\"parallelly\"), \" package will\\n\", \"support both versions for a long foreseeable time.\\n\",  #>                     \"See the \", list(\"parallelly::parallelly.options\"),  #>                     \" page for the settings.\\n\")), \"\\n\", \"\\n\",  #>                 list(\"\\n\", \"# Allow at most 5 MB globals per futures\\n\",  #>                   \"options(future.globals.maxSize = 5e6)\\n\",  #>                   \"\\n\", \"# Be strict; catch all RNG mistakes\\n\",  #>                   \"options(future.rng.onMisuse = \\\"error\\\")\\n\",  #>                   \"\\n\", \"\\n\"), \"\\n\", list(\"\\n\", \"To set \", list(),  #>                   \" options or environment variables when \",  #>                   list(), \" starts (even before the \", list(\"future\"),  #>                   \" package is loaded), see the \", list(\"Startup\"),  #>                   \" help page.  The \", list(list(\"https://cran.r-project.org/package=startup\"),  #>                     list(list(\"startup\"))), \" package provides a friendly mechanism for configurating \",  #>                   list(), \"'s startup process.\\n\"), \"\\n\")), source = list( #>             `Future-class.Rd` = \"R/backend_api-Future-class.R\",  #>             `FutureBackend-class.Rd` = c(\"R/backend_api-01-FutureBackend-class.R\",  #>             \"R/backend_api-03.MultiprocessFutureBackend-class.R\",  #>             \"R/backend_api-11.ClusterFutureBackend-class.R\",  #>             \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             \"R/backend_api-11.SequentialFutureBackend-class.R\",  #>             \"R/backend_api-13.MultisessionFutureBackend-class.R\" #>             ), FutureCondition.Rd = c(\"R/protected_api-FutureCondition-class.R\",  #>             \"R/protected_api-journal.R\"), FutureGlobals.Rd = \"R/protected_api-FutureGlobals-class.R\",  #>             FutureResult.Rd = \"R/protected_api-FutureResult-class.R\",  #>             `MultiprocessFuture-class.Rd` = \"R/backend_api-03.MultiprocessFutureBackend-class.R\",  #>             `UniprocessFuture-class.Rd` = \"R/backend_api-UniprocessFuture-class.R\",  #>             backtrace.Rd = \"R/utils_api-backtrace.R\", cancel.Rd = \"R/core_api-cancel.R\",  #>             cluster.Rd = \"R/backend_api-11.ClusterFutureBackend-class.R\",  #>             clusterExportSticky.Rd = \"R/utils-sticky_globals.R\",  #>             find_references.Rd = \"R/utils-marshalling.R\", future.Rd = c(\"R/core_api-future.R\",  #>             \"R/utils_api-futureCall.R\", \"R/utils_api-minifuture.R\" #>             ), futureAssign.Rd = c(\"R/delayed_api-futureAssign.R\",  #>             \"R/infix_api-01-futureAssign_OP.R\", \"R/infix_api-02-globals_OP.R\",  #>             \"R/infix_api-03-seed_OP.R\", \"R/infix_api-04-stdout_OP.R\",  #>             \"R/infix_api-05-conditions_OP.R\", \"R/infix_api-06-lazy_OP.R\",  #>             \"R/infix_api-07-label_OP.R\", \"R/infix_api-08-plan_OP.R\",  #>             \"R/infix_api-09-tweak_OP.R\"), futureOf.Rd = \"R/delayed_api-futureOf.R\",  #>             futureSessionInfo.Rd = \"R/utils_api-futureSessionInfo.R\",  #>             futures.Rd = \"R/protected_api-futures.R\", getExpression.Rd = \"R/backend_api-Future-class.R\",  #>             getGlobalsAndPackages.Rd = \"R/protected_api-globals.R\",  #>             makeClusterFuture.Rd = \"R/utils_api-makeClusterFuture.R\",  #>             mandelbrot.Rd = \"R/demo_api-mandelbrot.R\", multicore.Rd = \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             multisession.Rd = \"R/backend_api-13.MultisessionFutureBackend-class.R\",  #>             nbrOfWorkers.Rd = \"R/utils_api-nbrOfWorkers.R\", nullcon.Rd = \"R/utils-basic.R\",  #>             plan.Rd = c(\"R/utils_api-plan.R\", \"R/utils_api-plan-with.R\",  #>             \"R/utils_api-tweak.R\"), private_length.Rd = \"R/utils-basic.R\",  #>             `re-exports.Rd` = \"R/000.re-exports.R\", readImmediateConditions.Rd = \"R/utils-immediateCondition.R\",  #>             requestCore.Rd = \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             reset.Rd = \"R/core_api-reset.R\", resetWorkers.Rd = \"R/utils_api-plan.R\",  #>             resolve.Rd = \"R/protected_api-resolve.R\", resolved.Rd = c(\"R/backend_api-11.ClusterFutureBackend-class.R\",  #>             \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             \"R/core_api-resolved.R\"), result.Rd = \"R/protected_api-result.R\",  #>             run.Rd = \"R/backend_api-Future-class.R\", save_rds.Rd = \"R/utils-immediateCondition.R\",  #>             sequential.Rd = \"R/backend_api-11.SequentialFutureBackend-class.R\",  #>             sessionDetails.Rd = \"R/utils_api-sessionDetails.R\",  #>             signalConditions.Rd = \"R/protected_api-signalConditions.R\",  #>             sticky_globals.Rd = \"R/utils-sticky_globals.R\", usedCores.Rd = \"R/backend_api-11.MulticoreFutureBackend-class.R\",  #>             value.Rd = \"R/core_api-value.R\", `zzz-future.options.Rd` = \"R/utils-options.R\"),  #>         keywords = list(\"internal\", \"internal\", \"internal\", \"internal\",  #>             \"internal\", \"internal\", \"internal\", character(0),  #>             character(0), character(0), \"internal\", \"internal\",  #>             character(0), character(0), character(0), character(0),  #>             character(0), \"internal\", \"internal\", \"internal\",  #>             \"internal\", character(0), character(0), character(0),  #>             \"internal\", character(0), \"internal\", \"internal\",  #>             \"internal\", \"internal\", character(0), \"internal\",  #>             character(0), character(0), \"internal\", \"internal\",  #>             \"internal\", character(0), \"internal\", \"internal\",  #>             \"internal\", \"internal\", character(0), character(0)),  #>         concepts = list(character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0), character(0), character(0), character(0),  #>             character(0)), internal = c(TRUE, TRUE, TRUE, TRUE,  #>         TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE,  #>         FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE,  #>         FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE,  #>         TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE,  #>         TRUE, TRUE, FALSE, FALSE), lifecycle = list(NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,  #>             NULL, NULL, NULL, NULL, NULL, NULL)), tutorials = list( #>         name = character(0), file_out = character(0), title = character(0),  #>         pagetitle = character(0), url = character(0)), vignettes = list( #>         name = c(\"future-1-overview\", \"future-2-output\", \"future-2b-backend\",  #>         \"future-3-topologies\", \"future-4-issues\", \"future-4-non-exportable-objects\",  #>         \"future-5-startup\", \"future-6-future-api-backend-specification\",  #>         \"future-7-for-package-developers\", \"future-8-how-future-is-validated\" #>         ), type = c(\"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\", \"rmd\",  #>         \"rmd\", \"rmd\", \"rmd\", \"rmd\"), file_in = c(\"vignettes/future-1-overview.Rmd\",  #>         \"vignettes/future-2-output.Rmd\", \"vignettes/future-2b-backend.Rmd\",  #>         \"vignettes/future-3-topologies.Rmd\", \"vignettes/future-4-issues.Rmd\",  #>         \"vignettes/future-4-non-exportable-objects.Rmd\", \"vignettes/future-5-startup.Rmd\",  #>         \"vignettes/future-6-future-api-backend-specification.Rmd\",  #>         \"vignettes/future-7-for-package-developers.Rmd\", \"vignettes/future-8-how-future-is-validated.Rmd\" #>         ), file_out = c(\"articles/future-1-overview.html\", \"articles/future-2-output.html\",  #>         \"articles/future-2b-backend.html\", \"articles/future-3-topologies.html\",  #>         \"articles/future-4-issues.html\", \"articles/future-4-non-exportable-objects.html\",  #>         \"articles/future-5-startup.html\", \"articles/future-6-future-api-backend-specification.html\",  #>         \"articles/future-7-for-package-developers.html\", \"articles/future-8-how-future-is-validated.html\" #>         ), title = c(\"A Future for R: A Comprehensive Overview\",  #>         \"A Future for R: Text and Message Output\", \"A Future for R: Available Future Backends\",  #>         \"A Future for R: Future Topologies\", \"A Future for R: Common Issues with Solutions\",  #>         \"A Future for R: Non-Exportable Objects\", \"A Future for R: Controlling Default Future Strategy\",  #>         \"A Future for R: Future API Backend Specification\", \"A Future for R: Best Practices for Package Developers\",  #>         \"A Future for R: How the Future Framework is Validated\" #>         ), description = c(NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_, NA_character_, NA_character_,  #>         NA_character_, NA_character_, NA_character_), depth = c(1L,  #>         1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)))), examples = base::quote(TRUE),  #>     run_dont_run = base::quote(FALSE), seed = base::quote(1014L),  #>     lazy = base::quote(FALSE), override = base::quote(list()),  #>     install = base::quote(FALSE), preview = base::quote(FALSE),  #>     new_process = base::quote(FALSE), devel = base::quote(FALSE),  #>     quiet = base::quote(TRUE), cli_colors = base::quote(16777216L),  #>     hyperlinks = base::quote(TRUE)) #>  #> [[13]] #> pkgdown::build_site(...) #>  #> [[14]] #> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run,  #>     seed = seed, lazy = lazy, override = override, preview = preview,  #>     devel = devel, quiet = quiet) #>  #> [[15]] #> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run,  #>     seed = seed, override = override, preview = FALSE, devel = devel) #>  #> [[16]] #> unwrap_purrr_error(purrr::map(topics, build_reference_topic,  #>     pkg = pkg, lazy = lazy, examples_env = examples_env, run_dont_run = run_dont_run)) #>  #> [[17]] #> withCallingHandlers(code, purrr_error_indexed = function(err) { #>     cnd_signal(err$parent) #> }) #>  #> [[18]] #> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy,  #>     examples_env = examples_env, run_dont_run = run_dont_run) #>  #> [[19]] #> map_(\"list\", .x, .f, ..., .progress = .progress) #>  #> [[20]] #> with_indexed_errors(i = i, names = names, error_call = .purrr_error_call,  #>     call_with_cleanup(map_impl, environment(), .type, .progress,  #>         n, names, i)) #>  #> [[21]] #> withCallingHandlers(expr, error = function(cnd) { #>     if (i == 0L) { #>     } #>     else { #>         message <- c(i = \"In index: {i}.\") #>         if (!is.null(names) && !is.na(names[[i]]) && names[[i]] !=  #>             \"\") { #>             name <- names[[i]] #>             message <- c(message, i = \"With name: {name}.\") #>         } #>         else { #>             name <- NULL #>         } #>         cli::cli_abort(message, location = i, name = name, parent = cnd,  #>             call = error_call, class = \"purrr_error_indexed\") #>     } #> }) #>  #> [[22]] #> call_with_cleanup(map_impl, environment(), .type, .progress,  #>     n, names, i) #>  #> [[23]] #> .f(.x[[i]], ...) #>  #> [[24]] #> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env,  #>     run_dont_run = run_dont_run), error = function(err) { #>     cli::cli_abort(\"Failed to parse Rd in {.file {topic$file_in}}\",  #>         parent = err, call = quote(build_reference())) #> }) #>  #> [[25]] #> data_reference_topic(topic, pkg, examples_env = examples_env,  #>     run_dont_run = run_dont_run) #>  #> [[26]] #> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env)) NULL else new.env(parent = examples_env),  #>     topic = tools::file_path_sans_ext(topic$file_in), run_dont_run = run_dont_run) #>  #> [[27]] #> highlight_examples(code, topic, env = env) #>  #> [[28]] #> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic,  #>     env = eval_env, output_handler = handler) #>  #> [[29]] #> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #>  #> [[30]] #> withRestarts(with_handlers({ #>     for (expr in tle$exprs) { #>         ev <- withVisible(eval(expr, envir)) #>         watcher$capture_plot_and_output() #>         watcher$print_value(ev$value, ev$visible, envir) #>     } #>     TRUE #> }, handlers), eval_continue = function() TRUE, eval_stop = function() FALSE) #>  #> [[31]] #> withRestartList(expr, restarts) #>  #> [[32]] #> withOneRestart(withRestartList(expr, restarts[-nr]), restarts[[nr]]) #>  #> [[33]] #> doWithOneRestart(return(expr), restart) #>  #> [[34]] #> withRestartList(expr, restarts[-nr]) #>  #> [[35]] #> withOneRestart(expr, restarts[[1L]]) #>  #> [[36]] #> doWithOneRestart(return(expr), restart) #>  #> [[37]] #> with_handlers({ #>     for (expr in tle$exprs) { #>         ev <- withVisible(eval(expr, envir)) #>         watcher$capture_plot_and_output() #>         watcher$print_value(ev$value, ev$visible, envir) #>     } #>     TRUE #> }, handlers) #>  #> [[38]] #> eval(call) #>  #> [[39]] #> eval(call) #>  #> [[40]] #> withCallingHandlers(code, message = function (cnd)  #> { #>     watcher$capture_plot_and_output() #>     if (on_message$capture) { #>         watcher$push(cnd) #>     } #>     if (on_message$silence) { #>         invokeRestart(\"muffleMessage\") #>     } #> }, warning = function (cnd)  #> { #>     if (getOption(\"warn\") >= 2 || getOption(\"warn\") < 0) { #>         return() #>     } #>     watcher$capture_plot_and_output() #>     if (on_warning$capture) { #>         cnd <- sanitize_call(cnd) #>         watcher$push(cnd) #>     } #>     if (on_warning$silence) { #>         invokeRestart(\"muffleWarning\") #>     } #> }, error = function (cnd)  #> { #>     watcher$capture_plot_and_output() #>     cnd <- sanitize_call(cnd) #>     watcher$push(cnd) #>     switch(on_error, continue = invokeRestart(\"eval_continue\"),  #>         stop = invokeRestart(\"eval_stop\"), error = NULL) #> }) #>  #> [[41]] #> withVisible(eval(expr, envir)) #>  #> [[42]] #> eval(expr, envir) #>  #> [[43]] #> eval(expr, envir) #>  #> [[44]] #> future({ #>     foo(\"a\") #> }) #>  #> [[45]] #> Future(expr, substitute = FALSE, envir = envir, lazy = TRUE,  #>     seed = seed, globals = globals, packages = packages, stdout = stdout,  #>     conditions = conditions, label = label, onReference = onReference,  #>     ...) #>  #> [[46]] #> eval(expr, envir = globalenv()) #>  #> [[47]] #> eval(expr, envir = globalenv()) #>  #> [[48]] #> local({ #>     { #>         foo(\"a\") #>     } #> }) #>  #> [[49]] #> eval.parent(substitute(eval(quote(expr), envir))) #>  #> [[50]] #> eval(expr, p) #>  #> [[51]] #> eval(expr, p) #>  #> [[52]] #> eval(quote({ #>     { #>         foo(\"a\") #>     } #> }), new.env()) #>  #> [[53]] #> eval(quote({ #>     { #>         foo(\"a\") #>     } #> }), new.env()) #>  #> [[54]] #> foo(\"a\") #>  #> [[55]] #> my_log(...) #>  #> [[56]] #> log(x) #>"},{"path":"https://future.futureverse.org/reference/cancel.html","id":null,"dir":"Reference","previous_headings":"","what":"Cancel a future â€” cancel","title":"Cancel a future â€” cancel","text":"Cancels futures, option interrupt running ones.","code":""},{"path":"https://future.futureverse.org/reference/cancel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cancel a future â€” cancel","text":"","code":"cancel(x, interrupt = TRUE, ...)"},{"path":"https://future.futureverse.org/reference/cancel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cancel a future â€” cancel","text":"x Future. interrupt TRUE, running futures interrupted, future backend supports . ... arguments used S3 methods.","code":""},{"path":"https://future.futureverse.org/reference/cancel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cancel a future â€” cancel","text":"cancel() returns (invisibly) canceled Futures flagging \"canceled\" possibly interrupting well. Canceling lazy finished future effect.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/cancel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cancel a future â€” cancel","text":"","code":"## Set up two parallel workers plan(multisession, workers = 2)  ## Launch two long running futures fs <- lapply(c(1, 2), function(duration) {   future({     Sys.sleep(duration)     42   }) })  ## Wait until at least one of the futures is resolved while (!any(resolved(fs))) Sys.sleep(0.1)  ## Cancel the future that is not yet resolved r <- resolved(fs) cancel(fs[!r])  ## Get the value of the resolved future f <- fs[r] v <- value(f) message(\"Result: \", v) #> Result: 42  ## The value of the canceled future is an error try(v <- value(fs[!r])) #> Error : Future (<unnamed-3>) of class MultisessionFuture was canceled (pid 3874698) [future <unnamed-3> (7a1e043358c85e967b977d36447c9bc8-3); on 7a1e043358c85e967b977d36447c9bc8@hb-x1-2023<3873967> at 2026-01-23 09:31:53.646319]  ## Shut down parallel workers plan(sequential)"},{"path":"https://future.futureverse.org/reference/cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a cluster future whose value will be resolved asynchronously in a parallel process â€” cluster","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process â€” cluster","text":"WARNING: function must never called. may used plan()","code":""},{"path":"https://future.futureverse.org/reference/cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process â€” cluster","text":"","code":"cluster(   ...,   workers = availableWorkers(constraints = \"connections\"),   persistent = FALSE )"},{"path":"https://future.futureverse.org/reference/cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process â€” cluster","text":"workers cluster object, character vector host names, positive numeric scalar, function. character vector numeric scalar, cluster object created using makeClusterPSOCK(workers). function, called without arguments future created value used configure workers. function return types. workers == 1, processing using done current/main R session therefore fall back using sequential future. override fallback, use workers = (1). persistent FALSE, evaluation environment cleared objects prior evaluation future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/cluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process â€” cluster","text":"cluster future future uses cluster evaluation, means value computed resolved parallel another process. function must called directly.  Instead, typical usages :","code":"# Evaluate futures via a single background R process on the local machine plan(cluster, workers = I(1))  # Evaluate futures via two background R processes on the local machine plan(cluster, workers = 2)  # Evaluate futures via a single R process on another machine on on the # local area network (LAN) plan(cluster, workers = \"raspberry-pi\")  # Evaluate futures via a single R process running on a remote machine plan(cluster, workers = \"pi.example.org\")  # Evaluate futures via four R processes, one running on the local machine, # two running on LAN machine 'n1' and one on a remote machine plan(cluster, workers = c(\"localhost\", \"n1\", \"n1\", \"pi.example.org\"))"},{"path":[]},{"path":"https://future.futureverse.org/reference/cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a cluster future whose value will be resolved asynchronously in a parallel process â€” cluster","text":"","code":"# \\donttest{  ## Use cluster futures cl <- parallel::makeCluster(2, timeout = 60) plan(cluster, workers = cl)  ## A global variable a <- 0  ## Create future (explicitly) f <- future({   b <- 3   c <- 2   a * b * c })  ## A cluster future is evaluated in a separate process. ## Regardless, changing the value of a global variable will ## not affect the result of the future. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)  ## CLEANUP parallel::stopCluster(cl)  # }"},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":null,"dir":"Reference","previous_headings":"","what":"Export globals to the sticky-globals environment of the cluster nodes â€” clusterExportSticky","title":"Export globals to the sticky-globals environment of the cluster nodes â€” clusterExportSticky","text":"Export globals sticky-globals environment cluster nodes","code":""},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export globals to the sticky-globals environment of the cluster nodes â€” clusterExportSticky","text":"","code":"clusterExportSticky(cl, globals)"},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export globals to the sticky-globals environment of the cluster nodes â€” clusterExportSticky","text":"cl (cluster) cluster object returned parallel::makeCluster(). globals (list) named list sticky globals exported.","code":""},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export globals to the sticky-globals environment of the cluster nodes â€” clusterExportSticky","text":"(invisible; cluster) cluster object.","code":""},{"path":"https://future.futureverse.org/reference/clusterExportSticky.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export globals to the sticky-globals environment of the cluster nodes â€” clusterExportSticky","text":"requires future package installed cluster nodes.","code":""},{"path":"https://future.futureverse.org/reference/find_references.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the first or all references of an R object â€” find_references","title":"Get the first or all references of an R object â€” find_references","text":"Get first references R object Assert references among identified globals","code":""},{"path":"https://future.futureverse.org/reference/find_references.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the first or all references of an R object â€” find_references","text":"","code":"find_references(x, first_only = FALSE)  assert_no_references(   x,   action = c(\"error\", \"warning\", \"message\", \"string\"),   source = c(\"globals\", \"value\") )"},{"path":"https://future.futureverse.org/reference/find_references.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the first or all references of an R object â€” find_references","text":"x R object checked. first_only TRUE, first reference returned, otherwise references. action Type action take reference found. source source x globals value future?","code":""},{"path":"https://future.futureverse.org/reference/find_references.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the first or all references of an R object â€” find_references","text":"find_references() returns list zero references identified. reference detected, informative error, warning, message, character string produced, otherwise NULL returned invisibly.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a future â€” future","title":"Create a future â€” future","text":"Creates future evaluates R expression future calls R function set arguments. , , futures evaluated can configured using plan() evaluated parallel , instance, current machine, remote machine, via job queue compute cluster. Importantly, R code using futures remains regardless settings need modify code switching , say, sequential parallel processing.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a future â€” future","text":"","code":"future(   expr,   envir = parent.frame(),   substitute = TRUE,   lazy = FALSE,   seed = FALSE,   globals = TRUE,   packages = NULL,   stdout = TRUE,   conditions = \"condition\",   label = NULL,   ... )  futureCall(   FUN,   args = list(),   envir = parent.frame(),   lazy = FALSE,   seed = FALSE,   globals = TRUE,   packages = NULL,   stdout = TRUE,   conditions = \"condition\",   label = NULL,   ... )  minifuture(   expr,   substitute = TRUE,   globals = NULL,   packages = NULL,   stdout = NA,   conditions = NULL,   seed = NULL,   ...,   envir = parent.frame() )"},{"path":"https://future.futureverse.org/reference/future.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a future â€” future","text":"expr R expression. envir environment global objects identified. substitute TRUE, argument expr substitute():d, otherwise . lazy FALSE (default), future resolved eagerly (starting immediately), otherwise . seed (optional) TRUE, random seed, , state random number generator (RNG) set statistically sound random numbers produced (also parallelization). FALSE (default), assumed future expression neither needs uses random number generation. use fixed random seed, specify L'Ecuyer-CMRG seed (seven integers) regular RNG seed (single integer).  latter, L'Ecuyer-CMRG seed automatically created based given seed. Furthermore, FALSE, future monitored make sure use random numbers.  depending value option future.rng.onMisuse, check ignored, informative warning, error produced. seed NULL, effect seed = FALSE without RNG check performed. globals (optional) logical, character vector, named list control globals handled. details, see section 'Globals used future expressions' help future(). packages (optional) character vector specifying packages attached R environment evaluating future. stdout TRUE (default), standard output captured, re-outputted value() called. FALSE, output silenced (sinking null device outputted). Using stdout = structure(TRUE, drop = TRUE) causes captured standard output dropped future object soon relayed. can help decrease overall memory consumed captured output across futures. Using stdout = NA fully avoids intercepting standard output; behavior unhandled standard output depends future backend. conditions character string condition classes captured relayed.  default relay conditions, including messages warnings.  drop conditions, use conditions = character(0). Errors always relayed. Attribute exclude can used ignore specific classes, e.g. conditions = structure(\"condition\", exclude = \"message\") capture condition classes except inherit message class. Using conditions = structure(..., drop = TRUE) causes captured conditions dropped future object soon relayed, e.g. value(f). can help decrease overall memory consumed captured conditions across futures. Using conditions = NULL (recommended) avoids intercepting conditions, except errors; behavior unhandled conditions depends future backend environment R runs. label character string label attached future. FUN function evaluated. args list arguments passed function FUN. ... Additional arguments passed Future().","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a future â€” future","text":"future() returns Future evaluates expression expr. futureCall() returns Future calls function FUN arguments args. minifuture(expr) creates future minimal overhead, disabling user-friendly behaviors, e.g. automatic identification global variables packages needed, relaying output. Unless good reasons using function, please use future() instead. function exists mainly purpose profiling identifying automatic features future() introduce extra overhead.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a future â€” future","text":"state future either unresolved resolved. value future can retrieved using v <- value(f). Querying value non-resolved future block call future resolved. possible check whether future resolved without blocking using resolved(f). possible cancel() future resolved. Failed, canceled, interrupted futures can reset() lazy, vanilla future can relaunched. futureCall() function works analogously .call(), calls function set arguments.  difference .call() returns value call whereas futureCall() returns future.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"eager-or-lazy-evaluation","dir":"Reference","previous_headings":"","what":"Eager or lazy evaluation","title":"Create a future â€” future","text":"default, future resolved using eager evaluation (lazy = FALSE).  means expression starts evaluated soon future created. alternative, future can resolved using lazy evaluation (lazy = TRUE).  means expression evaluated value future requested. Note means expression may evaluated - guaranteed evaluated value requested.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"globals-used-by-future-expressions","dir":"Reference","previous_headings":"","what":"Globals used by future expressions","title":"Create a future â€” future","text":"Global objects (short globals) objects (e.g. variables functions) needed order future expression evaluated local objects defined future expression. example, variable global future assignment f whereas b local variable. order future resolved successfully (correctly), globals need gathered future created available whenever wherever future resolved. default behavior (globals = TRUE), globals automatically identified gathered. precisely, globals identified via code inspection future expression expr values retrieved environment envir starting point (basically via get(global, envir = envir, inherits = TRUE)). cases, automatic collection globals sufficient less tedious error prone manually specified. However, full control, also possible explicitly specify exactly globals providing names character vector. example, use Yet another alternative explicitly also specify values using named list Specifying globals explicitly avoids overhead added automatically identifying globals gathering values. Furthermore, know future expression make use global variables, can disable automatic search globals using Future expressions often make use functions one packages. long functions part set globals, future package make sure packages attached future resolved.  need globals frozen exported, future package export , reduces amount transferred objects. example, variable x median() globals, x exported whereas median(), part stats package, exported.  Instead made sure stats package search path future expression evaluated. Effectively, becomes manually specify , one can either effectively . Although rarely needed, combination automatic identification manual specification globals supported via attributes add (add false negatives) ignore (ignore false positives) value TRUE.  example, globals = structure(TRUE, ignore = \"b\", add = \"\") globals automatically identified, except b, used, addition global .","code":"a <- 42   f <- future({ b <- 2; a * b }) a <- 42   f <- future({ b <- 2; a * b }, globals = \"a\") a <- 42   f <- future({ b <- 2; a * b }, globals = list(a = a)) f <- future({ b <- 2; a * b }, globals = list(a = 42)) f <- future({ a <- 42; b <- 2; a * b }, globals = FALSE) x <- rnorm(1000)   f <- future({ median(x) }) x <- rnorm(1000)   f <- future({     library(stats)     median(x)   }) x <- rnorm(1000)   f <- future({     median(x)   }, globals = list(x = x, median = stats::median) x <- rnorm(1000)   f <- future({     library(stats)     median(x)   }, globals = list(x = x))"},{"path":[]},{"path":"https://future.futureverse.org/reference/future.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a future â€” future","text":"future logo designed Dan LaBar tweaked Henrik Bengtsson.","code":""},{"path":"https://future.futureverse.org/reference/future.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a future â€” future","text":"","code":"## Evaluate futures in parallel plan(multisession)  ## Data x <- rnorm(100) y <- 2 * x + 0.2 + rnorm(100) w <- 1 + x ^ 2   ## EXAMPLE: Regular assignments (evaluated sequentially) fitA <- lm(y ~ x, weights = w)      ## with offset fitB <- lm(y ~ x - 1, weights = w)  ## without offset fitC <- {   w <- 1 + abs(x)  ## Different weights   lm(y ~ x, weights = w) } print(fitA) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>       0.338        1.977   #>  print(fitB) #>  #> Call: #> lm(formula = y ~ x - 1, weights = w) #>  #> Coefficients: #>     x   #> 1.993   #>  print(fitC) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.3408       1.9513   #>    ## EXAMPLE: Future assignments (evaluated in parallel) fitA %<-% lm(y ~ x, weights = w)      ## with offset fitB %<-% lm(y ~ x - 1, weights = w)  ## without offset fitC %<-% {   w <- 1 + abs(x)   lm(y ~ x, weights = w) } print(fitA) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.3408       1.9513   #>  print(fitB) #>  #> Call: #> lm(formula = y ~ x - 1, weights = w) #>  #> Coefficients: #>     x   #> 1.971   #>  print(fitC) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.3408       1.9513   #>    ## EXAMPLE: Explicitly create futures (evaluated in parallel) ## and retrieve their values fA <- future( lm(y ~ x, weights = w) ) fB <- future( lm(y ~ x - 1, weights = w) ) fC <- future({   w <- 1 + abs(x)   lm(y ~ x, weights = w) }) fitA <- value(fA) fitB <- value(fB) fitC <- value(fC) print(fitA) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.3408       1.9513   #>  print(fitB) #>  #> Call: #> lm(formula = y ~ x - 1, weights = w) #>  #> Coefficients: #>     x   #> 1.971   #>  print(fitC) #>  #> Call: #> lm(formula = y ~ x, weights = w) #>  #> Coefficients: #> (Intercept)            x   #>      0.3408       1.9513   #>   ## EXAMPLE: futureCall() and do.call() x <- 1:100 y0 <- do.call(sum, args = list(x)) print(y0) #> [1] 5050  f1 <- futureCall(sum, args = list(x)) y1 <- value(f1) print(y1) #> [1] 5050"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a future assignment â€” futureAssign","title":"Create a future assignment â€” futureAssign","text":"x %<-% value (also known \"future assignment\") futureAssign(\"x\", value) create Future evaluates expression (value) binds variable x (promise). expression evaluated parallel background. Later , x first queried, value future automatically retrieved regular variable x materialized regular value.","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a future assignment â€” futureAssign","text":"","code":"futureAssign(   x,   value,   envir = parent.frame(),   substitute = TRUE,   lazy = FALSE,   seed = FALSE,   globals = TRUE,   packages = NULL,   stdout = TRUE,   conditions = \"condition\",   label = NULL,   ...,   assign.env = envir )  x %<-% value  fassignment %globals% globals fassignment %packages% packages  fassignment %seed% seed  fassignment %stdout% capture  fassignment %conditions% capture  fassignment %lazy% lazy  fassignment %label% label  fassignment %plan% strategy  fassignment %tweak% tweaks"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a future assignment â€” futureAssign","text":"x name future variable, hold value future expression (promise). value R expression. envir environment global objects identified. substitute TRUE, argument expr substitute():d, otherwise . lazy FALSE (default), future resolved eagerly (starting immediately), otherwise . seed (optional) TRUE, random seed, , state random number generator (RNG) set statistically sound random numbers produced (also parallelization). FALSE (default), assumed future expression neither needs uses random number generation. use fixed random seed, specify L'Ecuyer-CMRG seed (seven integers) regular RNG seed (single integer).  latter, L'Ecuyer-CMRG seed automatically created based given seed. Furthermore, FALSE, future monitored make sure use random numbers.  depending value option future.rng.onMisuse, check ignored, informative warning, error produced. seed NULL, effect seed = FALSE without RNG check performed. globals (optional) logical, character vector, named list control globals handled. details, see section 'Globals used future expressions' help future(). packages (optional) character vector specifying packages attached R environment evaluating future. stdout TRUE (default), standard output captured, re-outputted value() called. FALSE, output silenced (sinking null device outputted). Using stdout = structure(TRUE, drop = TRUE) causes captured standard output dropped future object soon relayed. can help decrease overall memory consumed captured output across futures. Using stdout = NA fully avoids intercepting standard output; behavior unhandled standard output depends future backend. conditions character string condition classes captured relayed.  default relay conditions, including messages warnings.  drop conditions, use conditions = character(0). Errors always relayed. Attribute exclude can used ignore specific classes, e.g. conditions = structure(\"condition\", exclude = \"message\") capture condition classes except inherit message class. Using conditions = structure(..., drop = TRUE) causes captured conditions dropped future object soon relayed, e.g. value(f). can help decrease overall memory consumed captured conditions across futures. Using conditions = NULL (recommended) avoids intercepting conditions, except errors; behavior unhandled conditions depends future backend environment R runs. label character string label attached future. assign.env environment variable assigned. fassignment future assignment, e.g. x %<-% { expr }. capture TRUE, standard output captured, otherwise . strategy backend controlling future resolved. See plan() details. tweaks named list (vector) arguments changed relative current backend. ... Additional arguments passed Future().","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a future assignment â€” futureAssign","text":"futureAssign() x %<-% expr returns Future invisibly, e.g. f <- futureAssign(\"x\", expr) f <- (x %<-% expr).","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a future assignment â€” futureAssign","text":"future created via future assignment, x %<-% value futureAssign(\"x\", value), value bound promise, queried internally call value()  future resolved regular variable bound value. example, future assignment x %<-% value, first time variable x queried call blocks , , future yet resolved. soon resolved, succeeding queries, querying x immediately give value. future assignment construct x %<-% value formal assignment per se, binary infix operator objects x expression value. However, using non-standard evaluation, construct can emulate assignment operator similar x <- value. Due R's precedence rules operators, future expressions often need explicitly bracketed, e.g. x %<-% { + b }.","code":""},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"adjust-future-arguments-of-a-future-assignment","dir":"Reference","previous_headings":"","what":"Adjust future arguments of a future assignment","title":"Create a future assignment â€” futureAssign","text":"future() futureAssign() take several arguments can used explicitly specify global variables packages future use. can also used override default behaviors future, e.g. whether output relayed . using future assignment, arguments can specified via corresponding assignment expression.  example, x %<-% { rnorm(10) } %seed% TRUE corresponds futureAssign(\"x\", { rnorm(10) }, seed = TRUE). several examples. explicitly specify variables functions future assignment use, use %globals%. explicitly specify packages need attached evaluation succeed, use %packages%. example,   median() function part 'stats' package. declare generate random numbers, use %seed%, e.g.   disable relaying standard output (e.g. print(), cat(), str()), keeping relaying conditions (e.g. message()   disable relaying conditions, use %conditions%, e.g.     create future without launching processed value really needed, use %lazy%, e.g.","code":"> x <- rnorm(1000) > y %<-% { median(x) } %globals% list(x = x) %packages% \"stats\" > y [1] -0.03956372 > x %<-% { rnorm(3) } %seed% TRUE > x [1] -0.2590562 -1.2262495  0.8858702 > x %<-% { cat(\"Hello\\n\"); message(\"Hi there\"); 42 } %stdout% FALSE > y <- 13 > z <- x + y Hi there > z [1] 55 > x %<-% { cat(\"Hello\\n\"); message(\"Hi there\"); 42 } %conditions% character(0) > y <- 13 > z <- x + y Hello > z [1] 55 > x %<-% { print(1:10); message(\"Hello\"); 42 } %stdout% FALSE > y <- 13 > z <- x + y Hello > z [1] 55 > x %<-% { Sys.sleep(5); 42 } %lazy% TRUE > y <- sum(1:10) > system.time(z <- x + y)   user  system elapsed   0.004   0.000   5.008 > z [1] 97"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"error-handling","dir":"Reference","previous_headings":"","what":"Error handling","title":"Create a future assignment â€” futureAssign","text":"future assignments promises, errors produced future expression signaled value future requested. example, create future assignment produces error, affected error \"touch\" future-assignment variable. example,","code":"> x %<-% { stop(\"boom\") } > y <- sum(1:10) > z <- x + y Error in eval(quote({ : boom"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"use-alternative-future-backend-for-future-assignment","dir":"Reference","previous_headings":"","what":"Use alternative future backend for future assignment","title":"Create a future assignment â€” futureAssign","text":"Futures evaluated future backend user specified plan(). regular futures, can temporarily use another future backend wrapping code (plan(...), { ... }), temporarily inside function using (plan(...), local = TRUE). achieve specific future assignment, use %plan%, e.g.   x resolved background via multisession backend, whereas y resolved sequentially main R session.","code":"> plan(multisession) > x %<-% { 42 } > y %<-% { 13 } %plan% sequential > z <- x + y > z [1] 55"},{"path":"https://future.futureverse.org/reference/futureAssign.html","id":"getting-the-future-object-of-a-future-assignment","dir":"Reference","previous_headings":"","what":"Getting the future object of a future assignment","title":"Create a future assignment â€” futureAssign","text":"underlying Future future variable x can retrieved without blocking using f <- futureOf(x), e.g.   Technically, future variable (promise) assigned time environment assign.env name future .future_<name>.","code":"> x %<-% { stop(\"boom\") } > f_x <- futureOf(x) > resolved(f_x) [1] TRUE > x Error in eval(quote({ : boom > value(f_x) Error in eval(quote({ : boom"},{"path":"https://future.futureverse.org/reference/futureOf.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the future of a future variable â€” futureOf","title":"Get the future of a future variable â€” futureOf","text":"Get future future variable created directly indirectly via future().","code":""},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the future of a future variable â€” futureOf","text":"","code":"futureOf(   var = NULL,   envir = parent.frame(),   mustExist = TRUE,   default = NA,   drop = FALSE )"},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the future of a future variable â€” futureOf","text":"var variable.  NULL, futures environment returned. envir environment search . mustExist TRUE variable exist, informative error thrown, otherwise NA returned. default default value future found. drop TRUE var NULL, returned list contains futures, otherwise also default values.","code":""},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the future of a future variable â€” futureOf","text":"Future (default). var NULL, named list Future:s returned.","code":""},{"path":"https://future.futureverse.org/reference/futureOf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the future of a future variable â€” futureOf","text":"","code":"a %<-% { 1 }  f <- futureOf(a) print(f) #> SequentialFuture: #> Label: <unnamed-12> #> Expression: #> { #>     1 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-12 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001761675 secs (started 2026-01-23 09:31:58.806846) #> Worker process: 7a1e043358c85e967b977d36447c9bc8  b %<-% { 2 }  f <- futureOf(b) print(f) #> SequentialFuture: #> Label: <unnamed-13> #> Expression: #> { #>     2 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-13 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001641512 secs (started 2026-01-23 09:31:58.813393) #> Worker process: 7a1e043358c85e967b977d36447c9bc8  ## All futures fs <- futureOf() print(fs) #> $a #> SequentialFuture: #> Label: <unnamed-12> #> Expression: #> { #>     1 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-12 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001761675 secs (started 2026-01-23 09:31:58.806846) #> Worker process: 7a1e043358c85e967b977d36447c9bc8 #>  #> $b #> SequentialFuture: #> Label: <unnamed-13> #> Expression: #> { #>     2 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-13 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001641512 secs (started 2026-01-23 09:31:58.813393) #> Worker process: 7a1e043358c85e967b977d36447c9bc8 #>  #> $f #> SequentialFuture: #> Label: <unnamed-13> #> Expression: #> { #>     2 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-13 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001641512 secs (started 2026-01-23 09:31:58.813393) #> Worker process: 7a1e043358c85e967b977d36447c9bc8 #>    ## Futures part of environment env <- new.env() env$c %<-% { 3 }  f <- futureOf(env$c) print(f) #> SequentialFuture: #> Label: <unnamed-14> #> Expression: #> { #>     3 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-14 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001682758 secs (started 2026-01-23 09:31:58.821153) #> Worker process: 7a1e043358c85e967b977d36447c9bc8  f2 <- futureOf(c, envir = env) print(f2) #> SequentialFuture: #> Label: <unnamed-14> #> Expression: #> { #>     3 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-14 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001682758 secs (started 2026-01-23 09:31:58.821153) #> Worker process: 7a1e043358c85e967b977d36447c9bc8  f3 <- futureOf(\"c\", envir = env) print(f3) #> SequentialFuture: #> Label: <unnamed-14> #> Expression: #> { #>     3 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-14 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001682758 secs (started 2026-01-23 09:31:58.821153) #> Worker process: 7a1e043358c85e967b977d36447c9bc8  fs <- futureOf(envir = env) print(fs) #> $c #> SequentialFuture: #> Label: <unnamed-14> #> Expression: #> { #>     3 #> } #> Globals: <none> #> Packages: <none> #> L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE) #> Capture standard output: TRUE #> Capture condition classes: â€˜conditionâ€™ (excluding â€˜<none>â€™) #> Immediate condition classes: â€˜immediateConditionâ€™ #> Lazy evaluation: FALSE #> Local evaluation: TRUE #> Early signaling: FALSE #> Actions: [n=1] â€˜runâ€™ #> State: â€˜finishedâ€™ (\"Future was resolved successfully\") #> Resolved: TRUE #> Unique identifier: 7a1e043358c85e967b977d36447c9bc8-14 #> Owner process: 7a1e043358c85e967b977d36447c9bc8 #> Class: â€˜SequentialFutureâ€™, â€˜UniprocessFutureâ€™, â€˜Futureâ€™ #> Value: 39 bytes of class â€˜numericâ€™ #> Duration: 0.001682758 secs (started 2026-01-23 09:31:58.821153) #> Worker process: 7a1e043358c85e967b977d36447c9bc8 #>"},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Get future-specific session information and validate current backend â€” futureSessionInfo","title":"Get future-specific session information and validate current backend â€” futureSessionInfo","text":"Get future-specific session information validate current backend","code":""},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get future-specific session information and validate current backend â€” futureSessionInfo","text":"","code":"futureSessionInfo(test = TRUE, anonymize = TRUE)"},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get future-specific session information and validate current backend â€” futureSessionInfo","text":"test TRUE, one futures created query workers validate information. anonymize TRUE, user names host names anonymized.","code":""},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get future-specific session information and validate current backend â€” futureSessionInfo","text":"Nothing.","code":""},{"path":"https://future.futureverse.org/reference/futureSessionInfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get future-specific session information and validate current backend â€” futureSessionInfo","text":"","code":"plan(multisession, workers = 2) futureSessionInfo() #> *** Package versions #> future 1.69.0.9002, parallelly 1.46.1.9003, parallel 4.5.2, globals 0.18.0.9004, listenv 0.10.0.9002 #>  #> *** Allocations #> availableCores(): #>            system /proc/self/status             nproc  #>                 8                 8                 8  #> availableWorkers(): #> $nproc #> [1] \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" #> [7] \"localhost\" \"localhost\" #>  #> $system #> [1] \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" \"localhost\" #> [7] \"localhost\" \"localhost\" #>  #> *** Settings #> - future.plan=<not set> #> - future.fork.multithreading.enable=<not set> #> - future.globals.maxSize=<not set> #> - future.globals.onReference=<not set> #> - future.resolve.recursive=<not set> #> - future.rng.onMisuse=<not set> #> - future.wait.timeout=<not set> #> - future.wait.interval=<not set> #> - future.wait.alpha=<not set> #> - future.startup.script=FALSE #>  #> *** Backends #> Number of workers: 2 #> List of future strategies: #> 1. multisession: #>    - args: function (..., workers = 2) #>    - tweaked: TRUE #>    - call: plan(multisession, workers = 2) #>  #> *** Basic tests #> Main R session details: #>       pid     r sysname           release #> 1 3873967 4.5.2   Linux 6.14.0-37-generic #>                                                            version nodename #> 1 #37~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 20 10:25:38 UTC 2  host001 #>   machine   login    user effective_user #> 1  x86_64 user001 user001        user001 #> Worker R session details: #>   worker     pid     r sysname           release #> 1      1 3875377 4.5.2   Linux 6.14.0-37-generic #> 2      2 3875378 4.5.2   Linux 6.14.0-37-generic #>                                                            version nodename #> 1 #37~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 20 10:25:38 UTC 2  host001 #> 2 #37~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 20 10:25:38 UTC 2  host001 #>   machine   login    user effective_user #> 1  x86_64 user001 user001        user001 #> 2  x86_64 user001 user001        user001 #> Number of unique worker PIDs: 2 (as expected) plan(sequential)"},{"path":"https://future.futureverse.org/reference/futures.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all futures in a container â€” futures","title":"Get all futures in a container â€” futures","text":"Gets futures environment, list, list environment returns object class (dimensions). Non-future elements returned .","code":""},{"path":"https://future.futureverse.org/reference/futures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all futures in a container â€” futures","text":"","code":"futures(x, ...)"},{"path":"https://future.futureverse.org/reference/futures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all futures in a container â€” futures","text":"x environment, list, list environment. ... used.","code":""},{"path":"https://future.futureverse.org/reference/futures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all futures in a container â€” futures","text":"object type x names /dimensions, set.","code":""},{"path":"https://future.futureverse.org/reference/futures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get all futures in a container â€” futures","text":"function useful retrieve futures created via future assignments (%<-%) therefore stored promises. function turns promises standard Future objects.","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":null,"dir":"Reference","previous_headings":"","what":"Inject code for the next type of future to use for nested futures â€” getExpression","title":"Inject code for the next type of future to use for nested futures â€” getExpression","text":"Inject code next type future use nested futures","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inject code for the next type of future to use for nested futures â€” getExpression","text":"","code":"getExpression(future, ...)"},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inject code for the next type of future to use for nested futures â€” getExpression","text":"future Current future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inject code for the next type of future to use for nested futures â€” getExpression","text":"future expression code injected set type future use nested futures, iff .","code":""},{"path":"https://future.futureverse.org/reference/getExpression.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inject code for the next type of future to use for nested futures â€” getExpression","text":"future backend specified one, default use sequential futures.  conservative approach protects spawning recursive futures mistake, especially multicore multisession ones. default also set options(mc.cores = 1L) (*) parallel R processes spawned functions parallel::mclapply() friends. Currently possible specify type nested futures used, meaning default always used. See Issue #37 plans adding support custom nested future types. (*) Ideally set mc.cores = 0 unfortunately cause mclapply() friends generate error saying \"'mc.cores' must >= 1\".  Ideally functions fall back using non-multicore alternative case, e.g. mclapply(...) => lapply(...). See https://github.com/HenrikBengtsson/Wishlist--R/issues/7 discussion .","code":""},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieves global variables of an expression and their associated packages â€” getGlobalsAndPackages","title":"Retrieves global variables of an expression and their associated packages â€” getGlobalsAndPackages","text":"Retrieves global variables expression associated packages","code":""},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieves global variables of an expression and their associated packages â€” getGlobalsAndPackages","text":"","code":"getGlobalsAndPackages(   expr,   envir = parent.frame(),   tweak = tweakExpression,   globals = TRUE,   locals = getOption(\"future.globals.globalsOf.locals\", TRUE),   resolve = getOption(\"future.globals.resolve\"),   persistent = FALSE,   maxSize = getOption(\"future.globals.maxSize\", 500 * 1024^2),   onReference = getOption(\"future.globals.onReference\", \"ignore\"),   ... )"},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieves global variables of an expression and their associated packages â€” getGlobalsAndPackages","text":"expr R expression whose globals found. envir environment globals searched. tweak (optional) function takes expression returned modified one. globals (optional) logical, character vector, named list, Globals object.  TRUE, globals identified code inspection based expr tweak searching environment envir.  FALSE, globals used.  character vector, globals identified lookup based names globals searching environment envir.  named list Globals object, globals used . locals globals part \"local\" environment function included ? resolve TRUE, future global variables (part one) resolved replaced \"constant\" future. persistent TRUE, non-existing globals (= identified expression found memory) always silently ignored assumed existing evaluation environment.  FALSE, non-existing globals default ignored, may also trigger informative error option future.globals.onMissing \"error\" (used troubleshooting). maxSize maximum allowed total size (bytes) globalsâ€”purpose preventing large exports / transfers happening mistake.  total size global objects greater limit, informative error message produced. maxSize = +Inf, assertion skipped. (Default: 500 MiB). ... used.","code":""},{"path":"https://future.futureverse.org/reference/getGlobalsAndPackages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieves global variables of an expression and their associated packages â€” getGlobalsAndPackages","text":"named list elements expr (tweaked expression), globals (named list class FutureGlobals) packages (character string).","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"WARNING: Please note sets stateless set cluster nodes, means clusterEvalQ(cl, { <- 3.14 }) work. Consider first beta version use great care, particularly stateless nature cluster. now, recommend manually validate can get identical results using cluster type get using classical parallel::makeCluster() cluster type.","code":""},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"","code":"makeClusterFuture(specs = nbrOfWorkers(), ...)"},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"specs Ignored. specified, value equal nbrOfWorkers() (default). missing value corresponds specifying nbrOfWorkers(). argument exists support parallel::makeCluster(NA, type = future::FUTURE). ... Named arguments passed future().","code":""},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"Returns parallel cluster object class FutureCluster.","code":""},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"future-clusters-are-stateless","dir":"Reference","previous_headings":"","what":"Future Clusters are Stateless","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"Traditionally, cluster nodes one--one mapping cluster worker process. example, cl <- makeCluster(2, type = \"PSOCK\") launches two parallel worker processes background, cluster node cl[[1]] maps worker #1 node cl[[2]] worker #2, never changes lifespan workers. one--one mapping allows deterministic configuration workers. examples, code may assign globals values specific worker, e.g. clusterEvalQ(cl[1], { <- 3.14 }) clusterEvalQ(cl[2], { <- 2.71 }). contrast, one--one mapping cluster nodes parallel workers using future cluster. make assumptions parallel task processed. parallel task processes future backend decide - backends deterministically, whereas others resolves task first available worker. Also, worker processes might transient future backends, .e. exist life-span parallel task terminates. , one must rely node-specific behaviors, concept make sense future cluster. protect , attempt address subset future cluster nodes, results error, e.g. clusterEvalQ(cl[1], ...), clusterEvalQ(cl[1:2], ...), clusterEvalQ(cl[2:1], ...) example give error. Exceptions latter limitation clusterSetRNGStream() clusterExport(), can safely used future clusters. See details.","code":""},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"clustersetrngstream","dir":"Reference","previous_headings":"","what":"clusterSetRNGStream","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"parallel::clusterSetRNGStream() distributes \"L'Ecuyer-CMRG\" RNG streams cluster nodes, record next round futures use . used, RNG state futures resolved recorded accordingly, next round future use , . strategy makes sure clusterSetRNGStream() expected effect although futures stateless.","code":""},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"clusterexport","dir":"Reference","previous_headings":"","what":"clusterExport","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"parallel::clusterExport() assign values cluster nodes. Specifically, values recorded used globals futures created .","code":""},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"clusterevalq","dir":"Reference","previous_headings":"","what":"clusterEvalQ","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"clusterEvalQ() called, call ignored, error produced. error can de-escalated warning setting R option future.ClusterFuture.clusterEvalQ \"warning\".","code":""},{"path":"https://future.futureverse.org/reference/makeClusterFuture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Future Cluster of Stateless Workers for Parallel Processing â€” makeClusterFuture","text":"","code":"plan(multisession) cl <- makeClusterFuture()  parallel::clusterSetRNGStream(cl)  y <- parallel::parLapply(cl, 11:13, function(x) {   message(\"Process ID: \", Sys.getpid())   mean(rnorm(n = x)) }) #> Process ID: 3875553 #> Process ID: 3875550 #> Process ID: 3875551 str(y) #> List of 3 #>  $ : num 0.0146 #>  $ : num -0.239 #>  $ : num -0.918  plan(sequential)"},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":null,"dir":"Reference","previous_headings":"","what":"Mandelbrot convergence counts â€” mandelbrot","title":"Mandelbrot convergence counts â€” mandelbrot","text":"Mandelbrot convergence counts","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mandelbrot convergence counts â€” mandelbrot","text":"","code":"mandelbrot(...)  # S3 method for class 'matrix' mandelbrot(Z, maxIter = 200L, tau = 2, ...)  # S3 method for class 'numeric' mandelbrot(   xmid = -0.75,   ymid = 0,   side = 3,   resolution = 400L,   maxIter = 200L,   tau = 2,   ... )"},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mandelbrot convergence counts â€” mandelbrot","text":"Z complex matrix convergence counts calculated. maxIter Maximum number iterations per bin. tau threshold; radius calling divergence (Mod(z) > tau). xmid, ymid, side, resolution Alternative specification complex plane Z, mean(Re(Z)) == xmid, mean(Im(Z)) == ymid, diff(range(Re(Z))) == side, diff(range(Im(Z))) == side, dim(Z) == c(resolution, resolution).","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mandelbrot convergence counts â€” mandelbrot","text":"Returns integer matrix (class Mandelbrot) non-negative counts.","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mandelbrot convergence counts â€” mandelbrot","text":"internal Mandelbrot algorithm inspired adopted similar GPL code Martin Maechler available ftp://stat.ethz.ch/U/maechler/R/ 2005-02-18 (sic!).","code":""},{"path":"https://future.futureverse.org/reference/mandelbrot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mandelbrot convergence counts â€” mandelbrot","text":"","code":"counts <- mandelbrot(xmid = -0.75, ymid = 0, side = 3) str(counts) #>  'Mandelbrot' int [1:400, 1:400] 1 1 1 1 1 1 1 1 1 1 ... #>  - attr(*, \"params\")=List of 3 #>   ..$ Z      : cplx [1:400, 1:400] -2.25-1.5i -2.25-1.49i -2.25-1.48i ... #>   ..$ maxIter: int 200 #>   ..$ tau    : num 2 if (FALSE) { # \\dontrun{ plot(counts) } # }  if (FALSE) { # \\dontrun{ demo(\"mandelbrot\", package = \"future\", ask = FALSE) } # }"},{"path":"https://future.futureverse.org/reference/multicore.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process â€” multicore","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process â€” multicore","text":"WARNING: function must never called. may used plan()","code":""},{"path":"https://future.futureverse.org/reference/multicore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process â€” multicore","text":"","code":"multicore(..., workers = availableCores(constraints = \"multicore\"))"},{"path":"https://future.futureverse.org/reference/multicore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process â€” multicore","text":"workers number parallel processes use. function, called without arguments future created value used configure workers. workers == 1, processing using done current/main R session therefore fall back using sequential future. override fallback, use workers = (1). ... used.","code":""},{"path":"https://future.futureverse.org/reference/multicore.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process â€” multicore","text":"multicore future future uses multicore evaluation, means value computed resolved parallel another process. function must called directly.  Instead, typical usages :","code":"# Evaluate futures in parallel on the local machine via as many forked # processes as available to the current R process plan(multicore)  # Evaluate futures in parallel on the local machine via two forked processes plan(multicore, workers = 2)"},{"path":"https://future.futureverse.org/reference/multicore.html","id":"support-for-forked-multicore-processing","dir":"Reference","previous_headings":"","what":"Support for forked (\"multicore\") processing","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process â€” multicore","text":"operating systems support process forking thereby multicore futures.  instance, forking supported Microsoft Windows. Moreover, process forking may break R environments RStudio. , future package disables process forking also cases.  See parallelly::supportsMulticore() details. Trying create multicore futures non-supported systems forking disabled result multicore futures falling back becoming sequential futures.  used RStudio, informative warning:","code":"> plan(multicore) Warning message: In supportsMulticoreAndRStudio(...) :   [ONE-TIME WARNING] Forked processing ('multicore') is not supported when running R from RStudio because it is considered unstable. For more details, how to control forked processing or not, and how to silence this warning in future R sessions, see ?parallelly::supportsMulticore"},{"path":[]},{"path":"https://future.futureverse.org/reference/multicore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a multicore future whose value will be resolved asynchronously in a forked parallel process â€” multicore","text":"","code":"## Use multicore futures plan(multicore)  ## A global variable a <- 0  ## Create future (explicitly) f <- future({   b <- 3   c <- 2   a * b * c })  ## A multicore future is evaluated in a separate forked ## process.  Changing the value of a global variable ## will not affect the result of the future. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)"},{"path":"https://future.futureverse.org/reference/multisession.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a multisession future whose value will be resolved asynchronously in a parallel R session â€” multisession","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session â€” multisession","text":"WARNING: function must never called. may used plan()","code":""},{"path":"https://future.futureverse.org/reference/multisession.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session â€” multisession","text":"","code":"multisession(   ...,   workers = availableCores(constraints = \"connections-16\"),   rscript_libs = .libPaths() )"},{"path":"https://future.futureverse.org/reference/multisession.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session â€” multisession","text":"workers number parallel processes use. function, called without arguments future created value used configure workers. workers == 1, processing using done current/main R session therefore fall back using sequential future. override fallback, use workers = (1). rscript_libs character vector R package library folders workers use.  default .libPaths() multisession workers inherits library path main R session. avoid , use plan(multisession, ..., rscript_libs = NULL). Important: Note library path set workers created, .e. plan(multisession) called.  changes .libPaths() main R session workers created effect. passed -parallelly::makeClusterPSOCK(). ... Additional arguments passed Future().","code":""},{"path":"https://future.futureverse.org/reference/multisession.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session â€” multisession","text":"MultisessionFuture. workers == 1, processing done current/main R session therefore fall back using lazy future.  override fallback, use workers = (1).","code":""},{"path":"https://future.futureverse.org/reference/multisession.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session â€” multisession","text":"multisession future future uses multisession evaluation, means value computed resolved parallel another R session. function must called directly.  Instead, typical usages :   background R sessions (\"workers\") created using makeClusterPSOCK(). total number R sessions available including current/main R process, see parallelly::availableCores(). multisession future special type cluster future.","code":"# Evaluate futures in parallel on the local machine via as many background # processes as available to the current R process plan(multisession)  # Evaluate futures in parallel on the local machine via two background # processes plan(multisession, workers = 2)"},{"path":[]},{"path":"https://future.futureverse.org/reference/multisession.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a multisession future whose value will be resolved asynchronously in a parallel R session â€” multisession","text":"","code":"# \\donttest{  ## Use multisession futures plan(multisession)  ## A global variable a <- 0  ## Create future (explicitly) f <- future({   b <- 3   c <- 2   a * b * c })  ## A multisession future is evaluated in a separate R session. ## Changing the value of a global variable will not affect ## the result of the future. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)  ## Explicitly close multisession workers by switching plan plan(sequential) # }"},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the number of workers available â€” nbrOfWorkers","title":"Get the number of workers available â€” nbrOfWorkers","text":"Get number workers available","code":""},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the number of workers available â€” nbrOfWorkers","text":"","code":"nbrOfWorkers(evaluator = NULL)  nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)"},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the number of workers available â€” nbrOfWorkers","text":"evaluator future evaluator function. NULL (default), current evaluator returned plan() used. background TRUE, workers can process future background considered.  FALSE, also workers running main R process considered, e.g. using 'sequential' backend. ... used; reserved future use.","code":""},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the number of workers available â€” nbrOfWorkers","text":"nbrOfWorkers() returns positive number \\({1, 2, 3, ...}\\), future backends may also +Inf. nbrOfFreeWorkers() returns non-negative number \\({0, 1, 2, 3, ...}\\) less equal nbrOfWorkers().","code":""},{"path":"https://future.futureverse.org/reference/nbrOfWorkers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the number of workers available â€” nbrOfWorkers","text":"","code":"plan(multisession) nbrOfWorkers()  ## == availableCores() #> [1] 8  plan(sequential) nbrOfWorkers()  ## == 1 #> [1] 1"},{"path":"https://future.futureverse.org/reference/nullcon.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a connection to the system null device â€” nullcon","title":"Creates a connection to the system null device â€” nullcon","text":"Creates connection system null device","code":""},{"path":"https://future.futureverse.org/reference/nullcon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a connection to the system null device â€” nullcon","text":"","code":"nullcon()"},{"path":"https://future.futureverse.org/reference/nullcon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a connection to the system null device â€” nullcon","text":"Returns open, binary base::connection().","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":null,"dir":"Reference","previous_headings":"","what":"Plan how to resolve a future â€” plan","title":"Plan how to resolve a future â€” plan","text":"function allows user plan future, specifically, specifies future()s resolved, e.g. sequentially parallel.","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plan how to resolve a future â€” plan","text":"","code":"plan(   strategy = NULL,   ...,   substitute = TRUE,   .skip = FALSE,   .call = TRUE,   .cleanup = NA,   .init = TRUE )  # S3 method for class 'FutureStrategyList' with(data, expr, ..., local = FALSE, envir = parent.frame(), .cleanup = NA)  tweak(strategy, ..., penvir = parent.frame())"},{"path":"https://future.futureverse.org/reference/plan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plan how to resolve a future â€” plan","text":"strategy future backend name one. substitute TRUE, strategy expression substitute():d, otherwise . .skip (internal) TRUE, attempts set future backend currently use, skipped. .call (internal) Used recording call function. .cleanup (internal) Used stop implicitly started clusters. .init (internal) Used initiate workers. data future plan use temporarily, e.g. plan(multisession). expr R expression evaluated. local TRUE, future plan specified data applied temporarily calling frame. Argument expr must specified local = TRUE. envir environment future plan set expression evaluated. penvir environment used searching future function name. ... Additional arguments overriding default arguments evaluation function.  additional arguments supported depends future backend used, e.g. several support argument workers . details, see individual backends linked .","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plan how to resolve a future â€” plan","text":"plan() returns previous plan invisibly new future backend chosen, otherwise returns current one visibly. value expression evaluated (invisibly). future function.","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plan how to resolve a future â€” plan","text":"default backend sequential, another one can set using plan(), e.g. plan(multisession) launch parallel workers running background, used resolve futures. shut background workers launched way, call plan(sequential).","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"built-in-evaluation-strategies","dir":"Reference","previous_headings":"","what":"Built-in evaluation strategies","title":"Plan how to resolve a future â€” plan","text":"future package provides following built-backends: sequential: Resolves futures sequentially current R process, e.g. plan(sequential). multisession: Resolves futures asynchronously (parallel) separate R sessions running background machine, e.g. plan(multisession) plan(multisession, workers = 2). multicore: Resolves futures asynchronously (parallel) separate forked R processes running background machine, e.g. plan(multicore) plan(multicore, workers = 2). backend supported Windows. cluster: Resolves futures asynchronously (parallel) separate R sessions running typically one machines, e.g. plan(cluster), plan(cluster, workers = 2), plan(cluster, workers = c(\"n1\", \"n1\", \"n2\", \"server.remote.org\")).","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"other-evaluation-strategies-available","dir":"Reference","previous_headings":"","what":"Other evaluation strategies available","title":"Plan how to resolve a future â€” plan","text":"addition built-ones, additional parallel backends implemented future-backend packages future.callr future.mirai leverage R package callr mirai: callr: Similar multisession, resolves futures parallel background R sessions local machine via callr package, e.g. plan(future.callr::callr) plan(future.callr::callr, workers = 2). difference future processed fresh parallel R worker, automatically shut soon future resolved. can help decrease overall memory usage. Moreover, contrary multisession, callr rely socket connections, means limited number connections R can open time. mirai_multisession: Similar multisession, resolves futures parallel background R sessions local machine via mirai package, e.g. plan(future.mirai::mirai_multisession) plan(future.mirai::mirai_multisession, workers = 2). mirai_cluster: Similar cluster, resolves futures parallel via pre-configured R mirai daemon processes, e.g. plan(future.mirai::mirai_cluster). Another example future.batchtools package, leverages batchtools package, resolve futures via high-performance compute (HPC) job schedulers, e.g. LSF, Slurm, TORQUE/PBS, Grid Engine, OpenLava; batchtools_slurm: backend resolves futures via Slurm scheduler, e.g. plan(future.batchtools::batchtools_slurm). batchtools_torque: backend resolves futures via TORQUE/PBS scheduler, e.g. plan(future.batchtools::batchtools_torque). batchtools_sge: backend resolves futures via Grid Engine (SGE, AGE) scheduler, e.g. plan(future.batchtools::batchtools_sge). batchtools_lsf: backend resolves futures via Load Sharing Facility (LSF) scheduler, e.g. plan(future.batchtools::batchtools_lsf). batchtools_openlava: backend resolves futures via OpenLava scheduler, e.g. plan(future.batchtools::batchtools_openlava).","code":""},{"path":"https://future.futureverse.org/reference/plan.html","id":"for-package-developers","dir":"Reference","previous_headings":"","what":"For package developers","title":"Plan how to resolve a future â€” plan","text":"Please refrain modifying future backend inside packages / functions, .e. call plan() code. Instead, leave control backend use end user. idea part core philosophy future frameworkâ€”developer can never know future backends user access . Moreover, making assumptions backends available, code also work automatically new backends developed wrote code. think necessary modify future backend within function, make sure undo changes exiting function. can achieved using (plan(...), local = TRUE), e.g. important end-user might already set future strategy elsewhere purposes likely know calling function break setup. Remember, package functions might used greater context multiple packages functions involved might also rely future framework, important avoid stepping others' toes.","code":"my_fcn <- function(x) {     with(plan(multisession), local = TRUE)     y <- analyze(x)     summarize(y)   }"},{"path":"https://future.futureverse.org/reference/plan.html","id":"using-plan-in-scripts-and-vignettes","dir":"Reference","previous_headings":"","what":"Using plan() in scripts and vignettes","title":"Plan how to resolve a future â€” plan","text":"writing scripts vignettes use futures, try place call plan() far (.e. early ) code possible. help users quickly identify future plan set allow modify computational resources. Even better leave user set plan() prior source():ing script running vignette. .future.R exists current directory / user's home directory, sourced future package loaded. , .future.R file provides convenient place users set plan(). behavior can controlled via R optionâ€”see future options details.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/plan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plan how to resolve a future â€” plan","text":"","code":"a <- b <- c <- NA_real_  # An sequential future plan(sequential) f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA   # A sequential future with lazy evaluation plan(sequential) f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }, lazy = TRUE) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA   # A multicore future (specified as a string) plan(\"multicore\") f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA  ## Multisession futures gives an error on R CMD check on ## Windows (but not Linux or macOS) for unknown reasons. ## The same code works in package tests. # \\donttest{  # A multisession future (specified via a string variable) plan(\"future::multisession\") f <- future({   a <- 7   b <- 3   c <- 2   a * b * c }) y <- value(f) print(y) #> [1] 42 str(list(a = a, b = b, c = c)) ## All NAs #> List of 3 #>  $ a: num NA #>  $ b: num NA #>  $ c: num NA  # }   ## Explicitly specifying number of workers ## (default is parallelly::availableCores()) plan(multicore, workers = 2) message(\"Number of parallel workers: \", nbrOfWorkers()) #> Number of parallel workers: 2   ## Explicitly close multisession workers by switching plan plan(sequential) # Evaluate a future using the 'multisession' plan with(plan(multisession, workers = 2), {   f <- future(Sys.getpid())   w_pid <- value(f) }) print(c(main = Sys.getpid(), worker = w_pid)) #>    main  worker  #> 3873967 3877181     # Evaluate a future locally using the 'multisession' plan local({   with(plan(multisession, workers = 2), local = TRUE)    f <- future(Sys.getpid())   w_pid <- value(f)   print(c(main = Sys.getpid(), worker = w_pid)) }) #>    main  worker  #> 3873967 3877277"},{"path":"https://future.futureverse.org/reference/private_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets the length of an object without dispatching â€” .length","title":"Gets the length of an object without dispatching â€” .length","text":"Gets length object without dispatching","code":""},{"path":"https://future.futureverse.org/reference/private_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets the length of an object without dispatching â€” .length","text":"","code":".length(x)"},{"path":"https://future.futureverse.org/reference/private_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets the length of an object without dispatching â€” .length","text":"x R object.","code":""},{"path":"https://future.futureverse.org/reference/private_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets the length of an object without dispatching â€” .length","text":"non-negative integer.","code":""},{"path":"https://future.futureverse.org/reference/private_length.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gets the length of an object without dispatching â€” .length","text":"function returns length(unclass(x)), tries avoid calling unclass(x) unless necessary.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/re-exports.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions Moved to 'parallelly' â€” re-exports","title":"Functions Moved to 'parallelly' â€” re-exports","text":"following function used part future, since migrated parallelly. migration started future 1.20.0 (November 2020). moved also useful outside future framework.","code":""},{"path":"https://future.futureverse.org/reference/re-exports.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions Moved to 'parallelly' â€” re-exports","text":"using future package, please switch use ones parallelly package. Thank ! parallelly::.cluster()    (longer re-exported) parallelly::autoStopCluster()   (longer re-exported) parallelly::availableCores() parallelly::availableWorkers() parallelly::makeClusterMPI()    (longer re-exported) parallelly::makeClusterPSOCK() parallelly::makeNodePSOCK()     (longer re-exported) parallelly::supportsMulticore() backward-compatible reasons, functions remain available exact copies also package (re-exports), e.g.   can still accessed :   Note goal remove package.","code":"cl <- parallelly::makeClusterPSOCK(2) cl <- future::makeClusterPSOCK(2)"},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Writes and Reads 'immediateCondition' RDS Files â€” readImmediateConditions","title":"Writes and Reads 'immediateCondition' RDS Files â€” readImmediateConditions","text":"Writes Reads 'immediateCondition' RDS Files","code":""},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Writes and Reads 'immediateCondition' RDS Files â€” readImmediateConditions","text":"","code":"readImmediateConditions(   path = immediateConditionsPath(rootPath = rootPath),   rootPath = tempdir(),   pattern = \"[.]rds$\",   include = getOption(\"future.relay.immediate\", \"immediateCondition\"),   signal = FALSE,   remove = TRUE )  saveImmediateCondition(   cond,   path = immediateConditionsPath(rootPath = rootPath),   rootPath = tempdir() )"},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Writes and Reads 'immediateCondition' RDS Files â€” readImmediateConditions","text":"path (character string) folder RDS files . pattern (character string) regular expression selecting RDS files read. include (character vector) class classes objects kept. signal (logical) TRUE, condition read signaled. remove (logical) TRUE, RDS files used removed exit. cond condition class immediateCondition.","code":""},{"path":"https://future.futureverse.org/reference/readImmediateConditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Writes and Reads 'immediateCondition' RDS Files â€” readImmediateConditions","text":"readImmediateConditions() returns unnamed base::list named lists elements condition signaled, condition elements hold immediateCondition objects. saveImmediateCondition() returns, invisibly, pathname RDS written.","code":""},{"path":"https://future.futureverse.org/reference/requestCore.html","id":null,"dir":"Reference","previous_headings":"","what":"Request a core for multicore processing â€” requestCore","title":"Request a core for multicore processing â€” requestCore","text":"cores available, current process blocks core available.","code":""},{"path":"https://future.futureverse.org/reference/requestCore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request a core for multicore processing â€” requestCore","text":"","code":"requestCore(   await,   workers = availableCores(constraints = \"multicore\"),   timeout,   delta,   alpha )"},{"path":"https://future.futureverse.org/reference/requestCore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request a core for multicore processing â€” requestCore","text":"await function used try \"collect\" finished multicore subprocesses. workers Total number workers available. timeout Maximum waiting time (seconds) allowed timeout error generated. delta base interval (seconds) wait try. alpha multiplicative factor used increase wait interval try.","code":""},{"path":"https://future.futureverse.org/reference/requestCore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Request a core for multicore processing â€” requestCore","text":"Invisible TRUE. cores available extensive waiting, timeout error thrown.","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":null,"dir":"Reference","previous_headings":"","what":"Reset a finished, failed, canceled, or interrupted future to a lazy future â€” reset","title":"Reset a finished, failed, canceled, or interrupted future to a lazy future â€” reset","text":"future successfully completed, canceled interrupted, failed due error, can relaunched resetting .","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reset a finished, failed, canceled, or interrupted future to a lazy future â€” reset","text":"","code":"reset(x, ...)"},{"path":"https://future.futureverse.org/reference/reset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reset a finished, failed, canceled, or interrupted future to a lazy future â€” reset","text":"x Future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reset a finished, failed, canceled, or interrupted future to a lazy future â€” reset","text":"reset() returns lazy, vanilla Future can relaunched. Resetting running future results FutureError.","code":""},{"path":"https://future.futureverse.org/reference/reset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reset a finished, failed, canceled, or interrupted future to a lazy future â€” reset","text":"lazy, vanilla Future can reused another R session. instance, :   can read evaluate future another R session using:","code":"library(future) a <- 2 f <- future(42 * a, lazy = TRUE) saveRDS(f, \"myfuture.rds\") library(future) f <- readRDS(\"myfuture.rds\") v <- value(f) print(v) #> [1] 84"},{"path":"https://future.futureverse.org/reference/reset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reset a finished, failed, canceled, or interrupted future to a lazy future â€” reset","text":"","code":"## Like mean(), but fails 90% of the time shaky_mean <- function(x) {   if (as.double(Sys.time()) %% 1 < 0.90) stop(\"boom\")   mean(x) }  x <- rnorm(100)  ## Calculate the mean of 'x' with a risk of failing randomly f <- future({ shaky_mean(x) })  ## Relaunch until success repeat({   v <- tryCatch(value(f), error = identity)   if (!inherits(v, \"error\")) break   message(\"Resetting failed future, and retry in 0.1 seconds\")   f <- reset(f)   Sys.sleep(0.1) }) #> Resetting failed future, and retry in 0.1 seconds cat(\"mean:\", v, \"\\n\") #> mean: 0.03014631"},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":null,"dir":"Reference","previous_headings":"","what":"Free up active background workers â€” resetWorkers","title":"Free up active background workers â€” resetWorkers","text":"Free active background workers","code":""},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Free up active background workers â€” resetWorkers","text":"","code":"resetWorkers(x, ...)"},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Free up active background workers â€” resetWorkers","text":"x FutureStrategy. ... used.","code":""},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Free up active background workers â€” resetWorkers","text":"function resolve active futures currently evaluated background workers.","code":""},{"path":"https://future.futureverse.org/reference/resetWorkers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Free up active background workers â€” resetWorkers","text":"","code":"resetWorkers(plan())"},{"path":"https://future.futureverse.org/reference/resolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve one or more futures synchronously â€” resolve","title":"Resolve one or more futures synchronously â€” resolve","text":"function provides efficient mechanism waiting multiple futures container (e.g. list environment) resolved meanwhile retrieving values already resolved futures.","code":""},{"path":"https://future.futureverse.org/reference/resolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve one or more futures synchronously â€” resolve","text":"","code":"resolve(   x,   idxs = NULL,   recursive = 0,   result = FALSE,   stdout = FALSE,   signal = FALSE,   force = FALSE,   sleep = getOption(\"future.wait.interval\", 0.01),   ... )"},{"path":"https://future.futureverse.org/reference/resolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve one or more futures synchronously â€” resolve","text":"x Future resolved, list, environment, list environment futures resolved. idxs (optional) integer logical index specifying subset elements check. recursive non-negative number specifying deep recursion done.  TRUE, infinite recursion used.  FALSE zero, recursion performed. result (internal) TRUE, results retrieved, otherwise . Note collects results parallel worker, can help lower overall latency multiple concurrent futures. return collected results. stdout (internal) TRUE, captured standard output relayed, otherwise . signal (internal) TRUE, captured conditions relayed, otherwise . force (internal) TRUE, captured standard output captured conditions already relayed relayed , otherwise . sleep Number seconds wait checking futures resolved since last time. ... used.","code":""},{"path":"https://future.futureverse.org/reference/resolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve one or more futures synchronously â€” resolve","text":"Returns x (regardless subsetting ). signal TRUE one futures produces error, error produced.","code":""},{"path":"https://future.futureverse.org/reference/resolve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Resolve one or more futures synchronously â€” resolve","text":"function resolves synchronously, .e. blocks x containing futures resolved.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/resolved.html","id":null,"dir":"Reference","previous_headings":"","what":"Check whether a future is resolved or not â€” resolved.ClusterFuture","title":"Check whether a future is resolved or not â€” resolved.ClusterFuture","text":"Check whether future resolved ","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check whether a future is resolved or not â€” resolved.ClusterFuture","text":"","code":"# S3 method for class 'ClusterFuture' resolved(x, timeout = NULL, ...)  # S3 method for class 'MulticoreFuture' resolved(x, timeout = NULL, ...)  resolved(x, ...)  # Default S3 method resolved(x, ...)  # S3 method for class 'list' resolved(x, ...)  # S3 method for class 'environment' resolved(x, ...)  # S3 method for class 'Future' resolved(x, ...)"},{"path":"https://future.futureverse.org/reference/resolved.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check whether a future is resolved or not â€” resolved.ClusterFuture","text":"x Future, list, environment (also includes list environment). timeout (numeric) maximum time (seconds) polling worker response. response available within time limit, FALSE returned assuming future still processed. NULL, value defaults getOption(\"future.<type>.resolved.timeout\"), getOption(\"future.resolved.timeout\"), finally 0.01 (seconds), <type> corresponds type future, e.g. cluster multicore. ... used.","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check whether a future is resolved or not â€” resolved.ClusterFuture","text":"logical vector length dimensions x. element TRUE unless corresponding element non-resolved future case FALSE. never signals error. default method always returns TRUE.","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check whether a future is resolved or not â€” resolved.ClusterFuture","text":"resolved() attempts launch lazy future, available worker, otherwise . resolved() methods must always return TRUE FALSE values, must always launch lazy futures, must never block indefinitely. always possible poll futures resolved using resolved(), e.g. (!(resolved(futures))) Sys.sleep(5). future backend must implement resolved() method. return either TRUE FALSE, throw FutureError (indicates significant, often unrecoverable infrastructure problem, interrupt).","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"behavior-of-cluster-and-multisession-futures","dir":"Reference","previous_headings":"","what":"Behavior of cluster and multisession futures","title":"Check whether a future is resolved or not â€” resolved.ClusterFuture","text":"worker slots occupied, resolved() ClusterFuture MultisessionFuture attempt free one checking whether one futures resolved. one, result collected order free one worker slot. resolved() ClusterFuture may receive immediate condition objects, rather FutureResult, polling worker results. cases, condition object collected another poll performed. 100 immediate conditions may collected way per resolved() call, considering future non-resolved FALSE returned.","code":""},{"path":"https://future.futureverse.org/reference/resolved.html","id":"behavior-of-multicore-futures","dir":"Reference","previous_headings":"","what":"Behavior of multicore futures","title":"Check whether a future is resolved or not â€” resolved.ClusterFuture","text":"resolved() MulticoreFuture may receive immediate condition objects, rather FutureResult, polling worker results. cases, condition objects collected, considering future non-resolved FALSE returned.","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the results of a resolved future â€” result.Future","title":"Get the results of a resolved future â€” result.Future","text":"Get results resolved future","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the results of a resolved future â€” result.Future","text":"","code":"# S3 method for class 'Future' result(future, ...)"},{"path":"https://future.futureverse.org/reference/result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the results of a resolved future â€” result.Future","text":"future Future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the results of a resolved future â€” result.Future","text":"FutureResult object. may signal FutureError, significant orchestration error. example, parallel worker process terminated abruptly (\"crashed\"), FutureInterruptError signaled.","code":""},{"path":"https://future.futureverse.org/reference/result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the results of a resolved future â€” result.Future","text":"function part backend Future API. function part frontend Future API.","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a future â€” run.Future","title":"Run a future â€” run.Future","text":"Run future","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a future â€” run.Future","text":"","code":"# S3 method for class 'Future' run(future, ...)"},{"path":"https://future.futureverse.org/reference/run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a future â€” run.Future","text":"future Future. ... used.","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a future â€” run.Future","text":"Future object.","code":""},{"path":"https://future.futureverse.org/reference/run.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a future â€” run.Future","text":"function can called per future. calls result informative error. future run value queried, run point.","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":null,"dir":"Reference","previous_headings":"","what":"Robustly Saves an Object to RDS File Atomically â€” save_rds","title":"Robustly Saves an Object to RDS File Atomically â€” save_rds","text":"Robustly Saves Object RDS File Atomically","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robustly Saves an Object to RDS File Atomically â€” save_rds","text":"","code":"save_rds(object, pathname, ...)"},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robustly Saves an Object to RDS File Atomically â€” save_rds","text":"object R object save. pathname RDS file written. ... (optional) Additional arguments passed base::saveRDS().","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robustly Saves an Object to RDS File Atomically â€” save_rds","text":"pathname RDS written.","code":""},{"path":"https://future.futureverse.org/reference/save_rds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Robustly Saves an Object to RDS File Atomically â€” save_rds","text":"Uses base::saveRDS internally writes object atomically first writing temporary file renamed.","code":""},{"path":"https://future.futureverse.org/reference/sequential.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a sequential future whose value will be in the current R session â€” sequential","title":"Create a sequential future whose value will be in the current R session â€” sequential","text":"WARNING: function must never called. may used plan()","code":""},{"path":"https://future.futureverse.org/reference/sequential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a sequential future whose value will be in the current R session â€” sequential","text":"","code":"sequential(..., envir = parent.frame())"},{"path":"https://future.futureverse.org/reference/sequential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a sequential future whose value will be in the current R session â€” sequential","text":"envir environment global objects identified. ... used.","code":""},{"path":"https://future.futureverse.org/reference/sequential.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a sequential future whose value will be in the current R session â€” sequential","text":"sequential future future evaluated sequentially current R session similarly R expressions evaluated R. difference R globals validated default just types futures package. function must called directly.  Instead, typical usages :","code":"# Evaluate futures sequentially in the current R process plan(sequential)"},{"path":"https://future.futureverse.org/reference/sequential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a sequential future whose value will be in the current R session â€” sequential","text":"","code":"## Use sequential futures plan(sequential)  ## A global variable a <- 0  ## Create a sequential future f <- future({   b <- 3   c <- 2   a * b * c })  ## Since 'a' is a global variable in future 'f' which ## is eagerly resolved (default), this global has already ## been resolved / incorporated, and any changes to 'a' ## at this point will _not_ affect the value of 'f'. a <- 7 print(a) #> [1] 7  v <- value(f) print(v) #> [1] 0 stopifnot(v == 0)"},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":null,"dir":"Reference","previous_headings":"","what":"Outputs details on the current R session â€” sessionDetails","title":"Outputs details on the current R session â€” sessionDetails","text":"Outputs details current R session","code":""},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outputs details on the current R session â€” sessionDetails","text":"","code":"sessionDetails(env = FALSE)"},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outputs details on the current R session â€” sessionDetails","text":"env TRUE, Sys.getenv() information returned.","code":""},{"path":"https://future.futureverse.org/reference/sessionDetails.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outputs details on the current R session â€” sessionDetails","text":"Invisibly list details.","code":""},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Signals Captured Conditions â€” signalConditions","title":"Signals Captured Conditions â€” signalConditions","text":"Captured conditions meet include exclude requirements signaled order captured.","code":""},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Signals Captured Conditions â€” signalConditions","text":"","code":"signalConditions(   future,   include = \"condition\",   exclude = NULL,   resignal = TRUE,   ... )"},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Signals Captured Conditions â€” signalConditions","text":"future resolved Future. include character string condition classes signal. exclude character string condition classes signal. resignal TRUE, already signaled conditions signaled , otherwise . ... used.","code":""},{"path":"https://future.futureverse.org/reference/signalConditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Signals Captured Conditions â€” signalConditions","text":"Returns Future conditioned signaled flagged signaled.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":null,"dir":"Reference","previous_headings":"","what":"Place a sticky-globals environment immediately after the global environment â€” sticky_globals","title":"Place a sticky-globals environment immediately after the global environment â€” sticky_globals","text":"Place sticky-globals environment immediately global environment","code":""},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Place a sticky-globals environment immediately after the global environment â€” sticky_globals","text":"","code":"sticky_globals(erase = FALSE, name = \"future:sticky_globals\", pos = 2L)"},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Place a sticky-globals environment immediately after the global environment â€” sticky_globals","text":"erase (logical) TRUE, environment erased, otherwise . name (character) name environment base::search path. pos (integer) position search path environment positioned.  pos == 0L, environment detached, exists.","code":""},{"path":"https://future.futureverse.org/reference/sticky_globals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Place a sticky-globals environment immediately after the global environment â€” sticky_globals","text":"(invisible; environment) environment.","code":""},{"path":"https://future.futureverse.org/reference/usedCores.html","id":null,"dir":"Reference","previous_headings":"","what":"Get number of cores currently used â€” usedCores","title":"Get number of cores currently used â€” usedCores","text":"Get number children (count current process) used current R session.  number children total number subprocesses launched process still running whose values yet collected.","code":""},{"path":"https://future.futureverse.org/reference/usedCores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get number of cores currently used â€” usedCores","text":"","code":"usedCores()"},{"path":"https://future.futureverse.org/reference/usedCores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get number of cores currently used â€” usedCores","text":"non-negative integer.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":null,"dir":"Reference","previous_headings":"","what":"The value of a future or the values of all elements in a container â€” value","title":"The value of a future or the values of all elements in a container â€” value","text":"Gets value future values elements (including futures) container list, environment, list environment. one futures unresolved, function blocks queried futures resolved.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The value of a future or the values of all elements in a container â€” value","text":"","code":"value(...)  # S3 method for class 'Future' value(future, stdout = TRUE, signal = TRUE, drop = FALSE, ...)  # S3 method for class 'list' value(   x,   idxs = NULL,   recursive = 0,   reduce = NULL,   stdout = TRUE,   signal = TRUE,   cancel = TRUE,   interrupt = cancel,   inorder = TRUE,   drop = FALSE,   force = TRUE,   sleep = getOption(\"future.wait.interval\", 0.01),   ... )  # S3 method for class 'listenv' value(   x,   idxs = NULL,   recursive = 0,   reduce = NULL,   stdout = TRUE,   signal = TRUE,   cancel = TRUE,   interrupt = cancel,   inorder = TRUE,   drop = FALSE,   force = TRUE,   sleep = getOption(\"future.wait.interval\", 0.01),   ... )  # S3 method for class 'environment' value(x, ...)"},{"path":"https://future.futureverse.org/reference/value.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The value of a future or the values of all elements in a container â€” value","text":"future, x Future, environment, list, list environment. stdout TRUE, standard output captured resolving futures relayed, otherwise . signal TRUE, conditions captured resolving futures relayed, otherwise . drop TRUE, resolved futures minimized size invalidated soon values collected output conditions relayed. Combining drop = TRUE inorder = FALSE reduces memory use sooner, especially avoiding risk holding future values end. idxs (optional) integer logical index specifying subset elements check. recursive non-negative number specifying deep recursion done.  TRUE, infinite recursion used.  FALSE zero, recursion performed. reduce optional function reducing values. Optional attribute init can used set initial value reduction. specified, first value used initial value. Reduction values done soon possible, always order x, unless inorder FALSE. cancel, interrupt TRUE signal TRUE, non-resolved futures canceled soon error detected one futures, signaling error. Argument interrupt passed cancel() controlling whether non-resolved futures also interrupted. inorder TRUE, standard output conditions relayed, value reduction done order futures occur x, always soon possible. achieved buffering details can released. setting inorder = FALSE, buffering takes place everything relayed reduced soon new future resolved. Regardless, values always returned order x. force (internal) TRUE, captured standard output captured conditions already relayed relayed , otherwise . sleep Number seconds wait checking futures resolved since last time. ... arguments used S3 methods.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The value of a future or the values of all elements in a container â€” value","text":"value() Future object returns value future, can type R object. value() list, environment, list environment returns object number elements class. Names dimension attributes preserved, available. future elements replaced corresponding value() values. elements, existing object kept -. signal TRUE one futures produces error, error relayed. remaining, non-resolved futures x canceled, prior signaling error. future interrupted, canceled, parallel worker terminated abruptly (\"crashed\"), FutureInterruptError signaled.","code":""},{"path":"https://future.futureverse.org/reference/value.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The value of a future or the values of all elements in a container â€” value","text":"","code":"## ------------------------------------------------------ ## A single future ## ------------------------------------------------------ x <- sample(100, size = 50) f <- future(mean(x)) v <- value(f) message(\"The average of 50 random numbers in [1,100] is: \", v) #> The average of 50 random numbers in [1,100] is: 49.58    ## ------------------------------------------------------ ## Ten futures ## ------------------------------------------------------ xs <- replicate(10, { list(sample(100, size = 50)) }) fs <- lapply(xs, function(x) { future(mean(x)) })  ## The 10 values as a list (because 'fs' is a list) vs <- value(fs) message(\"The ten averages are:\") #> The ten averages are: str(vs) #> List of 10 #>  $ : num 52.1 #>  $ : num 50.8 #>  $ : num 48 #>  $ : num 52.8 #>  $ : num 50.9 #>  $ : num 49.1 #>  $ : num 51.1 #>  $ : num 51.1 #>  $ : num 48.1 #>  $ : num 47.1  ## The 10 values as a vector (by manually unlisting) vs <- value(fs) vs <- unlist(vs) message(\"The ten averages are: \", paste(vs, collapse = \", \")) #> The ten averages are: 52.1, 50.76, 48.02, 52.82, 50.9, 49.06, 51.08, 51.06, 48.08, 47.1  ## The values as a vector (by reducing) vs <- value(fs, reduce = c) message(\"The ten averages are: \", paste(vs, collapse = \", \")) #> The ten averages are: 52.1, 50.76, 48.02, 52.82, 50.9, 49.06, 51.08, 51.06, 48.08, 47.1  ## Calculate the sum of the averages (by reducing) total <- value(fs, reduce = `+`) message(\"The sum of the ten averages is: \", total) #> The sum of the ten averages is: 500.98"},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":null,"dir":"Reference","previous_headings":"","what":"Options used for futures â€” zzz-future.options","title":"Options used for futures â€” zzz-future.options","text":"R options environment variables used future package packages enhancing .WARNING: Note names default values options may change future versions package.  Please use care notice.","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"packages-must-not-change-future-options","dir":"Reference","previous_headings":"","what":"Packages must not change future options","title":"Options used for futures â€” zzz-future.options","text":"Just like R options, package developer must change future.* options.  end-user set . find tweak one options, make sure undo changes immediately afterward.  example, want bump future.globals.maxSize limit creating future, use something like following inside function:","code":"oopts <- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB on.exit(options(oopts)) f <- future({ expr })  ## Launch a future with large objects"},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-controlling-futures","dir":"Reference","previous_headings":"","what":"Options for controlling futures","title":"Options used for futures â€” zzz-future.options","text":"future.plan: (character string future function) Default future backend used unless otherwise specified via plan(). also future plan set calling plan(\"default\").  specified, option may set future package loaded command-line option --parallel=ncores (short -p ncores) specified; ncores > 1, option future.plan set multisession otherwise sequential (addition option mc.cores set ncores, ncores >= 1). (Default: sequential) future.globals.maxSize: (numeric) Maximum allowed total size (bytes) global variables identified. used protect exporting large objects parallel workers mistake. Transferring large objects network, internet, can slow therefore introduce large bottleneck increases overall processing time. can also result large egress ingress costs, may exist systems. set +Inf, check large globals skipped. (Default: 500 * 1024 ^ 2 = 500 MiB) future.globals.onReference: (beta feature - may change) (character string) Controls whether identified globals scanned called references (e.g. external pointers connections) .  unlikely another R process (\"worker\") can use global uses internal reference master R processâ€”call objects non-exportable globals. option \"error\", informative error message produced non-exportable global detected. \"warning\", warning produced, processing continue; likely future resolved run-time error unless processed master R process (e.g. plan(sequential) plan(multicore)). \"ignore\", scan performed. (Default: \"ignore\" may change) future.resolve.recursive: (integer) integer specifying maximum recursive depth futures resolved. negative, nothing resolved.  0, future resolved.  1, future elements futures resolved, . +Inf, infinite search depth used. (Default: 0) future.onFutureCondition.keepFuture: (logical) TRUE, FutureCondition keeps copy Future object triggered condition. FALSE, dropped. (Default: TRUE) future.wait.timeout: (numeric) Maximum waiting time (seconds) future resolve free worker become available timeout error generated. (Default: 30 * 24 * 60 * 60 (= 30 days)) future.wait.interval: (numeric) Initial interval (seconds) polls. controls polling frequency finding available worker workers currently busy. also controls polling frequency resolve(). (Default: 0.01 = 1 ms) future.wait.alpha: (numeric) Positive scale factor used increase interval poll. (Default: 1.01)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-built-in-sanity-checks","dir":"Reference","previous_headings":"","what":"Options for built-in sanity checks","title":"Options used for futures â€” zzz-future.options","text":"Ideally, evaluation future side effects. protect unexpected side effects, future framework comes set built-tools checking . R options control built-checks happen fail. may modify troubleshooting purposes, please refrain disabling checks underlying problem fixed. Beta features: Please consider checks \"construction\". future.connections.onMisuse: (character string) future must close connections opens must close connections open . misuse detected option set \"error\", informative error produced. set \"warning\", warning produced. \"ignore\", check performed. (Default: \"warning\") future.defaultDevice.onMisuse: (character string) future must open graphics devices explicitly, creates new plots. rely default graphics device given R option \"default\", rarely intended. misuse detected option set \"error\", informative error produced. set \"warning\", warning produced. \"ignore\", check performed. (Default: \"warning\") future.devices.onMisuse: (character string) future must close graphics devices opens must close devices open . misuse detected option set \"error\", informative error produced. set \"warning\", warning produced. \"ignore\", check performed. (Default: \"warning\") future.globalenv.onMisuse: (character string) Assigning variables global environment purpose using variable later time makes sense futures, next future may evaluated different R process. protect mistakes, future framework attempts detect variables added global environment. detected, option set \"error\", informative error produced. \"warning\", warning produced. \"ignore\", check performed. (Default: \"ignore\") future.rng.onMisuse: (character string) random numbers used futures, parallel RNG declared order get statistical sound RNGs. can declare specifying future argument seed = TRUE. defaults future framework assume random number generation (RNG) taken place future expression L'Ecuyer-CMRG RNGs come unnecessary overhead needed. protect  mistakes declaring use RNG, future framework detects random numbers used despite declaring use. detected, options set \"error\", informative error produced. \"warning\", warning produced.  \"ignore\", check performed. (Default: \"warning\")","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-debugging-futures","dir":"Reference","previous_headings":"","what":"Options for debugging futures","title":"Options used for futures â€” zzz-future.options","text":"future.debug: (logical) TRUE, extensive debug messages generated. (Default: FALSE)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-controlling-package-startup","dir":"Reference","previous_headings":"","what":"Options for controlling package startup","title":"Options used for futures â€” zzz-future.options","text":"future.startup.script: (character vector logical) Specifies zero future startup scripts sourced future package attached. first existing script sourced. none specified files exist, nothing sourcedâ€”neither warning error. option specified, environment variable R_FUTURE_STARTUP_SCRIPT considered, multiple scripts may separated either colon (:) semicolon (;). neither set, either set TRUE, default look .future.R script current directory user's home directory.  disable future startup scripts, set option environment variable FALSE.  Importantly, option always set FALSE future package loaded part future expression evaluated, e.g. background process. words, sourced main R process future processes. (Default: TRUE main R process FALSE future processes / future evaluation) future.cmdargs: (character vector) Overrides commandArgs() future package loaded.","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-configuring-low-level-system-behaviors","dir":"Reference","previous_headings":"","what":"Options for configuring low-level system behaviors","title":"Options used for futures â€” zzz-future.options","text":"future.fork.multithreading.enable (beta feature - may change): (logical) Enable disable multi-threading using forked parallel processing.  FALSE, different multi-thread library settings overridden run single-thread mode. Specifically, multi-threading disabled OpenMP (requires RhpcBLASctl package) RcppParallel. TRUE, set (default), multi-threading allowed.  Parallelization via multi-threaded processing (done native code packages external libraries) time using forked (aka \"multicore\") parallel processing known unstable.  Note true using plan(multicore) also using, instance, mclapply() parallel package. (Default: set) future.output.windows.reencode: (logical) Enable disable re-encoding UTF-8 symbols incorrectly encoded captured.  R (< 4.2.0) older versions MS Windows, R capture UTF-8 symbols -captured standard output.  examples, UTF-8 check mark symbol (\"\\u2713\") relayed \"<U+2713>\" (string eight ASCII characters).  Setting option TRUE cause value() attempt recover intended UTF-8 symbols <U+nnnn> string components, , , string captured future resolved MS Windows. (Default: TRUE)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-for-demos","dir":"Reference","previous_headings":"","what":"Options for demos","title":"Options used for futures â€” zzz-future.options","text":"future.demo.mandelbrot.region: (integer) Either named list mandelbrot() arguments integer {1, 2, 3} specifying predefined Mandelbrot region. (Default: 1L) future.demo.mandelbrot.nrow: (integer) Number rows columns tiles. (Default: 3L)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"deprecated-or-for-internal-prototyping","dir":"Reference","previous_headings":"","what":"Deprecated or for internal prototyping","title":"Options used for futures â€” zzz-future.options","text":"following options exists troubleshooting purposes must used production.  used, risk results non-reproducible processed elsewhere.  lower risk used mistake, marked deprecated produce warnings set. future.globals.onMissing: (character string) Action take non-existing global variables (\"globals\" \"unknowns\") identified future created.  \"error\", error generated immediately.  \"ignore\", action taken attempt evaluate future expression made.  latter useful risk false-positive globals identified, e.g. future expression contains non-standard evaluation (NSE).  (Default: \"ignore\") future.globals.method: (character string) Method used identify globals. details, see globalsOf(). (Default: \"ordered\") future.globals.resolve: (logical) TRUE, globals Future objects (typically created explicit futures) resolved values (using value()) collected.  searching unresolved futures among globals (including content) can expensive, default instead leave run-time checks assert proper ownership resolving futures collecting values. (Default: FALSE)","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"environment-variables-that-set-r-options","dir":"Reference","previous_headings":"","what":"Environment variables that set R options","title":"Options used for futures â€” zzz-future.options","text":"R future.* options can set corresponding environment variable R_FUTURE_* future package loaded. means environment variables must set future package loaded order effect. example, R_FUTURE_RNG_ONMISUSE=\"ignore\", option future.rng.onMisuse set \"ignore\" (character string). Similarly, R_FUTURE_GLOBALS_MAXSIZE=\"50000000\", option future.globals.maxSize set 50000000 (numeric).","code":""},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"options-moved-to-the-parallelly-package","dir":"Reference","previous_headings":"","what":"Options moved to the 'parallelly' package","title":"Options used for futures â€” zzz-future.options","text":"Several functions moved parallelly package: parallelly::availableCores() parallelly::availableWorkers() parallelly::makeClusterMPI() parallelly::makeClusterPSOCK() parallelly::makeNodePSOCK() parallelly::supportsMulticore() options environment variables controlling adjusted accordingly different prefixes. example, option future.fork.enable renamed parallelly.fork.enable corresponding environment variable R_FUTURE_FORK_ENABLE renamed R_PARALLELLY_FORK_ENABLE. backward compatibility reasons, parallelly package support versions long foreseeable time. See parallelly::parallelly.options page settings.","code":""},{"path":[]},{"path":"https://future.futureverse.org/reference/zzz-future.options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options used for futures â€” zzz-future.options","text":"","code":"# Allow at most 5 MB globals per futures options(future.globals.maxSize = 5e6)  # Be strict; catch all RNG mistakes options(future.rng.onMisuse = \"error\")"},{"path":"https://future.futureverse.org/news/index.html","id":"version-development-version","dir":"Changelog","previous_headings":"","what":"Version (development version)","title":"Version (development version)","text":"â€¦","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1690","dir":"Changelog","previous_headings":"","what":"Version 1.69.0","title":"Version 1.69.0","text":"CRAN release: 2026-01-16","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-69-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.69.0","text":"Removed generic function .cluster(), re-exported parallelly package since 2020. needed, please use parallelly package instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-69-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.69.0","text":"Add conditionMessage() FutureCondition, appends metadata information original message. Add metadata FutureCondition objects default, e.g.Â session (including UUID, hostname, PID) condition created. print() Future outputs description current state.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-69-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.69.0","text":"makeClusterFuture() clusters signal errors parallel clusters. Instead signaled -instantly. future(..., packages = \"missing-package\") result error despite requesting non-installed package. bug introduced around future 1.40.0 (2025-04-10). plan(..., interrupts = ...) produce warning â€œDetected 1 unknown future arguments: â€˜interruptsâ€™â€ third-party future backends. plan(cluster, workers = parallelly::makeClusterSequential()) erase global environment soon future launched. resolved() â€˜clusterâ€™ future produce warning using parallelly::makeClusterSequential()) cluster.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-69-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.69.0","text":"cluster backend now defaults earlySignal = FALSE. effectively already case, internal thinko bug. Remove arguments earlySignal gc future(), futureAssign(), futureCall(). Attempts set produce deprecation warnings. Deprecated also hidden argument local, kept around legacy reasons. Use plan(..., earlySignal = ...) now deprecated produces deprecation warning. Remove argument run resolved(). Attempts set produces deprecation warning. Remove internal future field envir.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1680","dir":"Changelog","previous_headings":"","what":"Version 1.68.0","title":"Version 1.68.0","text":"CRAN release: 2025-11-17 fifth rollout several towards near-future major release. made possible due multi-year effort internal re-designs, work package maintainers, release, repeat. release fixes regressions introduced future 1.40.0 (2025-04-10) 1.67.0 (2025-07-29).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-68-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.68.0","text":"Calling clusterEvalQ() FutureCluster, introduced future 1.58.0 (2025-06-05), now error default - used just warning.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-68-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.68.0","text":"result() canceled interrupted cluster future returned future instead producing FutureInterruptError. cluster backend failed used MPIcluster created parallel::makeCluster(..., type = \"MPI\"). bug introduced future 1.40.0 [2025-04-10]. Setting R_FUTURE_PLAN=multisession .Renviron file, shell startup script, result â€œfork bombâ€ loading future package. happened setup future backend happened eagerly future package loaded instead deferred first future launched. resulted new, nested R workers created recursively, machine ran resources. bug introduced future 1.67.0 [2025-07-29]. value(..., reduce = structure(`+`, init = 42)) supported, `+` primitive function one must set attributes primitive functions. value() detects produces error suggestion use reduce = structure(\"+\",    init = 42) instead. latter still gave error, now fixed.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1670","dir":"Changelog","previous_headings":"","what":"Version 1.67.0","title":"Version 1.67.0","text":"CRAN release: 2025-07-29 fourth rollout several towards near-future major release. made possible due multi-year effort internal re-designs, work package maintainers, release, repeat. release fixes regressions introduced future 1.40.0 (2025-04-10).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-67-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.67.0","text":"Now argument workers plan(multisession) defaults availableCores(constraints = \"connections-16\"). make default plan(multisession) work also computers large number CPU cores (e.g.Â 192 256 cores) leaving 16 connection slots available needs. Futures now muffle packageStartupMessage conditions produced pre-loading pre-attaching packages, e.g.Â specified packages argument needed global objects.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-67-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.67.0","text":"pre-validation cluster worker allotted future launched unnecessarily expensive due thinko since future 1.40.0 (2025-04-10), e.g.Â take ~0.1-0.2 seconds multisession future, whereas fix effectively 0.0 seconds. Calling resolved() lazy ClusterFuture collect result first resolved future order free one worker slot. Now done slots occupied. net benefit lazy cluster futures launched faster, unless workers busy. Cluster multisession workers initiate things created, e.g.Â pre-loading packages memoization available cores. Previously, steps performed first future evaluated worker.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-67-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.67.0","text":"multicore future terminated abruptly (e.g.Â via tools::pskill() operating system), detected . Instead resulted unexpected error recovered . Now detected FutureInterruptError signaled, can handled future may reset(). Calls resolved() registered FutureJournal. Future backend factory created via calling environment rather via namespace environment lives.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1580","dir":"Changelog","previous_headings":"","what":"Version 1.58.0","title":"Version 1.58.0","text":"CRAN release: 2025-06-05 third rollout several towards near-future major release really excited . made possible due multi-year effort internal re-designs, work package maintainers, release, repeat. release fixes regressions introduced future 1.40.0 (2025-04-10), despite passing unit, regression, system tests.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-58-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.58.0","text":"Now futures produce warning detect default graphics device, defined R option \"device\", opened , instance, plot() call without explicitly opening graphics device. reason check rarely want plot default graphics device parallel processing, typically ends plotting Rplots.pdf file local parallel worker. truly wanted, please open graphics device explicitly (e.g.Â pdf() png()) plotting. Alternatively, explicitly set R option device inside future expression.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-58-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.58.0","text":"Add makeClusterFuture() creating cluster stateless parallel workers processing via future framework. requires R (>= 4.4.0) [2024-04-24]. Please make sure read help(\"makeClusterFuture\", package = \"future\") learn potential pitfalls. plan support corner cases future releases, possible, add mechanisms detecting non-supported cases give informative error.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-58-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.58.0","text":"Setting options(warn = 2) parallel worker ignored - warnings escalated errors worker, instead relayed -parent R session, unless options(warn    = 2) also set parent. Now options(warn = 2) worker causes warnings escalated immediately errors worker, therefore also terminates future. future() arguments stdout conditions applied packages specified via argument packages loaded attached. prevented us excluding, instance, packageStartupMessage:s, causing displayed sequential multicore processing. using cluster multisession backends, one , cases, end warnings â€œpackage may available loadingâ€ produced serialize(). type warnings now suppressed. Now cluster future backend tries even harder shut parallel cluster workers shutting backend. fails communicate one parallel workers, now close socket connections remain open towards cluster nodes. built-checks added, removed, modified graphical devices introduced future 1.40.0 (2025-04-10), produce false positives, complaining â€œfuture expression must close opened devices must close devices open. Details: 1 devices differ: index=2, =â€˜NAâ€™, =â€™â€˜â€œ. problem prune empty â€™â€™ check. multicore backend relay immediateCondition:s near-live fashion, results futures collected. sequential, cluster, multisession, multicore backends relayed immediateCondition:s, record properly future object.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1490","dir":"Changelog","previous_headings":"","what":"Version 1.49.0","title":"Version 1.49.0","text":"CRAN release: 2025-05-09 second rollout three-four major updates, now possible due multi-year effort internal re-designs, work package maintainers, release, repeat. release fixes two regressions introduced future 1.40.0 (2025-04-10), despite passing unit, regression, system tests Future API built years. upside, fixing issues led greatly improved static-code analyzer automatically finding global variables future expressions. Also, release, can now move releasing modern versions future backends future.callr future.mirai support interrupting futures near-live progress updates using progressr package. addition, map-reduce packages future.apply, furrr, doFuture can updated take advantage early exiting errors via cancellation futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-49-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.49.0","text":"future() better job identifying global variables future expression. achieved static-code analyzer now walking abstract syntax tree (AST) future expression using strategy better emulates R engine identifies global variables run-time. Add cancel() canceling one futures. default, attempts interrupt running futures. replaces interrupt() method introduced previous version, now removed. Now print() Future also reports current state future, e.g.Â â€˜createdâ€™, â€˜runningâ€™, â€˜finishedâ€™, â€˜interruptedâ€™. Now print(plan()) reports number created, launched, finished futures since future backend set. also reports total average runtime finished futures thus far.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-49-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.49.0","text":"Globals environment anonymous function lost since v1.40.0 (2025-04-10). partly resolved updates future package partly updates globals package. regression now fixed. Multisession workers stopped inheriting R package library path main R session v1.40.0 (2025-04-10). regression now fixed. rare cases, future backend might fail launch future time fail handle errors. result hard--understand, obscure errors. case future backend detect , errors now caught future package resignaled informative errors class FutureLaunchError. always handling launch errors, assure futures failing launch can always reset relaunched , possible alternative backend. future fails launch due issues parallel worker, querying value() produces FutureLaunchError. happened cluster multisession futures, resolved() return FALSE TRUE expected. addition, FutureLaunchError lost, resulting futures stuck unresolved state, FutureLaunchError error never signaled. Shutdown cluster multisession workers fail one workers already terminated, e.g.Â interrupted crashed. Now shutdown worker independent others, lowering risk leaving stray PSOCK workers behind. built-validation futures leave behind stray connections , cases, result Error vapply(,    FUN = .integer, FUN.VALUE = NA_integer_): values must length    1, FUN(X[[9]]) result length 0 stray connections.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-49-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.49.0","text":"interrupt() introduced previous version removed. Use cancel() instead. default cancel() interrupt well. One reason change word â€œinterruptâ€ conveys mechanism, whereas â€œcancelâ€ conveys intent, preferred style. Another reason interrupt() masked ditto popular rlang package, vice versa - choice cancel() fewer name clashes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1400","dir":"Changelog","previous_headings":"","what":"Version 1.40.0","title":"Version 1.40.0","text":"CRAN release: 2025-04-10 first rollout three major updates, now possible due multi-year effort internal re-designs, work package maintainers, release, repeat. release comes large redesign future backends implemented internally. One goal lower threshold implementing exciting, new features, hold long. features available already release, come near-future releases. Another goal make straightforward implement new backend. update fully backward compatible previous versions. Developers end-users can expect business usual. Like releases, version validated thoroughly via reverse-dependency checks, future.tests checks, .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-40-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.40.0","text":"Now () can used evaluate R expressions, including futures, using temporary future plan. example, (plan(multisession), { expr }) evaluates { expr } using multisession futures, reverting back plan set previously user. inside function, set (plan(multisession), local = TRUE), uses multisession futures function exits. Add interrupt(), interrupts future, parallel backend supports , otherwise silently ignored. can also used container (.e.Â lists, listenv:s environment) futures. Interrupts enabled default multicore multisession futures. Interrupts disabled default cluster futures, parallel workers may running remote machines overhead interrupting workers might large. override defaults, specify plan() argument interrupts, e.g.Â plan(cluster, workers = hosts,    interrupts = TRUE). Add reset(), resets future completed, failed, interrupted. future reset back lazy, vanilla future can relaunched. value() containers gained argument reduce, specifies function reducing values, e.g.Â values(fs, reduce =    `+`). Optional attribute init controls initial value. Note attributes must set primitive functions. workaround, use reduce = structure(\"+\", init = 42). value() containers gained argument inorder, can used control whether standard output conditions relayed order x, soon future x resolved. also controls order values reduced. value() gained argument drop turn resolved futures minimal, invalid light-weight futures values returned. reduces memory use. particularly useful using reduce combination inorder = FALSE. instance, list futures fs, know need query futures values , memory efficient performant use v <-    value(fs, reduce = `+`, inorder = FALSE, drop = TRUE). value() containers cancels non-resolved futures error detected one futures. Add minifuture(), like future(), different default arguments resulting less overhead added burden specify globals packages, conditions standard output relayed, ignoring random number generation. Printing plan() output details future backend, e.g. number workers, number free workers, backend settings, summary resolved non-resolved, active futures. Interrupted futures now handled produce informative error. Timeout errors triggered setTimeLimit() now relayed. Failures launch future now detected, handled, relayed error details failed. Failed workers automatically detected relaunched, supported parallel backend. instance, cluster worker interrupted, crashes reasons, relaunched. works local remote workers. future must close connections graphical devices opens, must never close ones open. Now value() produces warning misuse detected. may upgrade error future releases. default behavior can controlled via R option. Reverse dependency checks spotted one CRAN package, 426, left stray connections behind. parallel backends now prevent nested parallelization, unless explicitly allowed, e.g.Â settings recognized parallelly::availableCores() set future plan(). Previously, implemented backend, now â€™s handled automatically future framework. Add new FutureBackend API writing future backends. Please use care, updates next release cycles. maximum total size objects send worker can now configured per backend, e.g.Â plan(multisession,    maxSizeOfObjects = 10e6) produce error total size globals exceeds 10 MB. Backends sequential multicore longer limit maximum size globals, .e.Â now default maxSizeOfObjects    = +Inf. Backends cluster multisession also default maxSizeOfObjects = +Inf, unless R option future.globals.maxSize (sic!) set.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-40-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.40.0","text":"Now â€˜interruptâ€™ conditions captured evaluation future, results evaluation terminated FutureInterruptError. backends manage catch interrupts, leading parallel R workers terminate, resulting regular FutureError. Previously, interrupts result non-deterministic behavior errors depending future backend. Timeout errors triggered setTimeLimit() likely render future corresponding worker invalid. Identified fixed one reason cluster multisession futures result errors â€œUnexpected result (class â€˜NULLâ€™ != â€˜FutureResultâ€™) retrieved MultisessionFuture future â€¦ suggests communication â€˜RichSOCKnodeâ€™ #1 host â€˜localhostâ€™ (R development (unstable) (2025-03-23 r88038), platform x86_64-pc-linux-gnu) sync.â€ Switching plan active futures likely result active futures becoming corrupt, resulting unpredictable errors querying future , instance, value(), also resolved(), never produce error. Now futures become predictable, interrupted futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-40-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.40.0","text":"Updated future topology vignette information CPU-overuse protection error may occur using nested future plan avoid .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"cleanup-1-40-0","dir":"Changelog","previous_headings":"","what":"Cleanup","title":"Version 1.40.0","text":"Starting future 1.20.0 (2020-10-30), several low-level functions creating working PSOCK MPI clusters moved parallelly package. backward-compatibility reasons, functions kept future re-exports, e.g.Â future::makeClusterPSOCK() still works, whereas parallelly::makeClusterPSOCK() preferred use. long-term goal clean re-exports. Starting release, future package longer re-exports autoStopCluster(), makeClusterMPI(), makeNodePSOCK().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1340","dir":"Changelog","previous_headings":"","what":"Version 1.34.0","title":"Version 1.34.0","text":"CRAN release: 2024-07-29","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-34-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.34.0","text":"Added support backend maintainers specify â€œcleanupâ€ hook functions future strategies, called switching future plan. hook functions specified via optional cleanup attribute, cf.Â attr(cluster, \"cleanup\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-34-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.34.0","text":"Size calculation globals now done using much faster parallelly::serializedSize().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-34-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.34.0","text":"resolved() ClusterFuture:s produce Error:    'inherits(future, \"Future\")' TRUE instead intended, informative error message connection parallel worker broken.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1332","dir":"Changelog","previous_headings":"","what":"Version 1.33.2","title":"Version 1.33.2","text":"CRAN release: 2024-03-26","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-33-2","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.33.2","text":"Decreased overhead launching futures occurred future strategies used complex workers argument. example, plan(cluster, workers = cl), cl cluster object, come extra overhead, workers object unnecessarily transferred cluster nodes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-33-2","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.33.2","text":"Now plan(multisession, workers = (n)), cluster, preserves â€œAsIsâ€ class attribute workers argument propagated parallelly::makeClusterWorkers().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-33-2","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.33.2","text":"Clarify packages must change future.* options.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1331","dir":"Changelog","previous_headings":"","what":"Version 1.33.1","title":"Version 1.33.1","text":"CRAN release: 2023-12-22","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-33-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.33.1","text":"getExpression() â€˜clusterâ€™ future circumstances call local() global search path rather base::local() intended. example, package exports local() function attached, called instead, often leading hard--troubleshoot error.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1330","dir":"Changelog","previous_headings":"","what":"Version 1.33.0","title":"Version 1.33.0","text":"CRAN release: 2023-07-01","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-33-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.33.0","text":"â€˜clusterâ€™ future fails communicate parallel worker, post-mortem analysis figure , including inspecting whether worker process still alive . previous versions, worked workers running current machine. Starting version, also attempts check remote versions.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-33-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.33.0","text":"â€˜multicoreâ€™ future failed, parallel process crashed, corresponding parallel-worker slot never released. Now removed can confirm forked worker process longer alive.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-33-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.33.0","text":"â€˜multiprocessâ€™ strategy now fully removed. Please use â€˜multisessionâ€™ (recommended) â€˜multicoreâ€™ instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1320","dir":"Changelog","previous_headings":"","what":"Version 1.32.0","title":"Version 1.32.0","text":"CRAN release: 2023-03-07","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-32-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.32.0","text":"Add prototype internal event-logging framework purpose profiling futures backends. Add option future.globalenv.onMisuse optionally asserting future expression result variables added global environment. Add option future.onFutureCondition.keepFuture controlling whether FutureCondition objects keep copy Future object . default keep copy, future carries large global objects, FutureCondition also large, can result memory issues slow downs.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-32-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.32.0","text":"Fix future.tests check occurred MS Windows.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-32-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.32.0","text":"â€˜multiprocessâ€™ strategy, deprecated since future 1.20.0 [2020-10-30] now defunct. Please use â€˜multisessionâ€™ (recommended) â€˜multicoreâ€™ instead. Add optional assertion internal Future state field.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1310","dir":"Changelog","previous_headings":"","what":"Version 1.31.0","title":"Version 1.31.0","text":"CRAN release: 2023-02-01","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-31-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.31.0","text":"Remove function remote(). Note plan(remote, ...) deprecated since future 1.24.0 [2022-02-19] defunct since future 1.30.0 (2022-12-15).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-31-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.31.0","text":"Add example â€˜Common Issues Solutionsâ€™ vignette magrittr pipes can result error used future assignment operator fix .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-31-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.31.0","text":"Error messages contain deparsed version future expression become large cases expression comprises expanded, large objects. Now first 100 lines expression deparsed.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-31-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.31.0","text":"Deprecated plan(multiprocess, ...) now equals plan(sequential), still producing one warning time future created. Argument local defunct removed. Previously local = FALSE defunct. Remove defunct argument value resolve() methods. Remove defunct functions transparent() TransparentFuture().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1300","dir":"Changelog","previous_headings":"","what":"Version 1.30.0","title":"Version 1.30.0","text":"CRAN release: 2022-12-15","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-30-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.30.0","text":"futureOf() used listenv::map(), deprecated listenv (>= 0.9.0) favor listenv::mapping(). Starting R (>= 4.2.0), internal function myInternalIP() longer detected attempted system call failed, resulting obscure error instead falling back alternatives. errors produced system2() longer inherits class simpleError.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-30-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.30.0","text":"Strategy â€˜remoteâ€™ deprecated future 1.24.0 now defunct. Use plan(cluster, ..., persistent = TRUE) instead. Note persistent = TRUE eventually also become deprecated defunct, alternative solution available.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1290","dir":"Changelog","previous_headings":"","what":"Version 1.29.0","title":"Version 1.29.0","text":"CRAN release: 2022-11-06","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-29-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.29.0","text":"Add section â€˜Making sure stop parallel workersâ€™ â€˜Best Practices Package Developersâ€™, explains R CMD check may produce â€œchecking detritus temp directory â€¦ NOTEâ€ avoid .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-29-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.29.0","text":"evaluation sequential future reset warnings collected R prior creating future. happened plan(sequential) getOption(\"warn\") == 0. bug introduced future 1.26.0 [2022-05-27].","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-29-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.29.0","text":"Using deprecated plan(multiprocess) now trigger deprecation warning time multiprocess future created. means lot warnings produced. Note multiprocess deprecated since future 1.20.0 [2020-10-30]. Please use multisession (recommended) multicore instead. Removing values(), defunct since future 1.23.0. Use value() instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1280","dir":"Changelog","previous_headings":"","what":"Version 1.28.0","title":"Version 1.28.0","text":"CRAN release: 2022-09-02","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-28-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.28.0","text":"Mention source(..., local = TRUE) preferred source() used inside futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-28-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.28.0","text":".call(plan, args = list(multisession, workers = 2)) ignore workers argument, arguments.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-28-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.28.0","text":"Previously deprecated use local = FALSE futures now defunct. R option temporarily allow plan(transparent) although declared defunct now removed; plan(transparent), together functions transparent() TransparentFuture() now formally defunct. Using argument persistent multisession futures now defunct. Previously persistent = TRUE defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-28-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.28.0","text":"Use CSS style align image right instead non-HTML5 attribute align=\"right\". Avoid nested <em> tags HTML-generated help pages.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1270","dir":"Changelog","previous_headings":"","what":"Version 1.27.0","title":"Version 1.27.0","text":"CRAN release: 2022-07-22","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-27-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.27.0","text":"fallback sequential processing done â€˜multicoreâ€™ â€˜multisessionâ€™ workers = 1 can now overridden specifying workers = (1).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-27-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.27.0","text":"warnings errors showed wrong call. print() FutureResult report captured conditions class list, instead condition classes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1261","dir":"Changelog","previous_headings":"","what":"Version 1.26.1","title":"Version 1.26.1","text":"CRAN release: 2022-05-27","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-26-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.26.1","text":"TESTS: R CMD check ---cran R-devel MS Windows trigger NOTE â€œCheck: detritus temp directoryâ€ â€œFound following files/directories: â€˜Rscript1349cb8aeeba0â€™ â€¦â€. two package tests explicitly created PSOCK clusters without stopping . third test launched multisession future without resolving , prevented PSOCK worker terminate. detected R 4.2.0. problem macOS Linux, background workers automatically terminated main R session terminates.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-26-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.26.0","text":"R options environment variables now reset workers future resolved packages required future loaded attached. Previously, reset loaded attached. addition, pre-existing R options environment variables reset. new ones added removed now, know added R options environment variables might added loading package essential package work. current working directory changed evaluating future expression, current working directory now reset future resolved.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-26-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.26.0","text":"futureSessionInfo() gained argument anonymize. TRUE (default), host user names anonymized. futureSessionInfo() now also reports main R session details.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-26-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.26.0","text":"bug fix future 1.22.0 addressed issue object future(fcn(), globals = list(= 42, fcn =    function() )) found redesigned robust way. Use packages data.table ff cluster multisession futures broke future 1.25.0. data.table, saw â€œError setalloccol(ans) : verbose must TRUE FALSEâ€. ff, saw â€œError splitted$path[nopath] <- getOption(â€fftempdirâ€) : replacement length zeroâ€. See â€˜Significant Changesâ€™ fixed. deprecation warning using local = FALSE silenced sequential futures since future 1.25.0. futureCall() ignored arguments stdout, conditions, earlySignal, label, gc.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-26-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.26.0","text":"Strategy â€˜transparentâ€™ deprecated future 1.24.0 now defunct. Use plan(sequential, split = TRUE) instead. Strategy â€˜multiprocessâ€™ deprecated future 1.20.0, â€˜remoteâ€™ deprecated future 1.24.0. Since , attempts use plan() produce deprecation warning, limited one per R session. Starting release, warning now produced whenever using plan() deprecated future strategies.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1250","dir":"Changelog","previous_headings":"","what":"Version 1.25.0","title":"Version 1.25.0","text":"CRAN release: 2022-04-24","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-25-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.25.0","text":"R options environment variables now reset workers future resolved changes future expression effect following futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-25-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.25.0","text":"Now f <- future(..., stdout = structure(TRUE, drop = TRUE)) cause captured standard output dropped future object soon relayed , instance, value(f). Similarly, conditions = structure(\"conditions\", drop =    TRUE) drop captured non-error conditions soon relayed. can help decrease amount memory used, especially many active futures. Now resolve() respects option future.wait.interval. Previously, hardcoded poll results every 0.1 seconds.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-25-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.25.0","text":"Now, value() attempt recover UTF-8 symbols captured standard output future evaluated MS Windows support capturing UTF-8 symbols. Support UTF-8 capturing also MS Windows added R 4.2.0, typically requires --date MS Windows 10 MS Windows Server 2022.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-25-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.25.0","text":"default value option future.wait.interval decreased 0.2 seconds 0.01 seconds. controls polling frequency finding available worker workers currently busy. Starting release, option also controls polling frequency resolve().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-25-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.25.0","text":"bug introduced future 1.24.0 [2022-02-19] caused future plan tweaking break, e.g.Â plan(multicore, workers = 2) plan(sequential, split = TRUE) introduced breaking side effects futures evaluated.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1240","dir":"Changelog","previous_headings":"","what":"Version 1.24.0","title":"Version 1.24.0","text":"CRAN release: 2022-02-19","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-24-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.24.0","text":"Now future(..., seed = TRUE) forwards RNG state calling R session. Previously, leave intact.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-24-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.24.0","text":"Now plan() tweak() preserve calls arguments, e.g.Â plan(multisession, workers = 2, rscript_startup =    quote(options(socketOptions=\"-delay\"))), tweak(..., abc =    quote(x == y)).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-24-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.24.0","text":"nbrOfFreeWorkers() produce â€œError: â€˜.character(name)â€™ TRUEâ€ plan(multisession, workers = 1). Internal calls FutureRegistry(action = \"collect-first\") FutureRegistry(action = \"collect-last\") signal errors early polling resolved().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-24-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.24.0","text":"Strategy â€˜remoteâ€™ deprecated favor â€˜clusterâ€™. plan() function give informative deprecation warning â€˜remoteâ€™ used. now, warning given per R session. Strategy â€˜transparentâ€™ deprecated favor â€˜sequentialâ€™ argument split = TRUE set. plan() function give informative deprecation warning â€˜transparentâ€™ used. now, warning given per R session.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1230","dir":"Changelog","previous_headings":"","what":"Version 1.23.0","title":"Version 1.23.0","text":"CRAN release: 2021-10-31","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-23-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.23.0","text":"plan() now produces one-time warning â€˜transparentâ€™ strategy set. warning reminds user â€˜transparentâ€™ used troubleshooting purposes never used production. days plan(sequential, split = TRUE) together debug() probably better approach troubleshooting. long-term plan deprecate â€˜transparentâ€™ strategy. Support persistent = TRUE multisession futures defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-23-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.23.0","text":"UTF-8 symbols outputted MS Windows relayed escaped symbols, e.g.Â UTF-8 check mark symbol (\\u2713) relayed <U+2713> (8 characters). reason limitation R MS Windows. Now, value() attempts recover MS Windows output UTF-8 relaying . option disabling new feature.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-23-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.23.0","text":"TESTS: Using robust emulation crashed forked parallel workers understanding quit() must used forked R processes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-23-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.23.0","text":"Now future(..., seed) set random seed late possible just future expression evaluated. Previously done package dependencies attached, lead non-reproduce random numbers case package dependency update RNG seed attached.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-23-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.23.0","text":"values(), deprecated since future 1.20.0, now defunct. Use value() instead. Support persistent = TRUE multisession futures defunct. still needed, temporary workaround use cluster futures. However, likely support persistent eventually deprecated future backends. Argument value resolve(), deprecated since future 1.15.0, defunct favor argument result.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1221","dir":"Changelog","previous_headings":"","what":"Version 1.22.1","title":"Version 1.22.1","text":"CRAN release: 2021-08-25","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-22-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.22.1","text":"Disable package test emulates crashing forked parallel workers using parallel::makeCluster(..., type = \"FORK\"). test disabled macOS, appears main R session becomes unstable FORK node terminated.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-22-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.22.0","text":"lazy future remains generic future launched, means assigned future backend class launched. Argument seed futureAssign() futureCall() now defaults FALSE just like future(). R_FUTURE_* environment variables now read future package loaded, set corresponding future.* option. Previously, environment variables queried different functions fallback option set. parsing package loaded, decrease overhead functions, clarifies options can changed runtime whereas environment variables set startup.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-22-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.22.0","text":"overhead initiating futures significantly reduced. example, roundtrip time value(future(NULL)) twice fast â€˜sequentialâ€™, â€˜clusterâ€™, â€˜multisessionâ€™ futures. â€˜multicoreâ€™ futures roundtrip speedup 20%. speedup comes pre-compiling R expression used resolve future expression R expression templates can quickly compiled future. speeds creation expression ~10 times, compared re-compiling time. default timeout resolved() decreased 0.20 0.01 seconds cluster/multisession multicore futures, means spend less time waiting results available.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-22-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.22.0","text":"Analogously globals may scanned â€œnon-exportableâ€ objects option future.globals.onReference set \"error\" \"warning\", value() now check similar problems resolved value object. example f <-    future(xml2::read_xml(\"<body><\/body>\")), result invalid xml_document object run parallel, objects transferred R processes. addition specify condition classes captured relayed, now possible also specify condition classes ignored. example, conditions = structure(\"condition\", exclude    = \"message\") captures conditions message conditions. Now cluster futures use homogeneous = NULL default instead homogeneous = TRUE. new default result parallelly package trying infer whether TRUE FALSE used based workers argument. Now post-mortem analysis report multicore cluster futures case results retrieved include information globals sizes, non-exportable. similar, detailed report also produced cluster future fails set launch parallel worker. option future.fork.multithreading.enable FALSE, RcppParallel, addition OpenMP, forced run single threaded whenever running forked process (=â€˜multicoreâ€™ futures). done setting environment variable RCPP_PARALLEL_NUM_THREADS 1. Add futureSessionInfo() get quick overview future framework, current setup, run simple tests . Now plan(multicore) warns immediately multicore processing, , forked processing, supported, e.g.Â running RStudio Console.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-22-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.22.0","text":"plan(multiprocess, workers = n) warn â€˜multiprocessâ€™ deprecated argument workers specified. getGlobalsAndPackages() throw false error â€œmean create future within function? Invalid future expression tries use global ... variables exist: â€ ... solely part formula used S4 generic functions. enabled, option future.globals.onReference falsely alert â€˜Detected non-exportable reference (externalptr) one globals (<unknown>) used future expressionâ€™ globals, e.g.Â using future.apply furrr map-reduce functions using â€˜multisessionâ€™ backend. future(fcn(), globals = list(= 42, fcn = function() )) fail â€œError fcn() : object â€˜â€™ foundâ€ using sequential multicore futures. affected also map-reduce calls future.apply::future_lapply(1, function(x) ,    future.globals = list(= 42)). Resolving â€˜sequentialâ€™ future without globals result internal several ...future.* objects written calling environment, might global environment. Environment variable R_FUTURE_PLAN propagate nested futures, forcing onto also nested future plans. Now unset nested futures, resulting sequential future strategy unless another explicitly set plan(). Transparent futures longer warn local = FALSE deprecated. Although local = FALSE deprecated, still used internally â€˜transparentâ€™ futures longer. Please use â€˜transparentâ€™ futures production code never package. remote() produce error â€œobject â€˜homogeneousâ€™ foundâ€. nbrOfFreeWorkers() â€˜clusterâ€™ futures assumed current plan set cluster .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1210","dir":"Changelog","previous_headings":"","what":"Version 1.21.0","title":"Version 1.21.0","text":"CRAN release: 2020-12-10","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-21-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.21.0","text":"order handle conditionally higher call chain, warnings errors produced using random number generator (RNG) future without declaring intention use one now class RngFutureWarning RngFutureError, respectively. classes inherits RngFutureCondition. Now run-time errors resolving future take precedence RngFutureError:s. , future({ rnorm(1); log(\"\") }, seed =    FALSE) signal error â€˜log(â€œâ€)â€™ instead RNG error option future.rng.onMisuse set \"error\".","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-21-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.21.0","text":"Add nbrOfFreeWorkers() query many workers free take futures immediately. third-party future backends implemented , backends might produce error saying yet supported.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-21-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.21.0","text":"future(..., seed = TRUE) â€˜sequentialâ€™ futures set RNG kind parent process. Now behaves regardless future backend. Signaling immediateCondition:s â€˜multicoreâ€™ result Error save_rds(obj, file) : save_rds() failed rename    temporary save file    '/tmp/RtmpxNyIyK/progression21f3f31eadc.rds.tmp' (NA bytes; last    modified NA) '/tmp/RtmpxNyIyK/progression21f3f31eadc.rds' (NA    bytes; last modified NA). assertion end internal save_rds() function incorrectly assumed target file exist. However, file might already processed removed future main R session. value() run-time error RNG mistake signal RNG warning instead run-time error -internal-use-argument signal set FALSE. Due mistake introduced future 1.20.0, package end assigning .packageVersion object global environment loaded.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1201","dir":"Changelog","previous_headings":"","what":"Version 1.20.1","title":"Version 1.20.1","text":"CRAN release: 2020-11-03","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-20-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.20.1","text":"future::plan(\"multisession\") produce â€˜Error (debug) mdebug(â€œcovr::package_coverage() workaround â€¦â€) : argument interpretable logicalâ€™ covr package loaded.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-20-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.20.0","text":"Strategy â€˜multiprocessâ€™ deprecated favor either â€˜multisessionâ€™ â€˜multicoreâ€™, depending operating system R setup. plan() function give informative deprecation warning â€˜multiprocessâ€™ used. warning given per R session. Launching R Rscript command-line option --parallel=n, n > 1, now use â€˜multisessionâ€™ future strategy. Previously, use â€˜multiprocessâ€™, now deprecated. Support local = FALSE deprecated. time , remains supported â€˜transparentâ€™ futures â€˜clusterâ€™ futures use persistent = TRUE. However, note persistent =    TRUE also deprecated point future. deprecations required order standardize Future API across various types parallel backends. Now multisession workers inherit package library path main R session created, , calling plan(multisession). avoid , use plan(multisession,    rscript_libs = NULL), argument passed makeClusterPSOCK(). update, â€˜sequentialâ€™, â€˜multisessionâ€™, â€˜multicoreâ€™ futures see exact library path. Several functions managing parallel-style processing moved new parallelly package. Specifically, functions availableCores(), availableWorkers(), supportsMulticore(), .cluster(), autoStopCluster(), makeClusterMPI(), makeClusterPSOCK(), makeNodePSOCK() moved. None specific futures per se likely useful elsewhere . Also, separate, standalone package speed process releasing updates functions. code base future package shrunk 10-15% migration. backward compatibility, migrated functions remain package re-exports.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-20-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.20.0","text":"Setting future strategy argument split = TRUE cause standard output non-error conditions split (â€œtee:dâ€) workerâ€™s end, still relaying back main R session . can useful debugging browse() debug(), e.g.Â plan(sequential, split = TRUE). Without , debug output displayed. Now multicore futures relay immediateCondition:s near-live fashion. now possible pass arguments makeClusterPSOCK() accepts call plan(cluster, ...) plan(multisession,    ...). instance, set working directory cluster workers temporary folder, pass argument rscript_startup =    \"setwd(tempdir())\". Another example rscript_libs = c(libs,    \"*\") prepend library path worker paths libs. plan() tweak() check even arguments must set either . Specifically, attempts adjust following arguments future() result error: conditions, envir, globals, packages, stdout, substitute addition already validated lazy seed. tweak() now returns wrapper function calls original future strategy function modified defaults. Previously, make copy original function modified argument defaults. new approach make possible introduce new future arguments can modified tweak() plan() without update every future backend package, e.g.Â new split = TRUE argument.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-20-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.20.0","text":"Add â€˜Best Practices Package Developersâ€™ vignette. Add â€˜Future Framework Validatedâ€™ vignette.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-20-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.20.0","text":"Harmonizing Future constructor functions also use substitute =    TRUE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-20-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.20.0","text":"Since last version, future 1.19.1, future(..., conditions =    character(0L)) longer avoid intercepting conditions intended; instead, muffles conditions. now , use conditions = NULL. Relaying immediateCondition:s near-live multisession cluster underlying PSOCK cluster used useXDR=FALSE communication. print() Future also print attributes environment. error message produced nbrOfWorkers() incomplete. Renamed environment variable R_FUTURE_MAKENODEPSOCK_tries used makeClusterPSOCK() R_FUTURE_MAKENODEPSOCK_TRIES. Mandelbrot demo produce random numbers without declaring .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-20-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.20.0","text":"Strategy â€˜multiprocessâ€™ deprecated favor either â€˜multisessionâ€™ â€˜multicoreâ€™, depending operating system R setup. values() deprecated. Use value() instead. backward compatible code legacy, defunct, internal Future element value now removed. Using relying error.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1191","dir":"Changelog","previous_headings":"","what":"Version 1.19.1","title":"Version 1.19.1","text":"CRAN release: 2020-09-22","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-19-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.19.1","text":"passing ... globals, rather via arguments, higher-level map-reduce APIs future.apply furrr, arguments ... produce error â€œunused argumentâ€.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-19-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.19.0","text":"Futures detect random number generation (RNG) used resolve . future uses RNG without parallel RNG requested, informative warning produced. request parallel RNG, specify argument seed, e.g.Â f <- future(rnorm(3),    seed = TRUE) y %<-% { rnorm(3) } %seed% TRUE. Higher-level map-reduce APIs provide similarly named â€œseedâ€ arguments achieve . , escalate warning errors, set option future.rng.onMisuse \"error\". silence , set \"ignore\". Now, non-captured conditions muffled, possible. instance, future(warning(\"boom\"), conditions = c(\"message\")) truly muffle warning regardless backend used. needed fix bug.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-19-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.19.0","text":"makeClusterPSOCK() now retry create cluster node tries (default: 3) times giving . argument port species one port (e.g.Â port = \"random\") also attempt find valid random port tries times giving . pre-validation random port supported R (>= 4.0.0) skipped otherwise. makeClusterPSOCK() skips shell quoting elements rscript inherits AsIs. makeClusterPSOCK(), actually makeNodePSOCK(), gained argument quiet, can used silence output produced manual = TRUE. multithreading disabled multicore futures fail acknowledge setting current system, informative FutureWarning produced futures. Now availableCores() better supports Slurm. Specifically, environment variable SLURM_CPUS_PER_TASK set, requires option --slurm-cpus-per-task=n specified SLURM_JOB_NUM_NODES=1, falls back using SLURM_CPUS_ON_NODE, e.g.Â using --ntasks=n. Now availableCores() availableWorkers() supports LSF/OpenLava. Specifically, acknowledge environment variable LSB_DJOB_NUMPROC LSB_HOSTS, respectively.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-19-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.19.0","text":"Now plan(multisession), plan(cluster, workers = <number>), makeClusterPSOCK() use internally, sets localhost workers twice fast compared versions since future 1.12.0, brings back par bare-bone parallel::makeCluster(..., setup_strategy = \"sequential\") setup. slowdown introduced future 1.12.0 (2019-03-07) protection leaving stray R processes behind failed worker startup implemented. protection now makes use memoization speedup.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-19-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.19.0","text":"Sequential multicore backends, multisession, produce errors â€œâ€˜â€¦â€™ used incorrect contextâ€ cases ... part argument globals evaluation environment. Contrary future backends, conditions produced resolving sequential future using future(..., conditions =    character()) signaled, although reasonable expectation silenced. Now, non-captured conditions muffled, possible. Option future.rng.onMisuse passed nested futures. Disabling multithreading forked processes setting R option future.fork.multithreading.enable environment variable R_FUTURE_FORK_MULTITHREADING_ENABLE FALSE cause multicore futures always return value 1L. bug introduced future 1.17.0 (2020-04-17). getGlobalsAndPackages() always return globals element class FutureGlobals. getGlobalsAndPackages(..., globals) recalculate total_size even already calculated known zero. getGlobalsAndPackages(Formula::Formula(~ x)) produce â€œcondition length > 1â€ warnings (become errors future R versions).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1180","dir":"Changelog","previous_headings":"","what":"Version 1.18.0","title":"Version 1.18.0","text":"CRAN release: 2020-07-09","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-18-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.18.0","text":"Support persistent = TRUE multisession futures deprecated.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-18-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.18.0","text":"print() RichSOCKcluster gives information name host also version R platform node (â€œworkerâ€), e.g.Â â€œSocket cluster 3 nodes 2 nodes host â€˜localhostâ€™ (R version 4.0.0 (2020-04-24), platform x86_64-w64-mingw32), 1 node host â€˜n3â€™ (R version 3.6.3 (2020-02-29), platform x86_64-pc-linux-gnu)â€. Error messages cluster future failures now informative â€œUnexpected result (class â€˜NULLâ€™ != â€˜FutureResultâ€™)â€. example, future package installed worker, error message clearly says . Even, unexpected result error PSOCK cluster future, error produced give extra information node failed, e.g.Â â€œUnexpected result (class â€˜NULLâ€™ != â€˜FutureResultâ€™) retrieved ClusterFuture future (label = â€˜â€™, expression = â€˜â€¦â€™): suggests communication ClusterFuture worker (â€˜RichSOCKnodeâ€™ #1 host â€˜n3â€™ (R version 3.6.3 (2020-02-29), platform x86_64-pc-linux-gnu)) sync.â€ now possible set environment variables workers launched makeClusterPSOCK() specify \"<name>=<value>\" part rscript vector argument, e.g.Â rscript = c(\"ABC=123\", \"DEF='hello world'\", \"Rscript\"). works elements rscript match regular expression [[:alpha:]_][[:alnum:]_]*=.* longer shell quoted. makeClusterPSOCK() now returns cluster addition inheriting SOCKcluster also inherit RichSOCKcluster.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-18-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.18.0","text":"Made makeClusterPSOCK() makeNodePSOCK() agile name change parallel:::.slaveRSOCK() parallel:::.workRSOCK() R (>= 4.1.0). makeClusterPSOCK(..., rscript) try locate rscript[1] argument homogeneous FALSE (inferred FALSE). makeClusterPSOCK(..., rscript_envs) result syntax error starting workers due non-ASCII quotation marks option useFancyQuotes set FALSE. plan(list(...)) produce â€˜Error UseMethod(â€œtweakâ€) : applicable method â€™tweakâ€™ applied object class â€œlistâ€â€™ non-function object named â€˜listâ€™ search path. plan(x$abc) x <- list(abc = sequential) produce â€˜Error UseMethod(â€œtweakâ€) : applicable method â€™tweakâ€™ applied object class â€œc(â€˜FutureStrategyListâ€™, â€˜listâ€™)â€â€™. TESTS: R_FUTURE_FORK_ENABLE=false R CMD check ... produce â€˜Error: connections left open: â€¦â€™ checking â€˜multiprocessâ€™ example.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-18-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.18.0","text":"Support persistent = TRUE multisession futures deprecated. still needed, temporary workaround use cluster futures. However, likely support persistent eventually deprecated future backends. Options future.globals.method, future.globals.onMissing, future.globals.resolve deprecated produce warnings set. may used troubleshooting purposes may affect futures evaluated, means reproducibility guaranteed elsewhere.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1170","dir":"Changelog","previous_headings":"","what":"Version 1.17.0","title":"Version 1.17.0","text":"CRAN release: 2020-04-18","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-17-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.17.0","text":"Renamed values() value() clean simplify API.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-17-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.17.0","text":"makeClusterPSOCK() gained argument rscript_envs setting environment variables workers startup, e.g.Â rscript_envs =    c(FOO = \"3.14\", \"BAR\"). Now result future holds session details case error occurred evaluating future.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"miscellaneous-1-17-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.17.0","text":"CRAN servers _R_CHECK_LIMIT_CORES_ set. better emulate CRAN submission checks, future package , loaded, set environment variable â€˜TRUEâ€™ unset R    CMD check running. Note future::availableCores() respects _R_CHECK_LIMIT_CORES_ returns 2L (two cores) detected.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-17-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.17.0","text":"globals named version has_future overwritten â€œgarbageâ€ values internally. Disabling multi-threading using â€˜multicoreâ€™ futures work platforms.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-17-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.17.0","text":"values() S3 methods renamed value() since closely related original purpose value(). values() methods continue work soon formally deprecated later made defunct finally removed. Please replace values() value() calls.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1160","dir":"Changelog","previous_headings":"","what":"Version 1.16.0","title":"Version 1.16.0","text":"CRAN release: 2020-01-16","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-16-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.16.0","text":"Now oplan <- plan(new_strategy) returns list nested strategies previously set, instead just strategy top stack. makes easier temporarily use another plan. old behavior, use oplan <- plan(new_strategy)[[1]].","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-16-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.16.0","text":"Now value() detects future(..., seed = FALSE) call generated random numbers, might give unreliable results non-parallel safe, non-statistically sound random number generation (RNG) used. option future.rng.onMisuse \"warning\", warning produced. \"error\", error produced. \"ignore\" (default), mistake silently ignored. Using seed = NULL like seed = FALSE without performing RNG validation. convenience, argument seed future() may now also ordinary single integer random seed. , Lâ€™Ecuyer-CMRG RNG seed created seed. seed = TRUE, Lâ€™Ecuyer-CMRG RNG seed based current RNG state used. Use seed = FALSE known future use RNG. ClusterFuture:s now relay immediateCondition:s back main process momentarily signaled future resolved.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-16-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.16.0","text":"Add support automatically disable multi-threading using â€˜multicoreâ€™ futures. now, default allow multi-threaded processing might change future. disable multi-threaded, set option future.fork.multithreading.enable environment variable R_FUTURE_FORK_MULTITHREADING_ENABLE FALSE. requires RhpcBLASctl package installed. Parallelization via multi-threaded processing (done native code packages externally library) time using forked (aka â€œmulticoreâ€) parallel processing unstable cases. Note true using plan(multicore) also using, instance, parallel::mclapply(). beta names options might change later.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-16-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.16.0","text":"Evaluation futures fail global environment contained functions names small set base R functions, e.g.Â raw(), list(), options(). future(alist(=)) produce â€œError objectSize_list(x, depth = depth - 1L) : argumentâ€x_kkâ€ missing, defaultâ€","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-16-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.16.0","text":"Future FutureResult objects internal version 1.7 older deprecated since 1.14.0 (July 2019) now defunct. Defunct hidden argument progress resolve(), hidden arguments/fields condition calls FutureResult now gone.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1151","dir":"Changelog","previous_headings":"","what":"Version 1.15.1","title":"Version 1.15.1","text":"CRAN release: 2019-11-25","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-15-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.15.1","text":"default range ports makeClusterPSOCK() draws random port (argument port specified) can now controlled environment variable R_FUTURE_RANDOM_PORTS. default range still 11000:11999 parallel package.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-15-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.15.1","text":"change introduced resolved() future 1.15.0 cause lazy futures block workers occupied.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1150","dir":"Changelog","previous_headings":"","what":"Version 1.15.0","title":"Version 1.15.0","text":"CRAN release: 2019-11-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-15-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.15.0","text":"resolved() now launch lazy futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-15-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.15.0","text":"Now â€œvisibilityâ€ future values recorded reflected value(). Now option future.globals.onReference defaults environment variable R_FUTURE_GLOBALS_ONREFERENCE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-15-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.15.0","text":"Added â€˜Troubleshootingâ€™ section ?makeClusterPSOCK instructions troubleshoot setup local remote clusters fail.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-15-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.15.0","text":"values() resignal immediateCondition:s despite signaled per future. makeClusterPSOCK() produce warnings like â€œopen file â€˜/tmp/alice/Rtmpi69yYF/future.parent=2622.a3e32bc6af7.pidâ€™: fileâ€, e.g.Â launching R workers running Docker containers. Package set update RNG state R (.Random.seed) loaded, affect RNG reproducibility. Package set .Random.seed NULL, instead removing , turn produce warning â€œâ€˜.Random.seedâ€™ integer vector type â€˜NULLâ€™, ignoredâ€ next random number generated. Now future assignment list environments produce informative error messages attempting assign one element. makeClusterMPI() work MPI clusters comm 1.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-15-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.15.0","text":"Argument value resolve() deprecated. Use result instead. Use internal argument evaluator future() now defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1140","dir":"Changelog","previous_headings":"","what":"Version 1.14.0","title":"Version 1.14.0","text":"CRAN release: 2019-07-02","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-14-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.14.0","text":"types conditions now captured relayed. Previously, conditions class message warning relayed. one futures collection produces error, values() signal error soon detected. means calling values() guarantees resolve futures, guarantee result futures gathered back master R session error relayed.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-14-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.14.0","text":"values() now relays stdout signal soon possible long standard output conditions relayed original order. captured condition can â€œmuffledâ€, muffled. helps prevent conditions handled twice condition handlers futures evaluated main R session, e.g.Â plan(sequential). Messages warnings already muffled past. Forked processing considered unstable running R certain environments, RStudio environment. , â€˜multicoreâ€™ futures disabled cases since future 1.13.0. change caught several RStudio users surprise. Starting future 1.14.0, informative one-time-per-session warning produced attempts use â€˜multicoreâ€™ made non-supported environments RStudio. warning also produced using â€˜multiprocessâ€™, fall back using â€˜multisessionâ€™ futures. warning can disabled setting R option future.supportsMulticore.unstable, environment variable FUTURE_SUPPORTSMULTICORE_UNSTABLE \"quiet\". Now option future.startup.script falls back environment variable R_FUTURE_STARTUP_SCRIPT. Conditions inheriting immediateCondition signaled soon possible. Contrary types conditions, signaled per future, despite collected.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-14-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.14.0","text":"Early signaling take place resolved() ClusterFuture MulticoreFuture. early signaling enabled, functions resolved() resolve() relay captured conditions multiple times. , instance, result messages warnings outputted . Now value() resignal conditions. validation connections failed detect connection serialized (= NIL external pointer) macOS systems.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-14-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.14.0","text":"Argument progress resolve() now defunct (deprecated since future 1.12.0). Option future.progress ignored. make room progress-update mechanisms works. Usage internal argument evaluator future() now deprecated. Removed defunct argument output FutureError(). FutureResult fields/arguments condition calls now defunct. Use conditions instead. Future FutureResult objects internal version 1.7 older deprecated eventually become defunct. Future backends implement Future classes update implement result() method instead value() method Future classes. future backends available CRAN Bioconductor already updated accordingly.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1130","dir":"Changelog","previous_headings":"","what":"Version 1.13.0","title":"Version 1.13.0","text":"CRAN release: 2019-05-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-13-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.13.0","text":"Forked processing now disabled default running R via RStudio disabled, â€˜multicoreâ€™ futures fall back â€˜sequentialâ€™ futures. update follows RStudio recommendation using forked parallel processing within RStudio likely break RStudio R session. See help(\"supportsMulticore\") details, e.g.Â re-enable process forking. Note parallelization via â€˜multisessionâ€™ unaffected still work . Also, forked processing disabled, otherwise supported, using plan(\"multiprocess\") fall back using â€˜multisessionâ€™ futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-13-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.13.0","text":"Forked processing can disabled setting R option future.fork.enable FALSE (environment variable R_FUTURE_FORK_ENABLE=false). disabled, â€˜multicoreâ€™ futures fall back â€˜sequentialâ€™ futures even operating system supports process forking. set TRUE, â€˜multicoreâ€™ fall back â€˜sequentialâ€™. NA, set (default), set best-practices rules decide whether forking enabled . See help(\"supportsMulticore\") details. Now availableCores() also recognizes PBS environment variable NCPUS, PBSPro scheduler set PBS_NUM_PPN. , option future.availableCores.custom set function, availableCores() call function interpret value number cores. Analogously, option future.availableWorkers.custom can used specify hostnames set workers availableWorkers() sees. new options provide mechanism anyone customize availableCores() availableWorkers() case (yet) recognize, say, environment variables specific userâ€™s compute environment HPC scheduler. makeClusterPSOCK() gained support argument rscript_startup evaluating one R expressions background R worker prior worker event loop launching. provides convenient approach use, say, rscript_args =    c(\"-e\", sQuote(code)). makeClusterPSOCK() gained support argument rscript_libs control R package library search path workers. example, prepend folder ~/R-libs workers, use rscript_libs = c(\"~/R-libs\", \"*\"), \"*\" resolved current .libPaths() workers. Debug messages now prepended timestamp.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-13-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.13.0","text":"Add vignette â€˜Non-Exportable Objectsâ€™ (extracted another vignette).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-13-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.13.0","text":"makeClusterPSOCK() shell quote Rscript executable running pre-tests checking whether localhost Rscript processes can killed PIDs .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-13-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.13.0","text":"Argument value resolve() renamed result better reflect values collected argument used. Argument value still works backward compatibility, eventually formally deprecated defunct.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1120","dir":"Changelog","previous_headings":"","what":"Version 1.12.0","title":"Version 1.12.0","text":"CRAN release: 2019-03-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-12-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.12.0","text":"makeClusterPSOCK() fails create one many nodes, attempt stop nodes successfully created. lowers risk leaving R worker processes behind. Future results now hold timestamps evaluation future started finished.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-12-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.12.0","text":"Functions longer produce â€œpartial match â€˜conditionâ€™ â€˜conditionsâ€™â€ warnings options(warnPartialMatchDollar =    TRUE). future infix operators (%conditions%, %globals%, %label%, %lazy%, %packages%, %seed%, %stdout%) intended future assignments used wrong context, incorrectly applied next future created. Now â€™re discarded. makeClusterPSOCK() future (>= 1.11.1) produced warnings argument rscript length(rscript) > 1. Validation Lâ€™Ecuyer-CMRG RNG seeds failed recent R devel. options(OutDec = \",\"), default value several argument resolve NA_real_ rather numeric value resulting errors â€œ.finite(alpha) TRUEâ€.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-12-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.12.0","text":"Argument progress resolve() now deprecated. Argument output FutureError() now defunct. FutureError longer inherits simpleError.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-11111","dir":"Changelog","previous_headings":"","what":"Version 1.11.1.1","title":"Version 1.11.1.1","text":"CRAN release: 2019-01-26","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-11-1-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.1.1","text":"makeClusterPSOCK() fails connect worker, produces error detailed information happened. rare cases, another error produced generating information workers PID .","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-11-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.11.1","text":"defaults several arguments makeClusterPSOCK() makeNodePSOCK() can now controlled via environment variables addition R options supported past. advantage using environment variables inherited child processes, also nested ones. printing future plans now less verbose workers argument complex object PSOCK cluster object. Previously, output include verbose output attributes, etc.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-11-1","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.11.1","text":"TESTS: future package loaded, checks whether R    CMD check running . , future-specific environment variables adjusted tests play nice testing environment. instance, sets socket connection timeout PSOCK cluster workers 120 seconds (instead default 30 days!). lower risk zombie worker processes cluttering test machine (e.g.Â CRAN servers) case worker process left behind despite main R processes terminated. Note adjustments applied automatically checks package depends , imports, future package.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-11-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.1","text":"Whenever makeClusterPSOCK() fail connect worker, instance due port clash, leave R worker process running - also main R process terminated. worker running machine, makeClusterPSOCK() now attempt kill stray R processes. Note parallel::makePSOCKcluster() still problem.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1110","dir":"Changelog","previous_headings":"","what":"Version 1.11.0","title":"Version 1.11.0","text":"CRAN release: 2019-01-21","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-11-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.11.0","text":"Message warning conditions now captured relayed default.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-11-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.11.0","text":"future call stack (â€œtracebackâ€) now recorded evaluation future produces error. Use backtrace() future retrieve . Now futureCall() defaults args = list() making easier call functions take arguments, e.g.Â futureCall(function() 42). plan() gained argument .skip = FALSE. TRUE, setting future strategy already set skipped, e.g.Â calling plan(multisession) consecutively effect calling just . makeClusterPSOCK() produces informative error messages whenever setup R workers fails. Also, verbose messages now prefixed [local output] help distinguish output produced current R session produced background workers. now possible specify type SSH clients makeClusterPSOCK() automatically searches order, e.g.Â rshcmd = c(\"<rstudio-ssh>\", \"<putty-plink>\"). Now makeClusterPSOCK() preserves global RNG state (.Random.seed) also draws random port number. makeClusterPSOCK() gained argument rshlogfile. Cluster futures provide informative error messages communication worker node sync.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-11-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.0","text":"Argument stdout forced TRUE using single-core multicore single-core multisession futures. evaluated local environment, futureCall(..., globals =    \"\") set value global NULL, regardless exists true value . makeClusterPSOCK(..., rscript = \"my_r\") cases fail find intended my_r executable. ROBUSTNESS: cluster future, including multisession one, retrieve results wrong workers new set cluster workers set future created/launched results retrieved. happen connections R indexed solely integers recycled old connections closed new ones created. Now cluster futures assert connections workers valid, , informative error message produced. Calling result() non-resolved UniprocessFuture signal evaluation errors.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-11-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.11.0","text":"Removed defunct future::future_lapply(). Please use one future.apply package instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-1100","dir":"Changelog","previous_headings":"","what":"Version 1.10.0","title":"Version 1.10.0","text":"CRAN release: 2018-10-17","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-10-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.10.0","text":"Add support manually specifying globals addition automatically identified via argument globals %globals%. Two examples globals = structure(TRUE, add =    list(= 42L, b = 3.14)) globals = structure(TRUE, add =    c(\"\", \"b\")). Analogously, attribute ignore can used exclude automatically identified globals. error reported failing retrieve results future evaluated localhost cluster/multisession worker forked/multicore worker now informative. Specifically, mentions whether worker process still alive . Add makeClusterMPI(n) creating MPI-based clusters similar kind parallel::makeCluster(n, type = \"MPI\") also attempts workaround issues parallel::stopCluster() causes R stall. makeClusterPSOCK() makeClusterMPI() gained argument autoStop controlling whether cluster automatically stopped garbage collected . BETA: Now resolved() ClusterFuture non-blocking also clusters type MPIcluster created parallel::makeCluster(..., type = \"MPI\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-10-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.10.0","text":"Windows, plan(multiprocess) initiate workers. Instead workers set first future created.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-190","dir":"Changelog","previous_headings":"","what":"Version 1.9.0","title":"Version 1.9.0","text":"CRAN release: 2018-07-23","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-9-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.9.0","text":"Standard output now captured re-outputted value() called. new behavior can controlled argument stdout future() specifying %stdout% operator future assignment used.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-9-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.9.0","text":"R option width passed standard output captured consistently across workers consistently master process. Now future.* options passed also acknowledged using nested futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-9-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.9.0","text":"Add vignette â€˜Outputting Textâ€™. CLEANUP: core parts API now listed help index. done clarify Future API. Help non-core parts still via cross references indexed API well via help().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-9-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.9.0","text":"using forced, nested â€˜multicoreâ€™ parallel processing, , plan(list(tweak(multicore, workers = 2), tweak(multicore, workers    = 2))), child process attempt resolve futures owned parent process resulting error (â€˜bad error messageâ€™). using plan(multicore), forked worker terminate unexpectedly, corrupt master R session attempts using forked workers fail. forked worker terminated way user pressed Ctrl-C (worker receives SIGINT signal). makeClusterPSOCK() produced warning environment variable R_PARALLEL_PORT set random (e.g.Â CRAN). Printing plan() produce error deparsed call used set plan() longer 60 characters.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-9-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.9.0","text":"future::future_lapply() defunct (gives error called). Please use one future.apply package instead. Argument output FutureError() formally deprecated. Removed FutureEvaluationCondition classes related methods.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-181","dir":"Changelog","previous_headings":"","what":"Version 1.8.1","title":"Version 1.8.1","text":"CRAN release: 2018-05-03","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-8-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.8.1","text":"getGlobalsAndPackages() gained argument maxSize. makeClusterPSOCK() now produces informative warning environment variable R_PARALLEL_PORT specifies non-numeric port. Now plan() gives informative error message case fails, e.g.Â internal future validation fails . Added UnexpectedFutureResultError used backends signaling standard way unexpected result retrieved worker.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-8-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.8.1","text":"communication asynchronous future background R process failed, querying future state/results end infinite waiting loop. Now failed communication error recorded re-signaled querying attempts. Internal, seldom used myExternalIP() failed recognize IPv4 answers lookup servers. turn produce another error. R (>= 3.5.0), multicore futures produce multiple warnings originating querying whether background processes completed . warnings now suppressed.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-180","dir":"Changelog","previous_headings":"","what":"Version 1.8.0","title":"Version 1.8.0","text":"CRAN release: 2018-04-08","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-8-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.8.0","text":"Errors produced evaluating futures now (re-)signaled master R process -original content class attributes.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-8-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.8.0","text":"errors related orchestration futures class FutureError make easier distinguish future evaluation errors. Add support richer set results returned resolved futures. Previously value future expression, captured error resignaled, expected. Now FutureResult object may returned instead. Although supported release, update opens reporting additional information evaluation futures, e.g.Â captured output, timing memory benchmarks, etc. can take place, existing future backend packages updated accordingly. backtrace() returns last call produced error. unfortunately possible capture call stack led error evaluating future expression.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-8-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.8.0","text":"value() MulticoreFuture produce error (forked) background R workers terminate future expression resolved. limitation inherited parallel package. Now informative FutureError message produced. value() MulticoreFuture signal errors unless inherited simpleError - now â€™s enough inherits error. value() ClusterFuture longer produces FutureEvaluationError, FutureError, connection R worker changed (happens something drastic closeAllConnections() called.) futureCall(..., globals = FALSE) produce â€œError: second argument must listâ€, explicit arguments exported. also happen specifying globals name named list. Nested futures conservative requiring global variables exist, even false positives.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-8-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.8.0","text":"future::future_lapply() formally deprecated. Please use one future.apply package instead. Recently introduced FutureEvaluationCondition classes deprecated, longer serve purpose since future evaluation conditions now signaled -.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-170","dir":"Changelog","previous_headings":"","what":"Version 1.7.0","title":"Version 1.7.0","text":"CRAN release: 2018-02-11","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-7-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.7.0","text":"future_lapply() moved future.apply package available CRAN.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-7-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.7.0","text":"Argument workers future strategies may now also function, called without argument future strategy set used . instance, plan(multiprocess, workers =    halfCores) halfCores <- function() { max(1,    round(availableCores()/ 2)) } use half number available cores. useful using nested future strategies remote machines. Windows, makeClusterPSOCK(), therefore plan(multisession) plan(multiprocess), use SSH client distributed RStudio fallback neither ssh plink available system PATH. Now plan() makes sure nbrOfWorkers() work new strategy. help catch mistakes plan(cluster,    workers = cl) cl basic R list rather cluster list early . Added %packages% explicitly control packages attached future resolved, e.g.Â y %<-% { YT[2] } %packages%    \"data.table\". Note, needed cases automatic identification global package dependencies sufficient. Added condition classes FutureCondition, FutureMessage, FutureWarning, FutureError representing conditions occur future setup, launched, queried, retrieved. represent conditions occur evaluating future expression. conditions, new classes FutureEvaluationCondition, FutureEvaluationMessage, FutureEvaluationWarning, FutureEvaluationError exists.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.7.0","text":"Vignette â€˜Common Issues Solutionsâ€™ now documents case future framework fails identify variable global conditionally, e.g.Â (runif(1) <    1/2) x <- 0; y <- 2 * x.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"beta-features-1-7-0","dir":"Changelog","previous_headings":"","what":"Beta Features","title":"Version 1.7.0","text":"Added mechanism detecting globals may exportable external R process (â€œworkerâ€). Typically, globals carry connections external pointers (externalptr) can exported, exceptions. setting options future.globals.onReference \"warning\", warning produced informing user potential problems. \"error\", error produced. might false positive, default \"ignore\", cause scans skipped. non-exportable globals tests skipped, run-time error may produced future expression evaluated.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-7-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.7.0","text":"total size global variables overestimated, dramatically defined global environment large objects . sometimes result false error saying total size larger allowed limit. assignment x <- x + 1 left-hand side (LHS) x global failed identify x global right-hand side (RHS) x override local variable. Updates globals package fixed problem. makeClusterPSOCK(..., renice = 19) launch PSOCK worker via nice +19 resulting error â€œnice: â€˜+19â€™: file directoryâ€. bug inherited parallel::makePSOCKcluster(). Now using nice --adjustment=19 instead. Protection passing future objects futures work future strategy â€˜multicoreâ€™.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-7-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.7.0","text":"future_lapply() moved new future.apply package available CRAN. future::future_lapply() function soon deprecated, defunct, eventually removed future package. Please update code make use future.apply::future_lapply() instead. Dropped defunct â€˜eagerâ€™ â€˜lazyâ€™ futures; use â€˜sequentialâ€™ instead. Dropped defunct arguments cluster maxCores; use workers instead. previous version future package FutureError class used represent orchestration errors (now FutureError) evaluation errors (now FutureEvaluationError). usage class FutureError latter type errors deprecated updated FutureEvaluationError.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-162","dir":"Changelog","previous_headings":"","what":"Version 1.6.2","title":"Version 1.6.2","text":"CRAN release: 2017-10-16","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-6-2","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.6.2","text":"Now plan() accepts also strings \"future::cluster\". Now backtrace(x[[ER]]) works also non-environment x:s, e.g.Â lists.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-6-2","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.6.2","text":"measuring size globals scanning content, certain types classes inferred lengths objects incorrect causing internal subset --range issues. print() Future output one global per line instead concatenating information commas.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-161","dir":"Changelog","previous_headings":"","what":"Version 1.6.1","title":"Version 1.6.1","text":"CRAN release: 2017-09-09","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-6-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.6.1","text":"Now exporting getGlobalsAndPackages().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-6-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.6.1","text":"future_lapply() give â€œError objectSize.env(x, depth = depth - 1L): object â€˜nnnâ€™ foundâ€ instance â€˜nnnâ€™ part unresolved expression argument value.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-6-1","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.6.1","text":"FIX: package assertion tests made precise assumptions object sizes, fails introduction ALTREP R-devel causes Râ€™s SEXP header size change.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-160","dir":"Changelog","previous_headings":"","what":"Version 1.6.0","title":"Version 1.6.0","text":"CRAN release: 2017-08-13","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-6-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.6.0","text":"Now tweak(), hence plan(), generates informative error message non-future function specified mistake, e.g.Â calling plan(cluster) survival package attached future equivalent calling plan(survival::cluster) plan(future::cluster) intended.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-6-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.6.0","text":"nbrOfWorkers() gave error plan(remote). Fixed making â€˜remoteâ€™ future inherit cluster ().","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-6-0","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.6.0","text":"TESTS: longer testing forced termination forked cluster workers running Solaris. termination done launching future called quit(), appeared corrupted main R session running Solaris.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-6-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.6.0","text":"Formally defunct â€˜eagerâ€™ â€˜lazyâ€™ futures; use â€˜sequentialâ€™ instead. Dropped previously defunct %<=% %=>% operators.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-150","dir":"Changelog","previous_headings":"","what":"Version 1.5.0","title":"Version 1.5.0","text":"CRAN release: 2017-05-26","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-5-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.5.0","text":"Multicore multisession futures longer reserve one core main R process, done lower risk producing higher CPU load number cores available R session.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-5-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.5.0","text":"makeClusterPSOCK() now defaults use Windows PuTTY softwareâ€™s SSH client plink -ssh, ssh found. Argument homogeneous makeNodePSOCK(), helper function makeClusterPSOCK(), default FALSE also hostname fully qualified domain name (FQDN), , â€œcontains periodsâ€. instance, c('node1', 'node2.server.org') use homogeneous = TRUE first worker homogeneous = FALSE second. makeClusterPSOCK() now asserts cluster node functioning retrieving recording nodeâ€™s session information including process ID corresponding R process. Nested futures sets option mc.cores prevent spawning recursive parallel processes mistake. â€˜mc.coresâ€™ controls additional processes, previously set zero. However, since functions mclapply() support , now set one instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-5-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.5.0","text":"Help makeClusterPSOCK() gained detailed descriptions arguments defaults .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-5-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.5.0","text":"Formally deprecated eager futures; use sequential instead.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-5-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.5.0","text":"future_lapply() multicore / multisession futures, use suboptimal workload balancing split data one chunk many. longer problem argument workers now defined type futures (see note top). future_lapply(), well lazy multicore lazy sequential futures, respect option future.globals.resolve, hardcoded always resolve globals (future.globals.resolve =    TRUE). globals larger allowed size (option future.globals.maxSize) detected informative error message generated. Previous version introduced bug causing error produce another error. Lazy sequential futures produce error resolved required packages detached. print() display globals gathered lazy sequential futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"software-quality-1-5-0","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.5.0","text":"Added package tests globals part formulas part globals, e.g.Â purrr::map(x, ~ rnorm(.)), requires globals (>= 0.10.0). Now package tests parallel::makeCluster() test type = \"PSOCK\" clusters also \"FORK\" (supported). TESTS: Cleaned test scripts overall processing time tests roughly halved, preserving test coverage.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-140","dir":"Changelog","previous_headings":"","what":"Version 1.4.0","title":"Version 1.4.0","text":"CRAN release: 2017-03-13","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-4-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.4.0","text":"default future_lapply() now generate RNG seeds (future.seed = FALSE). proper random number generation needed, use future.seed = TRUE. details, see help page.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-4-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.4.0","text":"future() future_lapply() gained argument packages explicitly specifying packages attached futures evaluated. Note default throughout future package globals required packages automatically identified gathered, cases specified manually. default values arguments connectTimeout timeout makeNodePSOCK() can now controlled via global options.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"random-number-generation-1-4-0","dir":"Changelog","previous_headings":"","what":"Random Number Generation","title":"Version 1.4.0","text":"Now future_lapply() guarantees RNG state calling R process returning updated compared exact way regardless future.seed (except FALSE), future.scheduling future strategy used. done order guarantee R script calling future_lapply() multiple times numerically reproducible given initial seed. now possible specify pre-generated sequence .Random.seed seeds used FUN(x[[]], ...) call future_lapply(x, FUN, ...).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-1-4-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.4.0","text":"future_lapply() scans global variables non-resolved futures (resolve ) calculate total size . Previously, chunk (future) redo .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-4-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.4.0","text":"Now future_lapply(X, FUN, ...) identifies global objects among X, FUN ... recursively new globals found. Previously, first level globals scanned. mostly thanks bug fix globals 0.9.0. future used global object x class overrides length() produce error length(x) reports elements can subsetted. nbrOfWorkers() gave error plan(cluster, workers = cl) cl cluster object created parallel::makeCluster(), etc. prevented instance future_lapply() work setups. plan(cluster, workers = cl) cl <- makeCluster(..., type =    MPI\") give instant error due invalid internal assertion.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-4-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.4.0","text":"Previously deprecated arguments maxCores cluster now defunct. Previously deprecated assignment operators %<=% %=>% now defunct. availableCores(method = \"mc.cores\") now defunct favor \"mc.cores+1\".","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-130","dir":"Changelog","previous_headings":"","what":"Version 1.3.0","title":"Version 1.3.0","text":"CRAN release: 2017-02-19","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"significant-changes-1-3-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.3.0","text":"applicable, workers now initiated calling plan(), e.g.Â plan(cluster) set workers cluster nodes. Previously, happened first future created.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.3.0","text":"Renamed â€˜eagerâ€™ futures â€˜sequentialâ€™, e.g.Â plan(sequential). â€˜eagerâ€™ futures deprecated upcoming release. Added support controlling whether future resolved eagerly lazily creating future, e.g.Â future(..., lazy =    TRUE), futureAssign(..., lazy = TRUE), x %<-% { ... }    %lazy% TRUE. future(), futureAssign() futureCall() gained argument seed, specifies Lâ€™Ecuyer-CMRG random seed used future. seed future assignment can specified via %seed%. futureAssign() now passes additional arguments future(). Added future_lapply() supports load balancing (â€œchunkingâ€) perfect reproducibility (regardless type load balancing futures resolved) via initial random seed. Added availableWorkers(). default returns localhost workers according availableCores(). addition, detects common HPC allocations given environment variables set HPC scheduler. default plan(cluster) now workers =    availableWorkers(). Now plan() stops clusters implicitly created. instance, multisession cluster created plan(multisession) stopped plan(eager) called. makeClusterPSOCK() treats workers refer local machine local canonical hostname â€œlocalhostâ€. avoids launch workers SSH, may supported systems / compute cluster. Option future.debug = TRUE also reports total size globals identified cluster futures also size individual global variables exported. Option future.wait.timeout (replaces future.wait.times) specifies maximum waiting time free workers (e.g.Â core compute node) generating timeout error. Option future.availableCores.fallback, defaults environment variable R_FUTURE_AVAILABLECORES_FALLBACK can now used specify default number cores / workers returned availableCores() availableWorkers() settings available. instance, R_FUTURE_AVAILABLECORES_FALLBACK=1 set system wide HPC environment, R processes uses availableCores() detect many cores can used run single-core processes. Without fallback setting, without core-specifying settings, default use cores machine, play well multi-user systems.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-1-3-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 1.3.0","text":"Globals part locally defined functions now also identified thanks globals (>= 0.8.0) updates.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-3-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.3.0","text":"Lazy futures plan(lazy) now deprecated. Instead, use plan(eager) f <- future(..., lazy = TRUE) x %<-% {    ... } %lazy% TRUE. reason behind cases code uses futures works eager evaluation (lazy =    FALSE; default), vice verse. removing â€œlazyâ€ future strategy, user can longer override lazy = TRUE / FALSE developer using.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-3-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.3.0","text":"Creation cluster futures (including multisession ones) time already 40 seconds workers busy. New default timeout 30 days (option future.wait.timeout). nbrOfWorkers() gave error plan(cluster, workers) workers character vector cluster object parallel package. , future_lapply() gave error setups. availableCores(methods = \"_R_CHECK_LIMIT_CORES_\") give error running R CMD check.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-120","dir":"Changelog","previous_headings":"","what":"Version 1.2.0","title":"Version 1.2.0","text":"CRAN release: 2016-11-12","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.2.0","text":"Added makeClusterPSOCK() - version parallel::makePSOCKcluster() allows flexible control PSOCK cluster workers set launched communicated running external machines. Added generic .cluster() coercing objects cluster objects used plan(cluster, workers = .cluster(x)). Also added c() implementation cluster objects multiple cluster objects can combined single one. Added sessionDetails() gathering details current R session. plan() plan(\"list\") now prints user-friendly output. Unix, internal myInternalIP() tries alternatives finding local IP number.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-2-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.2.0","text":"%<=% deprecated. Use %<-% instead. %=>%.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-2-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.2.0","text":"values() lists list environments futures one futures resolved NULL give error. value() ClusterFuture give cryptic error message â€œError stop(ex) : bad error messageâ€ cluster worker crashed / terminated. Now instead give error message like â€œFailed retrieve value ClusterFuture cluster node #1 â€˜localhostâ€™. reason reported â€error reading connectionâ€. Argument user remote() ignored (since 1.1.0).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-111","dir":"Changelog","previous_headings":"","what":"Version 1.1.1","title":"Version 1.1.1","text":"CRAN release: 2016-10-11","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-1-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.1.1","text":"special case â€˜remoteâ€™ futures use workers =    \"localhost\" () use exact R executable main / calling R session (cases uses whatever Rscript found PATH). already indeed implemented 1.0.1, added support reverse SSH tunnels 1.1.0 default behavior lost.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-110","dir":"Changelog","previous_headings":"","what":"Version 1.1.0","title":"Version 1.1.0","text":"CRAN release: 2016-10-10","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.1.0","text":"REMOTE CLUSTERS: now simple use cluster() remote() connect remote clusters / machines. long can connect via SSH machines, works also future. new code completely avoids incoming firewall incoming port forwarding issues previously needed. done using reverse SSH tunneling. also need worry internal external IP numbers. Added optional argument label futures, e.g.Â f <-    future(42, label = \"answer\") v %<-% { 42 } %label% \"answer\". Added argument user cluster() remote(). Now Future classes supports run() launching future value() calls run() future launched. MEMORY: Now plan(cluster, gc = TRUE) causes background R session garbage collected immediately value collected. Since multisession remote futures special cases cluster futures, true well. ROBUSTNESS: Now default future strategy explicitly set strategies set, e.g.Â used nested futures. Previously, mc.cores set single core used, now also plan(\"default\") set. WORKAROUND: resolved() cluster futures block Linux future resolved. due bug R. workaround use round timeout (seconds) integer, seems always work / respected.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-1-1-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 1.1.0","text":"Global variables part subassignments future expressions recognized exported (iff found), e.g.Â x$<- value, x[[\"\"]]    <- value, x[1,2,3] <- value. Global variables part formulae future expressions recognized exported (iff found), e.g.Â y ~ x | z. alternative default automatic identification globals, now also possible explicitly specify either names (character vector) names values (named list), e.g.Â f <- future({ 2*}, globals = c(\"\")) f <- future({ 2*}, globals = list(= 42)). future assignments one can use %globals% operator, e.g.Â y %<-% {    2*} %globals% c(\"\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-1-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.1.0","text":"Added vignette command-line options methods controlling default type futures use.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-101","dir":"Changelog","previous_headings":"","what":"Version 1.0.1","title":"Version 1.0.1","text":"CRAN release: 2016-07-04","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-0-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.0.1","text":"ROBUSTNESS: special case â€˜remoteâ€™ futures use workers = \"localhost\" now use exact R executable main / calling R session (cases uses whatever Rscript found PATH). FutureError now extends simpleError longer error class captured errors.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-0-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.0.1","text":"Adding section vignette globals formulas describing currently automatically detected explicitly export .","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.0.1","text":"Since future 0.13.0, global pkg overwritten name last package attached future. Futures generated R.oo::Exception errors, triggered another internal error.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"CRAN release: 2016-06-24","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.0.0","text":"Add support remote(..., myip = \"<external>\"), now queries set external lookup services case one fails. Add mandelbrot() function used demo API convenience. ROBUSTNESS: .future.R script, sourced future package attached, gives error, error ignored warning. TROUBLESHOOTING: future requires attachment packages, namespace loaded separately attaching package. done order see actual error message case problem loading namespace. require()/library() error message otherwise suppressed replaced generic one.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-1-0-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 1.0.0","text":"Falsely identified global variables longer generate error future created. Instead, leave R evaluation individual futures throw error global variable truly missing. done order automatically handle future expressions use non-standard evaluation (NSE), e.g.Â subset(df, x < 3) x falsely identified global variable. Dropped support system environment variable R_FUTURE_GLOBALS_MAXSIZE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-1-0-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 1.0.0","text":"DEMO: Now Mandelbrot demo tiles single Mandelbrot region one future per tile. better illustrates parallelism. Documented R options used future package.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-1-0-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.0.0","text":"Custom futures based constructor function defined outside package gave error. plan(\"default\") assumed future.plan option string; gave error function. Various future options passed futures. startup .future.R script longer sourced future package attached future expression.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0150","dir":"Changelog","previous_headings":"","what":"Version 0.15.0","title":"Version 0.15.0","text":"CRAN release: 2016-06-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-15-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.15.0","text":"Added remote futures, cluster futures convenient default arguments simple remote access R, e.g. plan(remote, workers = \"login.-server.org\"). Now .future.R (found current directory otherwise userâ€™s home directory) sourced future package attach (loaded). helps separating scripts configuration futures. Added support plan(cluster, workers = c(\"n1\", \"n2\", \"n2\",    \"n4\")), workers (also ClusterFuture()) set host names passed parallel::makeCluster(workers). can also number localhost workers. Added command line option --parallel=<p>, long -p <p>. Now command line option -p <p> also set default future strategy multiprocessing (p >= 2 eager otherwise), unless another strategy already specified via option future.plan system environment variable R_FUTURE_PLAN. Now availableCores() also acknowledges environment variable NSLOTS set Sun/Oracle Grid Engine (SGE). MEMORY: Added argument gc = FALSE futures. TRUE, garbage collector run end process evaluated future (just returning value). may help lowering overall memory footprint running multiple parallel R processes. user can enable specifying plan(multiprocess, gc = TRUE). developer can control using future(expr, gc = TRUE) v %<-% { expr } %tweak% list(gc    = TRUE).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-0-15-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 0.15.0","text":"Significantly decreased overhead creating future, particularly multicore futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-15-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.15.0","text":"Future give error plan(list(\"eager\")), whereas work plan(\"eager\") plan(list(eager)).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0140","dir":"Changelog","previous_headings":"","what":"Version 0.14.0","title":"Version 0.14.0","text":"CRAN release: 2016-05-17","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-14-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.14.0","text":"Added nbrOfWorkers(). Added informative print() method Future class. values() passes arguments ... value() future. Added FutureError class.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"deprecated-and-defunct-0-14-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 0.14.0","text":"Renamed arguments maxCores cluster workers. using old argument names deprecation warning generated, still work made defunct future release.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-14-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.14.0","text":"resolve() lists environments work properly set futures resolved order, happen asynchronous futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0130","dir":"Changelog","previous_headings":"","what":"Version 0.13.0","title":"Version 0.13.0","text":"CRAN release: 2016-04-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-13-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.13.0","text":"Add support plan() specifying different future strategies different levels nested futures. Add backtrace() listing trace expressions evaluated (calls made) condition caught. Add transparent futures, eager futures early signaling conditioned enabled whose expression evaluated calling environment. makes evaluation futures similar possible R evaluates expressions, turn simplifies troubleshooting errors, etc. Add support early signaling conditions. default () signal conditions value queried. addition, may signaled soon possible, e.g.Â checking whether future resolved . Signaling conditions calling value() now controlled argument signal (previously onError). Now UniprocessFuture:s captures call stack errors occurring resolving futures. ClusterFuture() gained argument persistent = FALSE. persistent = TRUE, objects cluster R session created evaluation previous future available succeeding futures evaluated session. Moreover, globals still identified exported â€œmissingâ€ globals give error - instead assumed globals available environment future evaluated. OVERHEAD: Utility functions exported ClusterFuture now much smaller; previously export package environment.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-13-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.13.0","text":"f <- multicore(NA, maxCores = 2) end endless waiting loop free core availableCores() returned one. ClusterFuture() ignore local = TRUE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0120","dir":"Changelog","previous_headings":"","what":"Version 0.12.0","title":"Version 0.12.0","text":"CRAN release: 2016-02-24","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-12-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.12.0","text":"Added multiprocess futures, multicore futures supported, otherwise multisession futures. makes possible use plan(multiprocess) everywhere regardless operating system. Future strategy functions gained class attributes possible test type future currently used, e.g. inherits(plan(), \"multicore\"). ROBUSTNESS: R process created future can resolve . non-resolved future queried another R process, informative error generated explaining possible. ROBUSTNESS: Now value() multicore futures detects underlying forked R process terminated completing generates informative error message.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"performance-0-12-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 0.12.0","text":"Adjusted parameters schema used wait next available cluster node nodes polled frequently.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-12-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.12.0","text":"resolve() gained argument recursive. Added option future.globals.resolve controlling whether global variables resolved futures . TRUE, globals searched recursively futures found â€œglobalâ€ futures resolved. FALSE, global futures located, later trying resolved parent future, informative error message generated clarifying R process created future can resolve . default currently FALSE.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-12-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.12.0","text":"FIX: Exports objects available packages already attached future still exported. FIX: Now availableCores() returns 3L (=2L+1L) instead 2L _R_CHECK_LIMIT_CORES_ set.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0110","dir":"Changelog","previous_headings":"","what":"Version 0.11.0","title":"Version 0.11.0","text":"CRAN release: 2016-01-20","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-11-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.11.0","text":"Add multisession futures, analogously multicore ones, use multiple cores local machine difference evaluated separate R session running background rather separate forked R processes. multisession future special type cluster futures require explicit setup cluster nodes. Add support cluster futures, can make use cluster nodes created parallel::makeCluster(). Add futureCall(), futures .call() otherwise. Standardized options named, .e.Â future.<option>. used future options previously, make sure check follow format.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-11-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.11.0","text":"futures now validates globals default (globals = TRUE).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-0100","dir":"Changelog","previous_headings":"","what":"Version 0.10.0","title":"Version 0.10.0","text":"CRAN release: 2015-12-31","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-10-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.10.0","text":"Now %<=% can also assign multi-dimensional list environments. Add futures(), values() resolved(). Add resolve() resolve futures lists environments. Now availableCores() also acknowledges number CPUs allotted Slurm. CLEANUP: Now internal future variable created %<=% removed future variable resolved.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-10-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.10.0","text":"futureOf(envir = x) work properly x list environment.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-090","dir":"Changelog","previous_headings":"","what":"Version 0.9.0","title":"Version 0.9.0","text":"CRAN release: 2015-12-12","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.9.0","text":"ROBUSTNESS: Now values environment variables trimmed parsed. ROBUSTNESS: Add reproducibility test random number generation using Pierre Lâ€™Ecuyerâ€™s RNG stream regardless futures evaluated, e.g.Â eager, lazy multicore.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-9-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.9.0","text":"Now globals (â€œunknownâ€ variables) identified using new findGlobals(..., method = \"ordered\") globals (> 0.5.0) global variable preceding local variable name properly identified exported/frozen.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-9-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.9.0","text":"Updated vignette common issues case global variable identified hidden element assignment future expression.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.9.0","text":"Errors occurring multicore futures prevent multicore futures created.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-082","dir":"Changelog","previous_headings":"","what":"Version 0.8.2","title":"Version 0.8.2","text":"CRAN release: 2015-10-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-8-2","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.8.2","text":"Globals copies package objects exported future environments. future package attached future::future() imported, %<=% used internally another package. Similarly, also attached multicore futures used.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-081","dir":"Changelog","previous_headings":"","what":"Version 0.8.1","title":"Version 0.8.1","text":"CRAN release: 2015-10-05","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-8-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.8.1","text":"Added vignette â€˜Futures R: Common issues solutionsâ€™.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-8-1","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.8.1","text":"eager() multicore() gained argument globals, globals = TRUE validate global variables identified can located already future created. provides means providing tests global variables eager multicore futures lazy futures.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-8-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.8.1","text":"lazy(sum(x, ...), globals = TRUE) now properly passes ... function future setup. called within function called within function without ... arguments, informative error message thrown.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-080","dir":"Changelog","previous_headings":"","what":"Version 0.8.0","title":"Version 0.8.0","text":"CRAN release: 2015-09-07","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.8.0","text":"plan(\"default\") resets default strategy, synchronous eager evaluation unless option future_plan environment variable R_FUTURE_PLAN set. availableCores(\"mc.cores\") returns getOption(\"mc.cores\") + 1L, option mc.cores specifies â€œallowed number additional R processesâ€ used addition main R process.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.8.0","text":"plan(future::lazy) similar gave errors.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-070","dir":"Changelog","previous_headings":"","what":"Version 0.7.0","title":"Version 0.7.0","text":"CRAN release: 2015-07-14","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.7.0","text":"multicore() gained argument maxCores, makes possible use instance plan(multicore, maxCores = 4L). Add availableMulticore() [(-house) async package].","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.7.0","text":"colorful demo(\"mandelbrot\", package = \"future\").","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 0.7.0","text":"ROBUSTNESS: multicore() blocks one CPU cores available, iff currently occupied multicore futures. old <- plan(new) now returns old plan/strategy (newly set one).","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-060","dir":"Changelog","previous_headings":"","what":"Version 0.6.0","title":"Version 0.6.0","text":"CRAN release: 2015-06-19","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.6.0","text":"Add multicore futures, futures resolved asynchronously separate process. supported Unix-like systems, Windows.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-5-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.5.1","text":"Eager lazy futures now records result internally expression evaluated , even error values requested multiple times. Eager futures always created regardless error . Future objects environments record expression, call environment optional variables.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"globals-0-5-0","dir":"Changelog","previous_headings":"","what":"Globals","title":"Version 0.5.0","text":"lazy() â€œfreezesâ€ global variables time future created. way result lazy future likely â€˜eagerâ€™ future. also globals likely handled asynchronous futures.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-4-2","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.4.2","text":"plan() records call.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"documentation-0-4-2","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.4.2","text":"Added demo(\"mandelbrot\", package = \"future\"), can re-used future packages.","code":""},{"path":[]},{"path":"https://future.futureverse.org/news/index.html","id":"new-features-0-4-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.4.1","text":"Added plan(). Added eager future - useful troubleshooting.","code":""},{"path":"https://future.futureverse.org/news/index.html","id":"version-040","dir":"Changelog","previous_headings":"","what":"Version 0.4.0","title":"Version 0.4.0","text":"Distilled Future API (-house) async package.","code":""}]
